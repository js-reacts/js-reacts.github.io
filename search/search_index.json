{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to React","text":""},{"location":"#welcome-to-react","title":"Welcome to React","text":"<p>roadmap.sh/react</p> <ul> <li>React - Basic Theoretical Concepts</li> <li>React Redux Immutability Guide</li> <li>Immutable Data with Immer and React setState</li> <li>Immer Resources</li> <li>React\u2019s diff algorithm</li> </ul> <ul> <li>egghead.io</li> <li>tutsnode.org</li> </ul> <p>React is backend agnostic for frontend development.(1)</p> <ol> <li> <p>In other words, you don\u2019t have to rely on a JavaScript-based backend (Node or Deno) to use React. It\u2019s fine to use React with any other backend technology, such as Java, Ruby, Go, or Python.</p> <p>React is a UI library, after all. You can integrate it with any backend and any frontend data library (Backbone, Angular, Meteor, etc.).</p> <ul> <li>React Quickly, Second Edition by Morten Barklund, Azat Mardan (pg-11)</li> </ul> </li> </ol> <pre><code>import * as msw from \"msw\";\n\n// Logging the Module\nconsole.log(msw);\n\n//list all the method names\nconsole.log(Object.keys(msw));\n</code></pre> <code>ReactDOM</code> vs <code>react-router-dom</code> <ul> <li> <p><code>ReactDOM</code> is installed automatically when you install React, as it is part of the core React package and is responsible for rendering React components to the DOM.</p> <pre><code>import ReactDOM from 'react-dom/client';  // React 18 import\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(&lt;App /&gt;);\n</code></pre> <pre><code>import { createRoot } from 'react-dom/client'\n</code></pre> </li> <li> <p>react-router-dom is a separate package. It is not included automatically with React itself, and you need to install it separately if you want to use routing features in your React app.</p> <pre><code>import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\n</code></pre> </li> </ul> <p><code>react</code> and <code>react-dom</code> (core React libraries)</p> <ul> <li><code>ReactDOM</code> is bundled with React and is necessary for rendering React applications to the DOM.</li> <li>react-router-dom is a separate package that you need to install and import to handle routing in React applications.</li> </ul> Notes <ul> <li>Legacy API (<code>ReactDOM.render</code>): If you\u2019re upgrading from an older React version, <code>ReactDOM.render()</code> is deprecated in React 18. It still works in React 18 but is recommended to be replaced with <code>createRoot()</code> for better support with concurrent features.</li> <li><code>createRoot()</code> only works with React 18 and higher. If you\u2019re using an older version of React, you\u2019ll need to stick with the old <code>ReactDOM.render()</code> method.</li> </ul> <p>React itself comes with a few preinstalled dependencies</p> <p>When you create a React app with <code>Vite</code>, it comes with the following preinstalled dependencies:</p> <ul> <li><code>react</code> and <code>react-dom</code> (core React libraries)</li> <li><code>vite</code> (build tool)</li> <li><code>@vitejs/plugin-react</code> (React-specific Vite plugin)</li> <li><code>react-refresh</code> (enables Fast Refresh for React)</li> </ul> <p>What Are Components? (1)</p> <ol> <li> <p>When working with React, there are two alternative ways to define components:</p> <ul> <li>Class-based components (or \"class components\"): components defined via the <code>class</code> keyword</li> <li>Functional components (or \"function components\"): components that are defined via regular JavaScript functions</li> </ul> <p>React Key Concepts (2022 Packt Publishing) by Maximilian Schwarzm\u00fcller</p> </li> </ol> <p>A key concept of React is the usage of so-called components. Components are reusable building blocks which are combined to compose the final user interface.</p> <p>Please note that some components are nested inside other components\u2014i.e., components are also made up of other components. That's a key feature of React and similar libraries.</p> <p>To make a long story short, when working in a React project, you will work with lots of components. You will split your code into small, manageable building blocks and then combine these components to form the overall user interface. It's a key feature of React. (1)</p> <ol> <li> <p>Indeed, a function will be treated as a component and can therefore be used like a HTML element in JSX code if it returns a renderable value (typically JSX code).</p> <p>This is very important. You can only use a function as a React component in JSX code if it is a function that returns something that can be rendered by React. The returned value technically doesn't have to be JSX code, but in most cases, it will be.</p> <p>Non-JSX code being returned</p> <ul> <li><code>Portals</code> &amp;</li> <li><code>Refs</code></li> </ul> <p>React Key Concepts (2022 Packt Publishing) by Maximilian Schwarzm\u00fcller</p> </li> </ol> What kind of information do you store in component state? <p>In general, any state used in a web application belongs to one of three categories:</p> <ul> <li>Application data</li> <li>UI state</li> <li>Form data</li> </ul> <p>This isn\u2019t a rule or an artifact of React in particular, but it\u2019s a consequence of how stateful applications operate. Different types of data are stored in different ways.(1)</p> <ol> <li> <p>Application Data</p> <p>Application data is most often stored on a global level in your application.</p> <p>A better solution is often to create a data store in a component that is persistent in your application so that when data is loaded once, it remains through the application.</p> <p>We\u2019ll see different ways of doing this in the future involving built-in React functionality (using React Context)</p> <p>UI STATE</p> <p>UI state values are most often kept as local as possible. The information about whether the menu is open or not is only of relevance inside the menu component, so you can easily store this as local state inside this component only.</p> <p>FORM DATA</p> <p>While the user is interacting with a form, entering data, moving from one form field to the next, the current state of the form is often kept in local state in the component that covers all the form fields.</p> <ul> <li>React Quickly 2nd Edition, pg-141</li> </ul> </li> </ol>"},{"location":"#effects","title":"Effects","text":"<p>Remembering a value without re-rendering with <code>useRef</code></p> <p><code>useRef</code> is both one of the simplest hooks in React and also one of the least understood hooks.</p> <p>It\u2019s a hook with a passive state, which means the hook can contain state, but setting or updating the state doesn\u2019t cause a re-render.(1)</p> <ol> <li> <p><code>useRef</code> is used for a number of purposes, including remembering values between renders and serving as a reference to DOM elements used in the render.</p> <p>1. Passive State Values</p> <p>You can use the <code>useRef</code> hook to remember some value that is relevant between renders of the component but that doesn\u2019t directly affect the outcome of the component.</p> <p>To instantiate a <code>useRef</code> hook, you simply call the hook and store it in a variable. You can optionally pass an initial value to the hook as well.</p> <p>To read or update the current value of a <code>useRef</code> hook, you access the .current` property on the hook return value.</p> <p>2. References To DOM Elements</p> <p>The other use case for <code>useRef</code> is, as mentioned, to get references to DOM elements.</p> <p> </p> <ul> <li>React quickly, 2nd Edition - pg 216</li> </ul> </li> </ol> <p>Understanding rendering</p> <p>A functional component will render for one of three reasons:</p> <ul> <li>A functional component will render for one of three reasons:</li> <li>The parent component re-rendered.</li> <li>The component uses stateful hooks, which have updated.</li> </ul> <pre><code>Rendering on mount\nRendering on parent render\nRendering on state update\n</code></pre>"},{"location":"#hooks","title":"Hooks","text":"<p>At the time of writing, there are 15 built-in hooks in React (as of <code>React 18</code>), which we\u2019ll cover briefly, grouped by their functionality:</p> <ul> <li> <p>Stateful hooks \u2014 These functions are concerned with making components and applications stateful on several different layers and levels of complexity: <code>useState</code>, <code>useReducer</code>, <code>useRef</code>, <code>useContext</code>, <code>useDeferredValue</code>, and <code>useTransition</code>.</p> </li> <li> <p>Effect hooks \u2014 These functions are concerned with running effects inside a component at different stages of the overall component life cycle as well as during each individual render cycle: <code>useEffect</code> and <code>useLayoutEffect</code>.</p> </li> <li> <p>Memoization hooks \u2014 These functions are used for performance optimization by avoiding recalculating values if their constituent parts haven\u2019t changed: <code>useMemo</code>, <code>useCallback</code>, <code>useId</code>.</p> </li> <li> <p>Library hooks \u2014 These advanced functions are almost exclusively used in larger component libraries that are created to be shared either with the community or internally in a larger organization. These functions are rarely used in smaller or medium-size applications: <code>useDebugValue</code>, <code>useImperativeHandle</code>, <code>useInsertionEffect</code>, and <code>useSyncExternalStore</code>.</p> </li> </ul> <p>These 15 hooks are the built-in \u201cbase\u201d hooks that React comes with.(1)</p> <ol> <li> <p>You can build more hooks on top of them, but you can\u2019t build your own base hooks. You can only build hooks that utilize one or more of the existing hooks.</p> <p>Note that React might be extended with more built-in hooks in future releases. React 18.0 came with five new hooks, and incremental releases after React 18 might come with even more.</p> <ul> <li>React Quickly, Second Edition by Morten Barklund, Azat Mardan (pg-214)</li> </ul> </li> </ol> Hook Rules <p>If you use a hook, you must obey the two laws of hooks:</p> <ul> <li>only call hooks at the top level of a component (so no conditional hooks or loops of hooks), &amp;</li> <li>only use hooks inside functional components (so no hooks outside a component, in a helper function, or even in a class-based component).</li> </ul> <ul> <li>React Quickly, 2nd Edition</li> </ul> <ul> <li>Low-priority state updates with <code>useDeferredValue</code> and <code>useTransition</code></li> </ul> <p></p>"},{"location":"#handling-events-in-react","title":"Handling events in React","text":"<p>Events are the way that users interact with a JavaScript web application. Events can be caused by mouse movement or clicking, touch interface clicks and drags, keyboard button presses, scrolling, copying and pasting, as well as indirect interactions such as focusing and unfocusing elements or the entire application.</p> <p>There are two ways to handle events in React:</p> <ul> <li>You can use React to manage your event listener.</li> <li>You can manually add and remove your event listener directly on a DOM node.</li> </ul> <p>THE SYNTHETIC EVENT API</p> <p>React\u2019s synthetic events have an API that\u2019s based on the standard API model as efined in the HTML specification.</p> <p>For instance, all events have a <code>.type</code> property and a <code>.target</code> property. They also all have <code>.preventDefault()</code> and <code>.stopPropagation()</code> methods.(1)</p> <ol> <li>React Quicklly, 2nd Edition, pg-241</li> </ol> <p>Event phases and propagation</p>"},{"location":"#frozen-objects-in-javascript","title":"Frozen objects in JavaScript","text":"<p>Internally, React uses <code>Object.freeze()</code>, which is a built-in function in JavaScript to make the <code>this.props</code> object immutable. To check whether an object is frozen, you can use the <code>Object.isFrozen()</code> method. For example, you can determine whether this statement will return <code>true</code>:</p> <pre><code>class Test extends React.Component {\n  render() {\n    console.log(Object.isFrozen(this.props));\n    return React.createElement(\"div\");\n  }\n}\n\n//\nconst Dashboard = ({ title, name }) =&gt; {\n  console.log(\"typeof: \", Object.isFrozen(title), title, name);\n  return &lt;&gt;Dashboard&lt;/&gt;;\n};\n\nexport default Dashboard;\n</code></pre> <p>The details of this are pretty complex, but for now, just know that you should never try to edit or add properties inside a component itself. That is something you do in the parent context. (1)</p> <ol> <li> <p>The object of properties can be accessed inside a component using <code>this.props</code>. This object is a frozen (immutable) object, from which you can only read values, not set them.</p> <ul> <li>React Quickly, Second Edition by Morten Barklund, Azat Mardan (pg-46)</li> </ul> </li> </ol>"},{"location":"#navigating-the-react-mastery-journey","title":"Navigating the React mastery journey","text":"<p>The tools are sorted into three main groups, depending on what they do and where they are used:</p> <ul> <li>User interface \u2014 Includes things like UI libraries and animation tools</li> <li>Architecture \u2014 Includes data management tools, authentication libraries, and many others</li> <li>Productivity \u2014 Covers build tools, testing libraries, and more</li> </ul> <p> </p> <p></p> Quote <ul> <li> <p>Data management \u2014 Redux (and RTK), zustand, Immer, MobX, Jotai, Recoil, Akita, Elf, Rematch, Hookstate, react-easy-state, Unstated, RxJS, Effector, Valtio, Easy Peasy, Kea, storeon, nanostores, PouchDB, Firebase, Supabase, Synergies, Flux, and Fluxible</p> </li> <li> <p>State flow \u2014 XState, Robot, React Stately, Overmind, useStateMachine, Zag, Little State Machine, and React Transition State</p> </li> <li> <p>Remote data \u2014 TanStack Query, SWR, Relay, Apollo Client, React-Fetching-Library, Redux Saga, Appsync, Axios, GraphQL, FeathersJS, Swagger, and GraphQL-Tools</p> </li> <li> <p>Authentication and authorization \u2014 JWT, Firebase Authentication, OAuth2, AWS Amplify, Auth0, Okta, Passport.js, OpenID, AWS Cognito, Keycloak, and React Auth Kit</p> </li> <li>Accessibility \u2014 React Aria, axe-core, Reakit, and Downshift</li> <li>Form management \u2014 Formik, Yup, React Hook Form, React Final Form, and React-JSONSchema</li> </ul> <p></p>"},{"location":"#creating-a-stack-from-scratch","title":"Creating a stack from scratch","text":"<p>Choosing the right stack for a React project can be challenging, as many options are available in the ecosystem. In this section, we\u2019ll discuss some of the factors to consider when choosing stack components by looking at some example scenarios and suggesting specific technologies for them.</p> <p>The most important decision is the foundation layer of your application. This decision is the hardest to change at a later stage in development but of course still doable then, so don\u2019t get too stuck on it. Building on said foundation, you expand with technologies that solve your particular pain points in the easiest way possible.(1)</p> <ol> <li> <p>One crucial balancing act rests at the center of creating a stack for a new project: familiarity matters, but new technologies surpass existing ones. If your team knows TanStack, it doesn\u2019t matter if some other data-fetching library might technically be a better fit for a given new project. Your team will work a lot faster in a library they\u2019re familiar with than in a completely new one. On the other hand, if you don\u2019t challenge yourself, you\u2019ll never evolve, and as technologies go stale or become outdated, you\u2019ll never learn about the new and simpler/better/faster tools replacing them.</p> <p>Dancing on this balancing beam is at the center of the role of the team architect who\u2019s creating the technology stack. Where should we stick with what we know, and when should we challenge ourselves? These decisions don\u2019t exist just at the birth of a new project; they pop up continuously. Sometimes, you have to replace a given technology in your stack with a new one despite the growing pains it will inevitably introduce, simply because you have to keep up with the times. Let\u2019s go through some scenarios and see how we can solve them with a good choice of technologies</p> </li> </ol> SCENARIO: A MEDIUM- SIZE E-COMMERCE PLATFORM <p>You\u2019re tasked with revamping a medium-size e-commerce platform to improve performance, scalability, and user experience. For this kind of project, you want a stack that\u2019s proved itself time and time again, and you want to move fast and build things quickly. One good choice for a project like this one would be what we might call The Popular Stack:</p> <ul> <li>Next.js as the foundation</li> <li>RTK as the data management library</li> <li>TanStack as the data-fetching library</li> <li>Material UI with MUI as the styling library</li> </ul> <p>The Popular Stack offers the familiarity of Next.js for server-side rendering, TanStack for efficient data fetching, RTK for state management, and Material UI for a polished UI. This stack provides the tools needed to enhance the platform\u2019s speed and user interface, ensuring an excellent shopping experience.</p> SCENARIO: A PERSONAL PORTFOLIO WEBSITE <p>You\u2019re a solo developer looking to create a personal portfolio website that showcases your skills and projects. For this kind of project, you\u2019re free to play around, but you also want to use the latest and greatest tools out there, both to show off your skills and to stay ahead of the competition. The stack for such a project will always be changing with the times, but one possible candidate is what we\u2019ll call The Indie Stack:</p> <ul> <li>Vite at the foundation</li> <li>Zustand as the data management library</li> <li>Tailwind CSS as the styling library</li> </ul> <p>The Indie Stack is perfect for this scenario. Vite offers rapid development with blazing-fast bundling, zustand simplifies state management, and Tailwind CSS allows for quick and attractive styling. This stack empowers you to showcase your work efficiently and aesthetically.</p> SCENARIO: MAINTAINING A LEGACY ENTERPRISE DASHBOARD <p>Your team is responsible for maintaining a legacy enterprise dashboard built using older technologies. The stack for such a project was determined a long time ago, and you just have to play along. Refactoring this to a new stack is nigh on impossible as the project is huge. For now, you\u2019re stuck with The Old School Stack:</p> <ul> <li>Create React App (CRA) as the foundation</li> <li>Redux as the data management library</li> <li>Axios as the data-fetching library</li> <li>CSS Modules as the styling library</li> </ul> <p>The Old School Stack, with CRA for stability, Axios for data fetching, Redux for state management, and CSS Modules for maintainable styling, is still a good choice. It ensures compatibility with existing code while leaving an open door for gradual modernization.</p> SCENARIO: A FINANCIAL SERVICES WEB APPLICATION <p>You\u2019re developing a comprehensive web application for a financial services company. For this scenario, you want something that\u2019s trustworthy, secure, and scalable and that won\u2019t ruffle any feathers in senior management. You can\u2019t go wrong with The Enterprise Stack:</p> <ul> <li>Pure React plus TypeScript as the foundation</li> <li>Apollo as the data-fetching and management library</li> <li>Styled-components as the styling library</li> </ul> <p>The Enterprise Stack, combining React with TypeScript for strong typing, Apollo for managing complex data fetching and storage, and styled-components for consistent and maintainable styling, ensures robustness and scalability for handling financial transactions securely.</p> SCENARIO: RAPID PROTOTYPING OF A COLLABORATIVE TASK MANAGEMENT TOOL <p>Your startup is building a collaborative task management tool, and you need to prototype the core features quickly to attract potential investors and users. For this task, you want something that has a lot of magic built in and can very easily scale up and move fast. You don\u2019t mind if the design looks a bit derivative, as speed and features and making early investors satisfied with the progress are more important than a unique user interface. You should check out The Prototype Stack:</p> <ul> <li>Remix as the foundation</li> <li>Supabase as the backend</li> <li>Stale-While-Revalidate (SWR) as the data-fetching library</li> <li>Ant Design as the styling library</li> </ul> <p>The Prototype Stack, featuring Remix for fast server rendering, Supabase for rapid backend development, SWR for scalable data fetching, and Ant Design for a polished, feature-rich UI, allows you to create a functional prototype swiftly, demonstrating the product\u2019s potential to stakeholders.</p> <p>A technology stack (also known as a solution stack or simply stack) is central to software development, guiding the selection of technologies, frameworks, and tools for a project. (1)</p> <ol> <li> <p>The choice of a React stack components depends on project requirements and familiarity with the technologies, with options ranging from established stacks like The Popular Stack for e-commerce platforms to innovative stacks like The Indie Stack for personal portfolio websites, each tailored to specific project goals and constraints.</p> <ul> <li>React in Depth by Morten Barklund, pg-18</li> </ul> </li> </ol> <p></p> Book Links <ul> <li>Fluent React</li> <li>React Quickly, 2nd ed.</li> <li>React in Depth by Morten Barklund </li> <li>React Books Linkedin</li> </ul>"},{"location":"#reddit-links","title":"Reddit Links","text":"Dashboard React App <ul> <li>Dashboard Templated</li> <li>Free MUI Dashboard</li> </ul> Note <ul> <li>Reddit: Reactjs - How to work offline</li> <li>Reddit: A react starter with all the essentials for quick prototyping</li> <li>Reddit: Beyond React.memo: Smarter Ways to Optimize Performance</li> <li> <p>Reddit: React Router middleware is HERE! </p> </li> <li> <p>Reddit: React Query invalidation strategies</p> </li> <li> <p>Reddit: How to start with testing in React? </p> </li> <li> <p>Reddit: Looking for the Best Express, React &amp; Node.js Course \u2013 Project-Based Learning Recommendations?</p> </li> <li>Reddit: Should I migrate from React Query + context API -&gt; RTK Query + Redux for this use case </li> <li> <p>Reddit: Have you also published an app with dozens of forgotten console.log statements? </p> </li> <li> <p>Reddit: Decentralized (atomic) state management \u2013 now supports React 19! </p> </li> <li> <p>Reddit: React Native Apps Best UI/UX Thread </p> </li> <li> <p>Reddit: Reached $2.4k Revenue Milestone! \ud83c\udf89 Sharing the playbook that worked </p> </li> <li> <p>Reddit: API call on every page load </p> </li> <li> <p>Reddit: A Complete Guide to React useEffect vs useLayoutEffect for Beginners </p> </li> <li>Reddit: </li> <li>Reddit: </li> <li>Reddit: </li> </ul>"},{"location":"#redux","title":"REDUX","text":""},{"location":"#react-books","title":"React Books","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/","title":"How to Separate Business Logic from UI Logic in React","text":"","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#how-to-separate-business-logic-from-ui-logic-in-react","title":"How to Separate Business Logic from UI Logic in React","text":"<p>Separating business logic from UI logic is a best practice in React development. It leads to cleaner, more maintainable, and more testable code. Here\u2019s how you can achieve this separation effectively:</p> Why Separate? <ul> <li>UI logic handles rendering and user interaction.</li> <li>Business logic manages data fetching, state transformations, and domain-specific rules.</li> <li>Separation improves reusability, readability, and testability.</li> </ul> <p></p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#common-patterns-for-separation","title":"Common Patterns for Separation","text":"","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#1-use-custom-hooks","title":"1. Use Custom Hooks","text":"<p>Custom hooks encapsulate business logic and stateful behavior, keeping your UI components focused solely on rendering.</p> javascript<pre><code>// useProduct.js (business logic)\nimport { useState, useEffect } from \"react\";\nimport { fetchProductById } from \"./api/product\";\n\nexport function useProduct(productId) {\n  const [product, setProduct] = useState();\n\n  useEffect(() =&gt; {\n    async function retrieveProduct() {\n      const result = await fetchProductById(productId);\n      setProduct(result);\n    }\n    retrieveProduct();\n  }, [productId]);\n\n  return { product };\n}\n</code></pre> javascript<pre><code>// ProductView.js (UI logic)\nimport { useProduct } from \"./useProduct\";\n\nfunction ProductView({ productId, onAdd }) {\n  const { product } = useProduct(productId);\n\n  if (!product) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{product.title}&lt;/h1&gt;\n      &lt;p&gt;{product.totalCost}&lt;/p&gt;\n      &lt;button onClick={onAdd}&gt;Add to basket&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>This keeps the UI component focused on rendering, while the hook handles data fetching and state management.</p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#2-move-logic-to-helper-functions-or-services","title":"2. Move Logic to Helper Functions or Services","text":"<p>Extract pure business logic into plain JavaScript functions or service modules. These should not depend on React or the UI.</p> javascript<pre><code>// helpers/product.js\nexport function processProduct(product) {\n  return {\n    title: product.title,\n    totalCost: product.salePrice || product.cost,\n  };\n}\n</code></pre> javascript<pre><code>// api/product.js\nimport { processProduct } from \"../helpers/product\";\n\nexport async function fetchProductById(id) {\n  const response = await fetch(`/api/products/${id}`);\n  const data = await response.json();\n  return processProduct(data);\n}\n</code></pre> <p>This allows you to reuse and test business logic independently of the UI.</p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#3-use-dumb-presentational-components","title":"3. Use \"Dumb\" (Presentational) Components","text":"<p>Keep your UI components stateless and focused only on presentation. Pass data and event handlers as props.</p> javascript<pre><code>function ProductDisplay({ title, totalCost, onAdd }) {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{title}&lt;/h1&gt;\n      &lt;p&gt;{totalCost}&lt;/p&gt;\n      &lt;button onClick={onAdd}&gt;Add to basket&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>This makes UI components reusable and easy to test.</p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#4-advanced-state-management-libraries","title":"4. Advanced: State Management Libraries","text":"<p>For larger apps, consider using Redux, Zustand, or Context API to manage business logic and state outside of UI components.</p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#summary-table","title":"Summary Table","text":"Technique Business Logic Location UI Logic Location When to Use Custom Hooks Custom hook files Component files Most common, reusable logic Helper Functions/Services Separate JS modules Component files Pure functions, data processing Presentational Components N/A Component files For rendering only State Management Library Store/actions/selectors Component files Large/global state needs","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#key-principles","title":"Key Principles","text":"<ul> <li>Business logic should not import or depend on UI code\u2014only the reverse.</li> <li>Test business logic in isolation for reliability and maintainability.</li> <li>UI components should be as \"dumb\" as possible, only concerned with displaying data and handling user events</li> </ul>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#example-workflow","title":"Example Workflow","text":"<ul> <li>Write business logic (data fetching, validation, calculations) in custom hooks or helper files.</li> <li>UI components use these hooks or helpers, focusing only on rendering and user interaction.</li> <li>Pass data and callbacks as props to presentational components.</li> </ul> <p>By following these patterns, you achieve a clean separation of concerns, making your React codebase easier to scale, test, and maintain</p>","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#youtube","title":"Youtube","text":"","tags":["react"]},{"location":"blog/2025/04/26/how-to-separate-business-logic-from-ui-logic-in-react/#reference","title":"Reference","text":"<ul> <li>Reactjs separation of UI and business logic - Stack Overflow</li> <li>Path To A Clean(er) React Architecture (Part 6)Business Logic Separation</li> <li>Tips for separating business logic from UI logic? - Reddit</li> <li>Mastering the Art of Separating UI and Logic in React: A Comprehensive Guide</li> <li> <p>Separating Business Logic from UI: A Step-by-Step Guide for Better Code Organization</p> </li> <li> <p>React Refactoring (w/Storybook): Separate UI and Business Logic </p> </li> <li>Separation of Business Logic and User Interface (UI)</li> <li> <p>Decouple Your Code - How to Separate Business Logic from UI</p> </li> <li> <p>Split business logic from UI using Custom hooks in React</p> </li> <li> <p>Decoupling UI and Logic in React: A Clean Code Approach with Headless Components</p> </li> <li> <p>Where to Write Business Logic in React: Separation of Concerns for Frontend Interviews</p> </li> <li> <p>Modularizing React Applications with Established UI Patterns</p> </li> <li>How to separate logic from UI with React components</li> <li>Decoupling business logic from UI components</li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/","title":"Best Practices for Importing Files in a Large React Codebase","text":"","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#best-practices-for-importing-files-in-a-large-react-codebase","title":"Best Practices for Importing Files in a Large React Codebase","text":"<p>When working with a large React codebase, efficient file imports can have a significant impact on maintainability, readability, and performance.</p> <p>Here are some best practices for importing files in a large React project:</p>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#1-organize-files-and-folders-logically","title":"1. Organize Files and Folders Logically","text":"<ul> <li> <p>Group related components: Keep components, hooks, utilities, and styles organized in a well-structured folder hierarchy. For example:</p> <pre><code>/src\n/components\n    /Button\n    Button.jsx\n    Button.module.css\n    Button.test.jsx\n/hooks\n    useAuth.js\n/utils\n    formatDate.js\n/styles\n    theme.js\n</code></pre> </li> <li> <p>Feature-based organization: In large projects, consider organizing files based on features rather than type. For example, have a folder per feature (e.g., <code>/user</code>, <code>/auth</code>) with all the relevant files (components, hooks, etc.) inside.</p> </li> <li> <p>Use index files: Within each folder, you can create an <code>index.js</code> (or <code>.jsx</code>, <code>.ts</code>, etc.) file that exports all the relevant components and utilities. This makes it easier to import multiple files from a single location.</p> <pre><code>// /components/Button/index.js\nexport { default as Button } from \"./Button\";\nexport { default as ButtonGroup } from \"./ButtonGroup\";\n</code></pre> <p>Then, you can import like this:</p> <pre><code>import { Button, ButtonGroup } from \"components/Button\";\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#2-use-absolute-imports","title":"2. Use Absolute Imports","text":"<ul> <li>Avoid relative path hell: As your project grows, deeply nested folders can make relative imports cumbersome (e.g., <code>../../../</code>), which is hard to maintain and read.</li> <li>Configure absolute imports: Set up your project to use absolute imports based on the root directory, so you can import files without worrying about the relative path depth.</li> <li> <p>For React projects created with Create React App (CRA), this is as simple as adding the following to your <code>jsconfig.json</code> or <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n      \"baseUrl\": \"src\"\n  }\n}\n</code></pre> <p>Now you can import like this:</p> <pre><code>import { Button } from 'components/Button';\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#3-lazy-load-with-dynamic-imports","title":"3. Lazy Load with Dynamic Imports","text":"<ul> <li> <p>For larger codebases, especially if you have heavy components, use <code>React.lazy()</code> for code splitting. This allows you to load components asynchronously, reducing the initial bundle size.</p> <pre><code>import React, { Suspense } from \"react\";\nconst LazyComponent = React.lazy(() =&gt; import(\"components/LazyComponent\"));\n\nconst App = () =&gt; (\n  &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n    &lt;LazyComponent /&gt;\n  &lt;/Suspense&gt;\n);\n</code></pre> </li> <li> <p>This can be particularly useful for components that are only used under certain conditions or on specific routes.</p> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#4-group-imports-by-type-and-maintain-consistency","title":"4. Group Imports by Type and Maintain Consistency","text":"<ul> <li> <p>Group imports logically: Follow a consistent order for imports. A common practice is:</p> <ul> <li>React-related imports (like <code>react</code>, <code>react-dom</code>, etc.)</li> <li>Third-party libraries (e.g., <code>lodash</code>, <code>axios</code>)</li> <li>Internal modules (components, hooks, utils)</li> <li>Stylesheets (CSS, SCSS, or styled-components)</li> </ul> </li> <li> <p>Example:</p> <pre><code>// External dependencies\nimport React, { useState } from \"react\";\nimport PropTypes from \"prop-types\";\n\n// Internal modules\nimport { Button } from \"components/Button\";\nimport { useAuth } from \"hooks/useAuth\";\n\n// Styles\nimport \"./App.css\";\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#5-minimize-imports-from-large-libraries","title":"5. Minimize Imports from Large Libraries","text":"<ul> <li> <p>Avoid importing entire libraries if you only need specific utilities or components. For example, instead of:</p> <pre><code>import _ from \"lodash\";\n</code></pre> </li> <li> <p>You can import just the method you need:</p> <pre><code>import debounce from \"lodash/debounce\";\n</code></pre> </li> <li> <p>This reduces the size of the bundle and optimizes performance.</p> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#6-avoid-circular-dependencies","title":"6. Avoid Circular Dependencies","text":"<ul> <li>Circular dependencies can introduce hard-to-debug issues and performance problems. When designing the structure of your codebase, ensure that no files rely on each other in a cyclic manner.</li> <li> <p>Use tools like Madge to detect circular dependencies:</p> <pre><code>madge --circular src/\n</code></pre> </li> <li> <p>Best way to resolve circular dependencies in TypeScript</p> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#7-use-aliases-for-long-paths","title":"7. Use Aliases for Long Paths","text":"<ul> <li> <p>If your folder structure is deep, consider setting up aliases to simplify long paths. In a Webpack-based project, you can configure aliases in <code>webpack.config.js</code>:</p> <pre><code>resolve: {\n    alias: {\n        components: path.resolve(__dirname, 'src/components/'),\n        utils: path.resolve(__dirname, 'src/utils/'),\n    }\n}\n</code></pre> <p>This allows you to import with shorter, clearer paths:</p> <pre><code>import { Button } from \"components/Button\";\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#8-ensure-file-extensions-are-consistent","title":"8. Ensure File Extensions Are Consistent","text":"<ul> <li> <p>Stick to a convention for file extensions to avoid confusion:</p> <ul> <li><code>.jsx</code> for React components</li> <li><code>.js</code> for non-UI JavaScript files (utils, hooks, etc.)</li> <li><code>.ts</code> or <code>.tsx</code> if using TypeScript</li> <li><code>.css</code> or <code>.module.css</code> for CSS, or <code>.scss</code> if using Sass</li> </ul> </li> <li> <p>Avoid unnecessary extensions in imports. In most modern build setups (like Webpack), you don't need to specify the file extension, e.g., <code>import './styles'</code> instead of <code>import './styles.css'</code>.</p> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#9-consider-barrel-files-for-large-modules","title":"9. Consider Barrel Files for Large Modules","text":"<p>A barrel file is a single file that re-exports items from several files in a directory. This is particularly useful when a directory contains many files, such as a component directory. Instead of importing each file individually, you import from the barrel.</p> <ul> <li> <p>Example</p> <pre><code>// src/components/index.js\nexport { default as Button } from \"./Button\";\nexport { default as Input } from \"./Input\";\nexport { default as Modal } from \"./Modal\";\n</code></pre> </li> <li> <p>Now, you can import all components from a single place:</p> <pre><code>import { Button, Input, Modal } from \"components\";\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#10-use-code-linters-for-import-style-consistency","title":"10. Use Code Linters for Import Style Consistency","text":"<ul> <li>Use linters like ESLint with plugins like <code>eslint-plugin-import</code> to enforce import conventions and prevent problems like unused imports, incorrect paths, or missing modules.</li> <li> <p>Example ESLint rule for sorting imports:</p> <pre><code>\"import/order\": [\n\"error\",\n  {\n      \"groups\": [\n          [\"builtin\", \"external\"],\n          [\"internal\"],\n          [\"parent\", \"sibling\", \"index\"]\n      ],\n      \"alphabetize\": {\n          \"order\": \"asc\",\n          \"caseInsensitive\": true\n      }\n  }\n]\n</code></pre> </li> </ul> <p>By following these best practices, you can improve the scalability, readability, and performance of your large React codebase, making it easier to maintain and collaborate on.</p> <p>How to clear the logs file in ubuntu 22.04</p>","tags":["react"]},{"location":"blog/2025/04/27/best-practices-for-importing-files-in-a-large-react-codebase/#reference","title":"Reference","text":"<ul> <li> <p>Tyscript: w3schools</p> </li> <li> <p>What is a tsconfig.json</p> </li> <li> <p>Difference between tsconfig.json and tsconfig.app.json files in Angular</p> </li> <li> <p>Why does Vite create multiple TypeScript config files: tsconfig.json, tsconfig.app.json and tsconfig.node.json?</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/","title":"Advanced tips tricks antd design table","text":"<p>When working with Ant Design (AntD) and particularly with its Table component, there are several advanced tips and tricks you can use to enhance your tables and improve their functionality. Here are some advanced techniques:</p>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#overview","title":"Overview","text":"","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#1-custom-cell-rendering","title":"1. Custom Cell Rendering","text":"<p>You can use the <code>render</code> function to create complex cell contents. For example, you can include custom components, conditionally format data, or add interactive elements.</p> Basic <pre><code>{\n    title: 'Status',\n    render: (text, record) =&gt; (\n        &lt;span style={{ color: record.status === 'Active' ? 'green' : 'red' }}&gt;\n        {text}\n        &lt;/span&gt;\n    ),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#2-expandable-rows","title":"2. Expandable Rows","text":"<p>You can add expandable rows to show additional details when a row is clicked.</p> Basic <pre><code>const expandable = {\n    expandedRowRender: record =&gt; &lt;p&gt;{record.details}&lt;/p&gt;,\n    rowExpandable: record =&gt; record.details != null,\n};\n\n// In Table component\n&lt;Table expandable={expandable} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#3-custom-sorting-and-filtering","title":"3. Custom Sorting and Filtering","text":"<p>Define custom sorting and filtering logic by using the <code>sorter</code> and <code>filters</code> properties in column definitions.</p> Basic <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n\n    sorter: (a, b) =&gt; a.age - b.age,\n\n    sortDirections: ['descend', 'ascend'],\n\n    filters: [\n        { text: '20-30', value: '20-30' },\n        { text: '30-40', value: '30-40' }\n    ],\n\n    onFilter: (value, record) =&gt; {\n        const [min, max] = value.split('-').map(Number);\n        return record.age &gt;= min &amp;&amp; record.age &lt;= max;\n    },\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#4-pagination-and-infinite-scrolling","title":"4. Pagination and Infinite Scrolling","text":"<p>Configure pagination with custom settings or implement infinite scrolling to handle large datasets.</p> Basic <pre><code>// Pagination configuration\nconst pagination = {\n    pageSize: 10,\n    total: data.length,\n    onChange: page =&gt; console.log('Page:', page),\n};\n\n// Infinite scrolling\nconst handleScroll = e =&gt; {\n    if (e.target.scrollHeight - e.target.scrollTop === e.target.clientHeight) {\n        // Load more data\n    }\n};\n\n&lt;Table pagination={pagination} onScroll={handleScroll} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#5-cell-merging","title":"5. Cell Merging","text":"<p>You can merge cells in a table using the <code>rowSpan</code> and <code>colSpan</code> properties in the <code>render</code> function.</p> Basic <pre><code>{\n    title: 'Name',\n    render: (text, record, index) =&gt; ({\n        children: text,\n        props: {\n            rowSpan: index === 0 ? 2 : 0,\n            colSpan: 2,\n        },\n    }),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#6-dynamic-column-visibility","title":"6. Dynamic Column Visibility","text":"<p>Allow users to toggle column visibility dynamically using state management.</p> Basic <pre><code>const [visibleColumns, setVisibleColumns] = useState(['name', 'age']);\n\nconst handleVisibilityChange = (key) =&gt; {\n    setVisibleColumns(prev =&gt; prev.includes(key) ? prev.filter(col =&gt; col !== key) : [...prev, key]);\n};\n\nconst columns = [\n    {\n        title: 'Name',\n        dataIndex: 'name',\n        key: 'name',\n        ...visibleColumns.includes('name') &amp;&amp; { visible: true },\n    },\n    {\n        title: 'Age',\n        dataIndex: 'age',\n        key: 'age',\n        ...visibleColumns.includes('age') &amp;&amp; { visible: true },\n    },\n];\n\n// Render toggle buttons for columns\n{['name', 'age'].map(key =&gt; (\n    &lt;Button key={key} onClick={() =&gt; handleVisibilityChange(key)}&gt;\n        Toggle {key}\n    &lt;/Button&gt;\n))}\n\n// Table with dynamic columns\n&lt;Table columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#7-row-selection","title":"7. Row Selection","text":"<p>Customize row selection behavior to support multiple selection modes or custom checkboxes.</p> Basic <pre><code>const rowSelection = {\n    onChange: (selectedRowKeys, selectedRows) =&gt; {\n        console.log('Selected rows:', selectedRows);\n    },\n    getCheckboxProps: record =&gt; ({\n        disabled: record.name === 'Disabled User', // Disable selection for specific rows\n    }),\n};\n\n&lt;Table rowSelection={rowSelection} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#8-custom-filter-dropdowns","title":"8. Custom Filter Dropdowns","text":"<p>Create custom filter dropdowns for more advanced filtering options.</p> Basic <pre><code>import { Menu, Dropdown, Input } from 'antd';\nimport { DownOutlined } from '@ant-design/icons';\n\nconst filterDropdown = ({\n    setSelectedKeys,\n    selectedKeys,\n    confirm,\n    clearFilters,\n}) =&gt; (\n    &lt;div style={{ padding: 8 }}&gt;\n        &lt;Input\n            placeholder=\"Search...\"\n            value={selectedKeys[0]}\n            onChange={e =&gt; setSelectedKeys(e.target.value ? [e.target.value] : [])}\n            onPressEnter={() =&gt; confirm()}\n            style={{ marginBottom: 8, display: 'block' }}\n        /&gt;\n        &lt;Space&gt;\n            &lt;Button\n                type=\"primary\"\n                onClick={() =&gt; confirm()}\n                icon={&lt;SearchOutlined /&gt;}\n                size=\"small\"\n                style={{ width: 90 }}\n            &gt;\n                Search\n            &lt;/Button&gt;\n            &lt;Button onClick={() =&gt; clearFilters()} size=\"small\" style={{ width: 90 }}&gt;\n                Reset\n            &lt;/Button&gt;\n        &lt;/Space&gt;\n    &lt;/div&gt;\n);\n\n{\n    title: 'Name',\n    dataIndex: 'name',\n    filterDropdown: filterDropdown,\n    onFilter: (value, record) =&gt; record.name.toLowerCase().includes(value.toLowerCase()),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#9-tree-data","title":"9. Tree Data","text":"<p>Render hierarchical data with nested rows.</p> Basic <pre><code>const treeData = [\n    {\n        title: 'Parent 1',\n        key: '0-0',\n        children: [\n            {\n                title: 'Child 1',\n                key: '0-0-0',\n            },\n            {\n                title: 'Child 2',\n                key: '0-0-1',\n            },\n        ],\n    },\n];\n\n&lt;Table treeData={treeData} columns={columns} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#10-custom-toolbar-and-actions","title":"10. Custom Toolbar and Actions","text":"<p>Add custom toolbar actions like exporting, printing, or custom buttons.</p> Basic <pre><code>const toolbar = (\n    &lt;div&gt;\n        &lt;Button onClick={() =&gt; console.log('Export')}&gt;Export&lt;/Button&gt;\n        &lt;Button onClick={() =&gt; console.log('Print')}&gt;Print&lt;/Button&gt;\n    &lt;/div&gt;\n);\n\n// Render toolbar above the table\n&lt;&gt;\n    {toolbar}\n    &lt;Table columns={columns} dataSource={data} /&gt;\n&lt;/&gt;\n</code></pre> <p>Using these advanced tips and tricks can help you leverage the full power of Ant Design\u2019s Table component and tailor it to meet your specific needs and use cases.</p>","tags":["antd","react"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/","title":"API Call in Parent or Child","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#api-call-in-parent-or-child","title":"API Call in Parent or Child","text":"<p>In your provided code, the choice of where to call the API for the LogList data depends on your specific use case.</p> <p>Here\u2019s a breakdown of both approaches:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#1-api-call-in-the-parent-component","title":"1. API Call in the Parent Component","text":"ExampleWhen to Use <pre><code>import React, { useState, useEffect } from \"react\";\nimport { Tabs } from \"antd\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\"; // Adjust this import\nimport LogList from \"./LogList\";\nimport CheckListContainer from \"./CheckListContainer\"; // Assuming this is defined elsewhere\n\nconst { TabPane } = Tabs;\n\nconst MyComponent = () =&gt; {\n    const [activeKey, setActiveKey] = useState(\"1\");\n    const dispatch = useDispatch();\n    const { loading, data } = useSelector((state) =&gt; state.reference);\n\n    const handleTabChange = (key) =&gt; {\n        setActiveKey(key);\n        if (key === \"4\") {\n            dispatch(actionForCircularPlanningLog()); // Fetch data when switching to the Log List tab\n        }\n    };\n\n    return (\n        &lt;Tabs activeKey={activeKey} onChange={handleTabChange} type=\"line\"&gt;\n            &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n                {contactDetails()} {/* Assuming contactDetails is a function */}\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n                &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n                {activeKey === \"4\" &amp;&amp; &lt;LogList loading={loading} data={data} /&gt;}\n            &lt;/TabPane&gt;\n        &lt;/Tabs&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ul> <li>If the data is relevant to multiple child components.</li> <li>If you want to control the loading and error states centrally.</li> <li>If the data should be fetched when switching to the \"Log List\" tab.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#2-api-call-in-the-loglist-child-component","title":"2. API Call in the LogList Child Component","text":"ImplementationWhen to Use <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\"; // Adjust this import\nimport { Table } from \"antd\";\n\nconst LogList = () =&gt; {\n    const dispatch = useDispatch();\n    const { loading, data } = useSelector((state) =&gt; state.reference);\n\n    useEffect(() =&gt; {\n        dispatch(actionForCircularPlanningLog()); // Fetch data when LogList mounts\n    }, [dispatch]);\n\n    const columns = [\n        // Define your columns here\n    ];\n\n    const dataSource = (data || []).map((log) =&gt; ({\n        key: log.id,\n        remarks: log.remarks,\n        creationTime: log.creationTime,\n    }));\n\n    return (\n        &lt;Table\n            dataSource={dataSource}\n            loading={loading}\n            columns={columns}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default LogList;\n</code></pre> <ul> <li>If the <code>LogList</code> is only responsible for displaying its own data.</li> <li>If the data is not needed by any other component.</li> <li>If you want the <code>LogList</code> to handle its own loading and error states independently.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#summary","title":"Summary","text":"<ul> <li>Use the Parent Component for API Calls when the data is shared or needs to be controlled globally, particularly when changing tabs.</li> <li>Use the Child Component for API Calls when the component is self-contained and only needs to manage its own data.</li> </ul> <p>In your case, if the <code>LogList</code> is the only component needing the log data, you can opt for the child component approach. If you plan on expanding the functionality or sharing data between components, fetching it in the parent might be the better route.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/","title":"Application Structure for React.js","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-reactjs","title":"Application Structure for React.js","text":"<p>React.js itself does not provide a guideline on structuring projects but does suggest a few commonly used approaches.</p> <p>At the high level, you can group files in a React application in two ways:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#1-group-by-feature","title":"1. Group by feature","text":"<ul> <li>Create folders for every application module, feature, or route.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#2-group-by-file-type","title":"2. Group by file type","text":"<ul> <li>Create folders for different types of files.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-module-feature-or-route","title":"Group by Module, Feature, or Route","text":"<p>In this case, the file structure would mirror the business model or the application flow. For example, if you have an ecommerce application, you will have folders for product, productlist, checkout, etc. The CSS, JSX components, tests, subcomponents, or helper libraries explicitly required for the product module reside in the product folder:</p> <pre><code>common/\n    Avatar.js\n    Avatar.css\n    ErrorUtils.js\n    ErrorUtils.test.js\n\nproduct/\n    index.js\n    product.css\n    price.js\n    product.test.js\n\ncheckout/\n    index.js\n    checkout.css\n    checkout.test.js\n</code></pre> <p>The advantage of grouping files by feature is that if there is a change to the module, all the affected files are colocated in the same folder, and the change gets localized to a specific part of the code.</p> <p>The disadvantage is common components, logic, or styles used across modules should be identified periodically to avoid repetition and promote consistency and reuse.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-file-type","title":"Group by File Type","text":"<p>In this type of grouping, you would create different folders for CSS, components, test files, images, libraries, etc. Thus, logically related files would reside in different folders based on the file type:</p> <pre><code>css/\n    global.css\n    checkout.css\n    product.css\n\nlib/\n    date.js\n    currency.js\n    gtm.js\n\npages/\n    product.js\n    productlist.js\n    checkout.js\n</code></pre> <p>The advantages of this approach are:</p> <ul> <li>You have a standard structure that you can reuse across projects.</li> <li>Newer team members with little knowledge of the application-specific logic can still find files for something like styles or tests.</li> <li>Common components (such as date pickers) and styles imported in different   routes or modules can be changed once to ensure that the effect is seen across the application.</li> </ul> <p>The disadvantages are:</p> <ul> <li>A change in logic for a specific module would likely require changes in files   across different folders.</li> <li>As the number of features in the application grows, the number of files in different folders would increase, making it difficult to find a specific file.</li> </ul> <p>Either of these approaches could be easy to set up for small- to mid-sized applications with a small number of files (50 to 100) per folder. For larger projects, however, you may want to go for a hybrid approach based on the logical structure of your application. Let us look at some of the possibilities.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hybrid-grouping-based-on-domain-and-common-components","title":"Hybrid Grouping Based on Domain and Common Components","text":"<p>Here you would group all common components required across the application in a Components folder and all application flow-specific routes or features in a domain folder (the name could be domain, pages, or routes). Every folder can have subfolders for specific components and related files:</p> <pre><code>css/\n    global.css\ncomponents/\n    User/\n        profile.js\n        profile.test.js\n        avatar.js\n    date.js\n    currency.js\n    gtm.js\n    errorUtils.js\ndomain/\n    product/\n        product.js\n        product.css\n        product.test.js\n    checkout/\n        checkout.js\n        checkout.css\n        checkout.test.js\n</code></pre> <p>Thus, you can combine the advantages of both \u201cGroup by file type\u201d and \u201cGroup by feature\u201d by colocating related files, which change together frequently and common reusable components and styles used across the application. Depending on the complexity of the application, you can modify this to a flatter structure without subfolders or a more nested structure:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#flatter-structure","title":"Flatter structure","text":"<p>The following example illustrates a flatter structure:</p> <pre><code>domain/\n    product.js\n    product.css\n    product.test.js\n    checkout.js\n    checkout.css\n    checkout.test.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#nested-structure","title":"Nested structure","text":"<p>The following example shows a more nested structure:</p> <pre><code>domain/\n    product/\n        productType/\n            features.js\n            features.css\n            size.js\n        price/\n            listprice.js\n            discount.js\n</code></pre> <p>A variation to this approach is to create folders based on views or routes, in addition to those based on domain, as discussed here. A routing component can then coordinate the view to be displayed based on the current route. Next.js uses a similar structure.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-modern-react-features","title":"Application Structure for Modern React Features","text":"<p>Modern React apps use different features such as Redux, stateful containers, Hooks, and Styled Components. Let\u2019s see where the code related to these would fit in the application structure proposed in the previous section.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#redux","title":"Redux","text":"<p>Redux documentation strongly recommends colocating logic for a given feature in one place. Within a given feature folder, the Redux logic for that feature should be written as a single \u201cslice\u201d file, preferably using the Redux Toolkit createSlice API.</p> <p>The file bundles <code>{actionTypes, actions, reducer}</code> to a self-contained, isolated module. This is also known as the \u201cducks\u201d pattern (from Redux).</p> <p>For example, as given here:</p> <pre><code>/src\n    index.tsx: Entry point file that renders the React component tree\n\n/app\n    store.ts: store setup\n    rootReducer.ts: root reducer (optional)\n    App.tsx: root React component\n\n/common: hooks, generic components, utils, etc\n\n/features: contains all \"feature folders\"\n\n/todos: a single feature folder\n    todosSlice.ts: Redux reducer logic and associated actions\n    Todos.tsx: a React component\n</code></pre> <p>Another comprehensive example that uses Redux without creating containers or Hooks is available here.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#containers","title":"Containers","text":"<p>If you have structured your code to categorize components into presentational components and stateful container components, you can create a separate folder for the container components. Containers let you separate complex stateful logic from other aspects of the component:</p> <pre><code>/src\n    /components\n        /component1\n            index.js\n            styled.js\n    /containers\n        /container1\n</code></pre> <p>You can find a complete structure for an app with containers in the same article.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hooks","title":"Hooks","text":"<p>Hooks can fit into the hybrid structure just like any other type of code. You can have a folder at the app level for common Hooks that can be consumed by all React components. React Hooks used by only one component should remain in the component\u2019s file or a separate hooks.js file in the component\u2019s folder. You can find a sample structure here:</p> <pre><code>/components\n    /productList\n        index.js\n        test.js\n        style.css\n        hooks.js\n\n/hooks\n    /useClickOutside\n        index.js\n    /useData\n        index.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#styled-components","title":"Styled Components","text":"<p>If you are using Styled Components instead of CSS, you can have style.js files instead of the component-level CSS files mentioned earlier. For example, if you have a titlebar component, the structure would be something like this:</p> <pre><code>/src/components/button/\n    index.js\n    style.js\n</code></pre> <p>An application-level theme.js file would contain the values for colors to be used for background and text. A globals component could include definitions for common style elements that other components can use.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#reference","title":"Reference","text":"<ul> <li>Learning JavaScript Design Patterns: 2nd edition by Addy Osmani</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/","title":"Best folder structure in Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#best-folder-structure-in-redux-toolkit","title":"Best folder structure in Redux Toolkit","text":"<p>Is this the best folder structure for a large application using Redux Toolkit, and do we still need separate actions and reducers folders?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-folder-structure","title":"1. Folder Structure:","text":"<ul> <li>Your structure effectively separates concerns, which is great for maintainability.</li> <li>Using <code>/slices</code> is appropriate since Redux Toolkit encourages using \"slices\" to combine actions and reducers into one file.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-actions-and-reducers","title":"2. Actions and Reducers:","text":"<ul> <li> <p>No Separate Folders Needed: With Redux Toolkit, you typically don't need separate <code>/actions</code> and <code>/reducers</code> folders. Each slice file contains both the actions and the reducers, which helps reduce redundancy and keeps related code together.</p> </li> <li> <p>Example Slice:</p> </li> </ul> <pre><code>// /redux/slices/exampleSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst exampleSlice = createSlice({\n  name: \"example\",\n  initialState: {},\n  reducers: {\n    actionOne: (state, action) =&gt; {\n      // reducer logic\n    },\n    actionTwo: (state, action) =&gt; {\n      // reducer logic\n    },\n  },\n});\n\nexport const { actionOne, actionTwo } = exampleSlice.actions;\nexport default exampleSlice.reducer;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#suggested-structure","title":"Suggested Structure:","text":"<p>You could simplify your Redux-related folder as follows:</p> <pre><code>/redux\n\u251c\u2500\u2500 /slices             // Redux slices, combining actions and reducers\n\u251c\u2500\u2500 /store.js          // Store configuration\n\u2514\u2500\u2500 /middleware         // Any custom middleware (optional)\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#additional-tips","title":"Additional Tips:","text":"<ul> <li>Combine Slices: If your application grows, consider combining slices in a feature folder to keep related slices, components, and styles together.</li> <li>Testing: Maintain your <code>/tests</code> folder for unit tests that cover slices, components, and hooks.</li> <li>Documentation: As your app scales, consider documenting each folder's purpose to help onboard new developers.</li> </ul> <p>This structure and approach should enhance your application's scalability and maintainability.</p> <p>What is the /middleware folder in a Redux Toolkit application, and what does it contain, given that Redux Toolkit uses thunk by default?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview_1","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-purpose-of-the-middleware-folder","title":"1. Purpose of the <code>/middleware</code> Folder:","text":"<ul> <li>The <code>/middleware</code> folder is where you can define custom middleware that you want to use in your Redux application, beyond the default middleware provided by Redux Toolkit (like thunk).</li> <li>Middleware can be used for various purposes such as logging, error handling, analytics, or intercepting actions before they reach the reducer.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-default-middleware","title":"2. Default Middleware:","text":"<ul> <li>Redux Toolkit comes with <code>redux-thunk</code> and some other default middleware (like <code>redux-immutable-state-invariant</code> in development) included in the store configuration. You can still add your own custom middleware alongside these.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#example-middleware-file","title":"Example Middleware File:","text":"<p>Here\u2019s how you might structure a custom middleware file.</p> <p>Folder Structure:</p> <pre><code>/redux\n\u251c\u2500\u2500 /slices\n\u251c\u2500\u2500 /middleware\n\u2502   \u2514\u2500\u2500 loggerMiddleware.js\n\u251c\u2500\u2500 /store.js\n</code></pre> <p>Example Middleware: <code>loggerMiddleware.js</code></p> <pre><code>// /redux/middleware/loggerMiddleware.js\n\nconst loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  console.log(\"Dispatching action:\", action);\n  const result = next(action); // Pass action to the next middleware/reducer\n  console.log(\"Next state:\", store.getState());\n  return result; // Return the result of the action\n};\n\nexport default loggerMiddleware;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#integrating-middleware-in-store","title":"Integrating Middleware in Store:","text":"<p>You would then apply this middleware in your <code>store.js</code> file.</p> <p>Example <code>store.js</code></p> <pre><code>// /redux/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport rootReducer from \"./slices\"; // Your root reducer\nimport loggerMiddleware from \"./middleware/loggerMiddleware\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(loggerMiddleware), // Adding custom middleware\n});\n\nexport default store;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#summary","title":"Summary:","text":"<ul> <li>The <code>/middleware</code> folder is for any custom middleware you want to add to your Redux setup.</li> <li>You can create middleware for logging, API error handling, analytics, etc.</li> <li>Redux Toolkit uses thunk by default, but you can augment the middleware with your own logic as needed.</li> </ul> <p>What is the purpose of adding custom middleware in Redux Toolkit, what does it do, when should it be used, and what happens if it's not included?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview_2","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-purpose-of-custom-middleware","title":"1. Purpose of Custom Middleware:","text":"<ul> <li>Custom middleware is a powerful way to enhance the Redux store's capabilities. It allows you to intercept actions before they reach the reducers, enabling you to perform side effects or additional logic.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-what-custom-middleware-does","title":"2. What Custom Middleware Does:","text":"<ul> <li>Intercept Actions: Custom middleware can log actions, modify them, or even prevent them from reaching the reducers.</li> <li>Side Effects: You can perform asynchronous tasks, such as API calls, or other operations that are not purely related to state updates.</li> <li>Logging and Debugging: Middleware like logging can be useful during development to track dispatched actions and the resulting state.</li> </ul> Example of logging middleware:<pre><code>const loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  console.log(\"Dispatching action:\", action);\n  const result = next(action); // Pass the action to the next middleware/reducer\n  console.log(\"Next state:\", store.getState());\n  return result; // Return the result\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#3-when-to-use-custom-middleware","title":"3. When to Use Custom Middleware:","text":"<p>Use custom middleware when you need to perform:</p> <ul> <li>Logging of actions and state changes.</li> <li>Error handling for actions (e.g., capturing errors from API calls).</li> <li>Conditional action dispatching (e.g., delaying actions based on certain criteria).</li> <li>Analytics tracking to log user interactions with your app.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#4-what-if-you-do-not-use-it","title":"4. What If You Do Not Use It:","text":"<ul> <li>If you don't add custom middleware, your Redux store will still function with the default middleware (like thunk), but you lose the extra capabilities that custom middleware provides.</li> <li>You might miss out on useful features like action logging, error handling, or other custom side effects that could enhance the user experience or simplify debugging.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#summary_1","title":"Summary:","text":"<p>Custom middleware extends the functionality of Redux, enabling you to intercept and manipulate actions, perform side effects, and implement features that go beyond simple state management. While not strictly necessary for every application, it can be very helpful for logging, debugging, and handling complex asynchronous logic. If omitted, your application will still work with the default middleware, but you might miss out on valuable insights and features.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/","title":"How to Check the React Version in Your Project","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#how-to-check-the-react-version-in-your-project","title":"How to Check the React Version in Your Project","text":"<p>React, a popular JavaScript library for building user interfaces, undergoes regular updates to introduce new features, improvements, and bug fixes. As a React developer, it's essential to know the version of React used in your project. In this short blog post, we'll explore how you can easily check the React version of your project.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#methods-to-check-react-version","title":"Methods to Check React Version:","text":"<ol> <li> <p>Examine <code>package.json</code>:</p> <p>The <code>package.json</code> file is a central configuration file for Node.js projects, including React applications. Open the <code>package.json</code> file in your project's root directory using a text editor. Look for the \"dependencies\" section, where React is listed with its version.</p> <pre><code>\"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n\n    // other dependencies...\n}\n</code></pre> <p>In this example, the version of React is specified as \"<code>^17.0.1</code>\".</p> </li> <li> <p>Use Command Line:</p> <p>You can also use the command line to check the installed version of React. Open your terminal or command prompt, navigate to your project's root directory, and run the following command:</p> <pre><code>npm list react\n</code></pre> <p>If you're using Yarn, run:</p> <pre><code>yarn list react\n</code></pre> <p>This command will display the version of React installed in your project.</p> </li> <li> <p>Inspect the Browser Console:</p> <p>During development, you can view the React version in your browser's developer tools console. Open your application in a web browser, right-click on the page, select \"Inspect\" to open the developer tools, and navigate to the \"Console\" tab. Type the following command and press Enter:</p> <pre><code>console.log(React.version);\n</code></pre> <p>This will log the React version to the console.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#conclusion","title":"Conclusion:","text":"<p>Knowing the React version in your project is crucial for various reasons, including understanding the available features, compatibility, and potential need for updates. By examining your <code>package.json</code> file, using command-line tools, or inspecting the browser console, you can easily check the React version and ensure your project stays up-to-date with the latest advancements in React development.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/","title":"Checking Node.js Versions in React Projects","text":"","tags":["react","js"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/#checking-nodejs-versions-in-react-projects","title":"Checking <code>Node.js</code> Versions in React Projects","text":"<p>React itself doesn't directly depend on Node.js version. However, when you're developing a React application, you typically use Node.js and npm (Node Package Manager) to manage your project's dependencies, run development servers, and build your application for production.</p> <p>React projects typically come with a package.json file which specifies the project's dependencies, including the version of Node.js it's compatible with. You can find the required version of Node.js specified in the engines field of the package.json file.</p> package.json<pre><code>\"engines\": {\n  \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <p>This indicates that the project requires Node.js version <code>12.0.0</code> or later to run properly. You should install the specified version of Node.js on your development machine to ensure compatibility with the React project.</p> <p>You can check the <code>package.json</code> file in your React project's root directory to see which version of Node.js it requires. If you don't have a <code>package.json</code> file, it's likely that your React project hasn't been initialized properly, and you might need to set it up with npm init or yarn init to generate the file.</p>","tags":["react","js"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/","title":"Choosing Between Function Declarations and Arrow Functions for React Components","text":"","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#choosing-between-function-declarations-and-arrow-functions-for-react-components","title":"Choosing Between Function Declarations and Arrow Functions for React Components","text":"<p>When defining React components, you might encounter two common patterns: <code>function declarations</code> and <code>arrow functions</code>. Both approaches are valid, but they come with different nuances</p> Two common patterns <ol> <li>Function Declarations</li> <li>Arrow Functions.</li> </ol> <p>Let's explore these two styles and determine which one you might want to use in your React projects.</p>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#1-function-declaration","title":"1. Function Declaration","text":"ExampleAdvantagesDisadvantages <pre><code>import React from 'react';\n\nfunction TestComponent() {\n    return (\n        &lt;div&gt;TestComponent&lt;/div&gt;\n    );\n}\n\nexport default TestComponent;\n</code></pre> <ol> <li> <p>Hoisting:</p> <p>Function declarations are hoisted, meaning they can be called before they are defined in the code. This can be useful in certain scenarios, though it\u2019s less of a concern with modern React development.</p> </li> <li> <p>Traditional Syntax:</p> <p>This style is familiar to many developers and fits well with older JavaScript codebases. It\u2019s clear and straightforward, particularly for those accustomed to traditional function definitions.</p> </li> </ol> <ol> <li><code>this</code> Binding: While this isn't a concern for functional components, traditional function declarations come with their own <code>this</code> context, which can be confusing if you're mixing class-based and functional components.</li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#2-arrow-function","title":"2. Arrow Function","text":"ExampleAdvantagesDisadvantages <pre><code>import React from 'react';\n\nconst TestComponent = () =&gt; {\n    return (\n        &lt;&gt;&lt;/&gt;\n    );\n};\n\nexport default TestComponent;\n</code></pre> <ol> <li> <p>Conciseness:</p> <p>Arrow functions provide a more modern and concise syntax. They\u2019re often preferred for their brevity, which can make code easier to read and write.</p> </li> <li> <p>Lexical <code>this</code> Binding:</p> <p>Arrow functions inherit <code>this</code> from their surrounding context, which avoids some common pitfalls related to <code>this</code> in traditional functions.</p> </li> </ol> <ol> <li>Not Hoisted: Arrow functions are not hoisted. This means they need to be defined before they are used, which can be a minor drawback if you\u2019re used to the flexibility of function declarations.</li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#which-one-to-choose","title":"Which One to Choose?","text":"<p>For most modern React development, arrow functions are the preferred choice. Their concise syntax, combined with lexical <code>this</code> binding, aligns well with the functional programming paradigm promoted by React. They integrate seamlessly with other modern JavaScript features and libraries, enhancing readability and maintainability.</p> <p>However, function declarations remain a solid option, especially in projects where consistency with existing code is crucial or where hoisting could be beneficial. They are also a good choice for developers who prefer traditional JavaScript syntax.</p> <p>Ultimately, the decision between the two styles may come down to personal or team preference. Both patterns are valid and can be used effectively depending on the specific needs of your project and coding style.</p>","tags":["antd","react"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/","title":"Combine Slices in a Feature Folder","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#combine-slices-in-a-feature-folder","title":"Combine Slices in a Feature Folder","text":"<p>This approach promotes encapsulation, improves readability, and enhances collaboration among team members, particularly in larger projects.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#overview","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#1-combining-slices-in-a-feature-folder","title":"1. Combining Slices in a Feature Folder:","text":"<ul> <li>As your application grows, it can become beneficial to organize related slices, components, and styles into dedicated feature folders. This approach groups all relevant files for a specific feature or domain together, making it easier to manage and navigate your codebase.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#2-structure-of-a-feature-folder","title":"2. Structure of a Feature Folder:","text":"<p>A feature folder typically contains:</p> <ul> <li>Slices: Redux slices that manage the state for that feature.</li> <li>Components: UI components related to that feature.</li> <li>Styles: Any styles specific to that feature (e.g., CSS or styled-components).</li> <li>Hooks: Any custom hooks that are used within the feature.</li> </ul> Example Structure:<pre><code>/src\n\u251c\u2500\u2500 /features\n\u2502   \u251c\u2500\u2500 /user\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js      // Redux slice\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js     // User profile component\n\u2502   \u2502   \u251c\u2500\u2500 UserList.js        // User list component\n\u2502   \u2502   \u251c\u2500\u2500 userStyles.css      // Component-specific styles\n\u2502   \u2502   \u2514\u2500\u2500 useUser.js         // Custom hook for user data\n\u2502   \u2514\u2500\u2500 /posts\n\u2502       \u251c\u2500\u2500 postsSlice.js\n\u2502       \u251c\u2500\u2500 Post.js\n\u2502       \u251c\u2500\u2500 PostList.js\n\u2502       \u2514\u2500\u2500 postStyles.css\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#3-benefits-of-this-organization","title":"3. Benefits of This Organization:","text":"<ul> <li>Encapsulation: Keeps all files related to a feature together, reducing clutter in your codebase.</li> <li>Scalability: Makes it easier to scale features independently. New developers can focus on a specific feature without needing to understand the entire codebase.</li> <li>Readability: Improves code readability by making it clearer where to find related code. Developers can quickly locate the slice, components, and styles for a feature.</li> <li>Reusability: Encourages reusability of components and hooks within a feature.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#4-when-to-implement-this","title":"4. When to Implement This:","text":"<ul> <li>This organization becomes particularly valuable as your application grows in complexity or when you start working in a team. If you have multiple developers working on different features, feature folders can help avoid merge conflicts and make onboarding easier.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#summary","title":"Summary:","text":"<p>Combining slices in a feature folder organizes related code components, making it easier to manage, understand, and scale your application. This approach promotes encapsulation, improves readability, and enhances collaboration among team members, particularly in larger projects.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/","title":"Conditional Rendering in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conditional-rendering-in-react","title":"Conditional Rendering in React","text":"Conditional Rendering in React: Using Ternary Operators vs. Logical AND <p>Both code snippets are functionally equivalent, but there are differences in style and readability. Here\u2019s a comparison of the two approaches:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#1-using-a-ternary-operator","title":"1.  Using a Ternary Operator","text":"<pre><code>{isCircular ? (\n&lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; {\n            setIsTemplateModalOpen(true);\n            dispatch(actionForGetAllCircularPlanningTemplate());\n        }} style={{ marginRight: \"8px\" }}&gt;\n            Template\n        &lt;/Button&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n            Send for Approval\n        &lt;/Button&gt;\n    &lt;/div&gt;\n&lt;/&gt;\n) : null}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#2-using-logical-and-operator","title":"2.  Using Logical AND Operator","text":"<pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#comparison-and-recommendations","title":"Comparison and Recommendations","text":"Readability and Simplicity: <ul> <li>Logical AND (<code>&amp;&amp;</code>): This method is more concise and commonly used in React for conditional rendering. It directly expresses that the content should only render if the condition is true, making the code cleaner and easier to read.</li> <li>Ternary Operator (<code>? :</code>): This method is more explicit, showing both the <code>true</code> and <code>false</code> branches. It\u2019s useful when you need to render something when the condition is <code>false</code>, but in cases where you only care about rendering when true, it can be more verbose.</li> </ul> Use Case: <ul> <li>If you only need to render something based on a condition and don\u2019t need to handle the <code>false</code> case, the logical AND (<code>&amp;&amp;</code>) operator is typically preferred for its brevity.</li> <li>If you need to explicitly handle both <code>true</code> and <code>false</code> cases (e.g., rendering a fallback or alternative UI), the ternary operator is more appropriate.</li> </ul> Code Consistency: <ul> <li>Choose a style that is consistent with the rest of your codebase. Consistency helps maintain readability and makes it easier for others to understand and maintain the code.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion","title":"Conclusion","text":"<p>In most cases, using the logical AND (<code>&amp;&amp;</code>) operator is preferred for its simplicity and readability when you only need to render content conditionally:</p> <pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre> <p>This method clearly shows that the content is rendered only if <code>isCircular</code> is true, and it avoids the need to explicitly render <code>null</code> for the <code>false</code> case.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#question","title":"Question","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#what-is-conditional-rendering","title":"What is Conditional rendering","text":"<p>Conditional rendering in React is a technique used to render different components or elements based on certain conditions. It allows you to control what is displayed to the user based on the state or props of your component. This is essential for creating dynamic and interactive user interfaces.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#types-of-conditional-rendering","title":"Types of Conditional Rendering","text":"<ol> <li> <p>Using if Statements:</p> <ul> <li>You can use <code>if</code> statements inside your component to conditionally render different JSX elements.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; {\n  if (isLoggedIn) {\n    return &lt;h1&gt;Welcome Back!&lt;/h1&gt;;\n  } else {\n    return &lt;h1&gt;Please Log In&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Ternary Operators:</p> <ul> <li>The ternary operator is often used for inline conditional rendering within JSX.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; (\n  &lt;div&gt;\n    {isLoggedIn ? &lt;h1&gt;Welcome Back!&lt;/h1&gt; : &lt;h1&gt;Please Log In&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using Logical AND (<code>&amp;&amp;</code>) Operator:</p> <ul> <li>The logical AND operator is used to render content only if a condition is true.</li> </ul> <pre><code>const MyComponent = ({ showWelcome }) =&gt; (\n  &lt;div&gt;\n    {showWelcome &amp;&amp; &lt;h1&gt;Welcome to Our Website!&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using <code>switch</code> Statements:</p> <ul> <li>For more complex scenarios, a <code>switch</code> statement can be used to render different components based on multiple conditions.</li> </ul> <pre><code>const MyComponent = ({ status }) =&gt; {\n  switch (status) {\n    case 'loading':\n      return &lt;h1&gt;Loading...&lt;/h1&gt;;\n    case 'success':\n      return &lt;h1&gt;Data Loaded Successfully!&lt;/h1&gt;;\n    case 'error':\n      return &lt;h1&gt;Error Loading Data&lt;/h1&gt;;\n    default:\n      return &lt;h1&gt;Unknown Status&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Inline Functions:</p> <ul> <li>Sometimes, especially in more complex conditions, you might use inline functions or methods.</li> </ul> <pre><code>const MyComponent = ({ user }) =&gt; {\n  const renderUserGreeting = () =&gt; {\n    if (user) {\n      return &lt;h1&gt;Hello, {user.name}!&lt;/h1&gt;;\n    }\n    return &lt;h1&gt;Hello, Guest!&lt;/h1&gt;;\n  };\n\n  return &lt;div&gt;{renderUserGreeting()}&lt;/div&gt;;\n};\n</code></pre> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion_1","title":"Conclusion","text":"<p>Conditional rendering is a powerful feature in React that helps you create dynamic and interactive user interfaces. Choose the method that best fits the complexity of your conditions and maintain readability and maintainability of your code.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#advanced-topic","title":"Advanced Topic","text":"<p>While conditional rendering is essential in React, it is not the most advanced or the sole important topic. It is a foundational concept, but mastering React involves understanding multiple advanced concepts and patterns. Here\u2019s a breakdown of where conditional rendering fits and what other advanced topics exist in React:</p> <ol> <li> <p>Conditional Rendering (Basic to Intermediate)</p> <ul> <li>Conditional rendering is important because it allows you to dynamically show or hide components based on application state, props, or user interactions.</li> <li>It\u2019s essential but relatively straightforward once you understand basic JavaScript control structures.</li> </ul> </li> <li> <p>More Advanced and Important Topics in React</p> </li> </ol> <p>2.1 State Management (Advanced)</p> <ul> <li>Managing component state with hooks (<code>useState</code>, <code>useReducer</code>).</li> <li>Using libraries like <code>Redux</code> or <code>Context API</code> for global state management.</li> <li>Understanding how to handle complex state logic, side effects (<code>useEffect</code>), and async operations (e.g., API calls).</li> </ul> <p>2.2 React Hooks (Intermediate to Advanced)</p> <ul> <li>Hooks like <code>useEffect</code>, <code>useContext</code>, <code>useMemo</code>, <code>useCallback</code>, <code>useRef</code>, etc., bring reusability and optimization.</li> <li>Custom hooks are essential for abstracting complex logic into reusable pieces.</li> </ul> <p>2.3 Component Lifecycle and Side Effects (Advanced)</p> <ul> <li>Understanding how React\u2019s rendering lifecycle works and using hooks like <code>useEffect</code> to handle side effects (data fetching, subscriptions, cleanup).</li> <li>How React optimizes rendering with virtual DOM and reconciliation processes.</li> </ul> <p>2.4 Performance Optimization (Advanced)</p> <ul> <li>Techniques like memoization (<code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>) to prevent unnecessary re-renders.</li> <li>Code splitting and lazy loading for better performance using React.lazy and Suspense.</li> <li>Dealing with large lists efficiently using react-window or react-virtualized.</li> </ul> <p>2.5 Routing and Navigation</p> <ul> <li>Handling routing with libraries like React Router.</li> <li>Dynamic route matching, route guards, and lazy-loading routes.</li> </ul> <p>2.6 Context API (Intermediate to Advanced)</p> <ul> <li>The Context API allows for state sharing between components without prop drilling.</li> <li>It's useful for handling global state or themes, but managing complex state often requires Redux or other state libraries.</li> </ul> <p>2.7 Higher-Order Components (HOCs) &amp; Render Props</p> <ul> <li>HOCs and render props are patterns used for code reuse, which is essential for maintaining clean, reusable components in large codebases.</li> </ul> <p>2.8 Custom Hooks and Reusability Patterns</p> <ul> <li>Creating custom hooks allows for reusing logic across components.</li> <li>Exploring patterns like Compound Components and Provider Pattern for scalable and reusable UI libraries.</li> </ul> <p>2.9 React Context vs Redux (Global State Management)</p> <ul> <li>Understanding when to use React Context vs. more advanced state management libraries like Redux for global app state.</li> </ul> <p>2.10 Testing (Advanced)</p> <ul> <li>Testing React components using libraries like Jest and React Testing Library for unit testing and integration testing.</li> <li>Snapshot testing, mocking APIs, and ensuring UI behaves as expected are critical in scalable applications.</li> </ul> <p>2.11 TypeScript with React</p> <ul> <li>Adding TypeScript to React for better type checking, autocompletion, and code robustness in large applications.</li> <li>Advanced types and generics in components and hooks.</li> </ul> <p>2.12 Server-Side Rendering (SSR) and Static Site Generation (SSG)</p> <ul> <li>Understanding Next.js or Gatsby for building applications with SSR or SSG, improving SEO and performance.</li> <li>Managing data fetching and page pre-rendering in SSR.</li> </ul> <p>2.13 React Native (Mobile Development)</p> <ul> <li>Transitioning from React to React Native for mobile app development using similar paradigms.</li> <li>Handling platform-specific behaviors while sharing logic across mobile and web.</li> </ul> Conclusion <p>Conditional rendering is important but is only one of the core concepts of React. More advanced topics, such as state management, hooks, performance optimization, and patterns like HOCs or custom hooks, are vital for mastering React and handling real-world, scalable applications.</p> <p>Becoming proficient in React involves learning and mastering several areas, not just conditional rendering.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/08/11/conditinally-mounting-component/","title":"Conditinally Mounting Component","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#conditinally-mounting-component","title":"Conditinally Mounting Component","text":"<p>Yes, it's a good practice to mount the <code>LogList</code> component only when the corresponding <code>TabPane</code> is <code>active</code>. This approach can enhance performance by reducing the number of components that are rendered initially and by preventing unnecessary data fetching when the tab is not being viewed.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#benefits-of-conditional-mounting","title":"Benefits of Conditional Mounting:","text":"<ol> <li>Performance: It prevents the component from being mounted and the API call from being made until the tab is clicked, saving resources.</li> <li>User Experience: Users will only see relevant content when they actually navigate to that tab.</li> <li>State Management: If the component fetches data, it helps manage loading states and errors more effectively since you control when the data is fetched.</li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#how-to-implement-conditional-mounting","title":"How to Implement Conditional Mounting:","text":"<p>You can use a combination of state to track the active tab and conditional rendering for the <code>LogList</code> component.</p> <p>Here\u2019s how you can do it:</p> ExampleExplanation <pre><code>import React, { useState } from \"react\";\nimport { Tabs } from \"antd\";\nimport LogList from \"./LogList\"; // Adjust the import according to your structure\n\nconst { TabPane } = Tabs;\n\nconst MyComponent = () =&gt; {\n  const [activeKey, setActiveKey] = useState(\"1\"); // Default active tab key\n\n  const handleTabChange = (key) =&gt; {\n    setActiveKey(key);\n  };\n\n  return (\n    &lt;Tabs\n      defaultActiveKey=\"1\"\n      activeKey={activeKey}\n      onChange={handleTabChange}\n      type=\"line\"\n    &gt;\n      &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n        {contactDetails()} {/* Assuming contactDetails is a function */}\n      &lt;/TabPane&gt;\n      &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n        &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n      &lt;/TabPane&gt;\n      &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n        {activeKey === \"4\" &amp;&amp; &lt;LogList /&gt;}{\" \"}\n        {/* Only mount LogList when active */}\n      &lt;/TabPane&gt;\n    &lt;/Tabs&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li>State Management: The <code>activeKey</code> state tracks the currently active tab.</li> <li>Event Handling: The <code>handleTabChange</code> function updates the <code>activeKey</code> when a tab is clicked.</li> <li>Conditional Rendering: The <code>LogList</code> component is only rendered when <code>activeKey</code> is <code>\"4\"</code>.</li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#conclusion","title":"Conclusion","text":"<p>By following this pattern, you ensure that <code>LogList</code> is only mounted and rendered when the user is viewing that specific tab, enhancing performance and maintaining a better user experience.</p> <pre><code>\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/","title":"What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why","title":"What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?","text":"<p>Choosing between them depends on the complexity of your application's side effects and your team's familiarity with the respective concepts.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#1-main-differences","title":"1. Main Differences:","text":"<p>Conceptual Model:</p> <ul> <li> <p>Redux Thunk: Thunks are simple functions that return another function (the thunk) that can dispatch actions and perform asynchronous operations. It relies on promises and is more straightforward, suitable for simpler use cases.</p> </li> <li> <p>Redux Saga: Uses generator functions to manage side effects in a more declarative way. Sagas are more powerful and can handle complex asynchronous flows, allowing for more control over the execution of actions.</p> </li> </ul> <p>Ease of Use:</p> <ul> <li>Redux Thunk: Easier to learn and implement, especially for developers familiar with JavaScript Promises. It fits well for straightforward asynchronous tasks.</li> <li>Redux Saga: Has a steeper learning curve due to the concepts of generators and effects. However, it provides more advanced capabilities like canceling tasks, handling race conditions, and orchestrating complex flows.</li> </ul> <p>Testing:</p> <ul> <li>Redux Thunk: Testing thunks involves checking the dispatched actions and state changes, which can be simpler but less structured.</li> <li>Redux Saga: Sagas are easier to test due to their generator functions. You can test the effects in isolation, making the tests more predictable.</li> </ul> <p>Control Flow:</p> <ul> <li>Redux Thunk: Mostly linear and based on promise chains. It doesn't handle complex control flow well (e.g., waiting for multiple actions).</li> <li>Redux Saga: Offers powerful control flow mechanisms (e.g., <code>take</code>, <code>put</code>, <code>call</code>, <code>fork</code>, <code>race</code>) to manage concurrent actions and complex sequences.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#2-which-one-to-use-and-why","title":"2. Which One to Use and Why:","text":"<p>Use Redux Thunk:</p> <ul> <li>If your application has simple asynchronous needs, like fetching data from an API or submitting forms.</li> <li>When you want to keep things lightweight and straightforward without the overhead of learning generators and saga patterns.</li> </ul> <p>Use Redux Saga:</p> <ul> <li>If your application requires complex side effect management, such as handling multiple API calls simultaneously, canceling requests, or coordinating complex asynchronous workflows.</li> <li>When you need better control over side effects and want a more structured way to manage them, especially in larger applications.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#summary","title":"Summary","text":"<ul> <li>Redux Thunk: Simpler, easier to use for straightforward async tasks. Good for most basic needs.</li> <li>Redux Saga: More powerful and flexible for complex side effects. Better for larger applications with intricate asynchronous logic.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/","title":"Do we need to install redux-thunk separately when using Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit","title":"Do we need to install redux-thunk separately when using Redux Toolkit","text":"<p>Redux Toolkit includes redux-thunk as a built-in middleware by default when you create a store using <code>configureStore</code>.</p> <p>Do we need to install redux-thunk separately when using Redux Toolkit, and how can we use Redux Saga with it?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#1-no-need-to-install-redux-thunk-separately","title":"1. No Need to Install Redux Thunk Separately:","text":"<ul> <li>Redux Toolkit includes redux-thunk as a built-in middleware by default when you create a store using <code>configureStore</code>. Therefore, you do not need to install or configure redux-thunk separately; it is ready to use out of the box.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#2-using-redux-saga-with-redux-toolkit","title":"2. Using Redux Saga with Redux Toolkit:","text":"<ul> <li>If you want to use Redux Saga, you will need to install it separately and configure it as middleware when setting up your store. Redux Saga is useful for managing complex side effects and asynchronous flows in your application.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#steps-to-use-redux-saga-with-redux-toolkit","title":"Steps to Use Redux Saga with Redux Toolkit","text":"<ol> <li> <p>Install Redux Saga</p> <p>You can install Redux Saga using npm or yarn:</p> <pre><code>npm install redux-saga\n</code></pre> </li> <li> <p>Create a Saga</p> <p>Create a saga file where you define your saga functions.</p> <pre><code>// userSaga.js\nimport { call, put, takeEvery } from \"redux-saga/effects\";\nimport axios from \"axios\";\n\n// Worker saga for fetching users\nfunction* fetchUsers() {\n  try {\n    const response = yield call(\n      axios.get,\n      \"https://jsonplaceholder.typicode.com/users\"\n    );\n    yield put({ type: \"users/fetchSuccess\", payload: response.data });\n  } catch (error) {\n    yield put({ type: \"users/fetchError\", payload: error.message });\n  }\n}\n\n// Watcher saga\nfunction* watchFetchUsers() {\n  yield takeEvery(\"users/fetchRequest\", fetchUsers);\n}\n\n// Root saga\nexport default function* rootSaga() {\n  yield watchFetchUsers();\n}\n</code></pre> </li> <li> <p>Configure the Store with Saga Middleware</p> <p>You need to set up the Redux store and apply the saga middleware.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport createSagaMiddleware from \"redux-saga\";\nimport usersReducer from \"./usersSlice\";\nimport rootSaga from \"./userSaga\";\n\n// Create the saga middleware\nconst sagaMiddleware = createSagaMiddleware();\n\n// Configure the store\nconst store = configureStore({\n  reducer: {\n    users: usersReducer, // Add users slice reducer\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(sagaMiddleware), // Include saga middleware\n});\n\n// Run the root saga\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n</code></pre> </li> <li> <p>Dispatch Actions from a Component</p> <p>You can dispatch actions to trigger the saga in your components.</p> <pre><code>// UsersList.js\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nconst UsersList = () =&gt; {\n  const dispatch = useDispatch();\n  const { users, loading, error } = useSelector((state) =&gt; state.users);\n\n  useEffect(() =&gt; {\n    dispatch({ type: \"users/fetchRequest\" }); // Dispatch action to fetch users\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;/h1&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UsersList;\n</code></pre> </li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>No Separate Installation Needed: Redux Toolkit automatically includes redux-thunk, so you don\u2019t need to install it separately.</li> <li>Using Redux Saga: To use Redux Saga, you need to install it separately, create sagas for your asynchronous logic, and configure the saga middleware in your Redux store.</li> </ul> <p>This approach allows you to choose the best side-effect management strategy for your application, whether it's using built-in thunk support or the more advanced capabilities of Redux Saga.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/","title":"Understanding e.item.props in React and Ant Design's Menu Component","text":"","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#understanding-eitemprops-in-react-and-ant-designs-menu-component","title":"Understanding <code>e.item.props</code> in React and Ant Design's Menu Component","text":"<p>In the context of Ant Design's Menu component, <code>e.item.props</code> refers to the properties of the Menu.Item component that triggered the click event. When a menu item is clicked, Ant Design provides an event object e that contains various details about the event. One of these details is <code>e.item</code>, which represents the <code>Menu.Item</code> that was clicked.</p>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#how-eitemprops-works","title":"How <code>e.item.props</code> Works?","text":"<p>When you create a Menu in Ant Design, each Menu.Item can have its own properties. These properties are similar to the props you would pass to any React component. For instance, you might pass a <code>key</code>, <code>title</code>, or <code>custom data-*</code> attributes to a Menu.Item.</p> <p>Example</p> React<pre><code>import React, { useState } from 'react';\nimport { Menu } from 'antd';\n\nconst MyMenuComponent = ({ menuData, handleMenuClick }) =&gt; {\n    const [selectedTitle, setSelectedTitle] = useState('');\n\n    const handleClick = (e) =&gt; {\n        const clickedTitle = e.item.props['data-title'];\n        setSelectedTitle(clickedTitle);\n        handleMenuClick(clickedTitle);\n    };\n\n    return (\n        &lt;Menu onClick={handleClick} style={{ width: 256 }} mode=\"inline\"&gt;\n            {menuData.map((item, index) =&gt; (\n                &lt;Menu.Item\n                key={item.id}\n                data-title={item.title}\n                &gt;\n                &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n                &lt;/Menu.Item&gt;\n            ))}\n        &lt;/Menu&gt;\n    );\n};\n\nexport default MyMenuComponent;\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#why-use-eitemprops","title":"Why Use e.item.props?","text":"<p>Using <code>e.item.props</code> is beneficial for several reasons:</p> <ol> <li> <p>Dynamic Data Access:</p> <p>It allows you to dynamically access data associated with a menu item, such as titles, IDs, or custom attributes.</p> </li> <li> <p>Simplified Event Handling:</p> <p>Instead of setting up additional state or context to manage menu item data, you can directly access the properties within the event handler.</p> </li> <li> <p>Enhanced Flexibility:</p> <p>You can pass any data you need via custom attributes, making your components more flexible and easier to manage.</p> </li> </ol>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#conclusion","title":"Conclusion","text":"<p>Whether you're building a sidebar menu or any other interactive component, understanding how to use <code>e.item.props</code> effectively will enhance your React development experience.</p>","tags":["react","js"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/","title":"A Comparative Guide to Lodash and JavaScript","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#a-comparative-guide-to-lodash-and-javascript","title":"A Comparative Guide to Lodash and JavaScript","text":"<p>When it comes to working with arrays and objects in JavaScript, developers often face the decision of using utility libraries like Lodash or sticking with plain JavaScript.</p> <p>Utility Libraries vs. Native Methods: A Comparative Guide to Lodash and JavaScript</p> <p>Both have their advantages, and the choice ultimately depends on your specific needs and project requirements.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#the-case-for-lodash","title":"The Case for Lodash","text":"<p>Lodash is a powerful utility library that provides a wide array of functions to simplify common programming tasks. Here are some benefits of using Lodash:</p> <ol> <li> <p>Ease of Use: Lodash functions are often easier to read and understand. For example, using <code>_.sortBy</code> or <code>_.uniqBy</code> allows for quick and intuitive operations without having to write complex logic.</p> </li> <li> <p>Performance: Lodash is optimized for performance, especially when dealing with large datasets. It includes features like lazy evaluation, which can be beneficial for performance-sensitive applications.</p> </li> <li> <p>Cross-Browser Compatibility: Lodash handles many quirks and inconsistencies in JavaScript across different browsers, ensuring that your code works reliably everywhere.</p> </li> <li> <p>Chaining: Lodash supports method chaining, enabling a more fluid coding style that can reduce verbosity when performing multiple operations.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#the-case-for-plain-javascript","title":"The Case for Plain JavaScript","text":"<p>While Lodash offers many conveniences, there are compelling reasons to use plain JavaScript:</p> <ol> <li> <p>No Dependencies: Using plain JavaScript means you avoid adding external libraries to your project, reducing the overall size of your application and minimizing potential dependency issues.</p> </li> <li> <p>Built-in Features: Modern JavaScript (ES6 and beyond) has introduced many powerful features like <code>Array.prototype.map</code>, <code>filter</code>, and <code>reduce</code>, making it easier to perform operations without additional libraries.</p> </li> <li> <p>Learning Opportunity: Writing functions in plain JavaScript helps deepen your understanding of the language. You\u2019ll become more familiar with the core principles and best practices of JavaScript.</p> </li> <li> <p>Performance for Small Tasks: For smaller tasks or applications, plain JavaScript may perform just as well, if not better, than using a library like Lodash. The overhead of including a library can be unnecessary for simple operations.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#conclusion","title":"Conclusion","text":"<p>In the end, the choice between Lodash and plain JavaScript often comes down to the specific requirements of your project. If you need quick and robust solutions for manipulating data and want to leverage a library's features, Lodash is an excellent choice. However, for smaller projects or when aiming for minimal dependencies, plain JavaScript is perfectly capable and may be the better option.</p> <p>By understanding the strengths of both approaches, developers can make informed decisions that suit their coding style and project needs. Whether you choose Lodash or plain JavaScript, the most important factor is writing clean, efficient, and maintainable code.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#real-example","title":"Real Example","text":"lodashPlain js <pre><code>import { uniqBy, sortBy } from \"lodash\";\n\ncase REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n    const updateItems = state?.referencePartyListingCircularResponse;\n\n    return {\n        ...state,\n        referenceCircularPlanningAddLoading: false,\n        referenceCircularPlanningAddResponse: action.payload,\n        // referencePartyListingCircularResponse: [...updateItems, action.payload],\n        referencePartyListingCircularResponse: sortBy(\n            [...updateItems, action.payload],\n            \"partyName\"\n    ),\n};\n</code></pre> <pre><code>// Sort by partyName in ascending order\nconst sortedItems = newItems.sort((a, b) =&gt; a.partyName.localeCompare(b.partyName));\n</code></pre> <p>lodash</p> <p>Yes, you can import multiple specific functions from Lodash in a single import statement. For example, to import both <code>uniqBy</code> and <code>sortBy</code>, you can do it like this:</p> <pre><code>import { uniqBy, sortBy } from \"lodash\";\n</code></pre> <p>With this import, you can use both functions in your code without importing the entire Lodash library. Here's how you might use both in your reducer case:</p> <pre><code>import { uniqBy, sortBy } from 'lodash';\n\ncase REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n  const updateItems = state?.referencePartyListingCircularResponse || [];\n  const newItems = [...updateItems, action.payload];\n\n  // Remove duplicates if needed and then sort\n  const uniqueItems = uniqBy(newItems, 'yourUniqueKey'); // replace 'yourUniqueKey' with the key for uniqueness\n  return {\n    ...state,\n    referenceCircularPlanningAddLoading: false,\n    referenceCircularPlanningAddResponse: action.payload,\n    referencePartyListingCircularResponse: sortBy(uniqueItems, 'yourSortKey'), // replace 'yourSortKey' with the property you want to sort by\n  };\n</code></pre> <p>This approach keeps your imports clean and efficient!</p> <p>Native js Methods</p> <p>You can sort an array of objects by a specific property, such as partyName, using the built-in JavaScript <code>Array.prototype.sort</code> method. Here\u2019s how you can do it without using Lodash:</p> CodeExplanationOptimize using <code>localeCompare</code> <pre><code>case REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n    const updateItems = state?.referencePartyListingCircularResponse || [];\n    const newItems = [...updateItems, action.payload];\n\n    // Sort by partyName in ascending order\n    const sortedItems = newItems.sort((a, b) =&gt; {\n        if (a.partyName &lt; b.partyName) return -1;\n        if (a.partyName &gt; b.partyName) return 1;\n        return 0; // If they're equal\n    });\n\n    return {\n        ...state,\n        referenceCircularPlanningAddLoading: false,\n        referenceCircularPlanningAddResponse: action.payload,\n        referencePartyListingCircularResponse: sortedItems,\n    };\n</code></pre> <ul> <li>The sort method modifies the original array and sorts the items based on the partyName property.</li> <li> <p>The comparison function inside sort determines the order:</p> <ul> <li>If<code>a.partyName</code> is less than <code>b.partyName</code>, it returns <code>-1</code> (meaning <code>a</code> comes first).</li> <li>If<code>a.partyName</code> is greater than <code>b.partyName</code>, it returns <code>1</code> (meaning <code>b</code> comes first).</li> <li>If they are equal, it returns <code>0</code>, leaving their order unchanged.</li> </ul> </li> </ul> <p>This will sort your items in ascending order based on partyName.</p> <p>You can simplify the sorting logic using the localeCompare method, which is more concise and handles string comparison more effectively. Here\u2019s the optimized version:</p> <pre><code>// Sort by partyName in ascending order\nconst sortedItems = newItems.sort((a, b) =&gt; a.partyName.localeCompare(b.partyName));\n</code></pre> Explanation <p><code>localeCompare</code> compares two strings in the current locale, returning:</p> <ul> <li>A negative number if <code>a.partyName</code> comes before <code>b.partyName</code>.</li> <li>A positive number if <code>a.partyName</code> comes after <code>b.partyName</code>.</li> <li><code>0</code> if they are equal.</li> </ul> <p>This single line achieves the same result as the previous implementation but is cleaner and easier to read.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/","title":"Libraries for Immutable Data Structure in React","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#libraries-for-immutable-data-structure-in-react","title":"Libraries for Immutable Data Structure in React","text":"<p>Immer and Immutable.js are libraries that help manage immutable data in JavaScript, but they do so in different ways.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#1-immer","title":"1. Immer","text":"<p>Immer is great when you want immutability but don't want to change your code style too much. It lets you write code that looks like you\u2019re mutating state directly, but under the hood, it\u2019s creating a new state for you. Immer is often used in projects like Redux because it simplifies updating nested state without mutating it.</p> <p>When to use Immer?</p> <ul> <li>When you want simple syntax for managing immutable state.</li> <li>When you have deeply nested data and don\u2019t want to write repetitive code for immutability.</li> <li>It's particularly handy in state management (like Redux reducers).</li> </ul> Example using Immer <pre><code>import produce from 'immer';\n\n// Initial state\nconst state = {\n    user: {\n        name: 'John',\n        address: {\n            city: 'New York',\n            zip: '10001'\n        }\n    }\n};\n\n// Reducer with Immer\nconst newState = produce(state, draft =&gt; {\n    draft.user.address.city = 'San Francisco'; // Looks like mutation, but Immer makes this immutable.\n});\n\nconsole.log(newState);\n// {\n//   user: {\n//     name: 'John',\n//     address: {\n//       city: 'San Francisco',\n//       zip: '10001'\n//     }\n//   }\n// }\n</code></pre> <p>Why use Immer?</p> <p>Immer reduces the complexity of maintaining immutability, especially when dealing with deeply nested structures. It\u2019s easy to read and maintain since the code looks like you're directly mutating the data.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#2-immutablejs","title":"2. Immutable.js","text":"<p>Immutable.js is a more functional and strict approach to immutability. It provides immutable versions of JavaScript's common data structures (Lists, Maps, Sets, etc.) and guarantees immutability at the data structure level. However, it requires you to use Immutable.js specific APIs, which can make the code less readable for some developers who are not familiar with it.</p> <p>When to use Immutable.js?</p> <ul> <li>When you need a strict, performance-optimized immutable data structure.</li> <li>When working in a large-scale application where immutability is crucial, and you want to avoid accidental mutations.</li> <li>If you prefer working with functional programming paradigms.</li> </ul> Example using Immutable.js <pre><code>import { Map } from 'immutable';\n\n// Initial state as an Immutable Map\nconst state = Map({\n    user: Map({\n        name: 'John',\n        address: Map({\n            city: 'New York',\n            zip: '10001'\n        })\n    })\n});\n\n// Update state immutably\nconst newState = state.setIn(['user', 'address', 'city'], 'San Francisco');\n\nconsole.log(newState.toJS()); // Convert to plain JavaScript object\n// {\n//   user: {\n//     name: 'John',\n//     address: {\n//       city: 'San Francisco',\n//       zip: '10001'\n//     }\n//   }\n// }\n</code></pre> <p>Why use Immutable.js?</p> <p>Immutable.js ensures complete immutability and provides a rich API for working with immutable data structures. It\u2019s highly performant for large collections, but it has a steeper learning curve and can require more boilerplate than Immer.</p> Comparison of Immer vs. Immutable.js <ul> <li>Ease of Use Immer is easier to use and integrate into existing codebases since it allows you to work with plain JavaScript objects. Immutable.js requires learning a new API.</li> <li>Performance: Immutable.js may offer better performance for large datasets due to its structural sharing, but for most applications, Immer\u2019s performance is more than sufficient.</li> <li>Code Readability: Immer allows code that looks like mutable code (but is actually immutable), making it more readable, while Immutable.js requires its own methods, which can be less intuitive.</li> </ul> <p>When to choose one over the other:</p> <ul> <li>Use Immer when you want a simple, easy-to-adopt solution and are working with nested state in frameworks like Redux.</li> <li>Use Immutable.js when you need strict immutability enforcement, especially in larger-scale applications where performance on large datasets is a concern.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#additional","title":"Additional","text":"<p>is immer is used under the hood in redux. so we don't need to use immer in redux. is that correct?</p> <p>Yes, you're partially correct! Here's how it works:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#immer-in-redux","title":"Immer in Redux:","text":"<ul> <li>Since Redux Toolkit (RTK) was introduced, Immer has been used under the hood by default for handling state updates in reducers. This means that when you use <code>createSlice</code>, <code>createReducer</code>, or similar utility functions provided by Redux Toolkit, you can write reducers that look like they are mutating the state, but Redux Toolkit ensures immutability using Immer behind the scenes.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#so-do-you-need-to-use-immer-explicitly-in-redux-toolkit","title":"So, do you need to use Immer explicitly in Redux Toolkit?","text":"<p>No, you don't need to explicitly use Immer in Redux Toolkit. The toolkit takes care of immutability for you, and you can safely write \"mutative\" logic inside reducers as if you are modifying the state directly.</p> <p>However:</p> <ul> <li>If you're using plain Redux (not Redux Toolkit), you will need to manage immutability yourself. In that case, using Immer explicitly in reducers can be very helpful to simplify managing immutable state.</li> </ul> Example with Redux Toolkit (Immer is built-in): <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: { name: 'John', city: 'New York' },\n    reducers: {\n        updateCity(state, action) {\n            state.city = action.payload; // Looks like mutation, but Immer handles immutability\n        }\n    }\n});\n\nexport const { updateCity } = userSlice.actions;\nexport default userSlice.reducer;\n</code></pre> <p>In the above code, Immer is used under the hood to handle immutability, even though the <code>updateCity</code> reducer seems to modify the state directly.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#if-youre-using-plain-redux-without-redux-toolkit","title":"If you're using plain Redux (without Redux Toolkit):","text":"<p>If you\u2019re working with plain Redux and writing reducers manually, you'll have to either enforce immutability yourself (e.g., using <code>Object.assign</code> or the spread operator) or you can explicitly use Immer to simplify the process.</p> <pre><code>import produce from \"immer\";\n\nconst userReducer = (state = { name: \"John\", city: \"New York\" }, action) =&gt; {\n  switch (action.type) {\n    case \"UPDATE_CITY\":\n      return produce(state, (draft) =&gt; {\n        draft.city = action.payload; // Immer ensures immutability here\n      });\n    default:\n      return state;\n  }\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#summary","title":"Summary:","text":"<ul> <li>Redux Toolkit: Uses Immer under the hood, so you don\u2019t need to worry about immutability.</li> <li>Plain Redux: You have to enforce immutability yourself, but you can use Immer explicitly to make it easier.</li> </ul> <p>If you're using Redux Toolkit, you don't need to explicitly use Immer for immutability.</p> Title <ul> <li>Understanding Immutable State in Redux: How Immer Simplifies Your Code</li> <li>Immer in Redux Toolkit: The Secret to Easy State Management</li> <li>Why You Don\u2019t Need to Worry About Immutability with Redux Toolkit and Immer</li> <li>Redux Toolkit\u2019s Hidden Power: How Immer Handles State Mutations</li> <li>Simplify Your Redux Reducers with Immer and Redux Toolkit</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#additional-2","title":"Additional 2","text":"<p>The most widely used library for immutability in React is Immer. It has gained popularity due to its simplicity and ease of use, especially in conjunction with state management libraries like Redux.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#when-to-use-each-library","title":"When to Use Each Library","text":"<ol> <li> <p>Immutable.js</p> <ul> <li>Use When: You need complex data structures and want a comprehensive solution for immutability (e.g., large-scale applications with performance concerns).</li> <li>Pros: Offers rich data types (<code>Map</code>, <code>List</code>, <code>Set</code>) and optimizations for large data sets.</li> <li>Cons: Larger bundle size and steeper learning curve.</li> </ul> </li> <li> <p>Immer</p> <ul> <li>Use When: You want to simplify state management while maintaining immutability, especially in Redux or React state.</li> <li>Pros: Allows you to write mutable-like code, which is intuitive and easy to understand.</li> <li>Cons: Slightly less control over performance optimizations compared to Immutable.js.</li> </ul> </li> <li> <p>Immerable</p> <ul> <li>Use When: You want to make class instances immutable easily, while still using your own class methods.</li> <li>Pros: Integrates seamlessly with class-based components.</li> <li>Cons: More niche use case; not as widely adopted.</li> </ul> </li> <li> <p>Immutable-assign</p> <ul> <li>Use When: You need a lightweight solution for making simple updates to objects/arrays immutably.</li> <li>Pros: Simple API, minimal overhead.</li> <li>Cons: Limited functionality compared to other libraries.</li> </ul> </li> <li> <p>Seamless-immutable</p> <ul> <li>Use When: You want a straightforward library for creating immutable objects and arrays without additional complexity.</li> <li>Pros: Very easy to use and integrate.</li> <li>Cons: Lacks advanced data structures.</li> </ul> </li> <li> <p>Ramda</p> <ul> <li>Use When: You need a full-fledged functional programming library with immutability utilities.</li> <li>Pros: Comprehensive set of utilities for functional programming and immutability.</li> <li>Cons: Larger library; may be overkill if you only need immutability.</li> </ul> </li> <li> <p>Redux Toolkit</p> <ul> <li>Use When: You are using Redux for state management and want to leverage Immer\u2019s capabilities without adding another dependency.</li> <li>Pros: Built-in support for immutability, simplified setup for Redux.</li> <li>Cons: Only useful within the context of Redux.</li> </ul> </li> </ol> Summary <ul> <li>Choose Immer for most React state management scenarios.</li> <li>Choose Immutable.js for complex data structures and performance-critical applications.</li> <li>Use Redux Toolkit if you're already working with Redux and want to simplify state updates.</li> <li>Use simpler libraries (like seamless-immutable or immutable-assign) for lightweight projects or specific use cases.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/","title":"Difference between mutable and immutable data in react","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#difference-between-mutable-and-immutable-data-in-react","title":"Difference between mutable and immutable data in react","text":"<p>In React, understanding the difference between mutable and immutable data is key to managing state and optimizing performance.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#mutable-data","title":"Mutable Data:","text":"<ul> <li>Mutable data means the data can be changed directly after it's created.</li> <li>Example: Arrays and objects in JavaScript are mutable by default. You can modify their values directly without creating a new instance.</li> <li>Why it's problematic in React: If you mutate the state directly, React won't detect the change because React relies on immutability to determine if an update is needed (through shallow comparison). This can lead to bugs where the UI doesn't re-render when you expect it to.</li> </ul> <pre><code>const arr = [1, 2, 3];\narr.push(4); // This mutates the original array\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#immutable-data","title":"Immutable Data:","text":"<ul> <li>Immutable data cannot be modified after it's created. Instead, any change creates a new instance of the data with the modification.</li> <li>Example: You can treat arrays and objects as immutable by using methods that return a new array or object instead of modifying the original one.</li> <li>Why it's important in React: Immutability allows React to track changes efficiently. When state is updated immutably, React can easily determine if a component needs to re-render by comparing the old and new states.</li> </ul> <pre><code>const arr = [1, 2, 3];\nconst newArr = [...arr, 4]; // Creates a new array instead of mutating the original one\n</code></pre> <p>In React, working with immutable data helps ensure that updates to the state trigger a re-render of components when necessary. This is particularly important for performance optimization and managing complex UIs. Libraries like Immer and Immutable.js are often used to enforce immutability in larger projects.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"<p>When working with forms in Ant Design, managing the state and interactions effectively is crucial for a smooth user experience. One common scenario involves resetting the form fields when a modal is closed. To achieve this successfully, understanding and applying the correct order of operations is essential.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#why-order-of-operations-matters","title":"Why Order of Operations Matters","text":"<p>The order in which you execute operations can impact the behavior of your form. Specifically, if you're resetting the form fields when a modal closes, the sequence of operations matters because:</p> <ol> <li> <p>Reset Fields Before Closing Modal:</p> <p>To ensure that the form fields are cleared properly, you should call the <code>resetFields()</code> method before changing the modal visibility state. If you change the state first, the modal might close before the form has a chance to reset, leading to unexpected results.</p> </li> <li> <p>Avoid State Mismatch:</p> <p>Changing the modal state (e.g., setting <code>visible</code> to <code>false</code>) before resetting the form could lead to inconsistencies or race conditions where the form reset does not happen as expected.</p> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#best-practices","title":"Best Practices","text":"<p>Here\u2019s a simple example illustrating the correct order of operations:</p> <pre><code>import React, { useState } from 'react';\nimport { Modal, Form, Input, Button } from 'antd';\n\nconst ExampleModal = () =&gt; {\n    const [form] = Form.useForm();\n    const [isModalVisible, setIsModalVisible] = useState(false);\n\n    const handleCloseModal = () =&gt; {\n        // Ensure fields are reset before hiding the modal\n        form.resetFields();\n        setIsModalVisible(false);\n    };\n\n    const handleOpenModal = () =&gt; {\n        setIsModalVisible(true);\n    };\n\n    const onFinish = (values) =&gt; {\n        console.log('Form values:', values);\n    };\n\n    return (\n        &lt;&gt;\n            &lt;Button type=\"primary\" onClick={handleOpenModal}&gt;\n                Open Modal\n            &lt;/Button&gt;\n            &lt;Modal\n                title=\"Example Modal\"\n                visible={isModalVisible}\n                onCancel={handleCloseModal}\n                footer={null}\n            &gt;\n                &lt;Form\n                    form={form}\n                    onFinish={onFinish}\n                &gt;\n                    &lt;Form.Item\n                        name=\"exampleField\"\n                        label=\"Example Field\"\n                        rules={[{ required: true, message: 'Please input a value!' }]}\n                    &gt;\n                        &lt;Input /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                            Submit\n                        &lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            &lt;/Modal&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default ExampleModal;\n</code></pre> Key Takeaways <ol> <li> <p>Reset Form Fields First: Always reset the form fields before updating the state that controls the modal\u2019s visibility. This ensures that the form is cleared properly before the modal closes.</p> </li> <li> <p>Consistent State Management: Keep the state management for form visibility and form data handling consistent to avoid unexpected behaviors.</p> </li> </ol> <p>By adhering to this order of operations, you can ensure a seamless user experience, with forms resetting as expected when modals are closed. This approach minimizes bugs and provides a predictable behavior for users interacting with your forms.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/","title":"Predefined Functions in Redux Toolkit","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#predefined-functions-in-redux-toolkit","title":"Predefined Functions in Redux Toolkit","text":"<p>In Redux Toolkit, several functions are commonly used to simplify state management.</p> <p>Here are the most used components:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#1-configurestore","title":"1. configureStore","text":"<ul> <li>Purpose: Sets up the Redux store with sensible defaults, including middleware and DevTools.</li> <li>Usage: Simplifies store creation compared to the traditional <code>createStore</code>.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#2-createslice","title":"2. createSlice","text":"<ul> <li>Purpose: Generates actions and reducers based on a slice of the state.</li> <li>Usage: Reduces boilerplate by combining action creators and reducers into a single function.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#3-createasyncthunk","title":"3. createAsyncThunk","text":"<ul> <li>Purpose: Simplifies handling asynchronous logic in Redux.</li> <li>Usage: Automatically dispatches actions for the lifecycle of a promise (pending, fulfilled, rejected).</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#4-createentityadapter","title":"4. createEntityAdapter","text":"<ul> <li>Purpose: Helps manage normalized state for collections of items, such as a list of users or products.</li> <li>Usage: Provides methods for adding, updating, and removing items from the state.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#5-createselector","title":"5. createSelector","text":"<ul> <li>Purpose: Allows you to create memoized selectors to efficiently derive state.</li> <li>Usage: Helps in optimizing performance by preventing unnecessary re-renders.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#6-createreducer","title":"6. createReducer","text":"<ul> <li>Purpose: Provides a simpler way to create reducers with a more concise syntax, allowing for \"mutative\" logic.</li> <li>Usage: Similar to <code>createSlice</code>, but without generating actions.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#7-createaction","title":"7. createAction","text":"<ul> <li>Purpose: Creates an action creator function that returns an action object.</li> <li>Usage: Useful for defining actions outside of a slice.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#8-createreducer","title":"8. createReducer","text":"<ul> <li>Purpose: Provides a function to create reducers with the ability to write \"mutative\" logic.</li> <li>Usage: Can be used for simple cases where you want to avoid the complexity of slices.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/01/18/react-router-v6-guide/","title":"React Router v6 Guide","text":"","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#react-router-v6-guide","title":"React Router v6 Guide","text":"<p>React Router is a popular library for handling navigation and routing in React applications. It enables the creation of single-page applications (SPAs) by allowing developers to define the navigation structure of their applications, rendering different components based on the URL, and managing browser history.</p> <ol> <li> <p>Installation:</p> <p>Make sure you have React and React DOM installed, and then install React Router:</p> bash<pre><code>npm install react-router-dom\n</code></pre> </li> <li> <p>Basic Usage:</p> <p>Import necessary components:</p> jsx<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n</code></pre> <p>Wrap your application with the <code>Router</code> component:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Nested Routes:</p> <p>You can nest Route components to create nested routes:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n            &lt;Route path=\"profile\" element={&lt;Profile /&gt;} /&gt;\n            &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n            &lt;/Route&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Route Parameters:</p> <p>You can capture parameters from the URL using <code>`:param</code> syntax:</p> jsx<pre><code>&lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n</code></pre> <p>Access the parameter in the component:</p> jsx<pre><code>import { useParams } from 'react-router-dom';\n\nfunction UserProfile() {\nconst { id } = useParams();\n\n// Use the id parameter\n// ...\n}\n</code></pre> </li> <li> <p>Navigating Between Routes:</p> <p>Use the <code>Link</code> component for navigation:</p> jsx<pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> </li> <li> <p>Navigation Lifecycle Events:</p> <p>React Router v6 introduces the <code>useNavigate</code> hook for programmatic navigation:</p> jsx<pre><code>import { useNavigate } from 'react-router-dom';\n\nfunction MyComponent() {\nconst navigate = useNavigate();\n\nconst handleClick = () =&gt; {\n    // Navigate to a specific route\n    navigate('/new-route');\n};\n\n// ...\n}\n</code></pre> </li> <li> <p>Route Guards:</p> <p>Use the <code>useEffect</code> hook to guard against unauthorized access:</p> jsx<pre><code>import { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction PrivateRoute() {\nconst navigate = useNavigate();\n\nuseEffect(() =&gt; {\n    // Check if the user is authenticated\n    const isAuthenticated = // Your authentication logic here\n\n    if (!isAuthenticated) {\n    // Redirect to the login page\n    navigate('/login');\n    }\n}, [navigate]);\n\n// Render your private route content\nreturn &lt;div&gt;Private Route Content&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Query Parameters:</p> <p>Access and manipulate query parameters using the <code>useSearchParams</code> hook:</p> jsx<pre><code>import { useSearchParams } from 'react-router-dom';\n\nfunction MyComponent() {\nconst [searchParams, setSearchParams] = useSearchParams();\n\n// Access and manipulate search parameters\nconst paramValue = searchParams.get('paramName');\nsetSearchParams({ paramName: 'newValue' });\n\n// ...\n}\n</code></pre> </li> <li> <p>Custom Route Matching:</p> <p>You can define custom route matching logic using the <code>path</code> prop and the <code>element</code> prop of the <code>Route</code> component:</p> jsx<pre><code>&lt;Route\n    path=\"/custom-route\"\n    element={&lt;CustomComponent /&gt;}\n    caseSensitive={true}\n/&gt;\n</code></pre> </li> <li> <p>Error Boundary for Routes:</p> <p>Wrap your route components with an error boundary:</p> jsx<pre><code>function ErrorBoundary() {\n    // Your error handling logic\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Something went wrong!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n\n&lt;Route\n    path=\"/error-boundary\"\n    element={&lt;ErrorBoundary&gt;&lt;ErrorProneComponent /&gt;&lt;/ErrorBoundary&gt;}\n/&gt;\n</code></pre> </li> </ol> <p>This advanced guide covers some key concepts of React Router v6. Remember to refer to the official documentation for the most accurate and up-to-date information.</p>","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#reference","title":"Reference","text":"","tags":["Programming"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/","title":"The Role of Reducers in Async Logic","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#the-role-of-reducers-in-async-logic","title":"The Role of Reducers in Async Logic","text":"<p>In the <code>authSlice.js</code> example provided, the <code>reducers: {}</code> object is left empty because the authentication logic primarily relies on asynchronous actions (thunks) created using <code>createAsyncThunk</code>.</p> <p>Understanding Redux Toolkit: The Role of Reducers in Async Logic</p> <p>Here\u2019s a deeper look into why that is and when you might want to include synchronous reducers:</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#why-keep-reducers-empty","title":"Why Keep <code>reducers: {}</code> Empty?","text":"<ol> <li> <p>Asynchronous Actions: The primary functionality (like logging in and registering) is handled through <code>createAsyncThunk</code>. This automatically generates action types for pending, fulfilled, and rejected states:</p> </li> <li> <p>login/pending</p> </li> <li>login/fulfilled</li> <li>login/rejected</li> </ol> <p>Since these are handled in the <code>extraReducers</code>, there\u2019s no need for synchronous reducers for login, registration, or logout.</p> <ol> <li>Simplicity: Keeping the <code>reducers</code> object empty reduces complexity in the slice definition, especially if you're mainly working with async logic.</li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#when-to-use-synchronous-reducers","title":"When to Use Synchronous Reducers","text":"<p>You might want to include synchronous reducers in the <code>reducers</code> object when:</p> <ol> <li> <p>Managing Local State: If you need to manage local state or handle actions that don't involve asynchronous operations, such as toggling a loading state or updating user preferences.</p> </li> <li> <p>Handling Non-Async Actions: If you have actions that should directly mutate the state without waiting for an API response (like resetting the state or updating a field).</p> </li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#example-with-synchronous-reducers","title":"Example with Synchronous Reducers","text":"<p>Here\u2019s how you might include synchronous reducers in the authSlice.js:</p> Example <pre><code>// src/features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService } from '../../services/authService';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const data = await authService.login(credentials);\n    return data;\n});\n\nexport const register = createAsyncThunk('auth/register', async (userInfo) =&gt; {\n    const data = await authService.register(userInfo);\n    return data;\n});\n\nexport const logout = createAsyncThunk('auth/logout', async () =&gt; {\n    await authService.logout();\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {\n        resetError: (state) =&gt; {\n            state.error = null; // Reset error state\n        },\n        setUser: (state, action) =&gt; {\n            state.user = action.payload; // Directly set user data\n        }\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.isLoading = true;\n                state.error = null;\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.user = action.payload;\n            })\n            .addCase(login.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error.message;\n            })\n            .addCase(logout.fulfilled, (state) =&gt; {\n                state.user = null; // Clear user on logout\n            });\n    },\n});\n\nexport const { resetError, setUser } = authSlice.actions; // Export actions\nexport default authSlice.reducer;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#summary","title":"Summary","text":"<ul> <li>Empty <code>reducers</code>: Good for slices primarily using async actions via <code>createAsyncThunk</code>.</li> <li>Include <code>reducers</code>: Useful for managing local state, resetting errors, or directly setting data.</li> </ul> <p>This approach keeps your slice clean and focused on handling asynchronous operations while allowing for flexibility when you need to manage synchronous actions.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/","title":"Saving base64 data into an Excel file in a React application","text":"","tags":["react","base64"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/#saving-base64-data-into-an-excel-file-in-a-react-application","title":"Saving base64 data into an Excel file in a React application","text":"<p>To save base64 data into an Excel file in a React application, you can use the FileSaver library to handle the file download and the xlsx library to convert the base64 data into a format that can be saved as an Excel file.</p> <p>Here's a step-by-step guide on how to do this:</p> <ol> <li> <p>Install the necessary libraries:</p> <pre><code>npm install file-saver xlsx\n</code></pre> </li> <li> <p>Create a function to handle the download:</p> <pre><code>import { saveAs } from 'file-saver';\nimport * as XLSX from 'xlsx';\n\nconst saveBase64AsExcel = (base64Data, fileName) =&gt; {\n    // Convert base64 string to ArrayBuffer\n    const binaryString = window.atob(base64Data);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i &lt; len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n\n    // Use FileSaver to save the file\n    saveAs(blob, fileName);\n    };\n\n    // Example usage\n    const handleDownload = () =&gt; {\n    if (isDownloadStatus) {\n        let data = 'your_base64_data_here'; // Replace with your actual base64 data\n        saveBase64AsExcel(data, 'example.xlsx');\n    }\n};\n</code></pre> </li> <li> <p>Call the <code>handleDownload</code> function when you need to trigger the download:</p> <pre><code>import React from 'react';\n\nconst YourComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;button onClick={handleDownload}&gt;Download Excel&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default YourComponent;\n</code></pre> <p>This code snippet shows how to convert base64-encoded data into an <code>ArrayBuffer</code>, create a Blob from it, and use the <code>FileSaver</code> library to download it as an Excel file. You can replace 'your_base64_data_here' with your actual base64 data variable.</p> <p>Remember to import and use handleDownload in your component as shown in the example. This should allow you to download the base64 data as an Excel file when <code>isDownloadStatus</code> is true.</p> </li> </ol>","tags":["react","base64"]},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/","title":"form.setFieldsValue vs defaultValue in react","text":""},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#formsetfieldsvalue-vs-defaultvalue-in-react","title":"form.setFieldsValue <code>vs</code> defaultValue in react","text":"<p>Whether to set the default value using form.setFieldsValue or by using the defaultValue prop in <code>&lt;Select&gt;</code> depends on your specific use case and preference.</p> <p>Here's a breakdown of each approach:</p> <ol> <li> <p>Setting Default Value with <code>form.setFieldsValue</code>:</p> <p>Tip</p> jsx<pre><code>import { useEffect } from 'react';\nimport { Form, Select } from 'antd';\n\nconst YourComponent = ({ form, details, remainingLeaveApplicationTypesListing }) =&gt; {\n    useEffect(() =&gt; {\n        form.setFieldsValue({\n            leaveApplicationTypeId: details?.leaveApplicationTypeDto?.id\n        });\n    }, [form, details]);\n\n    return (\n        &lt;Form form={form}&gt;\n            &lt;Form.Item name=\"leaveApplicationTypeId\"&gt;\n                &lt;Select\n                    placeholder=\"Please select\"\n                    autoComplete=\"off\"\n                    // Define a function to handle selection changes\n                    onChange={(value) =&gt; handleSelect(value)}\n                &gt;\n                    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n                    remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n                        &lt;Select.Option\n                            value={leaveType.leaveApplicationTypeId}\n                            title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                            key={i}\n                        &gt;\n                            {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                        &lt;/Select.Option&gt;\n                    ))}\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n</code></pre> <p>With this approach, the default value is set programmatically using form.setFieldsValue inside a useEffect hook. This allows you to set the default value dynamically based on the details object. </p> <p>This approach is suitable when you need to calculate the default value or when the default value depends on asynchronous data fetching.</p> </li> <li> <p>Setting Default Value with <code>defaultValue</code> prop:</p> <p>Tip</p> jsx<pre><code>&lt;Select\n    placeholder=\"Please select\"\n    autoComplete=\"off\"\n    // Set the default value\n    defaultValue={details?.leaveApplicationTypeDto?.id}\n    // Define a function to handle selection changes\n    onChange={(value) =&gt; handleSelect(value)}\n&gt;\n    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n        remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n            &lt;Select.Option\n                value={leaveType.leaveApplicationTypeId}\n                title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                key={i}\n            &gt;\n                {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n            &lt;/Select.Option&gt;\n        ))}\n&lt;/Select&gt;\n</code></pre> <p>With this approach, you directly set the default value using the defaultValue prop of the <code>&lt;Select&gt;</code> component. </p> <p>This approach is simpler and more straightforward when you have a static default value or when the default value doesn't depend on other factors.</p> </li> </ol>"},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#which-approach-to-choose","title":"Which Approach to Choose:","text":"<ul> <li>If the default value depends on dynamic data or needs to be calculated based on other state/props, using <code>form.setFieldsValue</code> inside a <code>useEffect</code> hook is more appropriate.</li> <li>If the default value is static or doesn't depend on other factors, using the <code>defaultValue</code> prop directly in the <code>&lt;Select&gt;</code> component is simpler and cleaner.</li> </ul>"},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/","title":"Simplifying Error Management in React: A Deep Dive into Component Decomposition","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#simplifying-error-management-in-react-a-deep-dive-into-component-decomposition","title":"Simplifying Error Management in React: A Deep Dive into Component Decomposition","text":"<p>No, you don't need to create separate loader and error components in every component you decompose. Instead, you can follow a more centralized approach that promotes reusability and maintainability.</p> <p>do we need to make the loder and error component in every comopenet decomposition</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#overview","title":"Overview","text":"<p>Here are some strategies:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#1-centralized-loader-and-error-components","title":"1. Centralized Loader and Error Components","text":"<p>Create shared Loader and ErrorMessage components that can be used across different parts of your application. This reduces duplication and keeps your components DRY (Don't Repeat Yourself).</p> Example Structure <pre><code>src/\ncomponents/\n    Loader.js\n    ErrorMessage.js\n    ImageGallery/\n    ImageGallery.js\n    ImagePreview.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#2-usage-in-different-components","title":"2. Usage in Different Components","text":"<p>You can import and use these shared components in various places. For example:</p> Component <p><code>Loader.js</code></p> <pre><code>import React from \"react\";\nimport { Spin } from \"antd\"; // or any loader you prefer\n\nconst Loader = () =&gt; (\n    &lt;div style={{ textAlign: 'center', padding: '20px' }}&gt;\n        &lt;Spin size=\"large\" /&gt;\n    &lt;/div&gt;\n);\n\nexport default Loader;\n</code></pre> <p><code>ErrorMessage.js</code></p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#3-integrating-in-other-components","title":"3. Integrating in Other Components","text":"<p>You can then use these components in your other components, such as <code>ImageGallery</code>:</p> Example <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Loader from \"../Loader\";\nimport ErrorMessage from \"../ErrorMessage\";\nimport ImagePreview from \"./ImagePreview\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\n\nconst ImageGallery = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n        dispatch(getPhotosService(source.token));\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    if (status === 'loading') {\n        return &lt;Loader /&gt;;\n    }\n\n    if (error) {\n        return &lt;ErrorMessage message={error.message} /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Picture Gallery&lt;/h1&gt;\n            &lt;ImagePreview gallery={gallery} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ImageGallery;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#4-benefits-of-this-approach","title":"4. Benefits of This Approach","text":"<ul> <li>Reusability: By creating shared components, you can reuse them throughout your application without duplication.</li> <li>Consistency: This approach helps maintain a consistent look and feel for loaders and error messages across different components.</li> <li>Maintainability: If you need to change the appearance or behavior of loaders or error messages, you can do so in one place, and it will reflect everywhere.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#5-context-or-global-state-optional","title":"5. Context or Global State (Optional)","text":"<p>If you have complex loading and error handling across many components, consider using React Context or a global state management solution (like Redux) to manage loading and error states. This can further simplify component structure and enhance scalability.</p> Using Context <ol> <li>Create a Loading Context</li> </ol> <pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst LoadingContext = createContext();\n\nexport const useLoading = () =&gt; useContext(LoadingContext);\n\nexport const LoadingProvider = ({ children }) =&gt; {\n    const [loading, setLoading] = useState(false);\n\n    const startLoading = () =&gt; setLoading(true);\n    const stopLoading = () =&gt; setLoading(false);\n\n    return (\n        &lt;LoadingContext.Provider value={{ loading, startLoading, stopLoading }}&gt;\n            {children}\n        &lt;/LoadingContext.Provider&gt;\n    );\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#conclusion","title":"Conclusion","text":"<p>You should aim to create reusable components for loaders and error messages rather than duplicating them in every decomposed component. This makes your code cleaner, more maintainable, and easier to manage.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#additional","title":"Additional","text":"<p>Creating a custom loader using Ant Design's <code>Skeleton</code> component is straightforward and allows for flexibility in design. Below, I\u2019ll guide you through the steps to create a custom Ant Design <code>Skeleton</code> loader with various options for customization.</p> <p>Step 1: Set Up the Custom Skeleton Loader</p> <p>You can create a custom loader component that uses Ant Design's Skeleton while allowing for customization.</p> CustomSkeletonLoader.js <pre><code>import React from 'react';\nimport { Skeleton } from 'antd';\n\nconst CustomSkeletonLoader = ({\n    active = true,\n    title = true,\n    paragraph = { rows: 2, width: '100%' },\n    avatar = false,\n    style = {},\n}) =&gt; {\n    return (\n        &lt;div style={{ padding: '20px', ...style }}&gt;\n            &lt;Skeleton\n                active={active}\n                title={title}\n                paragraph={paragraph}\n                avatar={avatar}\n            /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CustomSkeletonLoader;\n</code></pre> <p>Step 2: Customize the Skeleton Loader</p> <p>You can customize the Skeleton loader based on the props you pass to it. Here are some ideas for customization:</p> <ol> <li>Avatar: You can include an avatar placeholder.</li> <li>Title: Control whether to display the title placeholder.</li> <li>Paragraph: Specify the number of rows and their width.</li> </ol> <p>Step 3: Example Usage</p> <p>You can use this custom loader in various parts of your application. Here\u2019s an example of how to implement it:</p> ExampleComponent.js <pre><code>import React from 'react';\nimport CustomSkeletonLoader from './CustomSkeletonLoader';\n\nconst ExampleComponent = ({ loading, data }) =&gt; {\n    if (loading) {\n        return &lt;CustomSkeletonLoader avatar title paragraph={{ rows: 3 }} /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{data.title}&lt;/h1&gt;\n            &lt;p&gt;{data.content}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>Step 4: CSS Customization (Optional)</p> <p>You can further customize the styles of the <code>Skeleton</code> by applying additional CSS. If you want to change the background color or other styles, you can do this in your CSS file.</p> Example CSS (styles.css) <pre><code>.ant-skeleton {\n    background-color: #f0f2f5; /* Change background color */\n}\n\n.ant-skeleton-title {\n    height: 20px; /* Customize title height */\n}\n\n.ant-skeleton-paragraph {\n    height: 16px; /* Customize paragraph height */\n    margin: 5px 0; /* Add spacing */\n}\n</code></pre> <p>Step 5: Import CSS in Your Component</p> <p>Make sure to import your custom CSS in your component or at the entry point of your application.</p> <pre><code>import \"./styles.css\"; // Adjust the path as necessary\n</code></pre> <p>Conclusion</p> <p>With this setup, you have a customizable Ant Design Skeleton loader that can be easily reused throughout your application. You can adjust the properties for different loading scenarios and enhance the user experience by providing visual feedback during data fetching.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#question","title":"Question","text":"Example of Using Custom PropsTheoryConclusion <p>Here\u2019s how you can use the <code>CustomSkeletonLoader</code> component and override its default props:</p> <pre><code>import React from 'react';\nimport CustomSkeletonLoader from './CustomSkeletonLoader';\n\nconst ExampleComponent = ({ loading, data }) =&gt; {\n    if (loading) {\n        return (\n            &lt;CustomSkeletonLoader\n                active={true}\n                title={true}\n                paragraph={{ rows: 3 }} // Override to show 3 rows\n                avatar={true} // Show avatar\n                style={{ margin: '20px' }} // Custom style\n            /&gt;\n        );\n    }\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;{data.title}&lt;/h1&gt;\n        &lt;p&gt;{data.content}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>Yes, in the <code>CustomSkeletonLoader</code> component, the props like <code>active</code>, <code>title</code>, <code>paragraph</code>, <code>avatar</code>, and <code>style</code> are predefined with default values. This approach allows the component to be flexible while providing sensible defaults. Here\u2019s a breakdown of each prop and why you might want to set defaults:</p> <p>Breakdown of Default Props</p> <ol> <li> <p>active:</p> <ul> <li>Default: <code>true</code></li> <li>Purpose: Indicates whether the skeleton is currently active. This helps control whether the loading animation is displayed. By default, it\u2019s set to true so the skeleton shows as a loading state.</li> </ul> </li> <li> <p>title:</p> <ul> <li>Default: <code>true</code></li> <li>Purpose: Determines if the skeleton should display a title placeholder. Setting this to true by default means that if the user doesn\u2019t specify otherwise, a title will be shown.</li> </ul> </li> <li> <p>paragraph:</p> <ul> <li>Default: <code>{ rows: 2, width: '100%' }</code></li> <li>Purpose: Configures the paragraph placeholder. The <code>rows</code> property sets how many lines of text to display, and the <code>width</code> can be adjusted if you want different widths for the skeleton. This default makes the loader suitable for most text elements.</li> </ul> </li> <li> <p>avatar:</p> <ul> <li>Default: <code>false</code></li> <li>Purpose: Controls whether an avatar placeholder is shown. It defaults to false, which means that the loader won\u2019t display an avatar unless specified by the user.</li> </ul> </li> <li> <p>style:</p> <ul> <li>Default: <code>{}</code></li> <li>Purpose: Allows additional styles to be applied to the loader component. By default, it\u2019s an empty object, so users can pass custom styles without affecting the existing ones.</li> </ul> </li> </ol> <p>Predefining props with default values in your <code>CustomSkeletonLoader</code> makes it user-friendly and easy to implement. Users can easily customize the loader as needed while benefiting from sensible defaults that suit common use cases. This approach strikes a good balance between flexibility and usability.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/","title":"Understanding the Importance of rowKey in React Tables","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#understanding-the-importance-of-rowkey-in-react-tables","title":"Understanding the Importance of rowKey in React Tables","text":"<p>When working with tables in React, especially when using libraries like Ant Design, setting a unique key for each row is crucial. The <code>rowKey</code> property allows the table component to efficiently manage and render rows, and here's why it matters.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#overview","title":"Overview","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#why-use-a-unique-rowkey","title":"Why Use a Unique <code>rowKey</code>?","text":"<ol> <li> <p>Performance Optimization: React relies on keys to identify which items have changed, are added, or are removed. When rows have unique keys, React can optimize re-rendering by only updating the affected rows rather than re-rendering the entire table.</p> </li> <li> <p>Consistent Row Identity: Using a unique identifier, such as an <code>id</code>, helps maintain the identity of each row across renders. This is especially important in dynamic lists where items may be reordered, added, or deleted. Consistent row identity ensures that the correct data is displayed for each row.</p> </li> <li> <p>Preventing Bugs: Without a unique key, React might mistakenly reuse DOM elements for different data. This can lead to incorrect rendering of content, unexpected behavior, or visual glitches, as React may not know which row corresponds to which data.</p> </li> <li> <p>Improved User Experience: With proper key management, interactions like sorting, filtering, or pagination will work seamlessly. Users will see a consistent experience without unexpected data flickering or mismatches.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#how-to-implement-rowkey-correctly","title":"How to Implement <code>rowKey</code> Correctly","text":"<p>When defining your table, you can specify <code>rowKey</code> by providing a unique identifier from your data source. For instance, if each item in your <code>todos</code> array has a unique <code>id</code>, you can set it like this:</p> <pre><code>&lt;Table\n  dataSource={todos}\n  columns={columns}\n  pagination={false}\n  scroll={{ y: 400 }}\n  rowHeight={10}\n  style={{ height: \"100%\" }}\n  rowKey=\"id\" // Ensure each row has a unique key\n/&gt;\n</code></pre> <p>This configuration ensures that each row in the table is associated with a specific <code>id</code>, allowing React to efficiently manage updates and changes.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion","title":"Conclusion","text":"<p>In summary, setting a unique <code>rowKey</code> for your table rows is not just a best practice; it is essential for maintaining performance, ensuring consistent rendering, and providing a better user experience. Always remember to use a unique identifier from your data, such as an <code>id</code>, to help React effectively manage your table rows. By doing so, you will create a more robust and reliable table component in your application.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#question","title":"Question","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#what-to-do-if-your-api-doesnt-provide-a-unique-key","title":"What to Do If Your API Doesn\u2019t Provide a Unique Key?","text":"<p>When working with data from an API, you may encounter situations where the response does not include a unique identifier for each item. This can pose challenges when rendering lists or tables in React, as each item needs a unique key for optimal performance and reliability. Here\u2019s how to handle this situation.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#why-is-a-unique-key-important","title":"Why Is a Unique Key Important?","text":"<p>Before we dive into solutions, it's important to understand why a unique key is critical:</p> <ul> <li>Performance Optimization: React uses keys to efficiently update and re-render components. Without unique keys, React might end up re-rendering the entire list, leading to performance issues.</li> <li>Data Consistency: Unique keys help maintain the identity of each item across renders, preventing bugs and mismatches.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#solutions-for-generating-unique-keys","title":"Solutions for Generating Unique Keys","text":"<p>If your API doesn\u2019t provide a unique key, consider the following approaches:</p> <ol> <li> <p>Use a Combination of Fields: If your data has multiple fields that, when combined, can form a unique identifier, use those. For example, combining <code>name</code> and <code>timestamp</code> might create a unique string for each item.</p> <pre><code>const rowKey = (item) =&gt; `${item.name}-${item.timestamp}`;\n</code></pre> </li> <li> <p>Generate a Unique Key Locally: You can generate unique keys on the client side using libraries like uuid or by creating a simple function that generates a random string.</p> <pre><code>npm install uuid\n</code></pre> <pre><code>import { v4 as uuidv4 } from \"uuid\";\n\n// Add a unique key to each todo item\nconst todosWithKeys = data.map((todo) =&gt; ({\n  ...todo,\n  id: uuidv4(), // Generate a unique ID\n}));\n</code></pre> </li> <li> <p>Index as a Last Resort: If no other unique identifiers are available, you can use the index of the item in the array as a key. However, this is generally not recommended for dynamic lists, as it can lead to issues with state preservation and performance.</p> <pre><code>&lt;Table dataSource={todos} rowKey={(item, index) =&gt; index} /&gt;\n</code></pre> </li> </ol> Note: <p>Using the index should be avoided when items can be <code>reordered</code>, <code>added</code>, or <code>removed</code>, as it can lead to inconsistent rendering.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion_1","title":"Conclusion","text":"<p>If your API doesn\u2019t provide a unique key, there are several strategies you can employ to create one. Whether by combining fields, generating keys locally, or using indices as a last resort, ensuring that each item in your list has a unique identifier is essential for optimal performance and a reliable user experience in your React application.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#implementation","title":"Implementation","text":"<p>To use uuid in your table setup, you would typically generate unique keys when you first receive the data from the API or before rendering the table. Here's how you can implement it:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"<ol> <li> <p>Install the UUID Package: If you haven't already, install the <code>uuid</code> package:</p> <pre><code>npm install uuid\n</code></pre> </li> <li> <p>Generate UUIDs for Each Todo Item: When you fetch your <code>todos</code> data, map through the array to add a unique key to each item. Here's how you can do that:</p> <pre><code>import { v4 as uuidv4 } from \"uuid\";\nimport { Table } from \"antd\"; // Assuming you're using Ant Design\n\nconst App = () =&gt; {\n  const [todos, setTodos] = React.useState([]);\n\n  // Example function to fetch todos\n  const fetchTodos = async () =&gt; {\n    const response = await fetch(\"your-api-url\");\n    const data = await response.json();\n\n    // Add a unique key to each todo item\n    const todosWithKeys = data.map((todo) =&gt; ({\n      ...todo,\n      id: uuidv4(), // Generate a unique ID\n    }));\n    setTodos(todosWithKeys);\n  };\n\n  React.useEffect(() =&gt; {\n    fetchTodos();\n  }, []);\n\n  const columns = [\n    // Define your columns here\n  ];\n\n  return (\n    &lt;Table\n      dataSource={todos}\n      columns={columns}\n      pagination={false}\n      scroll={{ y: 400 }}\n      rowHeight={10}\n      style={{ height: \"100%\" }}\n      rowKey=\"id\" // Use the unique id generated\n    /&gt;\n  );\n};\n\nexport default App;\n</code></pre> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#explanation","title":"Explanation","text":"<ul> <li>UUID Generation: When you map through the fetched <code>todos</code>, a unique <code>id</code> is generated using <code>uuidv4()</code> for each item.</li> <li>Setting Data: This new array with unique keys is then set to the state, ensuring each row in the table has a unique key.</li> <li>Using <code>rowKey</code>: The <code>rowKey</code> prop is set to <code>\"id\"</code>, allowing the table to use the generated unique IDs.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion_2","title":"Conclusion","text":"<p>By generating unique IDs for each todo item when fetching the data, you ensure that your table renders efficiently and correctly, even if the original API does not provide unique identifiers. This approach enhances performance and reduces the likelihood of bugs related to row identity.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#reference","title":"Reference","text":"<ul> <li>Generating Unique key in React</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/","title":"Useful React Libraries for Projects","text":"","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#useful-react-libraries-for-projects","title":"Useful React Libraries for Projects","text":"<p>Pdf</p>","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#loadash","title":"loadash","text":"<pre><code>import { uniqBy } from 'lodash';\n\nconst recentlyUsedTags = [\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst otherReferenceDtos = [\n  { code: \"BFL-sdfdsfsdfsdffsd\", id: \"23d4c5a0-7e2f-5d25-b7a6-f234512d4b4d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst combinedArray = [...recentlyUsedTags, ...otherReferenceDtos];\n\nconst uniqueArray = uniqBy(combinedArray, 'id');\n\nsetFilterReference(uniqueArray);\n</code></pre> <ul> <li>Top 10 JavaScript Libraries To Use in 2024 </li> <li>js-utility-libraries</li> </ul> <ul> <li>pip install mkdocs-pdf</li> <li>mkdocs-pdf: pypi</li> <li>How to link a pdf</li> <li></li> <li>How to Import SVGs in a React and Vite app</li> <li>How to display svg icons(.svg files) in UI using React Component?: slackoverflow</li> <li>How to use SVGs in React</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/","title":"Using Immer with Standard Redux","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#using-immer-with-standard-redux","title":"Using Immer with Standard Redux","text":"<p>Using <code>Immer</code> with <code>Redux</code> in the same project is a common practice and can be very beneficial.</p> <p>Here's how they can complement each other, along with standard practices:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#using-immer-with-redux","title":"Using Immer with Redux","text":"<ol> <li> <p>State Management Simplification:</p> <ul> <li>Immer allows you to write \"mutable\" code when updating state, which can make your reducers much more readable.</li> <li>Instead of returning new state objects with the spread operator or using methods like <code>map</code>, <code>filter</code>, or <code>reduce</code>, you can mutate a draft state directly.</li> </ul> </li> <li> <p>Integration with Redux Toolkit:</p> <ul> <li>Redux Toolkit already uses Immer under the hood for its <code>createSlice</code> method. This means you can write reducers that look mutable, but they are actually producing immutable updates.</li> <li>This allows you to leverage both libraries seamlessly, especially when using the Toolkit.</li> </ul> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#example-with-redux-toolkit-and-immer","title":"Example with Redux Toolkit and Immer","text":"CodeStandard Practices <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst itemsSlice = createSlice({\n    name: 'items',\n    initialState: [],\n    reducers: {\n        addItem: (state, action) =&gt; {\n            state.push(action.payload); // Mutative update, thanks to Immer\n        },\n        updateItem: (state, action) =&gt; {\n            const index = state.findIndex(item =&gt; item.id === action.payload.id);\n            if (index !== -1) {\n                state[index] = action.payload; // Mutative update\n            }\n        },\n        deleteItem: (state, action) =&gt; {\n            return state.filter(item =&gt; item.id !== action.payload.id); // Non-mutative, but still concise\n        },\n    },\n});\n\nexport const { addItem, updateItem, deleteItem } = itemsSlice.actions;\nexport default itemsSlice.reducer;\n</code></pre> <ol> <li> <p>Use Redux Toolkit:</p> <ul> <li>Start with Redux Toolkit for setting up Redux. It simplifies the Redux setup and integrates well with Immer.</li> </ul> </li> <li> <p>Leverage Immer for Reducers:</p> <ul> <li>Use Immer's mutability in reducers when you need more complex state updates. This can reduce boilerplate code and improve clarity.</li> </ul> </li> <li> <p>Keep State Management Concise:</p> <ul> <li>Use Immer to handle nested state updates easily without the need for deep cloning or complex logic.</li> </ul> </li> <li> <p>Evaluate Needs:</p> <ul> <li>While Immer is very useful, consider your project's complexity. For simple state updates, the standard Redux pattern may suffice without needing Immer.</li> </ul> </li> <li> <p>Documentation and Consistency:</p> <ul> <li>Document your use of these libraries in your codebase to ensure all team members understand the patterns being used.</li> </ul> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#conclusion","title":"Conclusion","text":"<p>Combining Immer and Redux Toolkit is a standard practice in modern Redux applications. It improves the developer experience by allowing clearer and more concise state management while maintaining the immutable nature of Redux.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/07/where-does-redux-shines/","title":"Where does redux shines?","text":"","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#where-does-redux-shines","title":"Where does <code>redux</code> shines?","text":"<p>Redux shines in scenarios where managing state across a complex application becomes cumbersome with React\u2019s built-in state management.</p> <p>Here are some common scenarios where Redux is beneficial, along with examples:</p>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-1","title":"Scenario 1","text":"<p>Complex State Management Across Multiple Components</p> <p>When your application has a complex state that needs to be shared among many components, Redux can centralize and simplify this state management.</p> ScenarioCode Example <p>Example: A Shopping Cart Application</p> <p>Imagine a shopping cart application where you have multiple components like <code>ProductList</code>, <code>Cart</code>, and <code>Checkout</code> that need to access and update the cart state.</p> <p>Without Redux:</p> <ul> <li>You might have to pass cart state and handlers through many layers of components using props, which can become messy and hard to maintain.</li> </ul> <p>With Redux:</p> <ul> <li>You can manage the cart state in a single Redux store, making it accessible from any component without prop drilling.</li> </ul> <pre><code>// actions.js\nexport const addItem = item =&gt; ({\n    type: 'ADD_ITEM',\n    payload: item,\n});\n\nexport const removeItem = id =&gt; ({\n    type: 'REMOVE_ITEM',\n    payload: id,\n});\n\n// reducers.js\nconst initialState = {\n    cart: [],\n};\n\nconst cartReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_ITEM':\n            return { ...state, cart: [...state.cart, action.payload] };\n        case 'REMOVE_ITEM':\n            return { ...state, cart: state.cart.filter(item =&gt; item.id !== action.payload) };\n        default:\n            return state;\n    }\n};\n\nexport default cartReducer;\n\n// store.js\nimport { createStore } from 'redux';\nimport cartReducer from './reducers';\n\nconst store = createStore(cartReducer);\n\nexport default store;\n\n// ProductList.js\nimport React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addItem } from './actions';\n\nconst ProductList = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddToCart = item =&gt; {\n        dispatch(addItem(item));\n    };\n\n    // Render product list with button to add to cart\n    return (\n        &lt;div&gt;\n            {/* Render product items */}\n            &lt;button onClick={() =&gt; handleAddToCart({ id: 1, name: 'Product 1' })}&gt;Add to Cart&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// Cart.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { removeItem } from './actions';\n\nconst Cart = () =&gt; {\n    const cart = useSelector(state =&gt; state.cart);\n    const dispatch = useDispatch();\n\n    const handleRemove = id =&gt; {\n        dispatch(removeItem(id));\n    };\n\n    return (\n        &lt;div&gt;\n        {cart.map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                {item.name}\n                &lt;button onClick={() =&gt; handleRemove(item.id)}&gt;Remove&lt;/button&gt;\n            &lt;/div&gt;\n        ))}\n        &lt;/div&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport ProductList from './ProductList';\nimport Cart from './Cart';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;ProductList /&gt;\n            &lt;Cart /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-2","title":"Scenario 2","text":"<p>Complex Async Operations</p> <p>Redux, especially with middleware like redux-thunk or redux-saga, helps manage complex asynchronous operations.</p> ScenarioCode Example <p>Example: Fetching Data from an API</p> <p>When you need to fetch data from an API and update your application state based on the result, Redux can help manage these async actions in a clean manner.</p> <p>Without Redux:</p> <ul> <li>You might handle async operations directly in components, leading to scattered logic and difficult-to-manage code.</li> </ul> <p>With Redux:</p> <ul> <li>Redux middleware like <code>redux-thunk</code> allows you to dispatch actions for async operations and manage loading, success, and error states.</li> </ul> <pre><code>// actions.js\nimport axios from 'axios';\n\nexport const fetchData = () =&gt; async dispatch =&gt; {\n    dispatch({ type: 'FETCH_DATA_REQUEST' });\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: response.data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n\n// reducers.js\nconst initialState = {\n    data: [],\n    loading: false,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'FETCH_DATA_REQUEST':\n            return { ...state, loading: true };\n        case 'FETCH_DATA_SUCCESS':\n            return { ...state, loading: false, data: action.payload };\n        case 'FETCH_DATA_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n\n// DataDisplay.js\nimport React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchData } from './actions';\n\nconst DataDisplay = () =&gt; {\n    const dispatch = useDispatch();\n    const { data, loading, error } = useSelector(state =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchData());\n    }, [dispatch]);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            {data.map(item =&gt; (\n            &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport DataDisplay from './DataDisplay';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;DataDisplay /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-3","title":"Scenario 3","text":"<p>Maintaining Consistent State Across Components</p> <p>If you have multiple components that need to access or modify the same piece of state in a consistent manner, Redux helps keep this state synchronized.</p> ScenarioCode Example <p>Example: User Authentication</p> <p>When managing user authentication status and user information, Redux can ensure that all components reflecting user-related data stay in sync.</p> <pre><code>// actions.js\nexport const login = user =&gt; ({\n    type: 'LOGIN',\n    payload: user,\n});\n\nexport const logout = () =&gt; ({\n    type: 'LOGOUT',\n});\n\n// reducers.js\nconst initialState = {\n    user: null,\n};\n\nconst authReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'LOGIN':\n            return { ...state, user: action.payload };\n        case 'LOGOUT':\n            return { ...state, user: null };\n        default:\n            return state;\n    }\n};\n\nexport default authReducer;\n\n// UserProfile.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { logout } from './actions';\n\nconst UserProfile = () =&gt; {\n    const user = useSelector(state =&gt; state.user);\n    const dispatch = useDispatch();\n\n    if (!user) return &lt;p&gt;Please log in.&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch(logout())}&gt;Logout&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// LoginForm.js\nimport React, { useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { login } from './actions';\n\nconst LoginForm = () =&gt; {\n    const [username, setUsername] = useState('');\n    const dispatch = useDispatch();\n\n    const handleSubmit = e =&gt; {\n        e.preventDefault();\n        dispatch(login({ name: username }));\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={e =&gt; setUsername(e.target.value)}\n                placeholder=\"Username\"\n            /&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport UserProfile from './UserProfile';\nimport LoginForm from './LoginForm';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;UserProfile /&gt;\n            &lt;LoginForm /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#summary","title":"Summary","text":"Redux is particularly useful for: <ul> <li>Complex state sharing among many components.</li> <li>Predictable state management with centralized control.</li> <li>Handling complex async operations with middleware.</li> <li>Maintaining consistent state across components in larger applications.</li> </ul> <p>These examples illustrate how Redux can help manage state in different scenarios, providing a more organized and scalable approach to state management.</p>","tags":["react","redux"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/","title":"Where to store API calls in Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#where-to-store-api-calls-in-redux-toolkit","title":"Where to store API calls in Redux Toolkit","text":"<p>Importing API functions typically depends on your project's organization and the specific architecture you're using.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#overview","title":"Overview","text":"<p>Here are a few common approaches:</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#1-feature-specific-api-imports","title":"1. Feature-Specific API Imports","text":"<p>If your API calls are closely tied to specific features, you can create an <code>api.js</code> file within each feature folder. This keeps everything related to that feature together.</p> Example <pre><code>/src\n    /features\n        /auth\n            authSlice.js\n            authAPI.js       // API functions for authentication\n        /products\n            productSlice.js\n            productAPI.js    // API functions for products\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#2-centralized-api-folder","title":"2. Centralized API Folder","text":"<p>For larger projects, you might prefer a centralized folder for all API calls. This can help manage your API functions in one place, especially if they are used across multiple features.</p> Example <pre><code>/src\n    /api\n        authAPI.js        // API functions for authentication\n        productAPI.js     // API functions for products\n    /features\n        /auth\n            authSlice.js\n        /products\n            productSlice.js\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#3-using-a-service-layer","title":"3. Using a Service Layer","text":"<p>You could also implement a service layer where each service file corresponds to a feature and contains both API calls and any logic related to that feature.</p> Example Structure <pre><code>/src\n    /services\n        authService.js    // Functions to handle authentication logic\n        productService.js  // Functions to handle product-related logic\n/features\n    /auth\n        authSlice.js\n    /products\n        productSlice.js\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#where-to-import-api-functions","title":"Where to Import API Functions","text":"<ul> <li>Within Feature Components/Slices: Import the API functions in your feature slices or components where they are needed. For example, in your <code>authSlice.js</code>, you could import the <code>authAPI.js</code> functions.</li> </ul> Example <pre><code>// In authSlice.js\nimport { login, register } from '../api/authAPI';\n\n// Usage in a thunk or action\n</code></pre> Summary <ul> <li>Use feature-specific API files for tightly coupled features.</li> <li>Use a centralized API folder for shared functions.</li> <li>Consider a service layer for better separation of concerns.</li> </ul> <p>Choose the structure that best fits your project's needs and keeps your code organized and maintainable!</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#categorized-by-application-size","title":"Categorized by Application Size","text":"<p>Let\u2019s clarify the approaches to organizing your API calls and services in a structured way, tailored for different application sizes.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#1-small-applications","title":"1. Small Applications","text":"<p>Structure: Centralized API File or Feature-Specific Files</p> <ul> <li>Centralized API File: All API calls in one place.</li> </ul> StructureExample (api.js) <pre><code>/src\n    /api\n        api.js           // Contains all API functions\n</code></pre> <pre><code>export const loginAPI = async (credentials) =&gt; {\n    // API call for login\n};\n\nexport const fetchProductsAPI = async () =&gt; {\n    // API call for fetching products\n};\n</code></pre> <ul> <li>Feature-Specific Files: Separate files for each feature.</li> </ul> StructureExample (authAPI.js) <pre><code>/src\n    /api\n        authAPI.js      // API functions for authentication\n        productAPI.js   // API functions for products\n</code></pre> <pre><code>export const login = async (credentials) =&gt; {\n    // API call for login\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#2-medium-applications","title":"2. Medium Applications","text":"<p>Structure: Feature-Specific API Files with Service Layer</p> <ul> <li>Feature-Specific API Files: Group related API calls.</li> </ul> StructureExample (authService.js) <pre><code>/src\n    /services\n        authService.js       // Handles auth logic and API calls\n        productService.js    // Handles product logic and API calls\n</code></pre> <pre><code>import { loginAPI, registerAPI } from '../api/authAPI';\n\nexport const login = async (credentials) =&gt; {\n    const response = await loginAPI(credentials);\n    // Handle response, e.g., saving tokens\n    return response.data;\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#3-large-applications","title":"3. Large Applications","text":"<p>Structure: Comprehensive Service Layer with Clear Separation</p> <ul> <li>Service Layer: Each service file handles its logic and API calls.</li> </ul> StructureExample (authService.js) <pre><code>/src\n    /services\n        authService.js       // Authentication logic and API calls\n        productService.js    // Product logic and API calls\n    /api\n        authAPI.js           // Raw API functions for authentication\n        productAPI.js        // Raw API functions for products\n</code></pre> <pre><code>import { loginAPI, registerAPI } from \"../api/authAPI\";\n\nexport const authService = {\n    login: async (credentials) =&gt; {\n        const response = await loginAPI(credentials);\n        // Additional login logic\n        return response.data;\n    },\n    register: async (userInfo) =&gt; {\n        const response = await registerAPI(userInfo);\n        // Additional registration logic\n        return response.data;\n    },\n};\n</code></pre> <p>Full Example</p> Project Structure1. authAPI.js2. authService.js3. authSlice.js4. store.js <pre><code>/src\n    /api\n        authAPI.js          // Raw API functions for authentication\n    /services\n        authService.js      // Authentication logic and API calls\n    /features\n        /auth\n        authSlice.js      // Redux slice for authentication state\n    /store\n        store.js            // Redux store setup\n</code></pre> <p>This file contains the raw API calls using <code>axios</code>.</p> <pre><code>// src/api/authAPI.js\nimport axios from 'axios';\n\nconst API_URL = 'https://api.example.com/auth'; // Replace with your API URL\n\nexport const loginAPI = async (credentials) =&gt; {\n    return await axios.post(`${API_URL}/login`, credentials);\n};\n\nexport const registerAPI = async (userInfo) =&gt; {\n    return await axios.post(`${API_URL}/register`, userInfo);\n};\n\nexport const logoutAPI = async () =&gt; {\n    return await axios.post(`${API_URL}/logout`);\n};\n</code></pre> <p>This file handles the logic for calling the API and managing side effects.</p> <pre><code>// src/services/authService.js\nimport { loginAPI, registerAPI, logoutAPI } from '../api/authAPI';\n\nexport const authService = {\n    login: async (credentials) =&gt; {\n        const response = await loginAPI(credentials);\n        // Additional logic (e.g., storing tokens) can be added here\n        return response.data;\n    },\n    register: async (userInfo) =&gt; {\n        const response = await registerAPI(userInfo);\n        return response.data;\n    },\n    logout: async () =&gt; {\n        await logoutAPI();\n        // Additional logic for logout can be added here\n    }\n};\n</code></pre> <p>This file defines the Redux slice for managing authentication state.</p> <pre><code>// src/features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService } from '../../services/authService';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const data = await authService.login(credentials);\n    return data; // Return user data (e.g., tokens)\n});\n\nexport const register = createAsyncThunk('auth/register', async (userInfo) =&gt; {\n    const data = await authService.register(userInfo);\n    return data; // Return user data\n});\n\nexport const logout = createAsyncThunk('auth/logout', async () =&gt; {\n    await authService.logout();\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {},\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.isLoading = true;\n                state.error = null;\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.user = action.payload; // Set user data\n            })\n            .addCase(login.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error.message; // Handle error\n            })\n            .addCase(logout.fulfilled, (state) =&gt; {\n                state.user = null; // Clear user on logout\n            });\n    },\n});\n\nexport default authSlice.reducer;\n</code></pre> <p>Set up the Redux store to include the authentication slice.</p> <pre><code>// src/store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from '../features/auth/authSlice';\n\nconst store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n\nexport default store;\n</code></pre> <p>Example Usage in a Component</p> ExampleSummary <p>Here\u2019s an example of how you might use the authentication features in a React component.</p> <pre><code>// src/components/LoginComponent.js\nimport React, { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { login } from '../features/auth/authSlice';\n\nconst LoginComponent = () =&gt; {\n    const [credentials, setCredentials] = useState({ email: '', password: '' });\n    const dispatch = useDispatch();\n    const { isLoading, error } = useSelector((state) =&gt; state.auth);\n\n    const handleSubmit = (e) =&gt; {\n        e.preventDefault();\n        dispatch(login(credentials));\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;form onSubmit={handleSubmit}&gt;\n                &lt;input\n                    type=\"email\"\n                    placeholder=\"Email\"\n                    value={credentials.email}\n                    onChange={(e) =&gt; setCredentials({ ...credentials, email: e.target.value })}\n                    required\n                /&gt;\n                &lt;input\n                    type=\"password\"\n                    placeholder=\"Password\"\n                    value={credentials.password}\n                    onChange={(e) =&gt; setCredentials({ ...credentials, password: e.target.value })}\n                    required\n                /&gt;\n                &lt;button type=\"submit\" disabled={isLoading}&gt;\n                    {isLoading ? 'Loading...' : 'Login'}\n                &lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default LoginComponent;\n</code></pre> <ol> <li>authAPI.js: Contains raw API calls using <code>axios</code>.</li> <li>authService.js: Handles calling the API and any additional logic (e.g., storing tokens).</li> <li>authSlice.js: Manages the authentication state using Redux Toolkit.</li> <li>store.js: Configures the Redux store with the authentication slice.</li> <li>LoginComponent.js: Example component that uses the login functionality.</li> </ol> <p>This structure keeps your code organized and makes it easy to manage authentication in a large application.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>Small Apps: Use a single API file or separate files for each feature.</li> <li>Medium Apps: Use feature-specific files along with a service layer for better organization.</li> <li>Large Apps: Implement a full service layer with clear separation between API calls and business logic.</li> </ul> <p>This should provide a clear and structured approach to organizing your API and service layers based on application size.</p> <p>Question</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#question-1","title":"Question 1","text":"<p>1. Storing API Calls:</p> <ul> <li>API calls, particularly those using Axios, are best stored in a dedicated <code>/services</code> folder within your project. This keeps your API logic separate from your components and Redux slices, promoting a clear structure and separation of concerns.</li> </ul> <p>2. Structure of the Services Folder:</p> <p>The <code>/services</code> folder can contain:</p> <ul> <li>An Axios instance for default configurations (like base URL and headers).</li> <li>Specific service files for various API endpoints or resources (e.g., users, posts).</li> </ul> <pre><code>/src\n\u251c\u2500\u2500 /services\n\u2502   \u251c\u2500\u2500 axiosInstance.js        // Axios instance with default settings\n\u2502   \u251c\u2500\u2500 userService.js          // API calls related to users\n\u2502   \u2514\u2500\u2500 postService.js          // API calls related to posts\n</code></pre> <p>3. Creating the Axios Instance:</p> <ul> <li>The Axios instance allows you to define default configurations (like the base URL) that will be used across all API calls.</li> </ul> axiosInstance.js<pre><code>// /services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\", // Set your API base URL here\n  timeout: 1000, // Optional: Set timeout for requests\n});\n\nexport default axiosInstance;\n</code></pre> <p>4. Defining API Calls in Service Files:</p> <ul> <li>Each service file can contain functions that correspond to specific API endpoints.</li> </ul> userService.js<pre><code>// /services/userService.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const getUsers = async () =&gt; {\n  const response = await axiosInstance.get(\"/users\");\n  return response.data;\n};\n\nexport const getUserById = async (id) =&gt; {\n  const response = await axiosInstance.get(`/users/${id}`);\n  return response.data;\n};\n</code></pre> <p>5. Benefits of This Organization:</p> <ul> <li>Separation of Concerns: Keeps your API logic distinct from your UI and Redux state management, making the code easier to read and maintain.</li> <li>Reusability: Allows for easy reuse of API calls across different components and slices.</li> <li>Easier Testing: Having a dedicated services layer makes it easier to mock API calls during unit testing.</li> </ul> <p>Summary:</p> <p>Storing API calls in a <code>/services</code> folder keeps your code organized and promotes separation of concerns. This structure allows for better maintainability, reusability, and testing of your API logic in a Redux Toolkit application.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/","title":"Write Cleaner Reducers with Immer","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#write-cleaner-reducers-with-immer","title":"Write Cleaner Reducers with Immer","text":"<p>Immer is primarily used in the following contexts within a JavaScript or React application:</p> Title <ul> <li>Simplifying State Management: The Power of Immer in Redux</li> <li>Write Cleaner Reducers with Immer: A Guide for Redux Developers</li> <li>Harnessing Immer for Immutable State Updates in React</li> <li>How Immer Transforms Redux: A Deep Dive into Mutable Logic</li> <li>Boost Your Redux Efficiency with Immer: Best Practices and Examples</li> <li>Understanding Immer: The Secret to Easier State Management in Redux</li> <li>From Immutable to Intuitive: Using Immer in Your Redux Workflow</li> <li>Integrating Immer with Redux Toolkit: Simplifying Your State Logic</li> <li>Mastering State Updates: Why You Should Use Immer in Your Projects</li> <li>Streamlining State Management: Leveraging Immer in React Applications</li> </ul> <p></p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#1-in-redux-reducers","title":"1. In Redux Reducers","text":"<ul> <li>Purpose: Simplifies state updates by allowing you to write mutable code that is transformed into immutable updates.</li> <li>Usage: In reducers, you can modify a draft state directly. For example:</li> </ul> <pre><code>import produce from \"immer\";\n\nconst reducer = produce((draft, action) =&gt; {\n  switch (action.type) {\n    case \"ADD_ITEM\":\n      draft.push(action.payload);\n      break;\n    case \"UPDATE_ITEM\":\n      const index = draft.findIndex((item) =&gt; item.id === action.payload.id);\n      if (index !== -1) {\n        draft[index] = action.payload;\n      }\n      break;\n    // Other cases...\n  }\n}, initialState);\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#2-in-redux-toolkit","title":"2. In Redux Toolkit","text":"<ul> <li>Purpose: Redux Toolkit integrates Immer by default for its <code>createSlice</code> function.</li> <li>Usage: When defining reducers, you can use mutable logic directly without needing to import Immer separately</li> </ul> <pre><code>import { createSlice } from \"@reduxjs/toolkit\";\n\nconst itemsSlice = createSlice({\n  name: \"items\",\n  initialState: [],\n  reducers: {\n    addItem: (state, action) =&gt; {\n      state.push(action.payload); // Mutable update\n    },\n    updateItem: (state, action) =&gt; {\n      const index = state.findIndex((item) =&gt; item.id === action.payload.id);\n      if (index !== -1) {\n        state[index] = action.payload; // Mutable update\n      }\n    },\n  },\n});\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#3-in-react-state-management","title":"3. In React State Management","text":"<ul> <li>Purpose: While less common, Immer can also be used to manage local component state.</li> <li>Usage: You can use Immer with the <code>useState</code> hook to simplify complex updates:</li> </ul> <pre><code>import { useState } from \"react\";\nimport produce from \"immer\";\n\nconst MyComponent = () =&gt; {\n  const [state, setState] = useState(initialState);\n\n  const updateState = (newData) =&gt; {\n    setState(\n      produce(state, (draft) =&gt; {\n        draft.someProperty = newData;\n      })\n    );\n  };\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#conclusion","title":"Conclusion","text":"<p>Immer is primarily used in reducers for state management in Redux (and Redux Toolkit) to allow for simpler, more readable code while maintaining immutability. It can also be applied to local component state updates in React for similar benefits.</p>","tags":["Porgramming","React"]},{"location":"hooks/React.memo-syntax/","title":"React.memo Syntax","text":""},{"location":"hooks/React.memo-syntax/#syntax-of-reactmemo","title":"Syntax of <code>React.memo</code>","text":"<p>The basic syntax of <code>React.memo</code> is:</p> <pre><code>const MemoizedComponent = React.memo(Component, [arePropsEqual?]);\n</code></pre> <ul> <li><code>Component</code>: The functional component to memoize.</li> <li><code>arePropsEqual</code> (optional): A custom comparison function for props. If omitted, React performs a shallow comparison of props.</li> </ul> <pre><code>import { memo } from \"react\";\n\nconst Todos = ({ todos }) =&gt; {\n  console.log(\"child render\");\n  return (\n    &lt;&gt;\n      &lt;h2&gt;My Todos&lt;/h2&gt;\n      {todos.map((todo, index) =&gt; {\n        return &lt;p key={index}&gt;{todo}&lt;/p&gt;;\n      })}\n    &lt;/&gt;\n  );\n};\n\nexport default memo(Todos);\n</code></pre>"},{"location":"hooks/React.memo-syntax/#should-you-use-reactmemo","title":"Should You Use <code>React.memo</code>?","text":"When to Use:When Not to Use: <ol> <li> <p>Avoid Unnecessary Re-renders: If your component:</p> <ul> <li>Receives props that rarely change.</li> <li>Is part of a parent component that re-renders frequently.</li> </ul> <pre><code>const ExpensiveChild = React.memo(({ data }) =&gt; {\n    console.log(\"Rendering ExpensiveChild\");\n    return &lt;div&gt;{data}&lt;/div&gt;;\n});\n</code></pre> </li> <li> <p>Performance Optimization: For components that are expensive to render, like components with:</p> <ul> <li>Complex logic.</li> <li>Heavy computations or rendering.</li> </ul> </li> </ol> <ol> <li>Small Components: If the component is lightweight, like a simple button or label, the overhead of <code>React.memo</code> might not bring noticeable benefits.</li> <li>Frequent Prop Changes: If the component receives props that change frequently, the re-computation of memoization (comparison) can add unnecessary overhead.</li> <li>Premature Optimization: If performance is not an issue, introducing <code>React.memo</code> can make your code more complex without much gain.</li> </ol>"},{"location":"hooks/React.memo-syntax/#decision-making-checklist","title":"Decision-Making Checklist","text":"<p>Ask yourself these questions:</p> <ul> <li>Does the parent component re-render frequently? If yes, consider using <code>React.memo</code>.</li> <li>Are the props of this component stable? If they change rarely, <code>React.memo</code> can be beneficial.</li> <li>Is this component computationally expensive? Use <code>React.memo</code> to avoid redundant expensive operations.</li> </ul>"},{"location":"hooks/React.memo-syntax/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Measure Before Optimization: Use React's <code>Profiler</code> or browser dev tools to identify performance bottlenecks before applying React.memo.</p> </li> <li> <p>Keep Code Readable: Don\u2019t overuse <code>React.memo</code>\u2014only apply it where it truly makes a difference.</p> </li> <li> <p>Combine with Other Optimizations: Pair <code>React.memo</code> with <code>useCallback</code> and <code>useMemo</code> to prevent re-creation of props or callback functions.</p> </li> </ul> <p>Conclusion</p> <p>You should use <code>React.memo</code> selectively. If your application doesn't face performance issues or the component is not part of a frequent rendering bottleneck, you can skip it. Focus on clean and maintainable code first, then optimize as needed.</p>"},{"location":"hooks/React.memo-vs-useMemo/","title":"React.memo vs useMemo","text":"<p><code>React.memo</code> and <code>useMemo</code> are different tools in React, designed for different use cases. Here's a detailed comparison:</p>"},{"location":"hooks/React.memo-vs-useMemo/#1-reactmemo","title":"1. <code>React.memo</code>","text":"<p>What it does:</p> <ul> <li>Optimizes functional components by preventing unnecessary re-renders.</li> <li>Memoizes the entire component and only re-renders it when its props change.</li> </ul> <p>How it works:</p> <ul> <li>Wraps a functional component to ensure it doesn\u2019t re-render if the incoming props are the same (shallow comparison by default).</li> </ul> <p>Usage:</p> <ul> <li> <p>To optimize component re-renders in cases where props don't change frequently.</p> Example<pre><code>const MyComponent = React.memo(({ count }) =&gt; {\n  console.log(\"Rendering MyComponent\");\n  return &lt;div&gt;Count: {count}&lt;/div&gt;;\n});\n</code></pre> </li> </ul> <p>Even if the parent component re-renders, <code>MyComponent</code> will not re-render unless the <code>count</code> prop changes.</p>"},{"location":"hooks/React.memo-vs-useMemo/#2-usememo","title":"2. useMemo","text":"<p>What it does:</p> <ul> <li>Optimizes expensive computations or derived values within a component by memoizing the result of a calculation.</li> <li>Returns a memoized value that is recalculated only when its dependencies change.</li> </ul> <p>How it works:</p> <ul> <li>Used inside a functional component to avoid re-computing values unnecessarily.</li> </ul> <p>Usage:</p> <ul> <li> <p>To optimize expensive calculations or prevent re-creation of objects or arrays.</p> Example<pre><code>import React, { useMemo } from \"react\";\n\nconst MyComponent = ({ items }) =&gt; {\n  const expensiveComputation = (items) =&gt; {\n    console.log(\"Computing...\");\n    return items.reduce((total, item) =&gt; total + item, 0);\n  };\n\n  const total = useMemo(() =&gt; expensiveComputation(items), [items]);\n\n  return &lt;div&gt;Total: {total}&lt;/div&gt;;\n};\n</code></pre> </li> </ul> <p>Here, the <code>expensiveComputation</code> function is only recalculated when the <code>items</code> array changes.</p>"},{"location":"hooks/React.memo-vs-useMemo/#key-differences","title":"Key Differences","text":"Aspect <code>React.memo</code> <code>useMemo</code> Purpose Prevents unnecessary component re-renders. Optimizes expensive calculations or derived values. What it Memoizes An entire functional component. A return value (calculated inside the component). Usage Context Wraps a functional component. Used inside a functional component. Dependencies Props of the memoized component. Explicit dependencies array (e.g., <code>[dep1, dep2]</code>). Trigger for Recalc Changes"},{"location":"hooks/React.memo-vs-useMemo/#when-to-use-each","title":"When to Use Each","text":"Note Use React.memo:Use useMemo: <p>When you want to optimize a functional component that:</p> <ul> <li>Re-renders frequently.</li> <li>Receives props that rarely change.</li> </ul> <p>Example: A component displaying static data passed as props.</p> <ul> <li>When you want to optimize a calculation or derived value inside a component.</li> <li>Example: Calculating filtered or aggregated data based on a dependency.</li> </ul>"},{"location":"hooks/React.memo-vs-useMemo/#combining-both","title":"Combining Both","text":"<p>You can use both together for maximum optimization:</p> <ul> <li>Use <code>React.memo</code> to optimize the component.</li> <li>Use <code>useMemo</code> to optimize expensive computations inside the component.</li> </ul> Example<pre><code>const MyComponent = React.memo(({ items }) =&gt; {\n  const total = useMemo(() =&gt; {\n    console.log(\"Calculating total...\");\n    return items.reduce((sum, item) =&gt; sum + item, 0);\n  }, [items]);\n\n  return &lt;div&gt;Total: {total}&lt;/div&gt;;\n});\n</code></pre> <p>Here:</p> <ul> <li><code>React.memo</code> ensures the component only re-renders if its props (<code>items</code>) change.</li> <li><code>useMemo</code> ensures the calculation only runs when <code>items</code> change.</li> </ul>"},{"location":"hooks/React.memo-vs-useMemo/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>React.memo</code> to optimize re-renders of entire components.</li> <li>Use <code>useMemo</code> to optimize calculations or derived values within a component.</li> <li>They complement each other but serve different purposes.</li> </ul>"},{"location":"hooks/React.memo/","title":"React.memo","text":""},{"location":"hooks/React.memo/#what-is-reactmemo","title":"What is React.memo?","text":"<p><code>React.memo</code> is a higher-order component (HOC) in React that optimizes functional components by preventing unnecessary re-renders. It works by memoizing the result of the component\u2019s render and re-rendering only when its props change.</p>"},{"location":"hooks/React.memo/#how-to-use-reactmemo","title":"How to Use React.memo?","text":"<p>Wrap your functional component with <code>React.memo</code>:</p> <pre><code>import React from \"react\";\n\nconst MyComponent = React.memo(({ value }) =&gt; {\n  console.log(\"Rendering MyComponent\");\n  return &lt;div&gt;{value}&lt;/div&gt;;\n});\n\nexport default MyComponent;\n</code></pre> <p>With Custom Comparison Logic</p> <p>By default, <code>React.memo</code> performs a shallow comparison of props. For custom comparison:</p> <pre><code>const MyComponent = React.memo(\n  ({ value }) =&gt; {\n    console.log(\"Rendering MyComponent\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n  },\n  (prevProps, nextProps) =&gt; {\n    // Return true if props are equal; false otherwise\n    return prevProps.value === nextProps.value;\n  }\n);\n</code></pre> When to, why, When not to <p>When to Use <code>React.memo</code>?</p> <ol> <li> <p>Pure Components:</p> <ul> <li>When your component renders the same output for the same props.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li> <p>Use it for components that:</p> <pre><code>-   Receive props that rarely change.\n-   Are part of a large tree where unnecessary renders are costly.\n</code></pre> </li> </ul> </li> <li> <p>Avoid Frequent Re-renders:</p> <ul> <li>When parent components re-render often but the child component's props don't change.</li> </ul> </li> </ol> <p>Why Use <code>React.memo</code>?</p> <ol> <li> <p>Reduce Render Cycles:</p> <ul> <li>Prevents re-renders for unchanged props, saving computational resources.</li> </ul> </li> <li> <p>Performance Boost:</p> <ul> <li>Useful for performance-critical applications with deep component trees.</li> </ul> </li> <li> <p>Cleaner Logic:</p> <ul> <li>Encapsulates memoization, avoiding manual checks inside the component.</li> </ul> </li> </ol> <p>When Not to Use <code>React.memo</code>?</p> <ol> <li> <p>Small Components:</p> <ul> <li>If the component is lightweight, the overhead of <code>React.memo</code> might outweigh its benefits.</li> </ul> </li> <li> <p>Dynamic Content:</p> <ul> <li>When props or state change frequently, <code>React.memo</code> won't help much.</li> </ul> </li> <li> <p>Inefficient Comparisons:</p> <ul> <li>If the comparison logic is complex or expensive, it can negate the optimization.</li> </ul> </li> </ol>"},{"location":"hooks/React.memo/#example-scenario","title":"Example Scenario","text":"Without <code>React.memo</code>:With <code>React.memo</code>: <pre><code>const Parent = () =&gt; {\n    const [count, setCount] = React.useState(0);\n    const [value, setValue] = React.useState(\"Hello\");\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n            &lt;Child value={value} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst Child = ({ value }) =&gt; {\n    console.log(\"Rendering Child\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n};\n</code></pre> <p>The <code>Child</code> component will re-render every time <code>Parent</code> re-renders, even though <code>value</code> doesn\u2019t change.</p> <pre><code>const Child = React.memo(({ value }) =&gt; {\n    console.log(\"Rendering Child\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n});\n</code></pre> <p>Now, <code>Child</code> re-renders only when value changes.</p> <p>In summary:</p> <ul> <li>Use React.memo to optimize functional components when props rarely change.</li> <li>It\u2019s not a silver bullet\u2014profile your app to confirm it improves performance.</li> </ul>"},{"location":"hooks/guides/","title":"Guide","text":"<p>React Design Patterns and Best Practices page number: 82</p> <p>Props are the way a parent component can pass its data down the tree to every component that needs it (or part of it).</p> <p>When a component passes some props to another component, it is called the Owner, irrespective of the parent-child relation between them.</p>"},{"location":"hooks/guides/#children","title":"Children","text":"<p>There is a special prop that can be passed from the owners to the components defined inside their render method; it is called children.</p> <p>In the React documentation, it is described as <code>opaque</code> because it is a property that does not tell anything about the value it contains.</p>"},{"location":"hooks/guides/#react-hooks-reference","title":"React Hooks Reference","text":"<ul> <li>Learn core Redux \u2014 The easiest way you can imagine</li> <li> <p>Redux Toolkit \u2014 The cheat sheet for Redux development</p> </li> <li> <p>React Hooks cheat sheet: Best practices with examples</p> </li> <li> <p>React Hooks Cheat Sheet</p> </li> <li> <p>React Hooks Cheatsheet \u2014 Most commonly used hooks in ReactJS</p> </li> <li> <p>The React Cheatsheet for 2021 (+ Real-World Examples)</p> </li> </ul>"},{"location":"hooks/guides/#reference","title":"Reference","text":"<p>LinkedIn React Post</p>"},{"location":"hooks/migrating-cra-vite/","title":"Migrating Cra to vite","text":""},{"location":"hooks/migrating-cra-vite/#migrating-create-react-app-to-vite","title":"Migrating create-react-app to Vite","text":"<pre><code>for x in src/**/*.js; do mv \"$x\" \"${x%.js}.jsx\"; done\n</code></pre>"},{"location":"hooks/migrating-cra-vite/#heres-a-modified-version","title":"Here's a modified version","text":"<p>You can use the find command along with exec to achieve this more efficiently.</p> bash<pre><code>find src -type f -name '*.js' -exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;\n</code></pre> <p>Explanation of the command:</p> <ul> <li> <p><code>find src -type f -name '*.js'</code>:</p> <p>This part finds all files (<code>-type f</code>) with a .js extension in the <code>src</code> directory.</p> </li> <li> <p><code>-exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;</code>:</p> <p>For each file found, it executes the given shell command to rename the file. The <code>{}</code> is a placeholder for the file name, and the <code>_</code> is a placeholder for <code>$0</code> in the shell command.</p> <p>So, when you run this command, it will find all <code>.js</code> files in the src directory and rename them to <code>.jsx</code>. Make sure to run this command from the parent directory containing the src directory.</p> </li> </ul>"},{"location":"hooks/migrating-cra-vite/#editor-in-react","title":"Editor in React","text":"<ul> <li>TinyMCE React</li> <li>ckeditor5-react</li> </ul>"},{"location":"hooks/migrating-cra-vite/#outdated-library","title":"Outdated Library","text":"<ul> <li>react-kanban: archived</li> </ul>"},{"location":"hooks/migrating-cra-vite/#reference","title":"Reference","text":"<ul> <li>Upgrade React: w3schools</li> <li>create-react-app to vite: youtube</li> <li>Bash Scripting to changes all file name</li> </ul>"},{"location":"hooks/react-context-api/","title":"react context api","text":""},{"location":"hooks/react-context-api/#react-context-api","title":"React Context API","text":"<pre><code># Context API Folder Structure\n\nsrc/\n|-- components/\n|-- context/\n|   |-- MyContext.js\n|   |-- MyContextProvider.js\n|-- pages/\n|-- App.js\n|-- index.js\n</code></pre> <p>The React Context API allows you to share state or behavior across your React components without having to pass props manually through each level of the component tree. Here's a simple guide on how to use the React Context API:</p>"},{"location":"hooks/react-context-api/#step-1-create-a-context","title":"Step 1: Create a Context","text":"<p>You can create a new context using the <code>createContext</code> function from React.</p> MyContext.js<pre><code>import { createContext } from \"react\";\n\nconst MyContext = createContext();\n\nexport default MyContext;\n</code></pre>"},{"location":"hooks/react-context-api/#step-2-create-a-provider-component","title":"Step 2: Create a Provider Component","text":"<p>Create a provider component that will wrap the part of your component tree where you want to make the context available. This provider component will be responsible for managing the state that you want to share.</p> MyContextProvider.js<pre><code>import React, { useState } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyContextProvider = ({ children }) =&gt; {\n  const [myState, setMyState] = useState(\"Initial value\");\n\n  const updateState = (newValue) =&gt; {\n    setMyState(newValue);\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ myState, updateState }}&gt;\n      {children}\n    &lt;/MyContext.Provider&gt;\n  );\n};\n\nexport default MyContextProvider;\n</code></pre>"},{"location":"hooks/react-context-api/#step-3-wrap-your-app-with-the-provider","title":"Step 3: Wrap Your App with the Provider","text":"<p>Wrap your main App component (or any parent component) with the provider component you created. This will make the context and its state available to all the components within that part of the component tree.</p> App.js<pre><code>import React from \"react\";\nimport MyContextProvider from \"./MyContextProvider\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;MyContextProvider&gt;\n      &lt;MyComponent /&gt;\n    &lt;/MyContextProvider&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"hooks/react-context-api/#step-4-consume-the-context-in-a-component","title":"Step 4: Consume the Context in a Component","text":"<p>Now, any component within the wrapped part of the tree can consume the context using the useContext hook.</p> MyComponent.js<pre><code>import React, { useContext } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyComponent = () =&gt; {\n  const { myState, updateState } = useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Value from context: {myState}&lt;/p&gt;\n      &lt;button onClick={() =&gt; updateState(\"New value\")}&gt;Update Context&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>Notes</p> <p>The key idea is that the state or functions you provide through the context provider become accessible to all the components that consume that context within the wrapped part of the component tree.</p>"},{"location":"hooks/react-context-api/#reference","title":"Reference","text":"<ul> <li>How to Use the React Context API in Your Projects: good</li> <li>React Context API: What is it and How it works?</li> </ul>"},{"location":"hooks/react-router/","title":"react router","text":""},{"location":"hooks/react-router/#router","title":"Router","text":"<pre><code>// Installation\n\n$ pnpm install react-router-dom\n</code></pre>"},{"location":"hooks/react-router/#how-to-install-react-router","title":"How to Install React Router?","text":"<p>React router contains 3 different packages for routing.</p> <ul> <li><code>react-router</code>: contains most of the core functionality of React Router including the route matching algorithm and most of the core components and react hooks</li> <li><code>react-router-native</code>: It is designed for mobile applications.</li> <li><code>react-router-dom</code>: It is designed for web applications.</li> </ul>"},{"location":"hooks/react-router/#components-in-react-router","title":"Components in React Router","text":"<p>React router components are divided into 3 main categories -</p> <ul> <li><code>Routers</code> - for instance, <code>&lt;BrowserRouter&gt;</code> and <code>&lt;HashRouter&gt;</code> components</li> <li><code>Route matchers</code> - for instance, <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> components</li> <li><code>Navigation</code> \u2013 for instance, <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> components</li> </ul> <p></p>"},{"location":"hooks/react-router/#code","title":"Code","text":"<pre><code>import { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre>"},{"location":"hooks/react-router/#redirect-component","title":"Redirect Component","text":"<pre><code>import {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect\n} from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;PrivateRoute path=\"/hidden\" component={Hidden} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nfunction PrivateRoute({ component: Component, ...rest }) {\n  // useAuth is some custom hook to get the current user's auth state\n  const isAuth = useAuth();\n\n  return (\n    &lt;Route\n      {...rest}\n      render={(props) =&gt;\n        isAuth ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/\" /&gt;\n      }\n    /&gt;\n  );\n}\n\nfunction Home() {\n  return &lt;&gt;home&lt;/&gt;;\n}\n\nfunction Hidden() {\n  return &lt;&gt;hidden&lt;/&gt;;\n}\n</code></pre> <p>The redirect component is very simple to use, very declarative, and allows us to see the great benefit of React Router DOM being component-based, just like everything in React.</p>"},{"location":"hooks/react-router/#react-router-hooks","title":"React Router Hooks","text":"<ul> <li>useHistory Hook</li> <li>useLocation Hook</li> <li>useParams Hook + Dynamic Routes</li> <li>useRouteMatch Hook</li> </ul> <pre><code>import { useHistory } from \"react-router-dom\";\n\n\nfunction About() {\n  const history = useHistory();\n\n  console.log(history.location.pathname); // '/about'\n\n  return (\n    &lt;&gt;\n     &lt;h1&gt;The about page is on: {history.location.pathname}&lt;/h1&gt;\n     &lt;button onClick={() =&gt; history.push('/')}&gt;Go to home page&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"hooks/react-router/#upgrading-fro-v5-to-v6","title":"Upgrading fro <code>v5</code> to <code>v6</code>","text":"<ul> <li>Upgrade all <code>&lt;Switch&gt;</code> elements to <code>&lt;Routes&gt;</code></li> <li>Use <code>useNavigate</code> instead of <code>useHistory</code></li> <li>Replace <code>useRouteMatch</code> with <code>useMatch</code></li> </ul> <p>Replacing Switch component with Routes</p> <pre><code>// old with Switch\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/about\"&gt;\n          &lt;AboutPage /&gt;\n        &lt;/Route&gt;\n        &lt;Route exact path=\"/profile\"&gt;\n          &lt;ProfilePage /&gt;\n        &lt;/Route&gt;\n        &lt;Route path=\"/profile/:id\"&gt;\n          &lt;ProfileUserPage /&gt;\n        &lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new with Routes\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Internal changes &amp; path evaluation (no more needed exact prop) For V5 we needed to put the exact prop on the component to go for that specific route we want</p> <pre><code>// old\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"hooks/react-router/#history","title":"History","text":"<pre><code>$ npm i history\n</code></pre> <p>There are three types of history</p> <ul> <li>browser</li> <li>hash</li> <li>memory</li> </ul> <pre><code>import {\n  createBrowserHistory,\n  createHashHistory,\n  createMemoryHistory\n} from 'history'\n</code></pre> <p>If you are using React Router, it can automatically create history objects for you, so you may never have to actually interact with history directly. Still, it is important to understand the differences between each type of history so that you can determine which one is right for your project.</p>"},{"location":"hooks/react-router/#reference","title":"Reference","text":"<ul> <li>React router overview</li> <li>React Router - Types, Mechanism, Installation And Examples</li> <li>The React Router Cheatsheet \u2013 Everything You Need to Know - (BEST)</li> <li>Using Hashrouter With React - Definitive Guide</li> <li>What is Hash Routing?</li> <li>upgrading v5 - v6: oficial doc</li> <li>React router V6: Some of the new changes </li> <li>A little bit of history - npm</li> <li>history - npm</li> </ul>"},{"location":"hooks/useCallback/","title":"useCallback","text":""},{"location":"hooks/useCallback/#usecallback-hook","title":"useCallback Hook","text":"<p><code>useCallback</code> is a React hook that is used to memoize functions so that they do not get recreated on each render, which can be useful to optimize performance in certain scenarios. Here's a simple real example to illustrate the use of <code>useCallback</code>.</p> <p></p> <pre><code>import React, { useState, useCallback } from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback\n  const handleClickWithoutCallback = () =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  };\n\n  // With useCallback\n  const handleClickWithCallback = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  }, [count]);\n  // Dependency array: specify dependencies that should trigger function re-creation\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n\n      &lt;button onClick={handleClickWithoutCallback}&gt;\n        Click Without useCallback\n      &lt;/button&gt;\n\n      &lt;button onClick={handleClickWithCallback}&gt;Click With useCallback&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>In this example:</p> <ul> <li>The component renders a count state variable.</li> <li>There are two buttons: one <code>without useCallback</code> and one <code>with useCallback</code>.</li> <li>The <code>handleClickWithoutCallback</code> function is created inside the component body, so it is recreated on every render. This can lead to unnecessary re-renders of child components if passed down as props.</li> <li>The <code>handleClickWithCallback</code> function is memoized using useCallback, and the dependency array <code>[count]</code> specifies that the function should be recreated only when the <code>count</code> variable changes. This can be useful to prevent unnecessary function recreation and optimize performance.</li> </ul> <p>In this simple example, the difference might not be significant, but in larger applications, especially when passing functions down to child components, using <code>useCallback</code> can help optimize performance by avoiding unnecessary re-renders triggered by new function instances.</p> <p>Scenario: When to use useCallback &amp; when not to use</p> <p>Here are some scenarios where using useCallback in React can be beneficial, and situations where it may not be necessary:</p> <p>Use useCallback:</p> <ol> <li> <p>Optimizing Child Components:</p> <ul> <li>When passing callback functions as props to child components.</li> <li>It prevents unnecessary re-renders of child components if the callback function reference changes.</li> </ul> <pre><code>const ParentComponent = () =&gt; {\n  const handleClick = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n  }, []);\n\n  return &lt;ChildComponent onClick={handleClick} /&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers in Dependencies:</p> <ul> <li>When using callback functions in the dependency array of <code>useEffect</code> to avoid unnecessary re-execution of the effect.   <pre><code>useEffect(() =&gt; {\n  // Effect logic\n}, [callbackFunction]);\n</code></pre></li> </ul> </li> <li> <p>Preventing Unnecessary Function Recreation:</p> <ul> <li>When you want to avoid recreating functions on each render, especially if those functions are passed as dependencies to other hooks or functions.   <pre><code>const memoizedFunction = useCallback(() =&gt; {\n  // Function logic\n}, [dependency1, dependency2]);\n</code></pre></li> </ul> </li> </ol> <p>Might Not Need useCallback:</p> <ol> <li> <p>Local Functions:</p> <ul> <li>If a function is defined inside a component and doesn't need to be referenced outside that component or passed down to child components, it may not need <code>useCallback</code></li> </ul> <pre><code>const MyComponent = () =&gt; {\n  const localFunction = () =&gt; {\n    // Local function logic\n  };\n\n  // No need for useCallback if localFunction is not passed as a prop or used in dependencies.\n  // ...\n};\n</code></pre> </li> <li> <p>Static Dependencies:</p> <ul> <li>If the function doesn't depend on any external variables or props, and its behavior is consistent across renders, <code>useCallback</code> might not be necessary.</li> </ul> <pre><code>const simpleFunction = () =&gt; {\n  // Function logic without dependencies\n};\n\n// No need for useCallback if simpleFunction doesn't depend on external variables.\n</code></pre> </li> <li> <p>Performance Impact is Negligible:</p> <ul> <li>In some cases, the performance impact of not using useCallback might be negligible, especially for smaller components or when function recreation does not affect the overall performance.</li> </ul> </li> </ol> <p>It's important to use <code>useCallback</code> judiciously and consider the specific use case and performance requirements of your application. If in doubt, you can start without <code>useCallback</code> and optimize later if performance becomes an issue.</p>"},{"location":"hooks/useCallback/#reference","title":"Reference","text":"<ul> <li>Your Guide to React.useCallback()</li> <li>Demystifying React Hooks: useCallback and useMemo </li> </ul>"},{"location":"hooks/useEffect-cleanup/","title":"useEffect cleanup","text":"<p>A cleanup function in React is typically used to perform necessary cleanup or resource disposal when a component unmounts. Here are some scenarios in which you should consider writing a cleanup function using the <code>useEffect</code> hook:</p>"},{"location":"hooks/useEffect-cleanup/#1-clearing-subscriptions-or-timers","title":"1. Clearing Subscriptions or Timers:","text":"<p>If your component sets up subscriptions (e.g., using <code>addEventListener</code>) or timers (e.g., using <code>setTimeout</code> or <code>setInterval</code>), it's crucial to clean them up when the component is unmounted to avoid memory leaks and unexpected behavior.</p> jsx<pre><code>useEffect(() =&gt; {\n  const timerId = setInterval(() =&gt; {\n    // Your logic here\n  }, 1000);\n\n  return () =&gt; {\n    // Cleanup: Clear the timer when the component unmounts\n    clearInterval(timerId);\n  };\n}, []);\n</code></pre>"},{"location":"hooks/useEffect-cleanup/#2-canceling-network-requests","title":"2. Canceling Network Requests:","text":"<p>If your component makes asynchronous requests (e.g., using <code>fetch</code>), you might want to cancel or abort the request if the component is unmounted to prevent setting state on an unmounted component.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"hooks/useEffect-cleanup/#3-cleaning-up-external-resources","title":"3. Cleaning Up External Resources:","text":"<p>If your component interacts with external resources or libraries (e.g., closing a WebSocket connection, cleaning up a third-party library instance), the cleanup function is the right place to perform these actions.</p> jsx<pre><code>useEffect(() =&gt; {\n  const socket = new WebSocket(\"wss://example.com\");\n\n  socket.addEventListener(\"open\", () =&gt; {\n    // Your logic here\n  });\n\n  return () =&gt; {\n    // Cleanup: Close the WebSocket connection when the component unmounts\n    socket.close();\n  };\n}, []);\n</code></pre>"},{"location":"hooks/useEffect-cleanup/#4-resetting-state-or-side-effects","title":"4. Resetting State or Side Effects:","text":"<p>If your component needs to reset certain state variables or undo side effects when it unmounts, the cleanup function can be used for such purposes.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Your effect logic here\n\n  return () =&gt; {\n    // Cleanup: Reset state or undo side effects when the component unmounts\n    resetState();\n  };\n}, [dependency]);\n</code></pre> <p>Remember that the cleanup function is an essential part of the useEffect lifecycle. It ensures that resources are properly released, preventing potential memory leaks or unintended behavior when a component is no longer in use. Always use the cleanup function to perform any necessary cleanup actions specific to the effects you've set up in your component.</p>"},{"location":"hooks/useEffect-technique-used/","title":"useEffect mostly used","text":"<p>The choice of <code>useEffect</code> technique often depends on the specific requirements of your application. However, one commonly used and versatile pattern is using <code>useEffect</code> for data fetching. This is especially relevant in applications that interact with APIs or external data sources. The pattern typically involves:</p> <ol> <li>Fetching data when the component mounts.</li> <li>Optionally fetching data based on changes in certain dependencies.</li> </ol> <p>Here's a breakdown of this pattern:</p>"},{"location":"hooks/useEffect-technique-used/#1-fetching-data-on-mount","title":"1. Fetching Data on Mount:","text":"<p>Use <code>useEffect</code> with an empty dependency array to fetch data when the component mounts. This ensures that the effect runs only once after the initial render.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"hooks/useEffect-technique-used/#2-fetching-data-based-on-dependencies","title":"2. Fetching Data Based on Dependencies:","text":"<p>Use <code>useEffect</code> with specific dependencies to refetch data when those dependencies change. This is useful for scenarios where you need to update data in response to user interactions or changes in the application state.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(`https://api.example.com/data/${userId}`);\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [userId]); // Refetch data when 'userId' changes\n</code></pre>"},{"location":"hooks/useEffect-technique-used/#3-cleanup-and-cancellation","title":"3. Cleanup and Cancellation:","text":"<p>Consider incorporating cleanup functions to handle scenarios like canceling pending requests or unsubscribing from external subscriptions when the component unmounts.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"hooks/useEffect-technique-used/#4-combining-multiple-useeffect-hooks","title":"4. Combining Multiple useEffect Hooks:","text":"<p>Break down complex logic into multiple <code>useEffect</code> hooks for better readability and maintainability. For example, separate data fetching from UI-related side effects.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Fetch initial data\n  const fetchData = async () =&gt; {\n    // ...\n  };\n  fetchData();\n}, []);\n\nuseEffect(() =&gt; {\n  // Handle UI-related side effects\n  // ...\n}, [data, userId]);\n</code></pre>"},{"location":"hooks/useEffect-technique-used/#5-asyncawait-pattern","title":"5. Async/Await Pattern:","text":"<p>Use the <code>async</code> keyword and <code>await</code> syntax for cleaner asynchronous code within the <code>useEffect</code>.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []);\n</code></pre> <p>This data-fetching pattern is commonly used because it covers a wide range of scenarios, from initial data loading to updating data based on changes in specific dependencies. It provides a clean and organized way to manage asynchronous operations in React components.</p>"},{"location":"hooks/useEffect-technique/","title":"useEffect Technique","text":""},{"location":"hooks/useEffect-technique/#_1","title":"useEffect Technique","text":"<p>The <code>useEffect</code> hook in React is used for handling side effects in functional components. It is a powerful tool that allows you to perform operations such as data fetching, subscriptions, or manually changing the DOM in response to component lifecycle events. Here are some advanced techniques and use cases for the <code>useEffect</code> hook:</p>"},{"location":"hooks/useEffect-technique/#1-conditional-execution","title":"1. Conditional Execution:","text":"<p>Use <code>useEffect</code> with dependencies to conditionally execute code when certain dependencies change. This is useful for optimizing performance and avoiding unnecessary computations.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Effect will run when 'dependency' changes\n  fetchData(dependency);\n}, [dependency]);\n</code></pre>"},{"location":"hooks/useEffect-technique/#2-cleanup-function","title":"2. Cleanup Function:","text":"<p>Use the cleanup function returned by <code>useEffect</code> for cleanup operations, such as canceling subscriptions or clearing intervals.</p> jsx<pre><code>useEffect(() =&gt; {\n  const subscription = subscribe();\n  return () =&gt; {\n    // Cleanup function: unsubscribe when the component unmounts\n    subscription.unsubscribe();\n  };\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"hooks/useEffect-technique/#3-debouncing-and-throttling","title":"3. Debouncing and Throttling:","text":"<p>Use <code>useEffect</code> in combination with debouncing or throttling techniques to limit the rate at which a function is called.</p> jsx<pre><code>useEffect(() =&gt; {\n  const debouncedFunction = debounce(() =&gt; {\n    // Code to run after debounce\n  }, 300);\n\n  // Attach the debounced function to an event listener, for example\n  window.addEventListener(\"scroll\", debouncedFunction);\n\n  return () =&gt; {\n    // Cleanup: remove the event listener when the component unmounts\n    window.removeEventListener(\"scroll\", debouncedFunction);\n  };\n}, []);\n</code></pre>"},{"location":"hooks/useEffect-technique/#4-global-state-synchronization","title":"4. Global State Synchronization:","text":"<p>Use <code>useEffect</code> to synchronize the component's state with a global state management solution, like Redux.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Update local state when global state changes\n  setLocalState(globalState);\n}, [globalState]);\n</code></pre>"},{"location":"hooks/useEffect-technique/#5-dependency-arrays-and-stale-closures","title":"5. Dependency Arrays and Stale Closures:","text":"<p>Be careful with dependencies and closures to avoid stale values. Use the functional form of <code>setState</code> to capture the latest state or props.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Avoid stale closures\n  const fetchData = async () =&gt; {\n    const result = await fetch(url);\n    // Use result and capture the latest 'mounted' value\n    if (mounted.current) {\n      setData(result);\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Set 'mounted' to false when the component unmounts\n    mounted.current = false;\n  };\n}, [url]);\n</code></pre>"},{"location":"hooks/useEffect-technique/#6-multiple-useeffect-for-separation-of-concerns","title":"6. Multiple useEffect for Separation of Concerns:","text":"<p>Use multiple <code>useEffect</code> blocks to separate different concerns, making your code more readable and maintainable.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Code for fetching data\n  fetchData();\n}, [dependencyForDataFetching]);\n\nuseEffect(() =&gt; {\n  // Code for handling UI updates\n  updateUI();\n}, [dependencyForUIUpdate]);\n</code></pre>"},{"location":"hooks/useEffect-technique/#7-promise-in-useeffect","title":"7. Promise in useEffect:","text":"<p>If you want to work with asynchronous code in <code>useEffect</code>, you can use the async keyword and await syntax.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchDataFromAPI();\n      setData(result);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [dependency]);\n</code></pre>"},{"location":"hooks/useEffect-technique/#8-combining-useeffect-with-other-hooks","title":"8. Combining useEffect with Other Hooks:","text":"<p>Combine useEffect with other hooks like useMemo or useCallback for more fine-grained control over the memoization of values and functions.</p> jsx<pre><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n\nuseEffect(() =&gt; {\n  // Effect using memoizedValue\n  performEffectWithMemoizedValue(memoizedValue);\n}, [memoizedValue]);\n</code></pre> <p>Notes</p> <p>By mastering these advanced techniques, you can make the most of the useEffect hook in your React applications and handle complex scenarios with ease. Always consider the specific requirements of your application and choose the approach that best fits your use case.</p>"},{"location":"hooks/useReducer-and-reducer/","title":"useReducer & Reducer","text":"<p>what is difference between useReudcer and redux reducer</p>"},{"location":"hooks/useReducer-and-reducer/#overview","title":"Overview","text":"<p><code>useReducer</code> and <code>Redux reducers</code> both handle state management, but they are used in different contexts and have different scopes.</p> <p>Here\u2019s a detailed comparison between useReducer and Redux reducers:</p>"},{"location":"hooks/useReducer-and-reducer/#1-scope-and-usage","title":"1. Scope and Usage","text":"useReducerRedux Reducers <ul> <li>Scope: Local to a single component or a small part of your application.</li> <li>Usage: Typically used for managing complex state logic within a single React component or within a small component tree.</li> </ul> <ul> <li>Scope: Global state management across an entire application.</li> <li>Usage: Used to manage application-wide state that can be shared across multiple components and accessed from different parts of the app.</li> </ul>"},{"location":"hooks/useReducer-and-reducer/#2-state-management","title":"2. State Management","text":"useReducerRedux Reducers <ul> <li>State: Manages state within a React component.</li> <li>Setup: Defined and used directly in a component. The state is local to that component and its children (if context is used). Integration: No need for additional libraries or setup beyond React itself.</li> </ul> <ul> <li>State: Manages global state that can be accessed by any component in the application.</li> <li>Setup: Requires setting up a Redux store, reducers, and possibly middleware (like <code>redux-thunk</code> or <code>redux-saga</code>) for handling side effects. Integration: Integrated with the Redux library, often using <code>react-redux</code> to connect components to the Redux store.</li> </ul>"},{"location":"hooks/useReducer-and-reducer/#3-side-effects-and-middleware","title":"3. Side Effects and Middleware","text":"useReducerRedux Reducers <ul> <li>Side Effects: Managed using <code>useEffect</code> within the component where <code>useReducer</code> is used.</li> <li>Middleware: Does not use middleware directly. Side effects are managed separately.</li> </ul> <ul> <li>Side Effects: Handled using middleware like <code>redux-thunk</code> or <code>redux-saga</code>, which allows asynchronous actions and complex side effects.</li> <li>Middleware: Redux has a robust middleware system that extends its capabilities for handling side effects, logging, and more.</li> </ul>"},{"location":"hooks/useReducer-and-reducer/#4-data-flow-and-architecture","title":"4. Data Flow and Architecture","text":"useReducerRedux Reducers <ul> <li>Data Flow: Local data flow within a component. Actions are dispatched to the reducer, which updates the component\u2019s local state.</li> <li>Architecture: Simplified, ideal for encapsulated state management within a component or small component tree.</li> </ul> <ul> <li>Data Flow: Centralized data flow. Actions are dispatched to the Redux store, and reducers update the global state. Components connect to the store to access or modify state.</li> <li>Architecture: More complex, designed for larger applications with centralized state management. Encourages a predictable state container pattern.</li> </ul>"},{"location":"hooks/useReducer-and-reducer/#5-example-comparisons","title":"5. Example Comparisons","text":"Example with <code>useReducer</code>Example with Redux <p>Here\u2019s a basic example of managing a counter with <code>useReducer</code>:</p> <pre><code>import React, { useReducer } from 'react';\n\n// Reducer function\nfunction counterReducer(state, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {state.count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p>Here\u2019s a basic example of managing a counter with Redux:</p> ReducerStore SetupComponentProvider Setup <pre><code>// counterReducer.js\nconst initialState = { count: 0 };\n\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore } from 'redux';\nimport counterReducer from './counterReducer';\n\nconst store = createStore(counterReducer);\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction Counter() {\n    const count = useSelector(state =&gt; state.count);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <pre><code>// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport Counter from './Counter';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;Counter /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"hooks/useReducer-and-reducer/#summary","title":"Summary","text":"<ul> <li> <p><code>useReducer</code>: Ideal for managing local or component-specific state with complex logic in a React component. It is simple and integrates seamlessly with React's hooks.</p> </li> <li> <p>Redux Reducers: Best for managing global state in larger applications where state needs to be shared across multiple components. Redux provides a centralized state management solution with robust middleware support for side effects.</p> </li> </ul> <p>Choosing between <code>useReducer</code> and Redux often depends on the scale and complexity of your application's state management needs. For simpler or isolated state management, <code>useReducer</code> is a great choice. For more extensive and shared state management, Redux offers a more powerful and scalable solution.</p>"},{"location":"hooks/useReducer-example/","title":"useReducer Example","text":""},{"location":"hooks/useReducer-example/#overview","title":"Overview","text":"<p>Sure! Let\u2019s dive into a more advanced real-time example using both <code>useState</code> and <code>useReducer</code>. We\u2019ll create a more complex form for managing a list of items where you can add, edit, and delete items.</p>"},{"location":"hooks/useReducer-example/#scenario","title":"Scenario","text":"<p>We'll build a form to manage a list of tasks with the following features:</p> Tip <ul> <li>Add: Add a new task to the list.</li> <li>Edit: Edit an existing task.</li> <li>Delete: Remove a task from the list.</li> <li>Complete/Uncomplete: Mark a task as complete or incomplete.</li> </ul> <p>We'll start with a basic example using <code>useState</code> and then move to a more complex example using <code>useReducer</code>.</p>"},{"location":"hooks/useReducer-example/#example","title":"Example","text":"Using <code>useState</code>Using <code>useReducer</code> <p>Here\u2019s a simple example using <code>useState</code> for managing tasks:</p> CodeExplanation <pre><code>import React, { useState } from 'react';\n\nfunction TaskManagerWithState() {\n    const [tasks, setTasks] = useState([]);\n    const [newTask, setNewTask] = useState('');\n    const [editingTask, setEditingTask] = useState(null);\n    const [editedTaskText, setEditedTaskText] = useState('');\n\n    const handleAddTask = () =&gt; {\n        if (newTask.trim()) {\n            setTasks([...tasks, { id: Date.now(), text: newTask, completed: false }]);\n            setNewTask('');\n        }\n    };\n\n    const handleEditTask = (task) =&gt; {\n        setEditingTask(task);\n        setEditedTaskText(task.text);\n    };\n\n    const handleSaveTask = () =&gt; {\n        setTasks(tasks.map(task =&gt;\n            task.id === editingTask.id\n                ? { ...task, text: editedTaskText }\n                : task\n        ));\n        setEditingTask(null);\n        setEditedTaskText('');\n    };\n\n    const handleDeleteTask = (taskId) =&gt; {\n        setTasks(tasks.filter(task =&gt; task.id !== taskId));\n    };\n\n    const handleToggleComplete = (taskId) =&gt; {\n        setTasks(tasks.map(task =&gt;\n            task.id === taskId\n                ? { ...task, completed: !task.completed }\n                : task\n        ));\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Task Manager with useState&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newTask}\n                onChange={(e) =&gt; setNewTask(e.target.value)}\n                placeholder=\"Add new task\"\n            /&gt;\n            &lt;button onClick={handleAddTask}&gt;Add Task&lt;/button&gt;\n\n            {editingTask &amp;&amp; (\n                &lt;div&gt;\n                    &lt;input\n                        type=\"text\"\n                        value={editedTaskText}\n                        onChange={(e) =&gt; setEditedTaskText(e.target.value)}\n                    /&gt;\n                    &lt;button onClick={handleSaveTask}&gt;Save&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            &lt;ul&gt;\n                {tasks.map(task =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; handleToggleComplete(task.id)}&gt;\n                        {task.completed ? 'Uncomplete' : 'Complete'}\n                        &lt;/button&gt;\n                        &lt;button onClick={() =&gt; handleEditTask(task)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; handleDeleteTask(task.id)}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TaskManagerWithState;\n</code></pre> <ul> <li>State Management: Manages the list of tasks and their state using <code>useState</code>.</li> <li>Add, Edit, Delete: Functions to add, edit, and delete tasks are directly managing the state.</li> <li>Toggle Completion: Toggles the completion status of a task.</li> </ul> <p>Now let\u2019s use <code>useReducer</code> for a more structured approach:</p> CodeExplanation <pre><code>import React, { useReducer, useState } from 'react';\n\n// Define action types\nconst ADD_TASK = 'ADD_TASK';\nconst EDIT_TASK = 'EDIT_TASK';\nconst SAVE_TASK = 'SAVE_TASK';\nconst DELETE_TASK = 'DELETE_TASK';\nconst TOGGLE_COMPLETE = 'TOGGLE_COMPLETE';\n\n// Define initial state\nconst initialState = {\n    tasks: [],\n    editingTask: null,\n    editedTaskText: ''\n};\n\n// Define reducer function\nfunction taskReducer(state, action) {\n    switch (action.type) {\n        case ADD_TASK:\n            return {\n                ...state,\n                tasks: [...state.tasks, { id: Date.now(), text: action.payload, completed: false }],\n                editingTask: null,\n                editedTaskText: ''\n            };\n        case EDIT_TASK:\n            return {\n                ...state,\n                editingTask: action.payload,\n                editedTaskText: action.payload.text\n            };\n        case SAVE_TASK:\n            return {\n                ...state,\n                tasks: state.tasks.map(task =&gt;\n                    task.id === state.editingTask.id\n                        ? { ...task, text: state.editedTaskText }\n                        : task\n                ),\n                editingTask: null,\n                editedTaskText: ''\n            };\n        case DELETE_TASK:\n            return {\n                ...state,\n                tasks: state.tasks.filter(task =&gt; task.id !== action.payload)\n            };\n        case TOGGLE_COMPLETE:\n            return {\n                ...state,\n                tasks: state.tasks.map(task =&gt;\n                    task.id === action.payload\n                        ? { ...task, completed: !task.completed }\n                        : task\n                )\n            };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction TaskManagerWithReducer() {\n    const [state, dispatch] = useReducer(taskReducer, initialState);\n    const [newTask, setNewTask] = useState('');\n\n    const handleAddTask = () =&gt; {\n        if (newTask.trim()) {\n            dispatch({ type: ADD_TASK, payload: newTask });\n            setNewTask('');\n        }\n    };\n\n    const handleSaveTask = () =&gt; {\n        dispatch({ type: SAVE_TASK });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Task Manager with useReducer&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newTask}\n                onChange={(e) =&gt; setNewTask(e.target.value)}\n                placeholder=\"Add new task\"\n            /&gt;\n            &lt;button onClick={handleAddTask}&gt;Add Task&lt;/button&gt;\n\n            {state.editingTask &amp;&amp; (\n                &lt;div&gt;\n                    &lt;input\n                        type=\"text\"\n                        value={state.editedTaskText}\n                        onChange={(e) =&gt; dispatch({ type: 'EDIT_TASK_TEXT', payload: e.target.value })}\n                    /&gt;\n                    &lt;button onClick={handleSaveTask}&gt;Save&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            &lt;ul&gt;\n                {state.tasks.map(task =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; dispatch({ type: TOGGLE_COMPLETE, payload: task.id })}&gt;\n                            {task.completed ? 'Uncomplete' : 'Complete'}\n                        &lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch({ type: EDIT_TASK, payload: task })}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch({ type: DELETE_TASK, payload: task.id })}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TaskManagerWithReducer;\n</code></pre> <ul> <li>Reducer Function: Manages state changes in a structured way with different actions for adding, editing, saving, deleting, and toggling tasks.</li> <li>State Management: The state and actions are handled by <code>useReducer</code>, which makes managing multiple state updates more organized.</li> <li>Dispatching Actions: Uses <code>dispatch</code> to send actions to the reducer, which then updates the state based on the action type.</li> </ul>"},{"location":"hooks/useReducer-example/#summary","title":"Summary","text":"<ul> <li><code>useState</code>: Simple and suitable for cases where state management is straightforward.</li> <li><code>useReducer</code>: More structured and useful for complex state logic involving multiple actions and state updates.</li> </ul> <p>Both approaches are demonstrated here to show how they fit different scenarios in managing state in a React application.</p>"},{"location":"hooks/useReducer-example/#which-scenarior-to-usereducer","title":"Which Scenarior to <code>useReducer</code>","text":"<p>Certainly! There are specific scenarios where <code>useReducer</code> is a better fit than <code>useState</code> due to its structured approach to state management. Here are some topics and examples where <code>useReducer</code> shines:</p>"},{"location":"hooks/useReducer-example/#1-complex-state-logic","title":"1. Complex State Logic","text":"<ul> <li> <p>Scenario: When state updates involve complex logic or multiple conditions.</p> </li> <li> <p>Example: Managing the state of a form with multiple fields that have interdependent validations or dynamic field updates.</p> </li> <li> <p>Why <code>useReducer</code>: It allows you to manage complex state transitions in a more organized way by defining a reducer function that processes different action types and updates the state accordingly.</p> </li> </ul>"},{"location":"hooks/useReducer-example/#2-multiple-actions-affecting-state","title":"2. Multiple Actions Affecting State","text":"<ul> <li> <p>Scenario: When your component needs to handle various actions that modify the state in different ways.</p> </li> <li> <p>Example: A todo list application where tasks can be added, edited, deleted, and marked as completed. Each action requires a different update to the state.</p> </li> <li> <p>Why <code>useReducer</code>: It provides a clear structure for handling different types of actions (e.g., <code>ADD_TASK</code>, <code>DELETE_TASK</code>) through a single reducer function, making the state management more predictable.</p> </li> </ul>"},{"location":"hooks/useReducer-example/#3-state-dependencies","title":"3. State Dependencies","text":"<ul> <li> <p>Scenario: When state updates are dependent on the previous state or other parts of the state.</p> </li> <li> <p>Example: A multi-step form where the content of later steps depends on user inputs from earlier steps.</p> </li> <li> <p>Why <code>useReducer</code>: It can handle complex state transitions that depend on the current state by allowing you to use the reducer function to apply changes based on the current state.</p> </li> </ul>"},{"location":"hooks/useReducer-example/#4-large-and-scalable-state-management","title":"4. Large and Scalable State Management","text":"<ul> <li> <p>Scenario: When managing a large state object with many properties that need to be updated in different ways.</p> </li> <li> <p>Example: A complex user profile where you need to update user details, preferences, and settings in different ways based on user actions.</p> </li> <li> <p>Why <code>useReducer</code>: It helps in keeping the state management scalable and maintainable by encapsulating all state updates within a reducer function, especially when the state object is large and involves multiple fields.</p> </li> </ul>"},{"location":"hooks/useReducer-example/#5-debugging-and-testing","title":"5. Debugging and Testing","text":"<ul> <li> <p>Scenario: When you need a predictable way to test and debug state changes.</p> </li> <li> <p>Example: An application with multiple components that interact with shared state in complex ways, such as a shopping cart with various actions (add, remove, update quantities).</p> </li> <li> <p>Why <code>useReducer</code>: The reducer function provides a clear way to see how different actions affect the state, which makes it easier to test and debug state transitions.</p> </li> </ul>"},{"location":"hooks/useReducer-example/#real-life-example-managing-a-multi-step-form","title":"Real-Life Example: Managing a Multi-Step Form","text":"<p>Consider a multi-step form where the user inputs data across several steps, and the data from previous steps affects the options or visibility of fields in later steps.</p> Using <code>useState</code>Using <code>useReducer</code> <pre><code>import React, { useState } from 'react';\n\nfunction MultiStepFormWithState() {\n    const [step, setStep] = useState(1);\n    const [formData, setFormData] = useState({\n        name: '',\n        email: '',\n        address: '',\n        age: '',\n    });\n\n    const handleChange = (e) =&gt; {\n        setFormData({\n            ...formData,\n            [e.target.name]: e.target.value\n        });\n    };\n\n    const handleNextStep = () =&gt; setStep(step + 1);\n    const handlePreviousStep = () =&gt; setStep(step - 1);\n\n    return (\n        &lt;div&gt;\n            {step === 1 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 1: Personal Info&lt;/h1&gt;\n                    &lt;input name=\"name\" value={formData.name} onChange={handleChange} placeholder=\"Name\" /&gt;\n                    &lt;input name=\"email\" value={formData.email} onChange={handleChange} placeholder=\"Email\" /&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {step === 2 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 2: Address&lt;/h1&gt;\n                    &lt;input name=\"address\" value={formData.address} onChange={handleChange} placeholder=\"Address\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {step === 3 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 3: Age&lt;/h1&gt;\n                    &lt;input name=\"age\" value={formData.age} onChange={handleChange} placeholder=\"Age\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={() =&gt; alert('Form Submitted')}&gt;Submit&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default MultiStepFormWithState;\n</code></pre> <pre><code>import React, { useReducer } from 'react';\n\n// Define action types\nconst NEXT_STEP = 'NEXT_STEP';\nconst PREVIOUS_STEP = 'PREVIOUS_STEP';\nconst UPDATE_FIELD = 'UPDATE_FIELD';\n\n// Define initial state\nconst initialState = {\n    step: 1,\n    formData: {\n        name: '',\n        email: '',\n        address: '',\n        age: ''\n    }\n};\n\n// Define reducer function\nfunction formReducer(state, action) {\n    switch (action.type) {\n        case NEXT_STEP:\n            return { ...state, step: state.step + 1 };\n        case PREVIOUS_STEP:\n            return { ...state, step: state.step - 1 };\n        case UPDATE_FIELD:\n            return {\n                ...state,\n                formData: { ...state.formData, [action.payload.name]: action.payload.value }\n            };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction MultiStepFormWithReducer() {\n    const [state, dispatch] = useReducer(formReducer, initialState);\n\n    const handleChange = (e) =&gt; {\n        dispatch({ type: UPDATE_FIELD, payload: { name: e.target.name, value: e.target.value } });\n    };\n\n    const handleNextStep = () =&gt; dispatch({ type: NEXT_STEP });\n    const handlePreviousStep = () =&gt; dispatch({ type: PREVIOUS_STEP });\n\n    return (\n        &lt;div&gt;\n            {state.step === 1 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 1: Personal Info&lt;/h1&gt;\n                    &lt;input name=\"name\" value={state.formData.name} onChange={handleChange} placeholder=\"Name\" /&gt;\n                    &lt;input name=\"email\" value={state.formData.email} onChange={handleChange} placeholder=\"Email\" /&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {state.step === 2 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 2: Address&lt;/h1&gt;\n                    &lt;input name=\"address\" value={state.formData.address} onChange={handleChange} placeholder=\"Address\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {state.step === 3 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 3: Age&lt;/h1&gt;\n                    &lt;input name=\"age\" value={state.formData.age} onChange={handleChange} placeholder=\"Age\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={() =&gt; alert('Form Submitted')}&gt;Submit&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default MultiStepFormWithReducer;\n</code></pre>"},{"location":"hooks/useReducer-example/#benefits-of-usereducer-in-this-scenario","title":"Benefits of useReducer in This Scenario","text":"<ul> <li>Structured State Management: All state transitions are handled in a single reducer function, making it easier to manage and understand the state logic.</li> <li>Clear Actions: Each action (<code>NEXT_STEP</code>, <code>PREVIOUS_STEP</code>, <code>UPDATE_FIELD</code>) is handled in a predictable way, simplifying debugging and maintenance.</li> <li>Scalability: Adding more steps or fields involves updating the reducer and actions, rather than adding more individual state updates.</li> </ul> <p>In summary, <code>useReducer</code> is best used when you have complex state logic, multiple actions, or need to manage large and interconnected pieces of state. It provides a more organized and scalable approach compared to <code>useState</code> in such scenarios.</p>"},{"location":"hooks/useReducer-with-api/","title":"useReducer with API","text":""},{"location":"hooks/useReducer-with-api/#overview","title":"Overview","text":"<p><code>useReducer</code> itself does not handle API calls or any side effects directly. It is solely focused on managing state changes within your component based on dispatched actions. However, you can use <code>useReducer</code> in combination with <code>useEffect</code> (or other side effect management techniques) to handle API calls or perform other side effects in your React components.</p>"},{"location":"hooks/useReducer-with-api/#combining-usereducer-with-useeffect","title":"Combining <code>useReducer</code> with <code>useEffect</code>","text":"<p>Here\u2019s how you can use <code>useReducer</code> to manage the state and <code>useEffect</code> to perform API calls:</p> <ol> <li>State Management with <code>useReducer</code>: Manage the local state transitions within your component.</li> <li>Fetching Data with <code>useEffect</code>: Perform API calls or other side effects based on the component's lifecycle or state changes.</li> </ol>"},{"location":"hooks/useReducer-with-api/#example-fetching-data-from-an-api","title":"Example: Fetching Data from an API","text":"<p>Let\u2019s say you have a component that fetches a list of users from an API. You want to handle loading, success, and error states using <code>useReducer</code>.</p> ExampleExplanationOther Considerations <pre><code>import React, { useReducer, useEffect } from 'react';\n\n// Define action types\nconst FETCH_REQUEST = 'FETCH_REQUEST';\nconst FETCH_SUCCESS = 'FETCH_SUCCESS';\nconst FETCH_FAILURE = 'FETCH_FAILURE';\n\n// Define initial state\nconst initialState = {\n    loading: false,\n    data: [],\n    error: null\n};\n\n// Define reducer function\nfunction reducer(state, action) {\n    switch (action.type) {\n        case FETCH_REQUEST:\n            return { ...state, loading: true, error: null };\n        case FETCH_SUCCESS:\n            return { ...state, loading: false, data: action.payload };\n        case FETCH_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction UserList() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        const fetchData = async () =&gt; {\n            dispatch({ type: FETCH_REQUEST });\n\n            try {\n                const response = await fetch('https://jsonplaceholder.typicode.com/users');\n                const data = await response.json();\n                dispatch({ type: FETCH_SUCCESS, payload: data });\n            } catch (error) {\n                dispatch({ type: FETCH_FAILURE, payload: error.message });\n            }\n        };\n\n        fetchData();\n    }, []); // Empty dependency array means this runs once on component mount\n\n    const { loading, data, error } = state;\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User List&lt;/h1&gt;\n            &lt;ul&gt;\n                {data.map(user =&gt; (\n                    &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default UserList;\n</code></pre> <ol> <li> <p>Reducer: The reducer handles three action types:</p> <ul> <li><code>FETCH_REQUEST</code>: Sets the loading state to <code>true</code> and clears any previous errors.</li> <li><code>FETCH_SUCCESS</code>: Updates the state with the fetched data and sets loading to <code>false</code>.</li> <li><code>FETCH_FAILURE</code>: Sets the error state and stops loading.</li> </ul> </li> <li> <p>Effect Hook: <code>useEffect</code> is used to perform the API call when the component mounts (empty dependency array). It dispatches actions based on the success or failure of the API call.</p> </li> <li> <p>Component Logic: Displays loading, error, or data based on the current state managed by <code>useReducer</code>.</p> </li> </ol> <ul> <li> <p>Handling Side Effects: For more complex scenarios or if side effects need to be managed differently, you might consider using libraries like <code>react-query</code>, <code>redux-thunk</code>, or <code>redux-saga</code>, which offer advanced solutions for handling side effects in conjunction with state management.</p> </li> <li> <p>Separation of Concerns: Using <code>useReducer</code> to manage state and <code>useEffect</code> to handle side effects helps maintain a clear separation of concerns, making your code easier to understand and maintain.</p> </li> </ul> <p>In summary, while <code>useReducer</code> doesn't handle API calls directly, it can be effectively combined with <code>useEffect</code> to manage state transitions based on the results of API calls or other side effects.</p>"},{"location":"hooks/useReducer/","title":"useReducer","text":"<p><code>useReducer</code> is a React Hook that is used to manage complex state logic in functional components. It is an alternative to <code>useState</code>, providing more control over state updates and handling complex state transitions more cleanly.</p>"},{"location":"hooks/useReducer/#overview","title":"Overview","text":""},{"location":"hooks/useReducer/#what-is-usereducer","title":"What is <code>useReducer</code>?","text":"<p><code>useReducer</code> is a Hook that helps manage state in a React component by providing a way to handle complex state logic. It works similarly to a reducer function in Redux, where you define how your state updates in response to various actions.</p>"},{"location":"hooks/useReducer/#how-does-it-work","title":"How does it work?","text":"<p><code>useReducer</code> takes two arguments:</p> <ol> <li> <p>Reducer Function: A function that determines how the state changes based on the action dispatched. It takes the current state and an action object, then returns the new state.</p> <pre><code>function reducer(state, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n</code></pre> </li> <li> <p>Initial State: The initial state of your component.</p> <pre><code>const initialState = { count: 0 };\n</code></pre> </li> </ol> <p>The <code>useReducer</code> hook returns an array with two elements:</p> <ol> <li>Current State: The current state of your component.</li> <li> <p>Dispatch Function: A function that you call with an action to trigger a state update.</p> <pre><code>const [state, dispatch] = useReducer(reducer, initialState);\n</code></pre> </li> </ol> Why do we need useReducer?When to use useReducer?What problem does it solve? <p><code>useReducer</code> is useful when:</p> <ol> <li> <p>Complex State Logic: If you have a component with complex state transitions, <code>useReducer</code> can make it easier to manage compared to multiple <code>useState</code> calls. It centralizes the state logic in one place.</p> </li> <li> <p>Multiple State Variables: When you have multiple related state variables that need to be updated together, <code>useReducer</code> helps manage them more coherently.</p> </li> <li> <p>Predictable State Updates: It enforces a clear pattern for how state updates occur, which can improve maintainability and debugability.</p> </li> <li> <p>State Transitions Based on Actions: If your state updates based on specific actions (like in a Redux-like setup), <code>useReducer</code> aligns well with this pattern.</p> </li> </ol> <ul> <li>When state updates are dependent on complex logic or multiple actions.</li> <li>When the state is an object and you need to update specific fields.</li> <li>When you want to centralize state management and make it easier to trace how state changes.</li> </ul> <ul> <li>Complex State Logic: Simplifies and organizes state transitions, making the component easier to understand and maintain.</li> <li>Centralized State Management: Provides a single location (the reducer function) for handling all state updates, which can be easier to manage than scattering state logic across multiple <code>useState</code> calls.</li> <li>Predictable Updates: Ensures that state updates are predictable and consistent, improving the reliability of the component.</li> </ul>"},{"location":"hooks/useReducer/#explain-to-5-years-old","title":"Explain to 5 years old","text":""},{"location":"hooks/useReducer/#question-1","title":"Question 1","text":"<p>explain useReducer to 5 years old</p> <p>Okay! Let's imagine you have a toy that needs to be fixed or changed in different ways. We\u2019ll use a simple story to explain useReducer.</p> <p>The Toy Box</p> <ol> <li> <p>Your Toy Box: Imagine you have a toy box where you keep your toys. This toy box can look different depending on how you play with it. Sometimes you want to put toys in, sometimes you want to take toys out, or maybe you want to tidy it up.</p> </li> <li> <p>Toy Fixer: You have a special toy fixer who knows exactly how to make changes to your toy box. This toy fixer listens to what you want and then decides how to change the toy box.</p> </li> </ol> <p>How It Works:</p> <ol> <li> <p>What You Want: When you tell the toy fixer what you want (like putting in a new toy or taking one out), you\u2019re giving it a \u201cmessage\u201d or \u201caction.\u201d For example, you might say, \u201cPut a teddy bear in the box\u201d or \u201cTake out the truck.\u201d</p> </li> <li> <p>Fixing the Toy Box: The toy fixer reads your message and knows exactly how to change the toy box. It uses a set of rules to make the changes, like if you say \u201cAdd a teddy bear,\u201d it puts the teddy bear in the box.</p> </li> <li> <p>New Look: After the toy fixer does its job, the toy box looks different, with the teddy bear now inside or the truck taken out.</p> </li> </ol> <p>In Simple Steps:</p> <ol> <li>Tell What You Want: You give a message to the toy fixer (like \u201cAdd a toy\u201d).</li> <li>Toy Fixer Makes Changes: The toy fixer reads the message and changes the toy box accordingly.</li> <li>New Toy Box: Now your toy box looks just the way you wanted it!</li> </ol> <p>In code, <code>useReducer</code> is like that toy fixer. It helps us manage changes to our \u201ctoy box\u201d (which is our state) by following rules and handling messages (actions) to update things correctly.</p>"},{"location":"hooks/useReducer/#question-2","title":"Question 2","text":"<p>now explain to 5 years old, when to use useState and useReducer.</p> <p>Sure! Let\u2019s think about <code>useState</code> and <code>useReducer</code> using simple toys and games.</p> useStateuseReducer <p>Imagine you have a box of crayons, and you only have a few crayons. You want to keep track of how many crayons you have, and it\u2019s pretty easy because you don\u2019t have too many.</p> <ol> <li>Counting Crayons: When you want to know how many crayons you have, you just look in the box.</li> <li>Adding Crayons: If you get a new crayon, you just add it to the box.</li> <li>Simple and Easy: It\u2019s easy to keep track because you only have a few crayons and it\u2019s not complicated.</li> </ol> <p>When to use <code>useState</code>: You use useState when you have something simple, like counting your crayons. It\u2019s easy and quick to manage because you don\u2019t have too many things to keep track of.</p> <p>Now, let\u2019s say you have a big toy box with lots of different toys. Some toys need to be fixed, some need to be put away, and some need to be cleaned. It\u2019s more complicated because you have different kinds of toys and many actions to handle.</p> <ol> <li>Different Actions: You might want to put toys away, fix broken ones, or organize them in different ways.</li> <li>Toy Fixer: You need a special toy fixer who knows all the rules for changing the toy box, like how to handle each type of toy and what to do with them.</li> <li>More Organized: The toy fixer follows a set of rules to make sure everything is handled correctly, and your toy box stays organized even though it\u2019s more complicated.</li> </ol> <p>When to use <code>useReducer</code>: You use <code>useReducer</code> when you have a big toy box with lots of different toys and many things to manage. It helps you keep everything organized by following rules and handling different actions in a structured way.</p> <p>Summary</p> <ul> <li><code>useState</code> is like counting crayons in a simple way. It\u2019s easy and works well when you don\u2019t have a lot to manage.</li> <li><code>useReducer</code> is like having a toy fixer for a big toy box with many different toys and actions. It helps manage everything in a more organized way when things get more complicated.</li> </ul> <p>So, if you\u2019re just keeping track of a few things, use <code>useState</code>. If you have a lot of things and need to handle them in different ways, use <code>useReducer</code>.</p>"},{"location":"hooks/useRef/","title":"useRef","text":""},{"location":"hooks/useRef/#useref-hooks","title":"useRef hooks","text":"<p><code>useRef</code> is a React hook that provides a way to create a mutable object that persists across renders. It's commonly used to access and interact with a DOM element or to persist values across renders without causing re-renders.</p> <p>Here's a beginner's guide on how to use useRef in React:</p>"},{"location":"hooks/useRef/#basic-usage","title":"Basic Usage:","text":"<ol> <li> <p>Import <code>useRef</code>:</p> <p>Import the useRef hook from React.</p> <pre><code>import React, { useRef } from \"react\";\n</code></pre> </li> <li> <p>Create a Ref:</p> <p>Use useRef() to create a ref object.</p> <pre><code>const myRef = useRef();\n</code></pre> </li> <li> <p>Attach Ref to a JSX Element:</p> <p>Attach the ref to a JSX element using the <code>ref</code> attribute.</p> <pre><code>return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n</code></pre> </li> <li> <p>Accessing the DOM Element:</p> <p>Use the <code>.current</code> property of the ref object to access the DOM element.</p> <pre><code>console.log(myRef.current); // Outputs the DOM element\n</code></pre> </li> </ol>"},{"location":"hooks/useRef/#example-with-a-functional-component","title":"Example with a Functional Component:","text":"<pre><code>import React, { useRef, useEffect } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const myRef = useRef();\n\n  useEffect(() =&gt; {\n    // Access the DOM element after the component is mounted\n    console.log(myRef.current);\n  }, []); // Empty dependency array ensures the effect runs only once after mount\n\n  return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"hooks/useRef/#use-cases-and-when-to-use-useref","title":"Use Cases and When to Use useRef:","text":"<ol> <li> <p>Accessing or Modifying DOM Elements:</p> <ul> <li>Use <code>useRef</code> when you need to access or modify a DOM element directly. For example, focusing an input field, measuring an element, or triggering imperative animations.</li> </ul> <pre><code>const inputRef = useRef();\n\nuseEffect(() =&gt; {\n  inputRef.current.focus();\n}, []);\n</code></pre> </li> <li> <p>Holding Mutable Values Without Causing Rerenders:</p> <ul> <li><code>useRef</code> can hold mutable values that persist across renders without causing re-renders. This is useful for storing values that shouldn't trigger component updates.</li> </ul> <pre><code>const countRef = useRef(0);\n\nuseEffect(() =&gt; {\n  countRef.current += 1;\n  console.log(\"Render count:\", countRef.current);\n});\n</code></pre> </li> <li> <p>Storing Previous Values:</p> <ul> <li>Use <code>useRef</code> to store and compare previous values, useful for certain scenarios like tracking changes in dependencies.</li> </ul> <pre><code>const prevValueRef = useRef();\nuseEffect(() =&gt; {\n  if (value !== prevValueRef.current) {\n    console.log(\"Value changed!\");\n  }\n  prevValueRef.current = value;\n}, [value]);\n</code></pre> <p>Remember that the ref value persists between renders, so changes to <code>.current</code> do not trigger a re-render. This makes <code>useRef</code> suitable for scenarios where you need to hold mutable values across renders without causing unnecessary updates.</p> </li> </ol>"},{"location":"hooks/custom/overview/","title":"Overview","text":""},{"location":"hooks/custom/overview/#custom-hooks-overview","title":"Custom Hooks Overview","text":"<p><code>npm install @welldone-software/why-did-you-render</code></p> <pre><code>import React, { useRef, useEffect } from \"react\";\n\nfunction useRenderCount() {\n  const count = useRef(0);\n\n  useEffect(() =&gt; {\n    count.current += 1;\n  });\n\n  return count.current;\n}\n\nfunction MyComponent() {\n  const renderCount = useRenderCount();\n\n  return &lt;div&gt;Render count: {renderCount}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"hooks/custom/overview/#example-1-custom-hook-returning-a-single-value","title":"Example 1: Custom Hook Returning a Single Value","text":"<p>Hook: <code>useWindowWidth</code></p> <p>This hook returns only the current window width as a single value.</p> <pre><code>import { useState, useEffect } from \"react\";\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() =&gt; {\n    function handleResize() {\n      setWidth(window.innerWidth);\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () =&gt; window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return width; // Single value returned\n}\n</code></pre> <p>Usage:</p> <pre><code>function MyComponent() {\n  const width = useWindowWidth();\n\n  return &lt;div&gt;Window width is: {width}px&lt;/div&gt;;\n}\n</code></pre>"},{"location":"hooks/custom/overview/#example-2-custom-hook-returning-multiple-values","title":"Example 2: Custom Hook Returning Multiple Values","text":"<p>Hook: <code>useCounter</code></p> <p>This hook manages a counter state and returns both the current count and functions to modify it.</p> <pre><code>import { useState } from \"react\";\n\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = () =&gt; setCount((c) =&gt; c + 1);\n  const decrement = () =&gt; setCount((c) =&gt; c - 1);\n  const reset = () =&gt; setCount(initialValue);\n\n  // Returning multiple values as an object\n  return { count, increment, decrement, reset };\n}\n</code></pre> <p>Usage:</p> <pre><code>function CounterComponent() {\n  const { count, increment, decrement, reset } = useCounter(10);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;+1&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;-1&lt;/button&gt;\n      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"hooks/custom/overview/#summary","title":"Summary","text":"Example Return Type What is returned <code>useWindowWidth</code> Single value Current window width (number) <code>useCounter</code> Object Count state and functions to update it"},{"location":"hooks/memo/overview/","title":"Overview","text":""},{"location":"hooks/memo/overview/#overview","title":"Overview","text":"<p>Let\u2019s briefly walk through how React.memo works. When an update happens in React, your component is compared with the results of the vDOM returned from its previous render. If these results are different\u2014i.e., if its props change\u2014the reconciler runs an update effect if the element already exists in the host environment (usually the browser DOM), or a placement effect if it doesn\u2019t. If its props are the same, the component still rerenders and the DOM is still updated.</p> <p>This is what React.memo is good for: avoiding unnecessary rerenders when a component\u2019s props are identical between renders. Since we can do this in React, it begs the question: how much and how often should we memoize stuff? Surely if we memoize every component, our application might be faster overall, no?</p>"},{"location":"hooks/memo/overview/#memoized-components-that-still-rerender","title":"Memoized Components That Still Rerender","text":"<p><code>React.memo</code> performs what is called a shallow comparison of the props to determine whether they\u2019ve changed or not. The problem with this is while scalar types can be compared quite accurately in JavaScript, nonscalars cannot.</p> <p>To have a high-quality discussion, let\u2019s break down briefly what scalar and nonscalar types are, and how they behave in comparison operations.</p>"},{"location":"hooks/memo/overview/#scalars-primitive-types","title":"Scalars (primitive types)","text":"<p>Scalar types, also known as primitive types, are foundational. These types represent singular, indivisible values. Unlike more complex data structures like arrays and objects, scalars do not possess properties or methods, and they are immutable by nature.</p> <p>This means that once a scalar value is set, it cannot be altered without creating a completely new value. JavaScript has several scalar types, including numbers, strings, booleans, and others like symbols, BigInts, undefined, and null. Each of these types serves a unique purpose. For instance, while numbers are self-explanatory, symbols provide a way to create unique identifiers, and undefined and null allow developers to represent the absence of a value in different contexts. When comparing scalar values, we\u2019re often interested in their actual content or value.</p>"},{"location":"hooks/memo/overview/#nonscalars-reference-types","title":"Nonscalars (reference types)","text":"<p>Moving beyond the simplicity of scalars, we encounter nonscalar or reference types.</p> <p>These types don\u2019t store data, but rather a reference or a pointer to where the data is stored in memory. This distinction is crucial because it impacts how these types are compared, manipulated, and interacted with in code. In JavaScript, the most common nonscalar types are objects and arrays. Objects allow us to store structured data with key-value pairs, while arrays provide ordered collections. Functions, too, are considered reference types in JavaScript.</p> <p>A key characteristic of nonscalars is that multiple references can point to the same memory location.</p> <p>This means that modifying data through one reference can impact other references pointing to the same data. When it comes to comparison, nonscalar types are compared by their memory reference, not by their content. This can sometimes lead to unexpected results for those not familiar with this nuance. For example, two arrays with identical content but different memory locations will be considered unequal when compared using the strict equality operator.</p> <p>Consider the following example:</p> <pre><code>// Scalar types\n\"a\" === \"a\"; // string; true\n3 === 3; // number; true\n// Non-scalar types\n[1, 2, 3] === [1, 2, 3]; // array; false\n{ foo: \"bar\"} === { foo: \"bar\" } // object; false\n</code></pre> <p>With this array comparison, the <code>arrays</code>, <code>objects</code>, and other nonscalar types are compared by reference: as in, does the lefthand-side array\u2019s reference to its position in the computer\u2019s memory equal the righthand-side\u2019s memory location. This is why the comparison returns false. The same is true for objects.</p> <p>What we\u2019re doing with the object comparison is creating two different objects in memory on the lefthand side and the righthand side\u2014of course they\u2019re not equal, they\u2019re two different objects that live in two different places in memory! They just have the same content.</p>"},{"location":"hooks/memo/overview/#reference","title":"Reference","text":"<ul> <li>Fluent react</li> </ul>"},{"location":"package/intro/","title":"Intro","text":""},{"location":"package/intro/#overview","title":"Overview","text":"<p>Utility Libraries</p> Library Icon Description Lodash \ud83d\udee0\ufe0f A utility library for working with arrays, objects, and functions. Date-fns \ud83d\udcc5 A modern, lightweight library for date manipulation. Classnames \u2728 A utility for conditionally joining CSS class names. React-Icons \ud83d\udd32 A library for using icons from popular icon sets like Font Awesome, Material Design, etc., as React components. Axios \ud83c\udf10 A promise-based HTTP client for making API requests. Tip <p>JavaScript utility libraries commonly used in React development.</p> <ul> <li> <p>lodash:</p> <p><code>Lodash</code> is a widely used utility library in the JavaScript ecosystem, and it provides a comprehensive set of functions for working with arrays, objects, strings, and more.</p> </li> </ul> Tip <pre><code>// 1. Installation\nnpm install lodash\n\n// 2. Importing\nimport _ from 'lodash'; // Import the entire library\n// or\nimport { map, filter, debounce } from 'lodash'; // Import specific functions\n\n// Example Debounce\nimport _ from 'lodash';\n\nconst debouncedFunction = _.debounce((value) =&gt; {\nconsole.log('Debounced:', value);\n}, 300);\n</code></pre> <ul> <li> <p>Underscore.js:</p> <p><code>Underscore.js</code> is similar to Lodash and provides a set of utility functions for working with arrays, objects, functions, and more. It predates Lodash and served as an inspiration for it.</p> </li> <li> <p>axios:</p> <p><code>axios</code> is a promise-based HTTP client that simplifies making HTTP requests. It is commonly used for handling API requests in React applications.</p> </li> <li> <p>React Query:</p> <p><code>React Query</code> is a library for managing, caching, and synchronizing data in React applications. It provides hooks for fetching and updating data with a focus on simplicity and performance.</p> </li> <li> <p>Ramda:</p> <p><code>Ramda</code> is a functional programming library that focuses on immutability and functional composition. It provides functions for functional programming paradigms and is suitable for projects that adopt a more functional style.</p> </li> <li> <p>Immer:</p> <p><code>Immer</code> is a library that simplifies state management by enabling a more convenient way to work with immutable data structures. It is often used in combination with React's state to make state updates more concise.</p> </li> </ul> Useful React Libraries for Projects <ol> <li>React-Konva</li> <li>React-Gesture-Handler</li> <li>React-Flip-Move</li> <li>React-Virtualized</li> <li>React-Toastify</li> <li>React-Page-Transition</li> <li>React 360</li> </ol> <ul> <li>Javascript Mastery</li> </ul>"},{"location":"package/intro/#categorized","title":"Categorized","text":"<p>React packages can be categorized into several broad types based on their purpose and functionality within a React application. Here\u2019s a categorization of common React packages:</p> <ol> <li> <p>Core React Libraries</p> <p>These are essential packages for working with React and managing its state, lifecycle, and rendering.</p> <ul> <li><code>react</code>: The core library for building React components.</li> <li><code>react-dom</code>: Provides methods for rendering React components to the DOM.</li> <li><code>react-scripts</code>: Scripts and configuration used by Create React App (CRA) to set up a React project.</li> <li><code>react-router-dom</code>: For routing in React applications, allowing navigation between different views or pages.</li> <li><code>react-redux</code>: A state management library that integrates Redux with React.</li> </ul> </li> <li> <p>State Management</p> <p>These packages help manage state in a React application, ranging from simple local state to global state management.</p> <ul> <li><code>redux</code>: A predictable state container for JavaScript apps (often used in React applications).</li> <li><code>@reduxjs/toolkit</code>: The official, recommended library for writing Redux logic with minimal boilerplate.</li> <li><code>recoil</code>: A state management library for React with a focus on atoms and selectors.</li> <li><code>mobx</code>: A library that makes state management simple and scalable by using observables.</li> <li><code>zustand</code>: A small, fast state management library that can be used as an alternative to Redux.</li> <li><code>valtio</code>: Proxy-based state management with minimal boilerplate.</li> </ul> </li> <li> <p>UI Component Libraries</p> <p>These libraries provide pre-built React components for UI development, saving time on designing and styling.</p> <ul> <li> <p><code>material-ui</code> (now @mui/material): A popular UI framework with a Material Design system.</p> </li> <li> <p><code>react-bootstrap</code>: React components for Bootstrap.</p> </li> <li><code>semantic-ui-react</code>: React components for Semantic UI.</li> <li><code>ant-design</code>: A design system with a set of high-quality React components.</li> <li><code>chakra-ui</code>: A modular and accessible component library for building React apps.</li> <li><code>tailwindcss</code> (with @tailwindcss/forms, @tailwindcss/typography): Utility-first CSS framework often used with React for styling.</li> </ul> </li> <li> <p>Form Handling</p> <p>These packages simplify form management, validation, and state management in React applications.</p> <ul> <li><code>react-hook-form</code>: A performant, flexible, and extensible form library for React.</li> <li><code>formik</code>: A popular library for building forms in React, with validation and state management.</li> <li><code>react-final-form</code>: Another form management library for React, providing a simple API for form state management.</li> <li><code>yup</code>: A JavaScript schema validator, often used in conjunction with form libraries like formik or react-hook-form.</li> </ul> </li> <li> <p>Testing and Debugging</p> <p>Packages for testing React components and debugging during development.</p> <ul> <li><code>jest</code>: A JavaScript testing framework often used with React to test components and logic.</li> <li><code>react-testing-library</code>: A library for testing React components in a way that focuses on user interactions and behavior rather than implementation details.</li> <li><code>enzyme</code>: A testing utility for React that allows for shallow rendering and full DOM rendering (less common today, as React Testing Library is preferred).</li> <li><code>msw</code> (Mock Service Worker): A library for mocking network requests in frontend tests.</li> <li><code>why-did-you-render</code>: A library for identifying unnecessary re-renders in React applications.</li> </ul> </li> <li> <p>Performance Optimization</p> <p>Packages that help optimize the performance of React apps.</p> <ul> <li><code>react-query</code> (now @tanstack/react-query): A data-fetching and caching library for React to handle server-state and make applications faster.</li> <li><code>react-window</code>: A library for efficiently rendering large lists and tabular data by rendering only the visible items.</li> <li><code>react-virtualized</code>: Similar to react-window, this library optimizes the rendering of large data sets by only rendering visible items in a list/grid.</li> <li><code>reselect</code>: A selector library used with Redux to memoize derived state and prevent unnecessary recalculations.</li> </ul> </li> <li> <p>Animation Libraries</p> <p>These packages help create smooth animations and transitions in React applications.</p> <ul> <li><code>framer-motion</code>: A popular library for creating animations and gestures in React.</li> <li><code>react-spring</code>: A physics-based animation library for React that\u2019s used to create interactive, smooth animations.</li> <li><code>react-transition-group</code>: A simple API for animations and transitions in React.</li> </ul> </li> <li> <p>Utility Libraries</p> <p>These are general-purpose utility libraries that provide functionality beyond React-specific code.</p> <ul> <li><code>lodash</code>: A utility library for working with arrays, objects, and functions.</li> <li><code>date-fns</code>: A modern, lightweight library for date manipulation.</li> <li><code>classnames</code>: A utility for conditionally joining CSS class names.</li> <li><code>react-icons</code>: A library for using icons from popular icon sets like Font Awesome, Material Design, etc., as React components.</li> <li><code>axios</code>: A promise-based HTTP client for making API requests.</li> </ul> </li> <li> <p>Internationalization (i18n)</p> <p>These packages help with translating and managing multiple languages in React apps.</p> <ul> <li><code>react-i18next</code>: A powerful internationalization framework for React based on i18next.</li> <li><code>formatjs</code>: A collection of libraries for formatting dates, numbers, and currencies, and handling translations.</li> </ul> </li> <li> <p>Build Tools and Development Utilities</p> <p>These are tools and utilities that assist with development and build processes in React.</p> <ul> <li><code>webpack</code>: A module bundler often used with React for bundling JavaScript, CSS, and other assets.</li> <li><code>babel</code>: A JavaScript compiler that\u2019s typically used with React for transpiling JSX and ES6+ code.</li> <li><code>eslint</code>: A static code analysis tool for identifying issues in JavaScript and JSX code.</li> <li><code>prettier</code>: A code formatter for consistent styling in React and other codebases.</li> </ul> </li> <li> <p>Server-Side Rendering (SSR) &amp; Static Site Generation (SSG)</p> <p>Packages for enabling SSR or SSG in React applications.</p> <ul> <li><code>next.js</code>: A React framework for server-side rendering, static site generation, and more.</li> <li><code>gatsby</code>: A React-based static site generator with powerful features for building static websites.</li> <li><code>react-helmet</code>: A library for managing the document head (meta tags, title, etc.) in a React app.</li> <li><code>react-snap</code>: A tool for pre-rendering React apps for static site generation.</li> </ul> </li> <li> <p>Mobile Development (React Native)</p> <p>These libraries are used specifically for React Native, which is for building mobile apps.</p> <ul> <li><code>react-native</code>: The core library for building mobile apps with React.</li> <li><code>react-navigation</code>: A navigation library for React Native.</li> <li><code>react-native-reanimated</code>: A library for building animations in React Native.</li> <li><code>react-native-gesture-handler</code>: A library for handling gestures in React Native applications.</li> </ul> </li> <li> <p>Miscellaneous/Other</p> <p>Packages that serve various other purposes in React development.</p> <ul> <li><code>react-error-boundary</code>: A higher-order component for handling JavaScript errors in React components.</li> <li><code>react-query-builder</code>: A component for building dynamic query interfaces in React.</li> <li><code>react-dropzone</code>: A React component for handling file uploads with drag-and-drop support.</li> </ul> </li> </ol> <p>These are some of the most commonly used categories and libraries in the React ecosystem. Each library often serves a specific purpose, and choosing the right one depends on the needs of your project.</p>"},{"location":"package/intro/#libraries","title":"Libraries","text":"<p>Certainly! Here\u2019s a categorized list of popular UI libraries for React, along with their use cases to help you determine when to use each one:</p> <ol> <li> <p>Component Libraries</p> <p>Ant Design</p> <ul> <li>When to Use: Ideal for enterprise-level applications with a design system. It offers a comprehensive suite of components and a well-defined aesthetic.</li> </ul> <p>Material-UI (MUI)</p> <ul> <li>When to Use: Best for applications that require a modern, material design aesthetic. Great for mobile-friendly designs and responsive layouts.</li> </ul> <p>Bootstrap (React-Bootstrap)</p> <ul> <li>When to Use: Suitable for projects that need a quick and familiar design. Good for responsive layouts and when you want to use Bootstrap\u2019s grid system.</li> </ul> <p>Chakra UI</p> <ul> <li>When to Use: Excellent for building accessible applications. It provides a set of composable components with built-in accessibility features.</li> </ul> </li> <li> <p>Design Systems</p> <p>Storybook</p> <ul> <li>When to Use: Not a UI library but a development tool for building UI components in isolation. Great for documenting and testing components.</li> </ul> <p>Blueprint</p> <ul> <li>When to Use: Designed for complex, data-dense interfaces. Suitable for desktop applications and when you need a lot of input fields and complex forms.</li> </ul> <p>Grommet</p> <ul> <li>When to Use: Good for building responsive and accessible applications. It offers a rich set of components with a focus on mobile-first design.</li> </ul> </li> <li> <p>Styling Libraries</p> <p>Styled Components</p> <ul> <li>When to Use: Perfect for styling React components with a CSS-in-JS approach. Useful for creating dynamic styles based on props.</li> </ul> <p>Emotion</p> <ul> <li>When to Use: Similar to Styled Components, it offers a flexible and performant way to style applications. Good for theming and styled components.</li> </ul> <p>Tailwind CSS</p> <ul> <li>When to Use: Ideal for utility-first styling, where you want to build custom designs without leaving your HTML. Great for rapid prototyping.</li> </ul> </li> <li> <p>Mobile UI Libraries</p> <p>React Native Elements</p> <ul> <li>When to Use: Useful for building mobile applications with a consistent design. Offers a wide range of cross-platform components.</li> </ul> <p>NativeBase</p> <ul> <li>When to Use: Ideal for building mobile apps that require a native look and feel. It includes components that work on both Android and iOS.</li> </ul> </li> <li> <p>Animation Libraries</p> <p>Framer Motion</p> <ul> <li>When to Use: Great for adding animations and transitions to React components. Perfect for interactive UIs that require smooth animations.</li> </ul> <p>React Spring</p> <ul> <li>When to Use: Ideal for physics-based animations. Suitable for applications that require more natural motion effects.</li> </ul> </li> <li> <p>Form Libraries</p> <p>Formik</p> <ul> <li>When to Use: Excellent for handling complex forms with validation. Ideal for managing form state and validation seamlessly.</li> </ul> <p>React Hook Form</p> <ul> <li>When to Use: Great for lightweight forms and performance-sensitive applications. It allows easy integration with UI libraries and validation.</li> </ul> </li> </ol> <p>Conclusion</p> <p>Choosing the right UI library depends on your project requirements, team familiarity, and design goals. Understanding the strengths and use cases of each library will help you make informed decisions and create effective, user-friendly applications.</p>"},{"location":"package/intro/#types-of-website-to-use-libraries","title":"Types of website to use Libraries","text":"<p>Here\u2019s a list of popular React component libraries categorized by the type of website or application you might build. This will help you choose the right library based on your project needs.</p>"},{"location":"package/intro/#1-enterprise-applications","title":"1. Enterprise Applications","text":"<p>Ant Design</p> <ul> <li>Type of Website: Enterprise-level applications, admin dashboards, and complex data-heavy interfaces.</li> <li>Use Cases: Management systems, CRM tools, and data visualization.</li> </ul> <p>Blueprint</p> <ul> <li>Type of Website: Complex desktop applications and data-dense interfaces.</li> <li>Use Cases: Financial applications, analytics dashboards, and enterprise software.</li> </ul>"},{"location":"package/intro/#2-e-commerce-websites","title":"2. E-commerce Websites","text":"<p>Material-UI (MUI)</p> <ul> <li>Type of Website: E-commerce platforms and retail websites.</li> <li>Use Cases: Product listings, shopping carts, and customer accounts.</li> </ul> <p>Chakra UI</p> <ul> <li>Type of Website: User-friendly e-commerce sites focused on accessibility.</li> <li>Use Cases: Online stores that prioritize responsive design and accessibility.</li> </ul>"},{"location":"package/intro/#3-blogs-and-content-management-systems","title":"3. Blogs and Content Management Systems","text":"<p>Grommet</p> <ul> <li>Type of Website: Blogs, personal websites, and content management systems.</li> <li>Use Cases: Simple content-focused layouts with responsive design.</li> </ul> <p>Semantic UI React</p> <ul> <li>Type of Website: Content-rich websites and blogs.</li> <li>Use Cases: Simple, clean designs for articles and posts.</li> </ul>"},{"location":"package/intro/#4-social-media-platforms","title":"4. Social Media Platforms","text":"<p>React Bootstrap</p> <ul> <li>Type of Website: Social media applications and networking platforms.</li> <li>Use Cases: User profiles, feeds, and messaging systems.</li> </ul> <p>Ant Design</p> <ul> <li>Type of Website: Social media or community-driven platforms with complex user interactions.</li> <li>Use Cases: Forums, discussion boards, and user dashboards.</li> </ul>"},{"location":"package/intro/#5-mobile-applications","title":"5. Mobile Applications","text":"<p>React Native Elements</p> <ul> <li>Type of Website: Mobile applications.</li> <li>Use Cases: Cross-platform mobile apps with a consistent design.</li> </ul> <p>NativeBase</p> <ul> <li>Type of Website: Mobile applications requiring a native look and feel.</li> <li>Use Cases: Apps for both iOS and Android with native components.</li> </ul>"},{"location":"package/intro/#6-dashboards-and-data-visualization","title":"6. Dashboards and Data Visualization","text":"<p>Recharts</p> <ul> <li>Type of Website: Data dashboards and visualization tools.</li> <li>Use Cases: Analytics platforms and reporting tools.</li> </ul> <p>Victory</p> <ul> <li>Type of Website: Customizable data visualization applications.</li> <li>Use Cases: Interactive charts and data-driven UIs.</li> </ul>"},{"location":"package/intro/#7-portfolio-and-personal-websites","title":"7. Portfolio and Personal Websites","text":"<p>Styled Components</p> <ul> <li>Type of Website: Personal portfolios and creative websites.</li> <li>Use Cases: Custom styling for unique designs and layouts.</li> </ul> <p>Framer Motion</p> <ul> <li>Type of Website: Interactive portfolios and personal sites.</li> <li>Use Cases: Smooth animations and transitions for engaging user experiences.</li> </ul>"},{"location":"package/intro/#conclusion","title":"Conclusion","text":"<p>Choosing the right component library depends on the type of website you are building and your specific requirements. Understanding the strengths of each library will help you create effective, user-friendly applications tailored to your audience's needs.</p>"},{"location":"package/animation/framer-motion/overview/","title":"Overview","text":""},{"location":"package/animation/react-transition-group/overview/","title":"Overview","text":""},{"location":"package/i18n/i18n/","title":"Intro","text":"<p>Tip</p> <ul> <li>Next.js: React framework</li> <li>styled-components: CSS styling</li> <li>apollographql: Data API</li> <li>authjs: Authentication</li> <li>React Testing Library and Jest: Testing</li> <li>GitHub: Version control</li> <li>Vercel: Serverless online web host</li> </ul>"},{"location":"package/i18n/i18n/#internationalization-and-localization","title":"Internationalization and localization","text":"<p>Internationalization and localization are basic practices in software development that enable you to design and deploy systems that can be tailored to multiple languages and areas. Let\u2019s learn the difference between them.</p>"},{"location":"package/i18n/i18n/#what-is-internationalization","title":"What is internationalization?","text":"<p>Internationalization is the process of creating and preparing your application so that it can potentially be used in several languages. This frequently entails extracting all of your application\u2019s strings into distinct files that can potentially be translated into multiple languages. It also requires structuring your software to ensure that it can correctly manage and show these translations.</p>"},{"location":"package/i18n/i18n/#what-is-localization","title":"What is localization?","text":"<p>This involves translating your locally optimized application into specific native languages. Translating an application\u2019s text is only one aspect of localization. It might also include other regionally unique elements, such as text direction, number forms, and date and time formats, among other things. React Router allows you to build localized routes. To manage language choice, you might, for instance, have several routes for various languages (such as \"<code>/en/about</code>\u201d and \"<code>/fr/about</code>\") or you can utilize a context or state.</p> <p>We have learned so much already and our knowledge has increased a lot. Next, we will move on to the penultimate section of this chapter, where we are going to learn all about adding translations and formatted messages in our React applications. We just learned about internationalization and localization, which is where we prepare our applications for different languages. Now, let\u2019s learn how to implement different languages in the code we write.</p>"},{"location":"package/i18n/react-i18next/overview/","title":"Overview","text":""},{"location":"package/miscellaneous/react-image-gallery/","title":"React Image Gallery","text":""},{"location":"package/miscellaneous/react-image-gallery/#overview","title":"Overview","text":"<p>Yes, there are several popular packages for handling images in React, each with different features and capabilities. Here are a few you might find useful:</p>"},{"location":"package/miscellaneous/react-image-gallery/#1-react-image","title":"1. React Image:","text":"<ul> <li>Package: react-image</li> <li>Features: This package provides a simple way to load images with a fallback for loading and error states.</li> <li>Installation:</li> </ul> <pre><code>npm install react-image\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { Img } from \"react-image\";\n\n&lt;Img\n  src={item.url}\n  style={{ height: \"200px\", width: \"200px\" }}\n  alt=\"Gallery\"\n  loader={&lt;span&gt;Loading...&lt;/span&gt;}\n  error={&lt;span&gt;Error loading image&lt;/span&gt;}\n/&gt;;\n</code></pre>"},{"location":"package/miscellaneous/react-image-gallery/#2-react-lazy-load-image-component","title":"2. React Lazy Load Image Component:","text":"<ul> <li>Package: react-lazy-load-image-component</li> <li>Features: This package allows you to lazy load images, which can improve performance for pages with many images.</li> <li>Installation:</li> </ul> <pre><code>npm install react-lazy-load-image-component\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { LazyLoadImage } from \"react-lazy-load-image-component\";\n\n&lt;LazyLoadImage\n  alt=\"Gallery\"\n  height={200}\n  src={item.url} // use normal src\n  width={200}\n  effect=\"opacity\"\n/&gt;;\n</code></pre>"},{"location":"package/miscellaneous/react-image-gallery/#3-react-image-gallery","title":"3. React Image Gallery:","text":"<ul> <li>Package: react-image-gallery</li> <li>Features: A flexible image gallery component with features like thumbnails, fullscreen mode, and more.</li> <li>Installation:</li> </ul> <pre><code>npm install react-image-gallery\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import ImageGallery from \"react-image-gallery\";\n\nconst images = gallery.map((item) =&gt; ({\n  original: item.url,\n  thumbnail: item.url,\n}));\n\n&lt;ImageGallery items={images} /&gt;;\n</code></pre>"},{"location":"package/miscellaneous/react-image-gallery/#4-cloudinary","title":"4. Cloudinary:","text":"<ul> <li>Package: cloudinary-react</li> <li>Features: If you're using Cloudinary for image storage and transformation, this package helps integrate with React.</li> <li>Installation:</li> </ul> <pre><code>npm install cloudinary-react\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { CloudinaryContext, Image } from \"cloudinary-react\";\n\n&lt;CloudinaryContext cloudName=\"your-cloud-name\"&gt;\n  &lt;Image publicId={item.publicId} height=\"200\" width=\"200\" /&gt;\n&lt;/CloudinaryContext&gt;;\n</code></pre>"},{"location":"package/miscellaneous/react-image-gallery/#summary","title":"Summary","text":"<p>Choose the package that best fits your use case based on your needs for loading, displaying, or managing images in your application. If you're just displaying images, <code>react-image</code> or <code>react-lazy-load-image-component</code> are great choices. For a gallery, <code>react-image-gallery</code> is excellent.</p>"},{"location":"package/miscellaneous/react-image-gallery/#additional","title":"Additional","text":"<p>LazyLoadImage</p> ExampleKey ChangesSummary <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport axios from \"axios\";\nimport { LazyLoadImage } from \"react-lazy-load-image-component\";\n\nconst Picture = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n\n        dispatch(getPhotosService(source.token));\n\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    console.log(\"gallery\", gallery);\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture&lt;/h1&gt;\n\n        {gallery &amp;&amp;\n            gallery.map((item) =&gt; (\n            &lt;LazyLoadImage\n                key={item.id}\n                alt=\"Gallery\"\n                height={200}\n                src={item.url} // use the item.url for the image source\n                width={200}\n                effect=\"opacity\" // this applies the fade-in effect\n            /&gt;\n            ))}\n        &lt;/&gt;\n    );\n};\n\nexport default Picture;\n</code></pre> <ol> <li>Use <code>LazyLoadImage</code>: Replace <code>LazyLoadComponent</code> with <code>LazyLoadImage</code>. The <code>LazyLoadImage</code> component is specifically designed for loading images lazily.</li> <li>Props on <code>LazyLoadImage</code>: The props such as key, <code>alt</code>, <code>height</code>, <code>src</code>, <code>width</code>, and effect should be passed directly to <code>LazyLoadImage</code>.</li> <li>Removed Unnecessary Code: Cleaned up the code for better readability.</li> </ol> <p>With these changes, your images should now load lazily, displaying them with a fade-in effect as they come into view. This approach helps improve the performance of your application, especially if you have many images to display.</p> <p>LazyLoadComponent</p> <p>The <code>LazyLoadComponent</code> is a wrapper component that should be used to wrap the actual image component, not directly used as an image itself.</p> <p>The <code>LazyLoadComponent</code> from the react-lazy-load-image-component package is used to lazily load components, not just images. It's ideal for wrapping any component that you want to load only when it enters the viewport. Here's how to properly use <code>LazyLoadComponent</code> in your code:</p> ExampleUsing <code>LazyLoadComponent</code>Key PointsAdditional Props <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport axios from \"axios\";\nimport { LazyLoadComponent } from \"react-lazy-load-image-component\";\n\nconst Picture = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n\n        dispatch(getPhotosService(source.token));\n\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    console.log(\"gallery\", gallery);\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture&lt;/h1&gt;\n\n        {gallery &amp;&amp;\n            gallery.map((item) =&gt; (\n            &lt;LazyLoadComponent key={item.id} effect=\"opacity\"&gt;\n                &lt;img\n                    src={item.url}\n                    alt=\"Gallery\"\n                    height=\"200\"\n                    width=\"200\"\n                /&gt;\n            &lt;/LazyLoadComponent&gt;\n            ))}\n        &lt;/&gt;\n    );\n};\n\nexport default Picture;\n</code></pre> <ol> <li>Wrap Your Component: Use <code>LazyLoadComponent</code> to wrap the components you want to load lazily.</li> <li>Children Prop: The <code>LazyLoadComponent</code> can have any children, so you can wrap images, text, or other components.</li> </ol> <ol> <li>Wrapping with <code>LazyLoadComponent</code>: Each image is wrapped with <code>LazyLoadComponent</code>. This component will handle lazy loading for the image inside it.</li> <li>Effect Prop: The effect <code>prop</code> is set to <code>\"opacity\"</code> to apply a fade-in effect when the image is loaded. You can change this to other effects like \"blur\" or use a custom CSS class.</li> <li>Usage of <code>img</code> Tag: Inside the <code>LazyLoadComponent</code>, you use a standard <code>img</code> tag to render the image.</li> </ol> <ul> <li>height and width: If you want to prevent layout shifts, you can specify <code>height</code> and <code>width</code> on the <code>LazyLoadComponent</code>.</li> <li>placeholder: You can also use a placeholder by adding a <code>placeholderSrc</code> prop, which can help maintain layout while the actual image is loading.</li> </ul> Conclusion <p>By using <code>LazyLoadComponent</code>, you can effectively reduce the initial loading time of your application and improve performance by loading images and other components only when they enter the viewport.</p>"},{"location":"package/miscellaneous/react-image-gallery/#when-to-use","title":"When to use","text":"<ul> <li>Use <code>LazyLoadComponent</code>: When you want to lazily load any React component (not just images), such as text, lists, or custom components.</li> <li>Use <code>LazyLoadImage</code>: When you specifically want to lazily load images with built-in optimizations and effects designed for images.</li> </ul> In summary <ul> <li><code>LazyLoadComponent</code> = for any component.</li> <li><code>LazyLoadImage</code> = specifically for images.</li> </ul>"},{"location":"package/miscellaneous/react-image-gallery/#lightbox","title":"Lightbox","text":"<p>To create a modal that displays an image with Next and Previous navigation options, you can use react-image-lightbox. This package makes it easy to implement a lightbox with image navigation.</p> InstallationExampleKey Features of the CodeConclusion <pre><code>npm install react-image-lightbox\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport \"react-image-lightbox/style.css\";\nimport Lightbox from \"react-image-lightbox\";\n\nconst PictureWithLightbox = ({ gallery }) =&gt; {\n    const [isOpen, setIsOpen] = useState(false);\n    const [currentImageIndex, setCurrentImageIndex] = useState(0);\n\n    const openLightbox = (index) =&gt; {\n        setCurrentImageIndex(index);\n        setIsOpen(true);\n    };\n\n    const goToPrevious = () =&gt; {\n        setCurrentImageIndex((prevIndex) =&gt;\n            prevIndex === 0 ? gallery.length - 1 : prevIndex - 1\n        );\n    };\n\n    const goToNext = () =&gt; {\n        setCurrentImageIndex((prevIndex) =&gt;\n            prevIndex === gallery.length - 1 ? 0 : prevIndex + 1\n        );\n    };\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Gallery&lt;/h1&gt;\n        &lt;div style={{ display: \"flex\", flexWrap: \"wrap\" }}&gt;\n            {gallery.map((item, index) =&gt; (\n                &lt;img\n                    key={item.id}\n                    src={item.url}\n                    alt=\"Gallery\"\n                    onClick={() =&gt; openLightbox(index)}\n                    style={{\n                    cursor: \"pointer\",\n                    height: \"200px\",\n                    width: \"200px\",\n                    margin: \"10px\",\n                    }}\n                /&gt;\n            ))}\n        &lt;/div&gt;\n\n        {isOpen &amp;&amp; (\n            &lt;Lightbox\n                mainSrc={gallery[currentImageIndex].url}\n                nextSrc={gallery[(currentImageIndex + 1) % gallery.length].url}\n                prevSrc={\n                    gallery[(currentImageIndex + gallery.length - 1) % gallery.length]\n                    .url\n                }\n                onCloseRequest={() =&gt; setIsOpen(false)}\n                onMovePrevRequest={goToPrevious}\n                onMoveNextRequest={goToNext}\n            /&gt;\n        )}\n        &lt;/&gt;\n    );\n};\n\nexport default PictureWithLightbox;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>isOpen</code>: Tracks whether the lightbox is open.</li> <li><code>currentImageIndex</code>: Stores the index of the currently displayed image.</li> </ul> </li> <li> <p>Open Lightbox:</p> <ul> <li>openLightbox(index): Sets the current image index and opens the lightbox.</li> </ul> </li> <li> <p>Navigation Functions:</p> <ul> <li><code>goToPrevious()</code>: Updates the index to show the previous image, wrapping around if at the beginning.</li> <li><code>goToNext()</code>: Updates the index to show the next image, wrapping around if at the end.</li> </ul> </li> <li> <p>Lightbox Component:</p> <ul> <li>Displays the current image and provides Next and Previous functionality with appropriate callbacks.</li> </ul> </li> </ol> <p>With this setup, you can click on any image in the gallery to open a modal with navigation options, allowing users to cycle through images seamlessly. This approach is user-friendly and provides a smooth viewing experience.</p>"},{"location":"package/miscellaneous/react-image-gallery/#reference","title":"Reference","text":"<ul> <li>react-lazy-load-image-component</li> <li>React Image Gallery</li> </ul>"},{"location":"package/miscellaneous/composition/imagegallery/","title":"Image Gallery","text":""},{"location":"package/miscellaneous/composition/imagegallery/#overview","title":"Overview","text":"<p>To make your <code>Picture</code> component reusable and more maintainable in a larger codebase, you can decompose it into smaller, focused components. This approach enhances readability, encourages reuse, and simplifies testing. Here are some strategies for decomposition and organization:</p>"},{"location":"package/miscellaneous/composition/imagegallery/#1-create-separate-components","title":"1. Create Separate Components","text":"<p>You can break down the <code>Picture</code> component into smaller components, such as:</p> <ul> <li>ImageGallery: A component that handles the rendering of the image gallery.</li> <li>ImagePreview: A component that manages the image preview functionality and its toolbar.</li> <li>LoadingSpinner: A component for loading states.</li> <li>ErrorMessage: A component for displaying error messages.</li> </ul>"},{"location":"package/miscellaneous/composition/imagegallery/#2-example-structure","title":"2. Example Structure","text":"<p>Here\u2019s how you could structure your components:</p> <pre><code>src/\n  components/\n    ImageGallery/\n      ImageGallery.js\n      ImagePreview.js\n      LoadingSpinner.js\n      ErrorMessage.js\n  redux/\n    features/\n      gallery/\n        services.js\n</code></pre>"},{"location":"package/miscellaneous/composition/imagegallery/#3-implementation","title":"3. Implementation","text":"ImageGallery.jsImagePreview.jsLoadingSpinner.jsErrorMessage.js <p>This component will fetch the images and manage the gallery state.</p> <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport ImagePreview from \"./ImagePreview\";\nimport LoadingSpinner from \"./LoadingSpinner\";\nimport ErrorMessage from \"./ErrorMessage\";\n\nconst ImageGallery = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n        dispatch(getPhotosService(source.token));\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    if (status === \"loading\") {\n        return &lt;LoadingSpinner /&gt;;\n    }\n\n    if (error) {\n        return &lt;ErrorMessage message={error.message} /&gt;;\n    }\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture Gallery&lt;/h1&gt;\n        &lt;ImagePreview gallery={gallery} /&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default ImageGallery;\n</code></pre> <p>This component will handle the preview logic.</p> <pre><code>import React, { useState } from \"react\";\nimport { Image, Space } from \"antd\";\nimport {\n    LeftOutlined,\n    RightOutlined,\n    RotateLeftOutlined,\n    RotateRightOutlined,\n    ZoomInOutlined,\n    ZoomOutOutlined,\n    UndoOutlined,\n    SwapOutlined,\n} from \"@ant-design/icons\";\n\nconst ImagePreview = ({ gallery }) =&gt; {\n    const [current, setCurrent] = useState(0);\n\n    return (\n        &lt;Image.PreviewGroup\n            preview={{\n                toolbarRender: (_, { transform: { scale }, actions }) =&gt; (\n                &lt;Space size={12} className=\"toolbar-wrapper\"&gt;\n                    &lt;LeftOutlined onClick={() =&gt; actions.onActive(-1)} /&gt;\n                    &lt;RightOutlined onClick={() =&gt; actions.onActive(1)} /&gt;\n                    &lt;SwapOutlined rotate={90} onClick={actions.onFlipY} /&gt;\n                    &lt;SwapOutlined onClick={actions.onFlipX} /&gt;\n                    &lt;RotateLeftOutlined onClick={actions.onRotateLeft} /&gt;\n                    &lt;RotateRightOutlined onClick={actions.onRotateRight} /&gt;\n                    &lt;ZoomOutOutlined disabled={scale === 1} onClick={actions.onZoomOut} /&gt;\n                    &lt;ZoomInOutlined disabled={scale === 50} onClick={actions.onZoomIn} /&gt;\n                    &lt;UndoOutlined onClick={actions.onReset} /&gt;\n                &lt;/Space&gt;\n                ),\n                onChange: (index) =&gt; {\n                    setCurrent(index);\n                },\n            }}\n        &gt;\n            {gallery.map((item) =&gt; (\n                &lt;Image\n                    key={item.id}\n                    src={item.url}\n                    alt=\"Gallery\"\n                    height={200}\n                    width={200}\n                /&gt;\n            ))}\n        &lt;/Image.PreviewGroup&gt;\n    );\n};\n\nexport default ImagePreview;\n</code></pre> <p>A simple component to display a loading spinner.</p> <pre><code>import React from \"react\";\nimport { Skeleton } from \"antd\";\n\nconst LoadingSpinner = () =&gt; (\n    &lt;Skeleton active paragraph={{ rows: 4 }} /&gt;\n);\n\nexport default LoadingSpinner;\n</code></pre> <p>A component to display error messages.</p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; (\n    &lt;div style={{ color: \"red\" }}&gt;\n        Error loading images: {message}\n    &lt;/div&gt;\n);\n\nexport default ErrorMessage;\n</code></pre>"},{"location":"package/miscellaneous/composition/imagegallery/#ant-image-css","title":"Ant Image CSS","text":"<pre><code>.toolbar-wrapper {\n  padding: 0px 24px;\n  color: #fff;\n  font-size: 20px;\n  background-color: rgba(0, 0, 0, 0.1);\n  border-radius: 100px;\n}\n\n.toolbar-wrapper .anticon {\n  padding: 12px;\n  cursor: pointer;\n}\n\n.toolbar-wrapper .anticon[disabled] {\n  cursor: not-allowed;\n  opacity: 0.3;\n}\n\n.toolbar-wrapper .anticon:hover {\n  opacity: 0.3;\n}\n</code></pre>"},{"location":"package/miscellaneous/composition/imagegallery/#production","title":"Production","text":"<p>In production applications, it's essential to handle errors gracefully while maintaining a good user experience. Here are some best practices for displaying error messages:</p> TheoryExample ImplementationKey Points <p>1. User-Friendly Messages</p> <p>Instead of displaying technical error messages, provide a user-friendly message that informs users something went wrong without exposing sensitive information.</p> <p>2. Hide Technical Details</p> <p>Avoid showing stack traces or error codes to end users. Instead, use a generic message like \"Something went wrong. Please try again later.\"</p> <p>3. Logging</p> <p>Log the actual error details (without exposing them to the user) for debugging purposes. This can be done through a logging service or your application's backend.</p> <p>4. Fallback UI</p> <p>Consider providing a fallback UI, such as a retry button or an option to go back to the home page, to enhance user experience.</p> <p>5. Conditional Rendering</p> <p>You can conditionally render error messages based on the environment. For example, show detailed errors in development but more user-friendly messages in production.</p> <p>You could modify your <code>ErrorMessage</code> component to handle different environments like this:</p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error loading images: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n</code></pre> <ul> <li>User Experience: Focus on a smooth user experience by not alarming users with technical jargon.</li> <li>Environment Check: Use environment variables to differentiate between development and production.</li> <li>Fallback Options: Consider including retry options or guidance on what to do next.</li> </ul> <p>By following these guidelines, you ensure that error handling in your application is both effective and user-friendly, especially in production environments.</p> <p>Additional</p> ExampleExplained <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; (\n    &lt;div style={{ color: \"red\" }}&gt;\n        Error loading images: {message}\n    &lt;/div&gt;\n);\n\nexport default ErrorMessage;\n\n\n// or\n\nimport React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error loading images: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n\n\nwhich is the standard practice and why?\n</code></pre> <p>The second implementation is the standard practice for error handling in production applications. Here\u2019s why:</p> <p>1. User Experience</p> <ul> <li>User-Friendly Messages: In the second implementation, the error message is simplified for end users. Instead of exposing potentially confusing technical details, it provides a clear, non-technical message: \"Something went wrong. Please try again later.\" This helps maintain a good user experience.</li> </ul> <p>2. Security</p> <ul> <li>Avoiding Information Leakage: Displaying detailed error messages (like in the first implementation) can inadvertently expose sensitive information about your application (e.g., internal structure, error codes) to users. This can be a security risk, especially if those details can be exploited.</li> </ul> <p>3. Environment-Specific Behavior</p> <ul> <li>Conditional Rendering: The second implementation checks the environment (process.env.NODE_ENV). This means you can provide detailed error messages during development (helpful for debugging) while showing a generic message in production, where users don't need technical details.</li> </ul> <p>4. Maintainability</p> <ul> <li>Easier Future Updates: If you decide to change how errors are handled in the future, having a single place where the environment check is made makes it easier to implement those changes without affecting user experience negatively.</li> </ul> <p>5. Consistent User Feedback</p> <ul> <li>Standardization: It sets a standard for how errors are presented across the application. This consistency helps users understand what to expect when an error occurs.</li> </ul> <p>Conclusion</p> <p>While the first implementation might be acceptable during development, the second implementation is preferred for production due to its focus on user experience, security, and maintainability. It's crucial to strike a balance between providing useful information to developers and protecting users from technical details that may confuse or concern them.</p>"},{"location":"package/miscellaneous/composition/imagegallery/#download-image","title":"Download Image","text":"OfficialCustomize Error HandlingMethod <pre><code>const onDownload = () =&gt; {\n    const url = imageList[current];\n    const suffix = url.slice(url.lastIndexOf('.'));\n    const filename = Date.now() + suffix;\n    fetch(url)\n        .then((response) =&gt; response.blob())\n        .then((blob) =&gt; {\n            const blobUrl = URL.createObjectURL(new Blob([blob]));\n            const link = document.createElement('a');\n            link.href = blobUrl;\n            link.download = filename;\n            document.body.appendChild(link);\n            link.click();\n            URL.revokeObjectURL(blobUrl);\n            link.remove();\n        });\n};\n</code></pre> <pre><code>const onDownload = () =&gt; {\nconst url = gallery[current].url; // Get the URL of the current image\nconst filename = `image_${Date.now()}.png`; // Create a filename\n\nfetch(url)\n    .then((response) =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.blob(); // Convert the response to a Blob\n    })\n    .then((blob) =&gt; {\n        const blobUrl = URL.createObjectURL(blob); // Create a blob URL\n        const link = document.createElement(\"a\");\n        link.href = blobUrl; // Set the blob URL as the link href\n        link.download = filename; // Set the download attribute with the filename\n        document.body.appendChild(link);\n        link.click(); // Trigger the download\n        document.body.removeChild(link); // Clean up\n        URL.revokeObjectURL(blobUrl); // Release the blob URL\n    })\n    .catch((error) =&gt; {\n        console.error('Download error:', error); // Handle any errors\n    });\n};\n</code></pre> <p>Key Points</p> <ol> <li> <p>Blob Handling:</p> <p>By using <code>response.blob()</code>, you convert the fetched response into a Blob object, which allows for more flexible handling of binary data.</p> </li> <li> <p>Error Handling:</p> <p>It's good practice to check if the response is OK (status 200) before trying to convert it to a blob. The error handling in the <code>.catch</code> block will log any errors that occur during the fetch.</p> </li> <li> <p>Creating a Blob URL:</p> <p><code>URL.createObjectURL(blob)</code> creates a temporary URL for the Blob, which is then used as the <code>href</code> in the link element for downloading.</p> </li> <li> <p>Cleanup:</p> <p>After triggering the download, you should revoke the object URL with <code>URL.revokeObjectURL(blobUrl)</code> to free up resources.</p> </li> </ol> <pre><code>const onDownload = () =&gt; {\n    const url = gallery[current].url; // Get the URL of the current image\n    const filename = `image_${Date.now()}.png`; // Create a filename (you can change the extension if needed)\n\n    // Create a temporary link element\n    const link = document.createElement(\"a\");\n    link.href = url; // Set the URL for the download\n    link.download = filename; // Set the download attribute with the filename\n    document.body.appendChild(link);\n    link.click(); // Trigger the download\n    document.body.removeChild(link); // Clean up\n};\n</code></pre>"},{"location":"package/miscellaneous/composition/imagegallery/#env","title":"Env","text":"<p>A <code>.env</code> file is used to define environment variables for your application, especially when using frameworks like React, Node.js, or any backend technology. This file is typically not committed to version control (e.g., Git) to keep sensitive information private.</p> ExampleExplanationNotes <p>Example of a <code>.env</code> File</p> <p>Here's a simple example of what a <code>.env</code> file might look like for a React application:</p> <pre><code># Environment configuration\nNODE_ENV=development\n\n# API configuration\nREACT_APP_API_URL=https://api.example.com\nREACT_APP_API_KEY=your_api_key_here\n\n# Feature flags\nREACT_APP_ENABLE_FEATURE_X=true\nREACT_APP_ENABLE_DEBUG_MODE=false\n</code></pre> <p>Explanation of Variables</p> <ol> <li> <p>NODE_ENV: This variable indicates the environment your application is running in. Common values are <code>development</code>, <code>production</code>, and <code>test</code>. In React, you can use <code>process.env.NODE_ENV</code> to access this variable.</p> </li> <li> <p>API Configuration:</p> <ul> <li><code>REACT_APP_API_URL</code>: The base URL for your API endpoints.</li> <li><code>REACT_APP_API_KEY</code>: An API key for authentication when making requests to your backend.</li> </ul> </li> <li> <p>Feature Flags:</p> <ul> <li>These variables allow you to toggle certain features on or off without changing the code. This is particularly useful for testing new features in production without impacting all users.</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li> <p>Prefixing: In a Create React App project, all environment variables that you want to access in your application must start with <code>REACT_APP_</code>. This is a security measure to prevent accidentally exposing sensitive environment variables.</p> </li> <li> <p>Avoid Committing: Make sure to add <code>.env</code> to your <code>.gitignore</code> file to avoid committing sensitive information to your version control system.</p> </li> <li> <p>Different Environments: You can create different <code>.env</code> files for different environments, such as <code>.env.development</code>, <code>.env.production</code>, and use a package like <code>dotenv</code> to manage them in a Node.js application.</p> </li> </ul> <p>Example of Adding to <code>.gitignore</code></p> <p>Your <code>.gitignore</code> file should include:</p> <pre><code># Environment variables\n.env\n</code></pre> <p>This setup helps ensure your sensitive configuration details are kept secure and not exposed in your source code.</p>"},{"location":"package/miscellaneous/composition/imagegallery/#reference","title":"Reference","text":"<ul> <li>Antd Image</li> </ul>"},{"location":"package/miscellaneous/composition/intro/","title":"Intro","text":"<p>dsfsdf</p>"},{"location":"package/monitoring-and-logging/intro/","title":"Intro","text":""},{"location":"package/monitoring-and-logging/intro/#overview","title":"Overview","text":"<p>A logLevel is a configuration that determines the level of detail for logs in your application or development tools. It's primarily used to control what messages are output to the console or logs based on their severity or purpose.</p>"},{"location":"package/monitoring-and-logging/intro/#why-do-we-need-loglevel","title":"Why Do We Need logLevel?","text":"<ol> <li> <p>Filter Log Messages:</p> <p>Prevent irrelevant or verbose logs (like debug information) from cluttering the console in production while enabling detailed debugging in development.</p> </li> <li> <p>Improve Performance:</p> <p>Avoid unnecessary logging operations, which can be resource-intensive, especially in production environments.</p> </li> <li> <p>Enhance Debugging:</p> <p>Enable verbose logging (e.g., <code>debug</code>, <code>info</code>) during development to identify issues faster.</p> </li> <li> <p>Security:</p> <p>Prevent sensitive or unnecessary debug information from being exposed in production logs.</p> </li> </ol>"},{"location":"package/monitoring-and-logging/intro/#difference-between-logging-libraies-and-services","title":"Difference between Logging Libraies and Services","text":"<p>The key difference between logging libraries and logging services lies in their functionality, purpose, and scope:</p>"},{"location":"package/monitoring-and-logging/intro/#logging-libraries","title":"Logging Libraries","text":"<p>Purpose: Provide tools to generate, format, and manage logs within an application.</p> <p>Key Features:</p> <ol> <li>Log Levels: Allow categorization of logs (e.g., debug, info, warn, error).</li> <li>Custom Transports: Define where logs should be sent (e.g., files, console, external endpoints).</li> <li>Formatting Options: Enable custom formats like JSON, timestamps, or plain text.</li> <li>Performance Optimization: Efficiently handle logging to minimize application overhead.</li> </ol> <p>Examples:</p> <ul> <li>Winston: Flexible Node.js logging library with custom transport and formatting options.</li> <li>Pino: High-performance JSON logger for Node.js and browsers.</li> <li>Loglevel: Lightweight logging library for client-side JavaScript.</li> </ul> <p>When to Use:</p> <ul> <li>For local logging (e.g., debugging, saving logs to files).</li> <li>When logs don't need to be aggregated across systems.</li> <li>When you want complete control over how logs are managed.</li> </ul> <p>Limitations:</p> <ul> <li>Logs are often stored locally unless sent to an external endpoint.</li> <li>Limited support for analyzing, searching, or aggregating logs across multiple instances or applications.</li> </ul>"},{"location":"package/monitoring-and-logging/intro/#logging-services","title":"Logging Services","text":"<p>Purpose: Provide platforms for collecting, aggregating, analyzing, and monitoring logs from multiple applications, servers, and environments.</p> <p>Key Features:</p> <ol> <li>Centralized Log Aggregation: Collect logs from various sources into a single system.</li> <li>Real-Time Monitoring: View logs and system metrics in real-time.</li> <li>Search and Filtering: Quickly find relevant logs using powerful search tools.</li> <li>Visualization and Dashboards: Create charts and graphs for trends and metrics.</li> <li>Alerts and Notifications: Trigger alerts based on log patterns or errors.</li> <li>Integration: Connect with other systems like Slack, PagerDuty, or email for notifications.</li> </ol> <p>Examples:</p> <ul> <li>Sentry: Focused on error tracking and performance monitoring.</li> <li>Datadog: Comprehensive observability platform for logs, metrics, and traces.</li> <li>Elastic Stack (ELK): Open-source suite for log collection (Elasticsearch, Logstash, Kibana).</li> <li>Splunk: Enterprise-grade platform for log analysis and monitoring.</li> </ul> <p>When to Use:</p> <ul> <li>For distributed systems with multiple services and instances.</li> <li>When logs need to be analyzed, visualized, or correlated with metrics.</li> <li>To monitor production environments for performance and errors.</li> <li>For auditing and compliance, where centralized logging is required.</li> </ul> <p>Limitations:</p> <ul> <li>Usually incurs a cost, especially for large-scale applications.</li> <li>Relies on external infrastructure, which could be a concern for sensitive data.</li> </ul>"},{"location":"package/monitoring-and-logging/intro/#comparison-table","title":"Comparison Table","text":"Aspect Logging Libraries Logging Services Purpose Generate and manage logs locally. Aggregate, monitor, and analyze logs globally. Scope Single application or instance. Distributed systems, multiple instances, or apps. Real-Time Analysis Not available or limited. Fully supported with dashboards and alerts. Storage Logs are stored locally or as specified. Logs are stored and searchable in the cloud. Cost Free or open-source (no external cost). Often subscription-based or pay-as-you-go. Examples Winston, Pino, Loglevel, Bunyan. Sentry, Datadog, ELK Stack, Splunk."},{"location":"package/monitoring-and-logging/intro/#using-both-together","title":"Using Both Together","text":"<p>For production-grade applications, a common pattern is to use logging libraries for generating logs and sending them to logging services for centralized storage and monitoring. For example:</p> <ul> <li>Use Winston or Pino in your application to format logs and send them to an external endpoint.</li> <li>Forward logs to Sentry, Datadog, or ELK for aggregation, analysis, and alerting.</li> </ul>"},{"location":"package/monitoring-and-logging/intro/#example-setup","title":"Example Setup","text":"<p>???+ example \"Combine Winston with Sentry:**</p> <pre><code>1.  Install dependencies:\n\n    ```bash\n    pnpm add winston @sentry/node @sentry/winston\n    ```\n\n2.  Configure logger:\n\n    ```jsx\n    const { createLogger, format, transports } = require('winston');\n    const Sentry = require('@sentry/node');\n    const SentryTransport = require('@sentry/winston');\n\n    Sentry.init({ dsn: 'your-sentry-dsn-url' });\n\n    const logger = createLogger({\n        level: 'info',\n        format: format.json(),\n        transports: [\n            new transports.Console(),\n            new SentryTransport({ level: 'error' }),\n        ],\n    });\n\n    logger.info('This is an info log');\n    logger.error('This is an error log');\n    ```\n\nIn this setup:\n\n-   [Winston](#) manages log generation.\n-   [Sentry](#) collects and monitors logs in the cloud.\n\nBy combining libraries and services, you get the best of both worlds: local control with global monitoring.\n</code></pre>"},{"location":"package/monitoring-and-logging/intro/#question","title":"Question","text":"<p>In large web applications, relying solely on <code>console.log</code> is discouraged due to its limitations in scalability, manageability, and performance. Instead, dedicated logging libraries like Winston, Pino, Loglevel, or services like Sentry and Datadog are used.</p>"},{"location":"package/monitoring-and-logging/intro/#why-not-use-consolelog-in-large-applications","title":"Why Not Use <code>console.log</code> in Large Applications?","text":"<ol> <li> <p>No Log Levels:</p> <p><code>console.log</code> does not categorize messages by severity (e.g., debug, info, warn, error), making it harder to filter or prioritize logs.</p> </li> <li> <p>Cluttered Output:</p> <p>Logs from all sources are mixed in the browser or server console, making it difficult to trace issues effectively.</p> </li> <li> <p>Lack of Persistent Storage:</p> <p><code>console.log</code> output isn't saved across sessions or accessible for future debugging, limiting its usefulness in identifying production issues.</p> </li> <li> <p>Performance Overhead:</p> <p>Excessive logging can slow down applications, especially in production, as <code>console.log</code> isn't optimized for high-frequency use.</p> </li> <li> <p>Security Risks:</p> <p>Sensitive data accidentally logged with <code>console.log</code> can be exposed in the browser's developer tools.</p> </li> <li> <p>No Remote Monitoring:</p> <p><code>console.log</code> doesn\u2019t integrate with external systems to collect and monitor logs for real-time issue tracking.</p> </li> </ol>"},{"location":"package/monitoring-and-logging/intro/#what-do-large-applications-use-instead","title":"What Do Large Applications Use Instead?","text":"<ol> <li> <p>Logging Libraries for the Browser</p> <ul> <li>Loglevel: Lightweight and browser-friendly. Great for front-end applications.</li> <li>Pino: High performance and supports both browser and server environments.</li> </ul> </li> <li> <p>Logging Libraries for the Server</p> <ul> <li>Winston: Flexible and widely used in Node.js applications for custom transports and formats.</li> <li>Bunyan: Focused on structured JSON logs, ideal for server applications.</li> <li>Pino: Super-fast and supports JSON-based logs, making it popular in high-performance applications.</li> </ul> </li> <li> <p>Logging Services</p> <p>These provide advanced monitoring, error tracking, and integrations:</p> <ul> <li>Sentry: For error and performance monitoring.</li> <li>Datadog: Comprehensive log aggregation and application monitoring.</li> <li>Elastic Stack (ELK): Elasticsearch, Logstash, and Kibana for centralized logging and visualization.</li> </ul> </li> </ol>"},{"location":"package/monitoring-and-logging/intro/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>console.log</code> sparingly during development for quick debugging.</li> <li>Transition to a logging library for structured logging, log levels, and remote monitoring.</li> <li>In large-scale applications, integrate logging libraries with monitoring tools like <code>Sentry</code> or <code>Datadog</code> for production-grade observability.</li> </ul>"},{"location":"package/monitoring-and-logging/logging-libraries/","title":"Libraries","text":"<p>Logging libraries provide features and capabilities that go far beyond the simple console.log function. Here's a breakdown of how logging libraries differ from console.log and why they are crucial for large, scalable applications:</p>"},{"location":"package/monitoring-and-logging/logging-libraries/#key-differences","title":"Key Differences","text":"Feature/Capability <code>console.log</code> Logging Libraries Log Levels No log levels\u2014everything is logged equally. Categorizes logs (e.g., <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>) for better filtering. Log Formatting Raw, unstructured messages. Custom formatting (JSON, timestamps, colors) for clarity and standardization. Log Filtering No built-in filtering; everything appears in the console. Allows filtering logs based on level, environment, or context. Output Destinations Outputs only to the console. Sends logs to multiple destinations: files, databases, remote APIs, etc. Persistence Logs disappear after the session ends (not saved). Logs can be stored in files, databases, or sent to monitoring services. Performance Impact Heavy usage can slow down applications, especially in production. Optimized for minimal impact on performance (e.g., async logging). Log Rotation Not available. Manages log file size by rotating logs automatically to prevent overflow. Correlation IDs No built-in support for tracing specific requests. Supports request tracking across services for distributed systems. Security May inadvertently expose sensitive data in logs. Provides tools to mask or redact sensitive information. Monitoring Integration Requires manual effort to integrate with monitoring services. Direct integration with tools like Sentry, Datadog, and Elasticsearch. Error Tracking Doesn't track error context or metadata automatically. Captures additional context (stack traces, metadata) for easier debugging."},{"location":"package/monitoring-and-logging/logging-libraries/#what-logging-libraries-do-differently","title":"What Logging Libraries Do Differently","text":"<ol> <li> <p>Structured Logging:</p> <p>Logging libraries output logs in structured formats like JSON, making them machine-readable and searchable.</p> <pre><code>console.log(\"User logged in\");\n// VS\nlogger.info({\n  event: \"User logged in\",\n  userId: 123,\n  timestamp: new Date(),\n});\n</code></pre> </li> <li> <p>Custom Log Levels:</p> <p>Libraries let you define and use log levels (e.g., <code>debug</code>, <code>warn</code>), allowing you to display only what\u2019s relevant.</p> <pre><code>logger.debug(\"This is a debug message\"); // Visible only in development\nlogger.error(\"Critical error occurred!\"); // Always visible\n</code></pre> </li> <li> <p>Centralized Log Management:</p> <p>Logs can be sent to files, remote servers, or log aggregation tools for centralized monitoring and analysis.</p> <pre><code>const logger = createLogger({\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: \"app.log\" }),\n  ],\n});\n</code></pre> </li> <li> <p>Error Tracking with Context:</p> <p>Libraries often capture additional details about errors, such as stack traces, request IDs, or user context.</p> </li> <li> <p>Remote Log Shipping:</p> <p>Libraries can forward logs to tools like Sentry or Datadog for real-time monitoring and alerting.</p> </li> <li> <p>Log Rotation and Retention:</p> <p>Automatically rotates log files to prevent storage overflow and supports retention policies.</p> </li> <li> <p>Environment-Specific Configurations:</p> <p>Adjust log levels or formats based on the environment (e.g., <code>debug</code> in development, <code>error</code> in production).</p> </li> </ol>"},{"location":"package/monitoring-and-logging/logging-libraries/#example-scenarios-where-libraries-outperform-consolelog","title":"Example Scenarios Where Libraries Outperform <code>console.log</code>","text":"<ol> <li> <p>Production Debugging:</p> <p>When an error occurs, logs include the exact timestamp, stack trace, and user session details. <code>console.log</code> doesn\u2019t provide this level of detail.</p> <pre><code>logger.error(\"Database connection failed\", { host: dbHost, user: dbUser });\n</code></pre> </li> <li> <p>Scalable Logging:</p> <p>A logging library can send logs from multiple services to a central location, making it easier to troubleshoot across distributed systems.</p> </li> <li> <p>Filtering Logs:</p> <p>You can configure a logger to display only warnings and errors in production, avoiding noisy debug messages.</p> </li> <li> <p>Integration with Monitoring Tools:</p> <p>Libraries can integrate directly with services like Sentry to alert developers about errors, whereas <code>console.log</code> cannot.</p> </li> </ol>"},{"location":"package/monitoring-and-logging/logging-libraries/#when-to-use-logging-libraries-instead-of-consolelog","title":"When to Use Logging Libraries Instead of console.log","text":"<ul> <li> <p>In Development:</p> <p>Use <code>console.log</code> for quick, temporary debugging. Replace it with a library for better control and context.</p> </li> <li> <p>In Production:</p> <p>Always use a logging library to ensure structured, persistent, and secure logs, with the ability to filter and manage log data effectively.</p> </li> </ul>"},{"location":"package/monitoring-and-logging/logging-libraries/#conclusion","title":"Conclusion","text":"<p>While <code>console.log</code> is simple and useful for local debugging, logging libraries are designed for scalable, maintainable, and secure logging in large applications. They provide features that are essential for identifying, tracing, and resolving issues in production environments.</p> <p>For a frontend React application using Vite, you need a logging library that is lightweight, browser-friendly, and easy to integrate. Here are some of the best logging libraries to consider:</p>"},{"location":"package/monitoring-and-logging/logging-libraries/#comparison-of-libraries","title":"Comparison of Libraries","text":"Library Best For Lightweight Log Levels Browser-Friendly Integration with Services Free/Open Source Loglevel Basic logging in React applications \u2705 \u2705 \u2705 \u274c \u2705 Pino High-performance JSON logging \u2705 \u2705 \u2705 \u2705 \u2705 Debug Scoped debugging logs \u2705 \u274c \u2705 \u274c \u2705 LogRocket Advanced monitoring with replay \u274c \u2705 \u2705 \u2705 \u274c Sentry Error tracking and performance logs \u274c \u2705 \u2705 \u2705 \u274c (Free tier)"},{"location":"package/monitoring-and-logging/logging-libraries/#recommendations","title":"Recommendations","text":"<ul> <li>For simple logging: Loglevel or Debug.</li> <li>For performance and structured logs: Pino.</li> <li>For session tracking and monitoring: LogRocket.</li> <li>For error monitoring and tracing: Sentry.</li> </ul> <p>In a production-grade React application, you can also combine libraries (e.g., use <code>Pino</code> for structured logs and send errors to <code>Sentry</code>).</p>"},{"location":"package/monitoring-and-logging/logging-libraries/#reference","title":"Reference","text":"<ul> <li>react-logger-lib</li> <li>@dodobrands/react-logger</li> <li>Logging for your frontend apps </li> <li>React Error Handling and Logging Best Practices</li> <li>10 React Logging Best Practices</li> </ul>"},{"location":"package/monitoring-and-logging/pino/example/","title":"Example","text":""},{"location":"package/monitoring-and-logging/pino/example/#overview","title":"Overview","text":"<p>To gracefully handle failures in log transmission, you need to implement a robust mechanism that prevents your application from entering infinite loops or encountering crashes due to repeated log transmission failures. Here\u2019s how you can do it:</p> Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> <p>1. Use a Retry Mechanism with Limits</p> <p>If a log fails to transmit, retry the transmission but limit the number of retries to avoid overloading your system.</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nconst sendLogToAPI = async (logObject, retryCount = 0) =&gt; {\n  const MAX_RETRIES = 3;\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    console.error(\"Log transmission failed:\", error);\n\n    if (retryCount &lt; MAX_RETRIES) {\n      console.warn(`Retrying (${retryCount + 1}/${MAX_RETRIES})...`);\n      setTimeout(() =&gt; sendLogToAPI(logObject, retryCount + 1), 1000); // Retry after 1 second\n    } else {\n      console.error(\"Max retries reached. Log will be dropped:\", logObject);\n    }\n  }\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n        sendLogToAPI(logObject);\n      },\n    },\n  },\n});\n\nexport default logger;\n</code></pre> <p>2. Queue Failed Logs for Later Transmission</p> <p>If the log transmission fails, queue the log and attempt to send it again after a set interval.</p> <pre><code>let logQueue = [];\nlet isSending = false;\n\nconst processLogQueue = async () =&gt; {\n  if (isSending || logQueue.length === 0) return;\n\n  isSending = true;\n  const log = logQueue.shift(); // Get the first log in the queue\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(log),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log, re-queuing:\", log);\n    logQueue.push(log); // Re-queue the log for another attempt\n  } finally {\n    isSending = false;\n  }\n\n  // Process the next log after a delay\n  setTimeout(processLogQueue, 1000);\n};\n\nconst queueLogForTransmission = (logObject) =&gt; {\n  logQueue.push(logObject);\n  processLogQueue();\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n        queueLogForTransmission(logObject);\n      },\n    },\n  },\n});\n\nexport default logger;\n</code></pre> <p>3. Graceful Fallback for Network Errors</p> <p>Detect network unavailability (e.g., navigator.onLine in the browser) and handle log transmission accordingly.</p> <pre><code>const sendLogToAPI = async (logObject) =&gt; {\n  if (!navigator.onLine) {\n    console.warn(\"Offline: Log will be queued:\", logObject);\n    logQueue.push(logObject);\n    return;\n  }\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log, queuing for retry:\", error);\n    logQueue.push(logObject); // Queue the log for retry\n  }\n};\n</code></pre> <p>4. Prevent Infinite Loops</p> <p>Ensure that the logger itself does not log errors caused by its own failure to prevent recursion.</p> <pre><code>let isLoggerError = false;\n\nconst sendLogToAPI = async (logObject) =&gt; {\n  if (isLoggerError) return; // Prevent recursive logging of logger errors\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    isLoggerError = true; // Flag to prevent recursion\n    console.error(\"Logger Error: Could not send log\", error);\n    isLoggerError = false;\n  }\n};\n</code></pre> <p>5. Handle Large Log Volume</p> <p>Implement rate limiting or batching to control the frequency of log transmissions and prevent overloading the server.</p> Batch Logs<pre><code>let logBatch = [];\nconst MAX_BATCH_SIZE = 10;\n\nconst sendBatchToAPI = async () =&gt; {\n  if (logBatch.length === 0) return;\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logBatch),\n    });\n    logBatch = []; // Clear the batch on success\n  } catch (error) {\n    console.error(\"Failed to send log batch, retrying...\", error);\n  }\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n\n        logBatch.push(logObject);\n\n        if (logBatch.length &gt;= MAX_BATCH_SIZE) {\n          sendBatchToAPI();\n        }\n      },\n    },\n  },\n});\n\nsetInterval(sendBatchToAPI, 5000); // Send logs every 5 seconds\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/example/#best-practices-for-error-handling-in-log-transmission","title":"Best Practices for Error Handling in Log Transmission","text":"<ol> <li>Retry with Limits: Use retries but limit the maximum attempts.</li> <li>Queue and Process Logs: Ensure failed logs are not lost and retry them later.</li> <li>Handle Offline Scenarios: Use <code>navigator.onLine</code> to detect and handle offline states.</li> <li>Avoid Recursive Logging: Prevent the logger from logging errors caused by itself.</li> <li>Use Batch Transmission: Reduce the frequency of API calls by batching logs.</li> <li>Log Gracefully in Development Only: Avoid overloading logs in production to maintain performance.</li> </ol> <p>These practices ensure robust log transmission while avoiding infinite loops or crashes.</p>"},{"location":"package/monitoring-and-logging/pino/example/#final-implementation","title":"Final Implementation","text":"<pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nlet logQueue = [];\nlet isSending = false;\nconst MAX_BATCH_SIZE = 10;\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 1000; // 1 second\nconst BATCH_INTERVAL = 5000; // 5 seconds\n\n// Send a batch of logs to the API\nconst sendBatchToAPI = async () =&gt; {\n  if (isSending || logQueue.length === 0) return;\n\n  isSending = true;\n  const batch = logQueue.splice(0, MAX_BATCH_SIZE);\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log batch, re-queuing...\", error);\n    logQueue = [...batch, ...logQueue]; // Re-queue the failed logs\n  } finally {\n    isSending = false;\n  }\n};\n\n// Periodically send batched logs\nsetInterval(sendBatchToAPI, BATCH_INTERVAL);\n\n// Enqueue a log for transmission\nconst enqueueLog = (logObject) =&gt; {\n  logQueue.push(logObject);\n  if (logQueue.length &gt;= MAX_BATCH_SIZE) {\n    sendBatchToAPI(); // Trigger batch sending if max size is reached\n  }\n};\n\n// Log function with retry mechanism\nconst sendLogWithRetry = async (logObject, retryCount = 0) =&gt; {\n  if (!navigator.onLine) {\n    console.warn(\"Offline: Log queued for later transmission:\", logObject);\n    enqueueLog(logObject);\n    return;\n  }\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify([logObject]), // Send as a single log\n    });\n  } catch (error) {\n    console.error(\"Log transmission failed:\", error);\n\n    if (retryCount &lt; MAX_RETRIES) {\n      setTimeout(\n        () =&gt; sendLogWithRetry(logObject, retryCount + 1),\n        RETRY_DELAY\n      );\n    } else {\n      console.error(\"Max retries reached. Log will be queued:\", logObject);\n      enqueueLog(logObject); // Queue the log if retries fail\n    }\n  }\n};\n\n// Create the Pino logger\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          msg: logEvent[0], // Main log message\n          context: logEvent[1] || {}, // Additional context if provided\n          timestamp: new Date().toISOString(),\n        };\n\n        sendLogWithRetry(logObject); // Use retry-enabled log sender\n      },\n    },\n    asObject: true, // Keep logs readable in the browser console\n  },\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\", // Set log level from environment\n});\n\nexport default logger;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/example/#how-to-use-the-logger","title":"How to Use the Logger","text":"<p>1. Import the logger wherever you need it:</p> <pre><code>import logger from \"./utils/logger\";\n</code></pre> <p>2. Use the logger to record logs:</p> <pre><code>logger.info(\"User clicked on button\", { userId: 123, action: \"click\" });\nlogger.error(\"Error occurred while fetching data\", { errorCode: 500 });\nlogger.warn(\"Potential issue detected\", { module: \"auth\" });\n</code></pre> <p>3. Logs will:</p> <ul> <li>Be sent immediately to the API.</li> <li>Be retried up to 3 times if transmission fails.</li> <li>Be queued if offline and sent when back online or in batches every 5 seconds.</li> </ul>"},{"location":"package/monitoring-and-logging/pino/intro/","title":"Intro","text":""},{"location":"package/monitoring-and-logging/pino/intro/#overview","title":"Overview","text":"<p>Pino is a fast and structured logging library, and while it's primarily designed for Node.js, it has a browser-compatible version called <code>pino</code> or <code>pino-browser</code>, which works well in React applications using Vite.</p> Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> Example <code>.env</code>for Log Levels <p>Control the verbosity of logs using an environment variable:</p> <pre><code># .env\nVITE_LOG_LEVEL=info\n</code></pre> <ul> <li>debug: Print everything, useful for development.</li> <li>info: Print standard application flow logs.</li> <li>warn: Print only warnings and errors.</li> <li>error: Print only errors.</li> </ul>"},{"location":"package/monitoring-and-logging/pino/intro/#1-setup-project-wide-logging","title":"1. Setup Project-Wide Logging","text":"<p>Create a Centralized Logger</p> <p>Create a <code>logger.js</code> file in a shared utilities folder (e.g., <code>src/utils</code>).</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nconst isDev = import.meta.env.MODE === \"development\";\n\nconst logger = pino({\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n  browser: {\n    asObject: true, // Makes logs readable in the browser console\n  },\n  transport: isDev\n    ? {\n        target: \"pino-pretty\",\n        options: { colorize: true }, // Pretty logs in development\n      }\n    : undefined,\n});\n\nexport default logger;\n</code></pre> <p>Configure Environment-Specific Log Levels</p> <p>Use <code>.env</code> files for different environments:</p> <pre><code># .env.development\nVITE_LOG_LEVEL=debug\n\n# .env.production\nVITE_LOG_LEVEL=error\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#2-integrate-logger-across-the-application","title":"2. Integrate Logger Across the Application","text":"<p>Use in React Components</p> <p>Import the logger and use it for logging user interactions, API calls, and errors.</p> <pre><code>// src/features/user/UserProfile.jsx\nimport React, { useEffect } from \"react\";\nimport logger from \"../../utils/logger\";\n\nfunction UserProfile({ userId }) {\n  useEffect(() =&gt; {\n    logger.info(`Fetching data for user ID: ${userId}`);\n    fetch(`/api/users/${userId}`)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; logger.debug(\"User data:\", data))\n      .catch((error) =&gt; logger.error(\"Error fetching user data:\", error));\n  }, [userId]);\n\n  return &lt;div&gt;User Profile for {userId}&lt;/div&gt;;\n}\n\nexport default UserProfile;\n</code></pre> <p>Use in Redux or State Management</p> <p>Integrate logging for debugging Redux actions or state changes.</p> <pre><code>// src/store/middleware/loggerMiddleware.js\nimport logger from \"../../utils/logger\";\n\nconst loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  logger.debug(\"Dispatching action:\", action);\n  const result = next(action);\n  logger.debug(\"New state:\", store.getState());\n  return result;\n};\n\nexport default loggerMiddleware;\n</code></pre> <p>Add the middleware to your Redux store:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport loggerMiddleware from \"./middleware/loggerMiddleware\";\nimport rootReducer from \"./reducers\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(loggerMiddleware),\n});\n\nexport default store;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#3-centralize-error-logging","title":"3. Centralize Error Logging","text":"<p>Use Error Boundaries</p> Example <p>Create an error boundary to catch React rendering errors and log them.</p> ClassFunction <pre><code>// src/components/ErrorBoundary.jsx\nimport React from \"react\";\nimport logger from \"../utils/logger\";\n\nclass ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(error) {\n        return { hasError: true };\n    }\n\n    componentDidCatch(error, info) {\n        logger.error(\"React error:\", { error, info });\n    }\n\n    render() {\n        if (this.state.hasError) {\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n        }\n\n        return this.props.children;\n    }\n}\n\nexport default ErrorBoundary;\n</code></pre> <p>Wrap your app with the <code>ErrorBoundary</code> in the root component:</p> <pre><code>import ErrorBoundary from './components/ErrorBoundary';\n\nfunction App() {\n    return (\n        &lt;ErrorBoundary&gt;\n            &lt;YourAppRoutes /&gt;\n        &lt;/ErrorBoundary&gt;\n    );\n}\n\nexport default App;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#4-monitor-api-calls","title":"4. Monitor API Calls","text":"<p>Create a wrapper for Axios (or any HTTP client) to log API requests and responses.</p> <pre><code>// src/utils/http.js\nimport axios from \"axios\";\nimport logger from \"./logger\";\n\nconst http = axios.create({\n  baseURL: \"/api\",\n});\n\nhttp.interceptors.request.use((config) =&gt; {\n  logger.info(\"API Request:\", config);\n  return config;\n});\n\nhttp.interceptors.response.use(\n  (response) =&gt; {\n    logger.debug(\"API Response:\", response);\n    return response;\n  },\n  (error) =&gt; {\n    logger.error(\"API Error:\", error);\n    return Promise.reject(error);\n  }\n);\n\nexport default http;\n</code></pre> <p>Use this instance throughout your app:</p> <pre><code>import http from \"../../utils/http\";\n\nhttp.get(\"/users\").then((response) =&gt; {\n  console.log(response.data);\n});\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#5-add-log-grouping-for-better-debugging","title":"5. Add Log Grouping for Better Debugging","text":"<p>Use <code>logger.group()</code> and <code>logger.groupEnd()</code> for logically related logs.</p> <pre><code>logger.group(\"User Interaction\");\nlogger.info(\"Button clicked\");\nlogger.debug(\"Current user state:\", userState);\nlogger.groupEnd();\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#6-extend-logging-to-monitoring-services","title":"6. Extend Logging to Monitoring Services","text":"<p>For production-ready logging, extend Pino with services like Sentry or LogRocket.</p> <p>Example: Sentry Integration</p> Install Sentry:<pre><code>pnpm add @sentry/react @sentry/browser\n</code></pre> Initialize it:<pre><code>// src/utils/logger.js\nimport * as Sentry from \"@sentry/react\";\nimport pino from \"pino\";\n\nSentry.init({\n  dsn: \"your-sentry-dsn\",\n  tracesSampleRate: 1.0,\n});\n\nconst logger = pino({\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n  browser: { asObject: true },\n});\n\nexport const captureException = (error, context) =&gt; {\n  Sentry.captureException(error, { extra: context });\n  logger.error(\"Captured exception:\", error, context);\n};\n\nexport default logger;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#7-organize-logs-by-feature","title":"7. Organize Logs by Feature","text":"<p>Organize logs by feature or module by creating feature-specific logger instances:</p> <pre><code>// src/features/user/logger.js\nimport logger from \"../../utils/logger\";\n\nconst userLogger = logger.child({ module: \"UserFeature\" });\n\nexport default userLogger;\n</code></pre> <p>Use it in user-specific components or services:</p> <pre><code>import userLogger from \"./logger\";\n\nuserLogger.info(\"User module initialized\");\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/intro/#benefits-of-using-pino-in-large-applications","title":"Benefits of Using Pino in Large Applications","text":"<ol> <li>Scalability: Structured, JSON-based logging works well in distributed systems.</li> <li>Environment-Specific Configurations: Log levels and outputs can be dynamically adjusted.</li> <li>Error Tracking: Easy integration with tools like Sentry or LogRocket for advanced monitoring.</li> <li>Performance: Lightweight and highly optimized for logging large volumes of data.</li> </ol> <p>This setup ensures reliable and maintainable logging for your large React + Vite application.</p>"},{"location":"package/monitoring-and-logging/pino/methods/","title":"Methods","text":""},{"location":"package/monitoring-and-logging/pino/methods/#overview","title":"Overview","text":"<p>Pino's officially supported logging methods correspond to the standard log levels. These methods allow you to log messages with varying levels of severity, which can be filtered or processed depending on the log level configuration.</p>"},{"location":"package/monitoring-and-logging/pino/methods/#officially-supported-methods-in-pino","title":"Officially Supported Methods in Pino","text":"Method Log Level Description <code>trace</code> 10 For very fine-grained, low-level, and verbose debugging information. <code>debug</code> 20 For debugging information useful during development. <code>info</code> 30 For general informational messages about application behavior or events. <code>warn</code> 40 For warnings about potentially harmful situations or recoverable errors. <code>error</code> 50 For errors that occur during runtime, typically those that require investigation. <code>fatal</code> 60 For critical errors that cause the application to terminate or become unusable."},{"location":"package/monitoring-and-logging/pino/methods/#key-notes","title":"Key Notes:","text":"<ol> <li> <p>Hierarchy of Log Levels:</p> <ul> <li>Logs with a level lower than the configured <code>level</code> will be ignored. For example, if you set the log level to <code>warn</code>, only <code>warn</code>, <code>error</code>, and <code>fatal</code> logs will appear.</li> </ul> </li> <li> <p>Log Level in Production:</p> <ul> <li>Use <code>error</code> or <code>fatal</code> for production environments to reduce log verbosity and focus on critical issues.</li> </ul> </li> <li> <p>Structured Logging:</p> <ul> <li>Each method can accept a message string and/or a structured object:</li> </ul> <pre><code>logger.info(\"Server started\");\nlogger.error({\n  error: \"Database connection failed\",\n  timestamp: new Date(),\n});\n</code></pre> </li> </ol>"},{"location":"package/monitoring-and-logging/pino/methods/#unsupported-methods","title":"Unsupported Methods","text":"<ul> <li>Pino does not support methods like <code>.err</code> or <code>.log</code>. These are often mistakenly used, leading to errors like <code>TypeError: (intermediate value).err is not a function</code>.</li> </ul> <p>If you need to log something with custom behavior, use a valid log method (<code>info</code>, <code>error</code>, etc.) and pass the relevant structured data as part of the log payload.</p>"},{"location":"package/monitoring-and-logging/pino/methods/#best-practice","title":"Best Practice","text":"<ul> <li>Use <code>trace</code> and <code>debug</code> for development environments.</li> <li>Use <code>warn</code>, <code>error</code>, and <code>fatal</code> for production environments.</li> <li>Always prefer structured logging by passing objects instead of plain strings for better log parsing and analysis.</li> </ul>"},{"location":"package/monitoring-and-logging/pino/notes/","title":"Notes","text":""},{"location":"package/monitoring-and-logging/pino/notes/#notes","title":"Notes","text":"<p><code>name</code> &amp; <code>msg</code> is not same because:</p> <ol> <li> <p><code>logger.info({msg: \"test\", testObj });</code></p> <ul> <li>The object passed here explicitly sets a key called <code>msg</code> for the log message, along with another key <code>testObj</code>.</li> <li>The <code>msg</code> key is recognized by Pino (depending on configuration) as the primary message field in the log entry.</li> <li>Example Output:</li> </ul> <pre><code>{\n    \"level\": \"info\",\n    \"msg\": \"test\",\n    \"testObj\": {\n        \"key\": \"value\" // example object contents\n    },\n    \"time\": \"2024-11-29T17:00:00.000Z\"\n}\n</code></pre> </li> <li> <p><code>logger.info({name: \"test\", testObj });</code></p> <ul> <li>Here, the log entry has keys <code>name</code> and <code>testObj</code>.</li> <li>Since there is no <code>msg</code> key in this case, Pino does not treat any field as the primary log message (unless you have customized <code>messageKey</code> in the configuration).</li> <li>Example Output:</li> </ul> <pre><code>{\n\"level\": \"info\",\n\"name\": \"test\",\n\"testObj\": {\n    \"key\": \"value\" // example object contents\n},\n\"time\": \"2024-11-29T17:00:00.000Z\"\n}\n</code></pre> </li> </ol>"},{"location":"package/monitoring-and-logging/pino/notes/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Primary Message Field:</p> <ul> <li>In the first example, the <code>msg</code> key is explicitly set and will be treated as the main log message in Pino's structured logs.</li> <li>In the second example, there is no <code>msg</code>, so the log message is treated as a generic object.</li> </ul> </li> <li> <p>Semantics:</p> <ul> <li><code>msg</code> is a reserved key in Pino logs and should generally hold the main log message for clarity.</li> <li>Using a custom field like <code>name</code> does not carry the same semantic meaning and might reduce clarity when analyzing logs.</li> </ul> </li> <li> <p>Log Parsing:</p> <ul> <li>Log management systems or log parsers may rely on the <code>msg</code> key for displaying the main message in dashboards or alerts.</li> <li>Without a <code>msg</code>, the log might appear less structured or harder to interpret in such systems.</li> </ul> </li> </ol>"},{"location":"package/monitoring-and-logging/pino/notes/#best-practice","title":"Best Practice","text":"<p>If the intent is to log a primary message along with additional context, the first format is preferred:</p> <pre><code>logger.info({ msg: \"Button clicked\", testObj });\n</code></pre> <p>This ensures consistent formatting and makes it easier to integrate with log parsing tools.</p>"},{"location":"package/monitoring-and-logging/pino/notes/#common-pino-options","title":"Common Pino Options","text":"<p>Below are some of the key options supported by Pino during logger initialization:</p> Option Description <code>level</code> Specifies the minimum log level to record. Logs below this level are ignored. Defaults to <code>\"info\"</code>. Valid levels are <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, and <code>fatal</code>. <code>timestamp</code> Configures the format of the timestamp in logs. You can disable it (<code>false</code>) or use a custom function to format timestamps (e.g., using <code>moment.js</code>). <code>browser</code> Allows customization of how logs are displayed in the browser, including structured logging (<code>asObject</code>) and sending logs to external services. <code>base</code> An object with additional default properties added to every log (e.g., <code>{ pid, hostname }</code>). Set to <code>null</code> to disable default properties. <code>messageKey</code> Customizes the key for the log message in structured logs. Defaults to <code>\"msg\"</code>. <code>enabled</code> Enables or disables logging entirely. Set to <code>false</code> to disable all logs. <code>hooks</code> Provides lifecycle hooks for modifying logs, such as the <code>logMethod</code> hook for customizing how logs are written. <code>serializers</code> Allows defining custom serializers for specific properties, such as masking sensitive data or formatting objects. <code>redact</code> Masks sensitive fields in logs (e.g., <code>\"password\"</code>). Can be an array of keys or a configuration object for redacting nested fields. <code>formatters</code> Customizes how the log object or log level appears in logs. <code>transport</code> Configures log transport for writing logs to files, streams, or external destinations in real-time. <code>customLevels</code> Allows defining additional custom log levels, extending Pino\u2019s default levels."},{"location":"package/monitoring-and-logging/pino/send-to-api/","title":"Sending to API","text":""},{"location":"package/monitoring-and-logging/pino/send-to-api/#overview","title":"Overview","text":"Installation<pre><code>pnpm add pino pino-pretty\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/send-to-api/#steps-to-send-logs-to-an-api","title":"Steps to Send Logs to an API","text":"Example logger.jslogs.jslogModel.jsApp.jsx <p>1. Create a Custom Log Transport</p> <p>Pino allows you to define custom transports for logs. You can create one that sends logs to an API endpoint.</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\n// Create a custom transport for sending logs to an API\nconst sendLogToAPI = async (logObject) =&gt; {\n    try {\n        await fetch(\"/api/logs\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(logObject),\n        });\n    } catch (error) {\n        console.error(\"Failed to send log:\", error);\n    }\n};\n\nconst logger = pino({\n    browser: {\n        transmit: {\n            send: (level, logEvent) =&gt; {\n                const logObject = {\n                    level,\n                    ...logEvent,\n                    timestamp: new Date().toISOString(),\n                };\n                sendLogToAPI(logObject); // Send log to API\n            },\n        },\n        asObject: true, // Keep logs readable in the browser console\n    },\n    level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n});\n\nexport default logger;\n</code></pre> <p>2. Setup the Backend API to Receive Logs</p> <p>On the backend, create an API route to accept logs and store them in the database. For example, with Express.js:</p> <pre><code>// server/routes/logs.js\nconst express = require('express');\nconst router = express.Router();\nconst { LogModel } = require('../models/logModel'); // Assuming you have a log schema\n\n// Endpoint to receive logs\nrouter.post('/', async (req, res) =&gt; {\n    try {\n        const log = new LogModel(req.body); // Create a new log entry\n        await log.save(); // Save to the database\n        res.status(200).send({ message: 'Log stored successfully' });\n    } catch (error) {\n        console.error('Error storing log:', error);\n        res.status(500).send({ error: 'Failed to store log' });\n    }\n});\n\nmodule.exports = router;\n</code></pre> <p>3. Create a Database Schema for Logs</p> <p>Define a schema for storing logs in your database. For example, using Mongoose for MongoDB:</p> <pre><code>// server/models/logModel.js\nconst mongoose = require('mongoose');\n\nconst logSchema = new mongoose.Schema({\n    level: { type: String, required: true },\n    msg: { type: String, required: true },\n    timestamp: { type: Date, required: true },\n    context: { type: Object }, // Additional log metadata\n});\n\nconst LogModel = mongoose.model('Log', logSchema);\nmodule.exports = { LogModel };\n</code></pre> <p>4. Use the Logger in Your Application</p> <p>The logs will now be transmitted to your API whenever the logger is called.</p> <pre><code>// Example usage in a React component\nimport logger from './utils/logger';\n\nfunction App() {\n    const handleClick = () =&gt; {\n        logger.info('Button clicked', { user: 'John Doe', action: 'click' });\n        logger.error('An error occurred', { errorCode: 500 });\n    };\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Log to API Example&lt;/h1&gt;\n        &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/send-to-api/#advantages-of-sending-logs-to-an-api","title":"Advantages of Sending Logs to an API","text":"<ol> <li>Centralized Logging: Logs from all clients and services can be stored in a single location.</li> <li>Persistent Storage: Logs can be retained long-term for debugging, audits, or analysis.</li> <li>Scalability: Enables aggregation of logs from distributed systems.</li> <li>Custom Alerts: Logs in a database can be queried for patterns and trigger alerts.</li> </ol>"},{"location":"package/monitoring-and-logging/pino/send-to-api/#additional-notes","title":"Additional Notes","text":"<ol> <li> <p>Batching Logs: Instead of sending logs individually, you can batch them to reduce API calls. Use a queue and periodically send logs in bulk.</p> <pre><code>let logQueue = [];\nconst batchLogs = () =&gt; {\n  if (logQueue.length &gt; 0) {\n    fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logQueue),\n    }).catch((error) =&gt; console.error(\"Failed to send logs:\", error));\n    logQueue = [];\n  }\n};\nsetInterval(batchLogs, 5000); // Send logs every 5 seconds\n</code></pre> </li> <li> <p>Error Handling: Ensure your application gracefully handles failures in log transmission to avoid infinite loops or crashes.</p> </li> <li> <p>Security: Be cautious about what information is logged to avoid exposing sensitive data.</p> </li> <li> <p>Services: If you don\u2019t want to manage logs manually, consider services like LogRocket, Sentry, or Datadog for automated logging and analysis.</p> </li> </ol> <p>This approach ensures logs from your frontend React app are stored in a database for monitoring, debugging, and auditing purposes.</p>"},{"location":"package/monitoring-and-logging/pino/send-to-api/#reference","title":"Reference","text":"<ul> <li>pino</li> </ul>"},{"location":"package/monitoring-and-logging/pino/simple-usage/","title":"Simple Usage","text":""},{"location":"package/monitoring-and-logging/pino/simple-usage/#overview","title":"Overview","text":"Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> <p>Log Levels in Pino</p> <p>Pino supports the following log levels, which control the severity and verbosity of logs:</p> Level Severity Description <code>fatal</code> 60 (highest) Indicates an unrecoverable error causing the application to crash. <code>error</code> 50 Non-critical errors requiring attention but not causing immediate failure. <code>warn</code> 40 Warnings about potential issues or deprecated usage. <code>info</code> 30 General operational information (e.g., application status, startup info). <code>debug</code> 20 Detailed debugging information useful during development. <code>trace</code> 10 (lowest) Very fine-grained logs for tracing code execution or troubleshooting. <code>silent</code> -1 (special) Disables all logging."},{"location":"package/monitoring-and-logging/pino/simple-usage/#what-log-levels-to-set-in-env-files","title":"What Log Levels to Set in <code>.env</code> Files","text":"<p>You can control the log verbosity in different environments by setting the <code>VITE_LOG_LEVEL</code> environment variable.</p> <p>1. <code>.env.development</code> (Development Environment)</p> <p>For development, you need verbose logging to debug issues effectively. Set the level to <code>debug</code> or <code>trace</code>.</p> <pre><code># .env.development\nVITE_LOG_LEVEL=debug\n</code></pre> <ul> <li>Reason: <code>debug</code> logs give detailed insights into the app's behavior without being as noisy as <code>trace</code>.</li> </ul> <p>2. <code>.env.production</code> (Production Environment)</p> <p>For production, logs should focus on errors and warnings to avoid performance overhead and clutter.</p> <pre><code># .env.production\nVITE_LOG_LEVEL=warn\n\n# or error only\nVITE_LOG_LEVEL=error\n</code></pre> <ul> <li>Reason: Warnings and errors are sufficient for monitoring production issues without flooding logs with unnecessary information.</li> </ul> <p>3. <code>.env</code> (Default Environment)</p> <p>Set a default level that works for both development and production but can be overridden by specific environments.</p> <pre><code># .env\nVITE_LOG_LEVEL=info\n</code></pre> <ul> <li>Reason: <code>info</code> logs provide general operational details, which is a safe default for most environments.</li> </ul>"},{"location":"package/monitoring-and-logging/pino/simple-usage/#how-pino-uses-vite_log_level","title":"How Pino Uses <code>VITE_LOG_LEVEL</code>","text":"<p>Here\u2019s how you can configure Pino to respect the <code>VITE_LOG_LEVEL</code> in your React + Vite application:</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\n// Get log level from environment variables\nconst logLevel = import.meta.env.VITE_LOG_LEVEL || \"info\";\n\n// Create a logger instance\nconst logger = pino({\n  level: logLevel, // Set log level dynamically\n  browser: {\n    asObject: true, // Make logs structured and readable in the browser console\n  },\n});\n\nexport default logger;\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/simple-usage/#summary","title":"Summary","text":"<ul> <li>In <code>.env.development</code>: Use <code>VITE_LOG_LEVEL=debug</code> for detailed logs during development.</li> <li>In <code>.env.production</code>: Use <code>VITE_LOG_LEVEL=warn</code> or <code>VITE_LOG_LEVEL=error</code> to monitor issues without performance hits.</li> <li>In <code>.env</code>: Use <code>VITE_LOG_LEVEL=info</code> as a fallback for environments not explicitly configured.</li> </ul> <p>This setup ensures you have the right logging detail for each environment while optimizing performance and usability.</p>"},{"location":"package/monitoring-and-logging/pino/simple-usage/#what-will-be-logged-in-production","title":"What Will Be Logged in Production?","text":"<p>When <code>VITE_LOG_LEVEL=error</code>:</p> <ul> <li>Only logs with severity <code>error</code> and <code>fatal</code> will be logged.</li> <li>Logs with lower severities (<code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>) will be suppressed.</li> </ul> <pre><code>logger.fatal(\"Critical failure!\"); // Will be logged\nlogger.error(\"Something went wrong\"); // Will be logged\nlogger.warn(\"This is a warning\"); // Will NOT be logged\nlogger.info(\"Application started\"); // Will NOT be logged\nlogger.debug(\"Debugging details\"); // Will NOT be logged\nlogger.trace(\"Tracing execution\"); // Will NOT be logged\n</code></pre>"},{"location":"package/monitoring-and-logging/pino/simple-usage/#reference","title":"Reference","text":"<ul> <li>pino logger</li> </ul>"},{"location":"package/testing/msw/msw-advanced/","title":"Advanced","text":""},{"location":"package/testing/msw/msw-advanced/#msw-advanced","title":"MSW Advanced","text":""},{"location":"package/testing/msw/msw-advanced/#reference","title":"Reference","text":"<ul> <li>msw migration 1.x \u2192 2.x</li> <li>Mock APIs with Mock Service Worker in any framework.</li> </ul>"},{"location":"package/testing/msw/overview/","title":"Overview","text":""},{"location":"package/testing/msw/overview/#generating-the-worker-script","title":"Generating the worker script","text":"<p>To generate the worker script, run the following command in your project\u2019s root directory:</p> <pre><code>npx msw init &lt;PUBLIC_DIR&gt; --save\n\nnpx msw init ./public --save\n</code></pre> <ul> <li>Version 1</li> <li>Version 2</li> </ul>"},{"location":"package/testing/msw/overview/#example","title":"Example","text":"<p>To explore the methods available in the MSW package and find their names or functionalities, you can refer to the following:</p>"},{"location":"package/testing/msw/overview/#1-logging-the-module","title":"1. Logging the Module","text":"<p>As mentioned, you can log the entire MSW module:</p> <pre><code>import * as msw from \"msw\";\n\nconsole.log(msw);\n</code></pre>"},{"location":"package/testing/msw/overview/#2-documentation","title":"2. Documentation","text":"<p>The best way to understand the available methods is to consult the official MSW documentation. The documentation provides detailed information about all the methods, their usage, and examples.</p>"},{"location":"package/testing/msw/overview/#3-typescript-definitions","title":"3. TypeScript Definitions","text":"<p>If you are using TypeScript, you can look at the type definitions for MSW. This can give you insights into the available methods and their signatures. You can check the <code>@mswjs/data</code> or <code>msw</code> packages directly in your <code>node_modules</code> or use an IDE that supports TypeScript IntelliSense.</p>"},{"location":"package/testing/msw/overview/#4-common-methods-and-properties","title":"4. Common Methods and Properties","text":"<p>Here are some of the main methods and properties provided by MSW:</p> <ul> <li><code>rest</code>: For defining REST API request handlers.</li> <li><code>graphql</code>: For defining GraphQL API request handlers.</li> <li><code>setupWorker</code>: Initializes the worker for browser environments.</li> <li><code>setupServer</code>: Initializes a server for Node.js environments.</li> <li><code>start()</code>: Starts the service worker or server.</li> <li><code>stop()</code>: Stops the service worker or server.</li> <li><code>listen()</code>: Starts intercepting requests (Node.js).</li> <li><code>close()</code>: Stops intercepting requests (Node.js).</li> <li><code>ctx</code>: A context object that contains utility functions to build responses (e.g., <code>ctx.json()</code>, <code>ctx.status()</code>, etc.).</li> </ul>"},{"location":"package/testing/msw/overview/#5-using-objectkeys","title":"5. Using <code>Object.keys()</code>","text":"<p>If you want to list all the method names programmatically, you can use <code>Object.keys()</code>:</p> <pre><code>import * as msw from \"msw\";\n\nconsole.log(Object.keys(msw));\n</code></pre> <p>This will give you an array of the top-level properties, which typically include methods and objects within MSW.</p>"},{"location":"package/testing/msw/overview/#6-exploring-in-a-repl","title":"6. Exploring in a REPL","text":"<p>If you have a JavaScript or TypeScript environment set up, you can also use a REPL (like Node.js or browser console) to require/import MSW and explore its properties interactively.</p> Example of Commands in REPL<pre><code>$ node\n&gt; const msw = require('msw');\n&gt; console.log(msw); // Logs the entire module\n&gt; console.log(Object.keys(msw)); // Lists all top-level keys\n&gt; console.log(msw.rest); // Logs the REST methods\n&gt; console.log(msw.setupWorker); // Logs the setupWorker function\n</code></pre> <p>Using these methods, you should be able to get a comprehensive view of what MSW offers!</p>"},{"location":"package/testing/msw/overview/#list-properties-and-methods","title":"List Properties and Methods:","text":"<pre><code>// Log the entire MSW object\nconsole.log(msw); // View all properties and methods\n\n// List all top-level keys\nconsole.log(Object.keys(msw));\n\n// If you want to check specific sections:\nconsole.log(Object.keys(msw.rest)); // REST methods\nconsole.log(Object.keys(msw.graphql)); // GraphQL methods\n</code></pre>"},{"location":"package/ui/antd/","title":"Intro","text":""},{"location":"package/ui/antd/#and","title":"and","text":"<pre><code>$ pnpm add antd\n$ pnpm add @ant-design/icons\n</code></pre>"},{"location":"package/ui/antd/#in-one-day","title":"In one day","text":"<p>Mastering Ant Design (antd) in React in just one day is ambitious, but you can certainly get a solid grasp of its advanced features by focusing your efforts strategically. Here\u2019s a plan to help you maximize your learning in one day:</p> <p>1. Set Up Your Environment (1 hour)</p> <ul> <li>Install Ant Design: Ensure you have a React environment ready. You can create a new project with Create React App:</li> </ul> <pre><code>npx create-react-app my-app\ncd my-app\nnpm install antd\n</code></pre> <ul> <li>Basic Setup: Import Ant Design styles in your index.js or App.js:</li> </ul> <pre><code>import \"antd/dist/antd.css\";\n</code></pre> <p>2. Explore the Components (3 hours)</p> <ul> <li> <p>Component Library: Go through the Ant Design Component Library. Focus on the following categories:</p> <pre><code>- Layout: Grids, containers, and menus.\n- Navigation: Breadcrumbs, tabs, pagination.\n- Data Entry: Forms, inputs, select, date pickers.\n- Data Display: Tables, lists, cards, avatars.\n- Feedback: Modals, notifications, alerts.\n</code></pre> </li> <li> <p>Practice: Build small examples for each component. For instance, create a form using <code>Form</code>, <code>Input</code>, and <code>Button</code> components.</p> </li> </ul> <p>3. Deep Dive into Advanced Features (3 hours)</p> <ul> <li> <p>Custom Themes: Learn how to customize the default theme using Less variables or CSS overrides.</p> </li> <li> <p>Form Management: Explore <code>Form</code> validation, nested forms, and dynamic fields. Implement a form that uses <code>Formik</code> or <code>react-hook-form</code> with antd.</p> </li> <li> <p>State Management: Understand how to manage global state with tools like Redux or Context API, and integrate it with antd components.</p> </li> <li> <p>Tables: Go deep into the <code>Table</code> component. Implement features like:</p> <pre><code>- Sorting\n- Filtering\n- Pagination\n- Editable cells\n- Row selection\n</code></pre> </li> </ul> <p>4. Routing and Navigation (1 hour)</p> <ul> <li>React Router: Set up <code>react-router</code> for navigation. Create multiple pages and use antd's <code>Menu</code> for navigation links.</li> </ul> <p>5. Responsive Design (1 hour)</p> <ul> <li>Grid System: Utilize the antd grid system for responsive layouts. Create a multi-column layout that adapts to different screen sizes.</li> </ul> <p>6. Testing (1 hour)</p> <ul> <li>Unit Testing: Learn how to test antd components using libraries like Jest and React - Testing Library. Write tests for your components, focusing on form submissions and interactions.</li> </ul> <p>7. Build a Complete Application (2 hours)</p> <ul> <li>Project: Create a small project that incorporates multiple antd components and features. For example, a simple task manager that allows users to add, delete, and edit tasks, using forms and tables.</li> </ul> <p>8. Documentation and Community (1 hour)</p> <ul> <li> <p>Explore Documentation: Familiarize yourself with the Ant Design documentation. Pay special attention to advanced usage sections.</p> </li> <li> <p>Community: Join communities or forums, such as GitHub discussions or Stack Overflow, to ask questions and see how others are using antd.</p> </li> </ul> <p>9. Practice and Reflect (1 hour)</p> <ul> <li>Review Your Code: Go through what you\u2019ve built throughout the day. Refactor where necessary and ensure best practices.</li> <li>Seek Feedback: If possible, share your work with peers or mentors for constructive criticism.</li> </ul> <p>Conclusion</p> <p>By following this structured approach, you'll be able to cover a lot of ground in mastering Ant Design in a day. Remember that mastery comes with practice, so continue to build projects and refine your skills beyond this initial day of learning!</p>"},{"location":"package/ui/antd/#mastering","title":"Mastering","text":"<p>To gain a deep understanding of Ant Design (antd) and its capabilities, it's crucial to master several advanced components that are commonly used in building complex applications. Here\u2019s a list of the most important components to focus on:</p> <p>1. Table</p> <ul> <li>Features: Sorting, filtering, pagination, row selection, expandable rows, and editable cells.</li> <li>Advanced Use Cases: Implementing custom renderers, integrating with server-side data, and managing complex data structures.</li> </ul> <p>2. Form</p> <ul> <li>Features: Controlled components, validation, dynamic fields, and form layout.</li> <li>Advanced Use Cases: Using external validation libraries (like Yup), managing nested forms, and integrating with state management solutions.</li> </ul> <p>3. Modal</p> <ul> <li>Features: Dialogs for confirmation, forms, and notifications.</li> <li>Advanced Use Cases: Implementing custom modal content and managing multiple modals efficiently.</li> </ul> <p>4. Menu</p> <ul> <li>Features: Navigation menus, submenus, and dropdowns.</li> <li>Advanced Use Cases: Dynamic menu generation based on user roles and permissions, and handling nested routing.</li> </ul> <p>5. Card</p> <ul> <li>Features: Contain multiple elements, customizable layouts, and actions.</li> <li>Advanced Use Cases: Creating interactive dashboards with cards, using grid layouts, and integrating with charts or other components.</li> </ul> <p>6. Notification and Message</p> <ul> <li>Features: System notifications and user feedback messages.</li> <li>Advanced Use Cases: Customizing notification placement, duration, and using them with asynchronous operations.</li> </ul> <p>7. Select and AutoComplete</p> <ul> <li>Features: Dropdown selections, multi-select, and search functionality.</li> <li>Advanced Use Cases: Implementing asynchronous options loading, custom option rendering, and integrating with API endpoints.</li> </ul> <p>8. DatePicker</p> <ul> <li>Features: Date selection, range selection, and date-time management.</li> <li>Advanced Use Cases: Customizing date formats, integrating with validation, and handling time zones.</li> </ul> <p>9. Spin and Loading</p> <ul> <li>Features: Loading indicators to improve UX.</li> <li>Advanced Use Cases: Managing loading states during data fetching and integrating with asynchronous actions.</li> </ul> <p>10. Grid</p> <ul> <li>Features: Responsive layout using Row and Col components.</li> <li>Advanced Use Cases: Building adaptive designs for different screen sizes and implementing complex layouts.</li> </ul> <p>11. Tree</p> <ul> <li>Features: Hierarchical data representation with expand/collapse functionality.</li> <li>Advanced Use Cases: Dynamic tree data loading, checkable trees, and drag-and-drop functionality.</li> </ul> <p>12. Tabs</p> <ul> <li>Features: Tabbed navigation for organizing content.</li> <li>Advanced Use Cases: Dynamic tab generation and preserving state across tabs.</li> </ul> <p>13. Steps</p> <ul> <li>Features: Step-by-step navigation for multi-step processes.</li> <li>Advanced Use Cases: Managing complex workflows and integrating forms within steps.</li> </ul> <p>Conclusion</p> <p>Focusing on these components will provide you with a comprehensive understanding of Ant Design's capabilities. Mastering them involves not just understanding how they work individually but also how they interact with each other to create cohesive user experiences. Additionally, practice by building projects that utilize these components in various ways to reinforce your knowledge!</p>"},{"location":"package/ui/antd/antd-autofill-input-issue/","title":"antd autofill input issue","text":"<p>why antd form filling username and password</p> <p></p> <p>How to disable autofill for antd input with react</p> Solution <p>I fixed this problem by adding <code>autoComplete=\"new-password\"</code> to the <code>Input.Password</code></p> <pre><code>&lt;Input.Password placeholder=\"Mot de Passe\" autoComplete=\"new-password\" /&gt;\n</code></pre> <p>antd validator example password</p> <p>I want to validate password using react with ant design</p> <p>AntD form validation With ReactJS</p> CODEUTILS <pre><code>&lt;Form.Item\n    label=\"Password\"\n    name=\"password\"\n    rules={[\n        {\n        required: true,\n        // message: \"Please enter password\",\n        },\n        { validator: validatePassword },\n    ]}\n    hasFeedback\n&gt;\n    &lt;Input.Password disabled={isView} autoComplete=\"new-password\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre> utils/validatePassword.js<pre><code>import logger from \"@shared/utils/logger\";\n\nexport const validatePassword = (_, value) =&gt; {\n    let check = !value;\n    logger.info({ msg: \"INFO: \", value, check });\n    if (!value) {\n        return Promise.reject(\"Password is required\");\n    }\n\n    // Password must contain at least one non-alphanumeric character\n    const nonAlphanumericRegex = /[^a-zA-Z0-9]/;\n    if (!nonAlphanumericRegex.test(value)) {\n        return Promise.reject(\n        \"Passwords must have at least one non-alphanumeric character.\"\n        );\n    }\n\n    // Password must contain at least one digit\n    const digitRegex = /\\d/;\n    if (!digitRegex.test(value)) {\n        return Promise.reject(\"Passwords must have at least one digit.\");\n    }\n\n    // Password must contain at least one uppercase letter\n    const uppercaseRegex = /[A-Z]/;\n    if (!uppercaseRegex.test(value)) {\n        return Promise.reject(\"Passwords must have at least one uppercase letter.\");\n    }\n\n    return Promise.resolve();\n};\n</code></pre> <p>antd validator example password</p>"},{"location":"package/ui/antd/antd-autofill-input-issue/#form","title":"FORM","text":"<pre><code>&lt;Form\n  name=\"basic\"\n  labelCol={{\n    span: 8,\n  }}\n  // REMEMBER ME\n  initialValues={{\n    remember: true,\n  }}\n&gt;\n  &lt;Form.Item name=\"remember\" valuePropName=\"checked\" label={null}&gt;\n    &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt;\n  &lt;/Form.Item&gt;\n\n  &lt;Form.Item label={null}&gt;\n    &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n      Submit\n    &lt;/Button&gt;\n  &lt;/Form.Item&gt;\n&lt;/Form&gt;\n</code></pre>"},{"location":"package/ui/antd/antd-autofill-input-issue/#reference","title":"Reference","text":"<ul> <li>Antd Form, antd.design</li> <li>AntD form validation With ReactJS</li> </ul>"},{"location":"package/ui/antd/antd-breakpoint/","title":"Antd Breakpoint","text":"<p>In Ant Design, the <code>Grid</code> component and its <code>useBreakpoint</code> hook are helpful for creating responsive layouts. The useBreakpoint hook allows you to get the current screen size based on predefined breakpoints.</p> <p>Here's an example of how to use <code>useBreakpoint</code> with Ant Design:</p> <p>Antd PRO Example: Click Here !!!</p>"},{"location":"package/ui/antd/antd-breakpoint/#usebreakpoint-hook","title":"useBreakpoint Hook","text":"<p>Use <code>useBreakpoint</code> Hook provide personalized layout. <code>xs</code> only takes effect when the screen match the min width.</p> <p></p> ExampleExplanation <pre><code>import React from \"react\";\nimport { Grid, Tag } from \"antd\";\nconst { useBreakpoint } = Grid;\n\nconst ResponsiveTags = () =&gt; {\n    // Get the current breakpoint information\n    const screens = useBreakpoint();\n\n    return (\n        &lt;div&gt;\n            &lt;h3&gt;Responsive Tags&lt;/h3&gt;\n            &lt;div&gt;\n                &lt;Tag color={screens.xs ? \"blue\" : \"green\"}&gt;\n                    XS: {screens.xs ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n                &lt;Tag color={screens.sm ? \"blue\" : \"green\"}&gt;\n                    SM: {screens.sm ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n                &lt;Tag color={screens.md ? \"blue\" : \"green\"}&gt;\n                    MD: {screens.md ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n                &lt;Tag color={screens.lg ? \"blue\" : \"green\"}&gt;\n                    LG: {screens.lg ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n                &lt;Tag color={screens.xl ? \"blue\" : \"green\"}&gt;\n                    XL: {screens.xl ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n                &lt;Tag color={screens.xxl ? \"blue\" : \"green\"}&gt;\n                    XXL: {screens.xxl ? \"Active\" : \"Inactive\"}\n                &lt;/Tag&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ResponsiveTags;\n</code></pre> <ul> <li> <p>useBreakpoint hook: This hook returns an object that contains boolean values for each of the responsive breakpoints (<code>xs</code>, <code>sm</code>, <code>md</code>, <code>lg</code>, <code>xl</code>, <code>xxl</code>). These values indicate whether the current screen size matches the respective breakpoint.</p> </li> <li> <p>Tag Component: You can use the <code>Tag</code> component from Ant Design to visually represent the screen size status (active or inactive). In this case, it changes the color and text based on the breakpoints.</p> </li> </ul> <p>This setup can be useful when designing a responsive UI where you need to adjust components or behaviors based on screen size. The <code>useBreakpoint</code> hook is especially helpful when you want to quickly adapt the layout without writing custom media queries.</p>"},{"location":"package/ui/antd/antd-breakpoint/#example-with-drawer","title":"Example with <code>Drawer</code>","text":"ExampleKey Changes <pre><code>import React, { useState, useEffect } from \"react\";\nimport { Link, useLocation } from \"react-router-dom\";\nimport {\n    AppstoreOutlined,\n    ContainerOutlined,\n    DesktopOutlined,\n    MailOutlined,\n    PieChartOutlined,\n    MessageOutlined,\n} from \"@ant-design/icons\";\nimport { Menu, Drawer, Button } from \"antd\";\nimport { useBreakpoint } from \"antd/es/grid/hooks\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n    const [visible, setVisible] = useState(false);\n    const location = useLocation();\n    const { sm } = useBreakpoint(); // Use Ant Design's breakpoint hook to detect mobile devices\n\n    // Menu items configuration\n    const items = [\n        {\n            key: \"dashboard\",\n            icon: &lt;PieChartOutlined /&gt;,\n            label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n        },\n        {\n            key: \"balance\",\n            icon: &lt;DesktopOutlined /&gt;,\n            label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n        },\n        {\n            key: \"spending\",\n            icon: &lt;ContainerOutlined /&gt;,\n            label: &lt;Link to=\"/spending\"&gt;Spending&lt;/Link&gt;,\n        },\n        {\n            key: \"chat\",\n            icon: &lt;MessageOutlined /&gt;,\n            label: &lt;Link to=\"/chat\"&gt;Chat&lt;/Link&gt;,\n        },\n        {\n            key: \"report\",\n            label: &lt;Link to=\"/reports\"&gt;Reports&lt;/Link&gt;,\n            icon: &lt;MailOutlined /&gt;,\n        },\n        {\n            key: \"profile\",\n            label: \"Profile\",\n            icon: &lt;AppstoreOutlined /&gt;,\n            children: [\n                {\n                    key: \"editProfile\",\n                    label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;,\n                },\n                {\n                    key: \"changePassword\",\n                    label: &lt;Link to=\"/profile/change-password\"&gt;Change password&lt;/Link&gt;,\n                },\n            ],\n        },\n    ];\n\n    // Function to find the selected menu key based on the current route\n    const findSelectedKey = (items) =&gt; {\n        for (const item of items) {\n            if (item.children) {\n                const selectedChild = findSelectedKey(item.children);\n                if (selectedChild) return selectedChild;\n            }\n            if (\n                React.isValidElement(item.label) &amp;&amp;\n                item.label.props.to === location.pathname\n            ) {\n                return item.key;\n            }\n        }\n        return null;\n    };\n\n    const selectedKey = findSelectedKey(items);\n\n    // Show the Drawer on small screens (mobile view)\n    const showDrawer = () =&gt; {\n        setVisible(true);\n    };\n\n    // Close the Drawer\n    const onClose = () =&gt; {\n        setVisible(false);\n    };\n\n    return (\n        &lt;&gt;\n        {/* Drawer for Mobile View */}\n        &lt;Button\n            className=\"mobile-menu-button\"\n            type=\"primary\"\n            onClick={showDrawer}\n            style={{\n                display: sm ? \"none\" : \"block\", // Hide on larger screens\n            }}\n        &gt;\n            Menu\n        &lt;/Button&gt;\n\n        &lt;Drawer\n            title=\"Menu\"\n            placement=\"left\"\n            closable={true}\n            onClose={onClose}\n            visible={visible}\n            width={240} // Customize the width of the drawer\n        &gt;\n            &lt;Menu\n                mode=\"inline\"\n                selectedKeys={[selectedKey]}\n                items={items}\n                onClick={onClose} // Close drawer when item is clicked\n            /&gt;\n        &lt;/Drawer&gt;\n\n        {/* Sidebar for Desktop View */}\n        &lt;div\n            style={{\n                width: collapsed ? 80 : width,\n                display: sm ? \"none\" : \"block\", // Hide on mobile\n            }}\n        &gt;\n            &lt;Menu\n                mode=\"inline\"\n                inlineCollapsed={collapsed}\n                selectedKeys={[selectedKey]}\n                items={items}\n                style={{ width: \"100%\" }}\n            /&gt;\n        &lt;/div&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <p>1.  <code>useBreakpoint</code> Hook:</p> <ul> <li>We are using Ant Design's <code>useBreakpoint</code> hook to determine if the screen size is small (<code>sm</code> breakpoint) and switch between the sidebar and drawer accordingly.</li> </ul> <p>2.  Drawer Implementation:</p> <ul> <li>The mobile drawer is shown using the <code>Drawer</code> component from Ant Design.</li> <li>A button (<code>Menu</code> button) is displayed only on mobile (based on the screen size).</li> <li>When clicked, the <code>Drawer</code> slides in from the left and shows the same menu items.</li> </ul> <p>3.  Toggle Logic:</p> <ul> <li><code>showDrawer</code> and <code>onClose</code> are used to open and close the drawer.</li> <li>The drawer is visible when <code>visible</code> is <code>true</code>.</li> </ul> <p>4.  Responsive Layout:</p> <ul> <li>The sidebar (<code>&lt;div&gt;</code> containing <code>Menu</code>) is hidden on mobile (<code>sm</code> breakpoint).</li> <li>The button to open the drawer is only visible on mobile.</li> </ul> Result <ul> <li>Mobile View: A collapsible <code>Drawer</code> that appears when the \"Menu\" button is clicked.</li> <li>Desktop View: A regular sidebar with the menu items visible, and it respects the <code>collapsed</code> state.</li> </ul>"},{"location":"package/ui/antd/antd-breakpoint/#reference","title":"Reference","text":"<ul> <li>Antd useBreakpoint Hook</li> <li>Antd Drawer</li> <li></li> </ul>"},{"location":"package/ui/antd/antd-configprovider/","title":"antd ConfigProvider","text":""},{"location":"package/ui/antd/antd-configprovider/#configprovider-overview","title":"ConfigProvider Overview","text":"<p>The <code>ConfigProvider</code> component was introduced in Ant Design v4. It was added to provide a centralized way to configure and customize various aspects of the library globally, such as theming, localization, or component-specific configurations.</p> Key Features of <code>ConfigProvider</code>:Example of using ConfigProvider: <ul> <li>Global Configuration: Allows you to globally configure properties like themes, locale, direction, etc., for all Ant Design components.</li> <li>Customizing Themes: You can pass configuration like primary color, component styles, or font sizes.</li> <li>Localization: You can easily set locale (language settings) across all components via ConfigProvider.</li> <li>Global Defaults: Set default properties for certain components globally (e.g., button size, input style).</li> </ul> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider, Button } from 'antd';\nimport enUS from 'antd/es/locale/en_US';  // Example locale (English)\nimport './App.css';\n\nconst App = () =&gt; {\n    return (\n        &lt;ConfigProvider locale={enUS} theme={{ primaryColor: '#25b864' }}&gt;\n            &lt;div style={{ padding: 20 }}&gt;\n                &lt;Button type=\"primary\"&gt;Primary Button&lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('root'));\n</code></pre> <p>Notable Changes with ConfigProvider:</p> <ul> <li>Before <code>v4</code>, Ant Design relied more on inline configurations for components or directly using CSS to apply styles. <code>ConfigProvider</code> made it easier to manage global settings.</li> <li><code>ConfigProvider</code> is especially useful when you have a large application and want to control settings globally instead of configuring each component individually.</li> </ul> <p>Version Timeline:</p> <ul> <li>v4.0.0 (Released in 2020) \u2014 Introduced <code>ConfigProvider</code> as part of a major update.</li> </ul>"},{"location":"package/ui/antd/antd-configprovider/#detailed-example-of-files","title":"Detailed Example of Files","text":"src/config/theme.tssrc/index.tsxsrc/App.tsx <p>This file contains the reusable theme configuration.</p> <pre><code>// src/config/theme.ts\nimport { ThemeConfig } from 'antd/es/config-provider/context';\n\n// Define the default theme configuration\nexport const themeConfig: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Primary green color\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\n// Example of another theme (optional, for dynamic switching or theming)\nexport const darkTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#000000',  // Dark theme (black)\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\nexport const lightTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Light theme (green)\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n</code></pre> <p>Here, you set up the root rendering of the app and apply the ConfigProvider with the theme configuration.</p> <pre><code>// src/index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider } from 'antd';\nimport App from './App';\nimport 'antd/dist/reset.css';  // Ant Design reset CSS\nimport { themeConfig } from './config/theme';  // Import the reusable theme configuration\n\nReactDOM.render(\n    &lt;ConfigProvider theme={themeConfig}&gt;\n        &lt;App /&gt;\n    &lt;/ConfigProvider&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>This is the main application component where you can manage the layout and add logic to toggle themes, etc.</p> <pre><code>// src/App.tsx\nimport React, { useState } from 'react';\nimport { Button, ConfigProvider } from 'antd';\nimport { themeConfig, darkTheme, lightTheme } from './config/theme';  // Import theme config\n\nconst App: React.FC = () =&gt; {\n    const [theme, setTheme] = useState(themeConfig);\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === lightTheme ? darkTheme : lightTheme);\n    };\n\n    return (\n        &lt;ConfigProvider theme={theme}&gt;\n            &lt;div style={{ padding: '50px' }}&gt;\n                &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n                Toggle Theme\n                &lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p><code>src/components/Button.tsx</code></p> <p>Example of a simple button component that uses Ant Design\u2019s <code>Button</code> component. You can create reusable components like this.</p> <pre><code>// src/components/Button.tsx\nimport React from \"react\";\nimport { Button as AntButton, ButtonProps } from \"antd\";\n\n// Custom Button component that wraps Ant Design's Button\nconst Button: React.FC&lt;ButtonProps&gt; = (props) =&gt; {\n  return &lt;AntButton {...props} /&gt;;\n};\n\nexport default Button;\n</code></pre> <p><code>src/pages/Home.tsx</code></p> <p>Example of a page component (<code>Home.tsx</code>), which might contain layout and specific content for the home page.</p> <pre><code>// src/pages/Home.tsx\nimport React from \"react\";\nimport { Button } from \"antd\";\n\nconst Home: React.FC = () =&gt; {\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;h1&gt;Welcome to the Home Page&lt;/h1&gt;\n      &lt;Button type=\"primary\"&gt;Primary Button&lt;/Button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\n</code></pre> <p><code>src/styles/global.css (optional)</code></p> <p>If you need global styles (not using CSS-in-JS or styled-components), you can add a <code>global.css</code> file for general layout, spacing, or custom styles.</p> <pre><code>/* src/styles/global.css */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  padding: 0;\n}\n\nh1 {\n  color: #333;\n}\n</code></pre> <p>Make sure to import the global styles in your index.tsx or App.tsx if needed:</p> <pre><code>// src/index.tsx\nimport \"./styles/global.css\"; // Import global styles (if you use plain CSS)\n</code></pre>"},{"location":"package/ui/antd/antd-configprovider/#summary-of-folder-structure","title":"Summary of Folder Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 assets/                 # Optional assets (images, icons, etc.)\n\u251c\u2500\u2500 components/             # Reusable components like Button, Card, etc.\n\u2502   \u251c\u2500\u2500 Button.tsx          # Custom button component\n\u2502   \u2514\u2500\u2500 CustomCard.tsx      # Another reusable component\n\u251c\u2500\u2500 config/                 # Configuration for themes, API, etc.\n\u2502   \u2514\u2500\u2500 theme.ts            # Theme configuration file for Ant Design\n\u251c\u2500\u2500 pages/                  # Components representing different pages\n\u2502   \u251c\u2500\u2500 Home.tsx            # Home page component\n\u2502   \u2514\u2500\u2500 Dashboard.tsx       # Dashboard page component\n\u251c\u2500\u2500 styles/                 # Global or custom styles\n\u2502   \u2514\u2500\u2500 global.css          # Global CSS styles (if used)\n\u251c\u2500\u2500 App.tsx                 # Main app component\n\u251c\u2500\u2500 index.tsx               # React entry point\n\u2514\u2500\u2500 theme.ts                # Reusable theme config for Ant Design (could be merged into `config/`)\ntsconfig.json               # TypeScript configuration\npackage.json                # Project dependencies and scripts\n</code></pre> <p>This structure is flexible, scalable, and ensures that your theme configuration and components remain reusable and maintainable.</p>"},{"location":"package/ui/antd/antd-configprovider/#what-to-define-in-configprovider","title":"What to Define in ConfigProvider","text":"<p>ConfigProvider in Ant Design is a powerful tool for centralizing and managing global configurations for your application. However, there are some best practices for what you should define within ConfigProvider and what you should avoid. Here's a breakdown of what to define only in ConfigProvider and what you might want to handle elsewhere:</p> Summary: What to Define in <code>ConfigProvider</code> <ul> <li>Global Theme Settings (e.g., colors, fonts, border radius)</li> <li>Locale (for internationalization)</li> <li>Global Component Defaults (e.g., button size, notification duration)</li> <li>Layout Direction (LTR/RTL)</li> </ul> What to Avoid Defining in <code>ConfigProvider</code> <ul> <li>Specific Component Styles (use CSS or styled-components for this)</li> <li>Component-Specific Props (use props directly on components)</li> <li>Custom CSS Styles (use external stylesheets or CSS-in-JS)</li> <li>State or Business Logic (handle this in your components or state management)</li> </ul> <p>By following these guidelines, you can make the most out of ConfigProvider while keeping your code clean and maintainable. Let me know if you need more help!</p> <pre><code>const lightTheme = {\n  token: {\n    colorPrimary: \"#1890ff\", // Primary button color, etc.\n    colorText: \"#000000\", // Primary text color (black in light theme)\n    colorBackground: \"#ffffff\", // Background color (white in light theme)\n    colorTextSecondary: \"#8c8c8c\", // Secondary text color (gray)\n    fontFamily: \"Arial, sans-serif\",\n    borderRadiusBase: \"4px\", // Default border radius for components\n  },\n};\n\nconst darkTheme = {\n  token: {\n    colorPrimary: \"#1890ff\", // Same primary color for buttons\n    colorText: \"#ffffff\", // Primary text color (white in dark theme)\n    colorBackground: \"#333333\", // Dark background color\n    colorTextSecondary: \"#888888\", // Secondary text color (light gray)\n    fontFamily: \"Arial, sans-serif\",\n    borderRadiusBase: \"4px\", // Border radius for components\n  },\n};\n</code></pre>"},{"location":"package/ui/antd/antd-configprovider/#question","title":"Question","text":""},{"location":"package/ui/antd/antd-configprovider/#question-1","title":"Question 1","text":"<p>why are we using the two times the ConfigProvider in index.tsx and App.tsx</p> <p>You're right to question that! Using ConfigProvider in both index.tsx and App.tsx would be redundant in most cases. Generally, ConfigProvider should be used once at the root level (in index.tsx), and there's no need to wrap it again in App.tsx unless you specifically want to override the theme at a more localized level (like in a specific page or component).</p>"},{"location":"package/ui/antd/antd-configprovider/#corrected-approach","title":"Corrected Approach","text":"<p>You should use ConfigProvider only once at the top-level (in index.tsx). Here\u2019s the corrected approach:</p> <p>src/index.tsx</p> <p>The <code>ConfigProvider</code> should be applied here, wrapping the entire application, so the theme is accessible globally across all components.</p> <pre><code>// src/index.tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { ConfigProvider } from \"antd\";\nimport App from \"./App\";\nimport \"antd/dist/reset.css\"; // Ant Design reset CSS\nimport { themeConfig } from \"./config/theme\"; // Import the reusable theme configuration\n\nReactDOM.render(\n  &lt;ConfigProvider theme={themeConfig}&gt;\n    &lt;App /&gt;\n  &lt;/ConfigProvider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> <p>src/App.tsx</p> <p>Since the <code>ConfigProvider</code> is already wrapped in <code>index.tsx</code>, you don\u2019t need to use it again here unless you're applying a different theme for a specific part of the app. So, you can simply use <code>App</code> as a regular component:</p> <pre><code>// src/App.tsx\nimport React, { useState } from \"react\";\nimport { Button } from \"antd\";\nimport { darkTheme, lightTheme } from \"./config/theme\"; // Import theme config\n\nconst App: React.FC = () =&gt; {\n  const [theme, setTheme] = useState(lightTheme); // Start with light theme\n\n  const toggleTheme = () =&gt; {\n    setTheme(theme === lightTheme ? darkTheme : lightTheme); // Toggle theme\n  };\n\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n        Toggle Theme\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>Explanation:</p> <ol> <li><code>ConfigProvider</code> in <code>index.tsx</code>: This is where you define and provide the theme globally for the entire application.</li> <li>No <code>ConfigProvider</code> in <code>App.tsx</code>: Since <code>ConfigProvider</code> is already at the root level in <code>index.tsx</code>, there\u2019s no need to wrap <code>App</code> with it again unless you're overriding the theme for specific parts of the app.</li> </ol> <p>If you did want to override the theme for a specific part of the app (for example, in a particular page or component), you could use a second <code>ConfigProvider</code> inside <code>App.tsx</code>, but that would be for localized theming, not for global theming.</p> <p>Conclusion:</p> <p>You only need to use <code>ConfigProvider</code> once in the root component (<code>index.tsx</code>), and then the theme will be applied globally to all components. If you need to override the theme for specific components or pages, you can wrap those parts with another <code>ConfigProvider</code> inside <code>App.tsx</code> or other child components.</p>"},{"location":"package/ui/antd/antd-configprovider/#question-2","title":"Question 2","text":"<p>if we toogle theme does it changes the global theme.</p> <p>Great question! The short answer is no, toggling the theme locally within a component like <code>App.tsx</code> (or other parts of the app) does not automatically update the global theme across the entire app unless you manage the theme state at a global level.</p> <p>How ConfigProvider Works</p> <p>The <code>ConfigProvider</code> in Ant Design provides a global theme configuration to all child components. When you use <code>ConfigProvider</code> with a specific theme, that <code>theme</code> will apply to all of its children. However, if you try to toggle the theme locally (within a single component), it won't update the global theme for the entire app unless you make the theme state management global.</p> <p>How to Achieve Global Theme Toggling</p> <p>To toggle the theme globally (across the entire app), you need to lift the theme state up to a higher level, likely at the root of your application. This way, when the theme is toggled, it will affect the entire app, and the <code>ConfigProvider</code> will re-render with the new theme.</p> <p>Here\u2019s how you can implement global theme toggling properly:</p> <ol> <li> <p>Lift the Theme State to the Root Level</p> <p>You\u2019ll want to manage the theme state at the top level (usually in <code>index.tsx</code> or a <code>ThemeProvider</code> component) so that toggling the theme updates the global configuration. You can then pass this state down to <code>ConfigProvider</code>.</p> </li> <li> <p>Update the Theme Dynamically</p> <p>When the theme changes, you need to update the <code>ConfigProvider</code> dynamically. This will allow you to apply the theme globally.</p> </li> </ol> <p>Example Implementation</p> 1. src/index.tsx (Root Component)2. src/App.tsx3. src/config/theme.ts <p>In this example, the theme state is managed in the root component (<code>index.tsx</code>), and the <code>ConfigProvider</code> is updated dynamically when the theme changes.</p> <pre><code>// src/index.tsx\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider } from 'antd';\nimport App from './App';\nimport 'antd/dist/reset.css';  // Ant Design reset CSS\nimport { themeConfig, darkTheme, lightTheme } from './config/theme';  // Import theme configs\n\n// Manage the theme globally\nconst Root: React.FC = () =&gt; {\n    const [theme, setTheme] = useState(lightTheme);  // Initial theme\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === lightTheme ? darkTheme : lightTheme);  // Toggle between light and dark\n    };\n\n    return (\n        &lt;ConfigProvider theme={theme}&gt;\n            &lt;App toggleTheme={toggleTheme} /&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nReactDOM.render(&lt;Root /&gt;, document.getElementById('root'));\n</code></pre> <p>In <code>App.tsx</code>, we now receive the <code>toggleTheme</code> function as a prop and use it to toggle the theme globally.</p> <pre><code>// src/App.tsx\nimport React from 'react';\nimport { Button } from 'antd';\n\ninterface AppProps {\ntoggleTheme: () =&gt; void;\n}\n\nconst App: React.FC&lt;AppProps&gt; = ({ toggleTheme }) =&gt; {\n    return (\n        &lt;div style={{ padding: '50px' }}&gt;\n            &lt;h1&gt;Global Theme Toggle&lt;/h1&gt;\n            &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n                Toggle Theme\n            &lt;/Button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>Define both the light and dark theme configurations as before.</p> <pre><code>// src/config/theme.ts\nimport { ThemeConfig } from 'antd/es/config-provider/context';\n\n// Default light theme\nexport const lightTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Green\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\n// Dark theme configuration\nexport const darkTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#000000',  // Dark\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n</code></pre> <p>Key Points:</p> <ul> <li><code>ConfigProvider</code> is now wrapped around the whole app (<code>Root</code> component in <code>index.tsx</code>), which allows the theme to be shared globally.</li> <li><code>toggleTheme</code> is lifted to the root (Root component) so that when the theme is toggled, the entire app re-renders with the new theme.</li> <li>The <code>theme</code> is passed down as a prop to <code>ConfigProvider</code>, ensuring that the theme is dynamically updated across the entire app when it changes.</li> </ul> <p>How This Works:</p> <ul> <li>Initially, <code>lightTheme</code> is applied by default (via useState).</li> <li>When the \"Toggle Theme\" button is clicked, it triggers <code>toggleTheme</code>, which switches the theme between <code>lightTheme</code> and <code>darkTheme</code>.</li> <li>Because <code>ConfigProvider</code> is wrapping the entire app, the change in theme will be reflected globally.</li> </ul> <p>Conclusion:</p> <p>By managing the theme state at the root level (<code>index.tsx</code> or <code>Root</code> component), toggling the theme will update the global theme via <code>ConfigProvider</code>, ensuring that the entire app is consistently themed.</p>"},{"location":"package/ui/antd/antd-configprovider/#reference","title":"Reference","text":"<ul> <li>ConfigProvider</li> </ul>"},{"location":"package/ui/antd/antd-render-func/","title":"render function","text":""},{"location":"package/ui/antd/antd-render-func/#overview","title":"Overview","text":"<p>In Ant Design (antd), the <code>render</code> function in table columns is crucial for customizing how data is displayed in each cell. Here\u2019s a breakdown of what the <code>render</code> function does and the implications of not using it.</p> What the <code>render</code> Function DoesWhat Happens If You Don\u2019t Use It <ol> <li> <p>Custom Display: The <code>render</code> function allows you to define how the cell content is rendered. You can return simple text, formatted HTML, or even React components.</p> </li> <li> <p>Access to Data: The function provides access to predefined parameters, such as:</p> <ul> <li><code>text</code>: The value of the current cell.</li> <li><code>record</code>: The entire row data.</li> <li><code>index</code>: The row index.</li> <li><code>column</code>: The column configuration.</li> </ul> </li> <li> <p>Conditional Formatting: You can implement conditional logic to change styles or display different content based on the data.</p> </li> <li> <p>Interactive Elements: It allows you to include interactive components (like buttons or links) in the cells.</p> </li> </ol> <ol> <li> <p>Default Rendering: If you do not define a <code>render</code> function for a column, the table will use the default rendering behavior, which simply displays the value specified by the <code>dataIndex</code> of that column.</p> </li> <li> <p>Limited Customization: You won\u2019t be able to apply any custom formatting or conditional rendering. For example, you can't change the text color based on a condition or render a button.</p> </li> <li> <p>Static Content: The content will be static and only reflect the data from the data source without any interactivity or enhancements.</p> </li> </ol> <p>Example Comparison</p> <ul> <li>Using <code>render</code></li> </ul> <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n    render: (text) =&gt; (\n        &lt;span style={{ color: text &gt; 40 ? 'red' : 'black' }}&gt;{text}&lt;/span&gt;\n    ),\n}\n</code></pre> <ul> <li> <p>Outcome: The age will be displayed in red if greater than 40.</p> </li> <li> <p>Not Using <code>render</code></p> </li> </ul> <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n}\n</code></pre> <ul> <li>Outcome: The age will simply be displayed as-is without any custom styling or logic.</li> </ul> <p>Summary</p> <p>Using the <code>render</code> function in antd tables is essential for customizing how data is presented and interacted with. Not using it limits the table's flexibility and functionality, resulting in a more static and less engaging user experience. If you have further questions or need more examples, feel free to ask!</p>"},{"location":"package/ui/antd/antd-render-func/#what-is-the-use-_-of-render-function","title":"What is the use <code>_</code> of render function","text":"<p>In Ant Design (antd) and in JavaScript in general, the underscore (<code>_</code>) can be used in several contexts, especially in function parameters. Here\u2019s a breakdown of its typical usage and when to use it:</p> <p>Common Uses of <code>_</code> in Ant Design</p> <ol> <li> <p>Ignoring Parameters:</p> <ul> <li> <p>If a function receives more parameters than it actually uses, you can use <code>_</code> to indicate that you are intentionally ignoring those parameters. This is common in the render function of table columns, where you might not need all available parameters.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>render: (text, record, _) =&gt; {\n  return &lt;span&gt;{text}&lt;/span&gt;; // Ignoring the third parameter\n};\n</code></pre> </li> <li> <p>Placeholder for Unused Values:</p> <ul> <li> <p>Similar to ignoring parameters, <code>_</code> can act as a placeholder to clarify that certain parameters are not needed, making the code more readable.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>render: (text, _, index) =&gt; {\n  return (\n    &lt;span&gt;\n      {index + 1}: {text}\n    &lt;/span&gt;\n  ); // Using only `text` and `index`\n};\n</code></pre> </li> </ol> When to Use <code>_</code>When Not to Use <code>_</code> <ul> <li>Readability: Use <code>_</code> when it improves the readability of your code by making it clear which parameters are not utilized.</li> <li>Indicating Intent: If you want to show that a parameter is intentionally ignored (e.g., to prevent warnings about unused parameters), use <code>_</code>.</li> </ul> <ul> <li>Meaningful Parameters: If a parameter is meaningful and could be useful later, don\u2019t ignore it. Instead, use descriptive names or utilize the parameter in your logic.</li> <li>Confusion: Avoid using <code>_</code> if it may cause confusion. For instance, if the context of the parameters isn\u2019t clear, it\u2019s better to use more descriptive variable names.</li> </ul> <p>Example in an Ant Design Table</p> <p>Here's how you might see <code>_</code> used in a typical antd table render function:</p> <pre><code>const columns = [\n  {\n    title: \"Name\",\n    dataIndex: \"name\",\n    render: (text, record, _) =&gt; (\n      &lt;span&gt;\n        {text} (ID: {record.key})\n      &lt;/span&gt;\n    ),\n  },\n  {\n    title: \"Age\",\n    dataIndex: \"age\",\n    render: (_, record) =&gt; &lt;span&gt;{record.age} years old&lt;/span&gt;,\n  },\n];\n</code></pre> <p>Summary</p> <p>Using <code>_</code> is a helpful convention to improve code clarity and manage unused parameters in your functions. Use it when you want to indicate that certain parameters are intentionally ignored or unnecessary, but avoid it if it could lead to confusion or if you might need the parameter later. If you have any more questions or need further clarification, feel free to ask!</p>"},{"location":"package/ui/antd/antd-render-func/#parameter-order-in-render-function","title":"Parameter Order in <code>render</code> Function","text":"<p>In Ant Design (antd), the render function for table columns typically accepts parameters in a specific order. Understanding this order is crucial for utilizing the data effectively. Here's the standard parameter order and what each parameter represents:</p> <p>Standard Parameter Order in render Function</p> <ul> <li><code>text</code>: The content of the cell, usually the value from the data source corresponding to the <code>dataIndex</code>.</li> <li><code>record</code>: The entire row data for the current row.</li> <li><code>index</code> (optional): The index of the current row in the data source.</li> <li><code>column</code> (optional): The column configuration object.</li> </ul> <p>Example</p> <pre><code>{\n  title: 'Name',\n  dataIndex: 'name',\n  render: (text, record, index, column) =&gt; {\n    return &lt;span&gt;{text} (Row: {index + 1})&lt;/span&gt;;\n  },\n}\n</code></pre> Is It Necessary to Pass Arguments in Order? <ul> <li> <p>Yes, it is necessary to follow the order:</p> <p>The parameters must be in the expected order if you plan to use them. If you do not use them as intended, you might not access the correct values.</p> </li> </ul> What Happens If You Don\u2019t Pass Parameters in Order? <ol> <li> <p>Incorrect Values:</p> <p>If you mix up the parameters, you might end up accessing the wrong data. For example, treating <code>record</code> as <code>text</code> could lead to unexpected behavior.</p> </li> <li> <p>Undefined Behavior:</p> <p>If you try to access properties or methods that don't exist on the wrongly assigned parameter, it could result in runtime errors.</p> </li> </ol> Example of Incorrect OrderUsing Only Required Parameters <p>If you try to change the order or omit certain parameters:</p> <pre><code>{\n    title: 'Name',\n    dataIndex: 'name',\n    render: (record, text) =&gt; { // Incorrect order\n        return &lt;span&gt;{text}&lt;/span&gt;; // This will not work as intended\n    },\n}\n</code></pre> <ul> <li>In this case, <code>text</code> would receive the <code>record</code> value, leading to potential issues and incorrect output.</li> </ul> <p>If you only need some of the parameters, you can still choose to omit the ones you don\u2019t need, but you should maintain the order:</p> <pre><code>{\n    title: 'Name',\n    dataIndex: 'name',\n    render: (text) =&gt; {\n        return &lt;span&gt;{text}&lt;/span&gt;; // Only using text, omitting record and index\n    },\n}\n</code></pre> <p>Summary</p> <ul> <li>The order of parameters in the <code>render</code> function is important and should be respected to avoid confusion and ensure that you access the correct data.</li> <li>You can omit parameters you don\u2019t need, but the ones you do use must be in the correct order.</li> <li>Misordering parameters can lead to errors or unintended behavior, so always keep the defined order in mind when implementing the <code>render</code> function.</li> </ul>"},{"location":"package/ui/antd/antd-render-func/#what-happens-if-we-only-use-record","title":"What happens if we only use <code>record</code>","text":"<p>If you use the <code>render</code> function in an Ant Design (antd) table like this:</p> <pre><code>render: (record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> What Happens <ol> <li> <p>Parameter Misuse:</p> <ul> <li>The <code>render</code> function is designed to take specific parameters, typically the first being <code>text</code>, which represents the value of the cell being rendered. The second is usually <code>record</code>, which represents the entire row of data.</li> </ul> </li> <li> <p>Output:</p> <ul> <li>In this case, you are trying to directly use <code>record</code> as the only parameter. While this will technically work without throwing an error, you are not following the conventional parameter order. This means that the first parameter (the cell's value) is ignored, which could lead to confusion.</li> </ul> </li> <li> <p>Accessing Data:</p> <ul> <li>If <code>record</code> contains a <code>name</code> property, the cell will correctly display the name from that row. For example, if <code>record</code> is:</li> </ul> <pre><code>{ key: '1', name: 'John', age: 32, address: 'New York' }\n</code></pre> <p>Then the output will be:</p> <pre><code>John\n</code></pre> </li> </ol> Recommended Usage <p>While your implementation might work, it's better practice to adhere to the expected parameter order to avoid confusion and ensure clarity in your code. The standard usage would be:</p> <pre><code>render: (text, record) =&gt; {\n    return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Why It\u2019s Important to Follow the Order</p> <ol> <li> <p>Readability: Following the conventional parameter order (i.e., <code>text</code>, <code>record</code>, <code>index</code>, <code>column</code>) makes the code easier to read and understand for others (or yourself in the future).</p> </li> <li> <p>Consistency: It maintains consistency across your codebase, which is especially helpful in larger projects where multiple developers are involved.</p> </li> <li> <p>Potential Errors: Although using just <code>record</code> won\u2019t cause immediate errors, it could lead to issues if you later decide to rely on the first parameter (like <code>text</code>) for other rendering logic.</p> </li> </ol> <p>Summary</p> <p>Using just <code>record</code> in the <code>render</code> function will work as long as you access the properties correctly, but it's best practice to follow the expected parameter order. This approach enhances readability, consistency, and reduces the likelihood of confusion or errors in the future. If you have more questions or need further clarification, feel free to ask!</p>"},{"location":"package/ui/antd/antd-render-func/#ignored-parameter","title":"Ignored Parameter","text":"<p>If you don't need the <code>text</code> parameter in the <code>render</code> function, you can safely omit it by using an underscore (<code>_</code>) or just by using a single parameter (the one you need). Here\u2019s how you can do it:</p> <p>Using an Underscore to Indicate Ignored Parameter</p> <p>You can indicate that you're intentionally ignoring the <code>text</code> parameter by using an underscore:</p> <pre><code>render: (_, record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Using Only the Necessary Parameter</p> <p>Alternatively, if you prefer clarity and don\u2019t want to include an unused parameter, you can just write:</p> <pre><code>render: (record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> What Happens <ol> <li> <p>No Errors: Both of these approaches will work without throwing any errors. The <code>record</code> parameter will provide access to the entire row of data, allowing you to retrieve the <code>name</code> property.</p> </li> <li> <p>Readability:</p> <ul> <li>Using an underscore makes it clear to anyone reading the code that you are intentionally ignoring the first parameter.</li> <li>Just using <code>record</code> could lead to confusion, as it deviates from the conventional order.</li> </ul> </li> </ol> Best Practice <p>While it\u2019s technically acceptable to use just <code>record</code>, the most conventional approach is to include the <code>text</code> parameter and use an underscore or simply acknowledge that you won't be using it. This maintains consistency with the expected signature of the <code>render</code> function:</p> <pre><code>render: (_, record) =&gt; {\n    return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Summary</p> <p>You can ignore the <code>text</code> parameter in the <code>render</code> function if you don\u2019t need it. Using an underscore (<code>_</code>) is a common practice to indicate that you are intentionally ignoring that parameter, promoting code readability and maintaining conventional coding standards. If you have further questions or need more details, feel free to ask!</p>"},{"location":"package/ui/antd/antd-tree/","title":"Antd Tree","text":""},{"location":"package/ui/antd/antd-tree/#antd-tree","title":"Antd Tree","text":"<pre><code>import { Drawer, Tree, Form } from \"antd\";\nimport PermissionFooter from \"./PermissionFooter\";\nimport { useEffect } from \"react\";\n\nconst PermissionDrawer = ({\n  roleId,\n  form,\n  handleEditPermission,\n  open,\n  close,\n  loading,\n  fields,\n}) =&gt; {\n  // Response data for permissions\n  const responseData = [\n    {\n      groupName: \"Application\",\n      permissions: [\n        {\n          groupName: \"Application\",\n          type: \"Permissions\",\n          value: \"Permissions.Application.CanViewDataWeekendOnly\",\n          selected: false,\n        },\n        {\n          groupName: \"Application\",\n          type: \"Permissions\",\n          value: \"Permissions.Application.CanViewDashboard\",\n          selected: false,\n        },\n        {\n          groupName: \"Application\",\n          type: \"Permissions\",\n          value: \"Permissions.Application.CanViewDataDuringBusinessHours\",\n          selected: false,\n        },\n      ],\n    },\n    {\n      groupName: \"PermissionManagement\",\n      permissions: [\n        {\n          groupName: \"PermissionManagement\",\n          type: \"Permissions\",\n          value: \"Permissions.PermissionMgmt.CanView\",\n          selected: false,\n        },\n        {\n          groupName: \"PermissionManagement\",\n          type: \"Permissions\",\n          value: \"Permissions.PermissionMgmt.CanEdit\",\n          selected: false,\n        },\n        {\n          groupName: \"PermissionManagement\",\n          type: \"Permissions\",\n          value: \"Permissions.PermissionMgmt.CanCreate\",\n          selected: false,\n        },\n        {\n          groupName: \"PermissionManagement\",\n          type: \"Permissions\",\n          value: \"Permissions.PermissionMgmt.CanDelete\",\n          selected: false,\n        },\n      ],\n    },\n    {\n      groupName: \"UserPermissions\",\n      permissions: [\n        {\n          groupName: \"UserPermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.User.CanView\",\n          selected: false,\n        },\n        {\n          groupName: \"UserPermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.User.CanEdit\",\n          selected: false,\n        },\n        {\n          groupName: \"UserPermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.User.CanCreate\",\n          selected: false,\n        },\n        {\n          groupName: \"UserPermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.User.CanDelete\",\n          selected: false,\n        },\n      ],\n    },\n    {\n      groupName: \"RolePermissions\",\n      permissions: [\n        {\n          groupName: \"RolePermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.Role.CanView\",\n          selected: false,\n        },\n        {\n          groupName: \"RolePermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.Role.CanEdit\",\n          selected: false,\n        },\n        {\n          groupName: \"RolePermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.Role.CanCreate\",\n          selected: false,\n        },\n        {\n          groupName: \"RolePermissions\",\n          type: \"Permissions\",\n          value: \"Permissions.Role.CanDelete\",\n          selected: false,\n        },\n      ],\n    },\n  ];\n\n  // Format the response data to be used in AntD Tree\n  const treeData = responseData.map((group) =&gt; ({\n    title: group.groupName,\n    key: group.groupName, // key for group\n    children: group.permissions.map((permission) =&gt; ({\n      title: permission.value, // Title is the permission value\n      key: permission.value, // key is the permission value\n      checkable: true,\n      defaultChecked: permission.selected,\n    })),\n  }));\n\n  // Function to handle changes in Tree selection\n  const onCheck = (checkedKeys) =&gt; {\n    // Filter out the group keys and only keep the permission values\n    const permissionValues = checkedKeys.filter(\n      (key) =&gt; !responseData.some((group) =&gt; group.groupName === key) // Ensure group names are excluded\n    );\n\n    form.setFieldsValue({\n      permissions: permissionValues, // Only set selected permission values\n    });\n  };\n\n  useEffect(() =&gt; {\n    // Set initial checked permissions when opening the drawer\n    const checkedKeys = [];\n    responseData.forEach((group) =&gt;\n      group.permissions.forEach((permission) =&gt; {\n        if (permission.selected) {\n          checkedKeys.push(permission.value); // Only push the permission's value\n        }\n      })\n    );\n    form.setFieldsValue({ permissions: checkedKeys });\n  }, [responseData, form]);\n\n  return (\n    &lt;Drawer\n      title=\"Edit Permission\"\n      open={open}\n      onClose={() =&gt; close()}\n      closable={false}\n      footer={\n        &lt;PermissionFooter\n          loading={loading}\n          onCancel={close}\n          onSubmit={() =&gt; form.submit()}\n        /&gt;\n      }\n    &gt;\n      &lt;Form form={form} layout=\"vertical\" onFinish={handleEditPermission}&gt;\n        {/* Wrap Tree inside Form.Item to capture selected values */}\n        &lt;Form.Item\n          name=\"permissions\"\n          label=\"Permissions\"\n          rules={[\n            {\n              required: true,\n              message: \"Please select at least one permission!\",\n            },\n          ]}\n        &gt;\n          &lt;Tree\n            checkable\n            onCheck={onCheck}\n            defaultExpandedKeys={treeData.map((group) =&gt; group.key)}\n            treeData={treeData}\n          /&gt;\n        &lt;/Form.Item&gt;\n        {fields}\n      &lt;/Form&gt;\n    &lt;/Drawer&gt;\n  );\n};\n\nexport default PermissionDrawer;\n</code></pre>"},{"location":"package/ui/antd/antd-tree/#not-use-mutating-foreach","title":"Not use Mutating <code>forEach</code>","text":"<p>Using <code>forEach</code> in the <code>useEffect</code> hook, as shown in your code, is not necessarily bad, but there are other approaches that can be more concise and efficient, especially for transforming and collecting values.</p> Reasons to Avoid forEach: <ul> <li>Mutating State: <code>forEach</code> is used for side-effects (mutations) and is less declarative compared to array methods like <code>map</code> or <code>filter</code>, which can return a new array without modifying the original.</li> <li>Performance: While <code>forEach</code> is fine for small arrays, if your data set grows, the performance might degrade since you are iterating through each permission in a nested loop. Other methods might be faster or clearer in intention.</li> </ul>"},{"location":"package/ui/antd/antd-tree/#more-declarative-approach","title":"More Declarative Approach:","text":"<p>Instead of using <code>forEach</code>, you can use <code>reduce</code> or <code>flatMap</code> to create a new array of <code>checkedKeys</code> directly, which is more concise and functional.</p>"},{"location":"package/ui/antd/antd-tree/#example-with-flatmap","title":"Example with <code>flatMap</code>:","text":"<p>You can combine the <code>permissions</code> from all groups into a single array and then filter those that are selected.</p> <pre><code>useEffect(() =&gt; {\n  // Use flatMap to flatten the array of permissions and map to their values if selected\n  const checkedKeys = responseData.flatMap((group) =&gt;\n    group.permissions\n      .filter((permission) =&gt; permission.selected)\n      .map((permission) =&gt; permission.value)\n  );\n\n  // Set the permissions in the form\n  form.setFieldsValue({ permissions: checkedKeys });\n}, [responseData, form]);\n</code></pre> Why flatMap is Better Here: <ul> <li>Concise and Declarative: <code>flatMap</code> is more declarative than <code>forEach</code>, as it directly transforms the array of permissions into an array of <code>checkedKeys</code>.</li> <li>No Mutation: It doesn't mutate the original array or rely on side effects. Instead, it constructs a new array by mapping and filtering.</li> <li>Flattening: Since <code>flatMap</code> can flatten the results, you don\u2019t need to manually push values into an array.</li> </ul>"},{"location":"package/ui/antd/antd-tree/#example-with-reduce","title":"Example with <code>reduce</code>:","text":"<p>You could also use <code>reduce</code> if you prefer a more explicit approach.</p> <pre><code>useEffect(() =&gt; {\n  // Use reduce to accumulate selected permissions' values into checkedKeys\n  const checkedKeys = responseData.reduce((acc, group) =&gt; {\n    group.permissions.forEach((permission) =&gt; {\n      if (permission.selected) {\n        acc.push(permission.value);\n      }\n    });\n    return acc;\n  }, []);\n\n  // Set the permissions in the form\n  form.setFieldsValue({ permissions: checkedKeys });\n}, [responseData, form]);\n</code></pre> Why reduce? <ul> <li>Explicit Accumulation: <code>reduce</code> gives you more control over how the array is accumulated, which could be useful if you need more complex transformations in the future.</li> <li>Functional Approach: Like <code>flatMap</code>, <code>reduce</code> is a more functional, immutable way to work with arrays.</li> </ul> <p>Summary:</p> <ul> <li>Performance: Both <code>flatMap</code> and <code>reduce</code> are typically faster than <code>forEach</code> because they allow you to transform data in one pass.</li> <li>Conciseness: <code>flatMap</code> or <code>reduce</code> is more concise and easier to read than manually pushing values inside a <code>forEach</code>.</li> <li>Immutability: These methods create new arrays, which is generally a better practice than mutating existing arrays.</li> </ul> <p>In your case, using <code>flatMap</code> is the most efficient and readable choice. It avoids unnecessary nested <code>forEach</code> loops, is concise, and directly returns the selected permission <code>value</code> keys in one step.</p>"},{"location":"package/ui/antd/antd-tree/#updated-fixed-bug-for-collapsing-initially","title":"Updated &amp; Fixed bug for collapsing initially","text":"<p>The reason the tree might be collapsed initially, even when you're trying to expand all groups by default, is that the <code>defaultExpandedKeys</code> prop is being set too late or not being applied properly when the component first renders. This could be caused by the following:</p> Potential Causes <ol> <li> <p>Asynchronous Data Loading:</p> <ul> <li>If <code>responseData</code> is fetched asynchronously (e.g., from an API), it might not be available immediately when the component is first rendered. Since <code>defaultExpandedKeys</code> is set based on <code>responseData</code>, if it's not available at the initial render, the <code>Tree</code> will collapse by default.</li> </ul> </li> <li> <p>Missing or Delayed <code>treeData</code> Update:</p> <ul> <li>If <code>treeData</code> is derived from <code>responseData</code> and <code>responseData</code> is changing over time, the <code>Tree</code> component might not react to changes in <code>treeData</code> as you expect. This could cause it to collapse because it hasn\u2019t received the full data yet.</li> </ul> </li> </ol> Solutions <ol> <li> <p>Ensure <code>defaultExpandedKeys</code> is Correctly Set After Data is Loaded:</p> <ul> <li>You need to make sure that defaultExpandedKeys is set after the responseData is fully loaded or updated.</li> </ul> <p>You can handle this by ensuring the <code>defaultExpandedKeys</code> are set dynamically when <code>responseData</code> is available. Here's an example of how you could modify the code to handle this properly.</p> </li> <li> <p>Use <code>useEffect</code> to Update <code>defaultExpandedKeys</code>:</p> <ul> <li>You should use <code>useEffect</code> to set the <code>defaultExpandedKeys</code> once the data is loaded and available.</li> </ul> </li> </ol> Here\u2019s an improved approach<pre><code>import { useEffect, useState } from \"react\";\nimport { Drawer, Tree, Form } from \"antd\";\nimport PermissionFooter from \"./PermissionFooter\";\n\nconst PermissionDrawer = ({\n  roleId,\n  form,\n  handleEditPermission,\n  open,\n  close,\n  loading,\n  fields,\n  responseData,\n}) =&gt; {\n  const [expandedKeys, setExpandedKeys] = useState([]);\n\n  useEffect(() =&gt; {\n    // Only set expanded keys when responseData is available\n    if (responseData &amp;&amp; responseData.length &gt; 0) {\n      // Set default expanded keys to include all group keys\n      setExpandedKeys(responseData.map((group) =&gt; group.groupName));\n    }\n  }, [responseData]);\n\n  // Format the response data to be used in AntD Tree\n  const treeData = responseData.map((group) =&gt; ({\n    title: group.groupName,\n    key: group.groupName, // key for group\n    children: group.permissions.map((permission) =&gt; ({\n      title: permission.value, // Title is the permission value\n      key: permission.value, // key is the permission value\n      checkable: true,\n      defaultChecked: permission.selected,\n    })),\n  }));\n\n  // Function to handle changes in Tree selection\n  const onCheck = (checkedKeys) =&gt; {\n    const permissionValues = checkedKeys.filter(\n      (key) =&gt; !responseData.some((group) =&gt; group.groupName === key) // Ensure group names are excluded\n    );\n    form.setFieldsValue({\n      permissions: permissionValues, // Only set selected permission values\n    });\n  };\n\n  useEffect(() =&gt; {\n    // Set initial checked permissions when opening the drawer\n    const checkedKeys = responseData.flatMap((group) =&gt;\n      group.permissions\n        .filter((permission) =&gt; permission.selected)\n        .map((permission) =&gt; permission.value)\n    );\n\n    form.setFieldsValue({ permissions: checkedKeys });\n  }, [responseData, form]);\n\n  return (\n    &lt;Drawer\n      title=\"Edit Permission\"\n      open={open}\n      onClose={() =&gt; close()}\n      closable={false}\n      footer={\n        &lt;PermissionFooter\n          loading={loading}\n          onCancel={close}\n          onSubmit={() =&gt; form.submit()}\n        /&gt;\n      }\n    &gt;\n      &lt;Form form={form} layout=\"vertical\" onFinish={handleEditPermission}&gt;\n        {/* Wrap Tree inside Form.Item to capture selected values */}\n        &lt;Form.Item\n          name=\"permissions\"\n          label=\"Permissions\"\n          rules={[\n            {\n              required: true,\n              message: \"Please select at least one permission!\",\n            },\n          ]}\n        &gt;\n          &lt;Tree\n            checkable\n            onCheck={onCheck}\n            // Ensure all groups are expanded by default\n            expandedKeys={expandedKeys} // Control the expanded state\n            treeData={treeData}\n          /&gt;\n        &lt;/Form.Item&gt;\n        {fields}\n      &lt;/Form&gt;\n    &lt;/Drawer&gt;\n  );\n};\n\nexport default PermissionDrawer;\n</code></pre> Note Key Changes:Why This Works: <ol> <li> <p><code>useState</code> for <code>expandedKeys</code>:</p> <ul> <li>Introduced a state variable <code>expandedKeys</code> to track which nodes should be expanded. Initially, it's an empty array, but it will be updated once the responseData is available.</li> </ul> </li> <li> <p><code>useEffect</code> for <code>expandedKeys</code>:</p> <ul> <li> <p>The <code>expandedKeys</code> are set inside a <code>useEffect</code> that runs when <code>responseData</code> changes. This ensures that the keys are set once the data is available.</p> </li> <li> <p>The keys for expanding are derived from the <code>responseData</code>, specifically the <code>groupName</code>.</p> </li> </ul> </li> <li> <p><code>expandedKeys</code> in the <code>Tree</code> Component:</p> <ul> <li>The <code>Tree</code> component now uses the <code>expandedKeys</code> state instead of relying on <code>defaultExpandedKeys</code>, which allows dynamic control of the expanded nodes.</li> </ul> </li> </ol> <ul> <li> <p>State-driven Expansion: By controlling the expanded keys via state (<code>expandedKeys</code>), you're ensuring that the tree is only expanded once responseData is fully loaded. This avoids the issue where the tree might collapse if the responseData hasn't been loaded when the component first renders.</p> </li> <li> <p>Efficient Update: The <code>expandedKeys</code> state is updated reactively via <code>useEffect</code>, which makes sure the tree expands only after the data is fully available.</p> </li> </ul> <p>This solution should solve the issue of the tree being collapsed initially, ensuring all groups are expanded by default as soon as the data is available.</p>"},{"location":"package/ui/antd/antd-tree/#collapse-when-click-on-dropdown-icon","title":"Collapse when click on dropdown icon","text":"<p>The reason you can collapse the tree when clicking the icon is likely due to the default behavior of the <code>Tree</code> component in Ant Design. The <code>Tree</code> component, by default, allows users to toggle the expansion of nodes by clicking the expand/collapse icon, even if you set <code>expandedKeys</code> to control which nodes are expanded.</p> <p>If you want to prevent users from collapsing the nodes (i.e., make the tree fully expanded and not allow collapse), you can use the following approaches:</p>"},{"location":"package/ui/antd/antd-tree/#option-1-disable-the-collapse-behavior-using-onexpand","title":"Option 1: Disable the Collapse Behavior Using <code>onExpand</code>","text":"<p>You can control the expansion of the <code>Tree</code> using the <code>onExpand</code> prop. By providing a custom function for <code>onExpand</code>, you can prevent users from collapsing any nodes.</p> <pre><code>import { useEffect, useState } from \"react\";\nimport { Drawer, Tree, Form } from \"antd\";\nimport PermissionFooter from \"./PermissionFooter\";\n\nconst PermissionDrawer = ({\n  roleId,\n  form,\n  handleEditPermission,\n  open,\n  close,\n  loading,\n  fields,\n  responseData,\n}) =&gt; {\n  const [expandedKeys, setExpandedKeys] = useState([]);\n\n  useEffect(() =&gt; {\n    if (responseData &amp;&amp; responseData.length &gt; 0) {\n      // Set expanded keys to include all group keys (expand all groups by default)\n      setExpandedKeys(responseData.map((group) =&gt; group.groupName));\n    }\n  }, [responseData]);\n\n  const treeData = responseData.map((group) =&gt; ({\n    title: group.groupName,\n    key: group.groupName, // key for group\n    children: group.permissions.map((permission) =&gt; ({\n      title: permission.value, // Title is the permission value\n      key: permission.value, // key is the permission value\n      checkable: true,\n      defaultChecked: permission.selected,\n    })),\n  }));\n\n  const onExpand = (expandedKeys) =&gt; {\n    // Prevent collapse by resetting the expanded keys to the current state (i.e., do nothing when expanding)\n    setExpandedKeys(expandedKeys); // This will still allow expanding, but won't allow collapsing\n  };\n\n  const onCheck = (checkedKeys) =&gt; {\n    const permissionValues = checkedKeys.filter(\n      (key) =&gt; !responseData.some((group) =&gt; group.groupName === key) // Ensure group names are excluded\n    );\n    form.setFieldsValue({\n      permissions: permissionValues, // Only set selected permission values\n    });\n  };\n\n  useEffect(() =&gt; {\n    const checkedKeys = responseData.flatMap((group) =&gt;\n      group.permissions\n        .filter((permission) =&gt; permission.selected)\n        .map((permission) =&gt; permission.value)\n    );\n    form.setFieldsValue({ permissions: checkedKeys });\n  }, [responseData, form]);\n\n  return (\n    &lt;Drawer\n      title=\"Edit Permission\"\n      open={open}\n      onClose={() =&gt; close()}\n      closable={false}\n      footer={\n        &lt;PermissionFooter\n          loading={loading}\n          onCancel={close}\n          onSubmit={() =&gt; form.submit()}\n        /&gt;\n      }\n    &gt;\n      &lt;Form form={form} layout=\"vertical\" onFinish={handleEditPermission}&gt;\n        &lt;Form.Item\n          name=\"permissions\"\n          label=\"Permissions\"\n          rules={[\n            {\n              required: true,\n              message: \"Please select at least one permission!\",\n            },\n          ]}\n        &gt;\n          &lt;Tree\n            checkable\n            onCheck={onCheck}\n            expandedKeys={expandedKeys}\n            onExpand={onExpand} // Listen to expansion\n            treeData={treeData}\n          /&gt;\n        &lt;/Form.Item&gt;\n        {fields}\n      &lt;/Form&gt;\n    &lt;/Drawer&gt;\n  );\n};\n\nexport default PermissionDrawer;\n</code></pre> Note Key Change:How It Works: <ul> <li><code>onExpand</code> Prop: I added the <code>onExpand</code> prop to handle the expansion and prevent the user from collapsing any group. In the provided <code>onExpand</code> function, I make sure that the <code>expandedKeys</code> state is reset to the current value, effectively preventing the collapse action.</li> </ul> <ol> <li>User Expands: When a user clicks to expand a node, the <code>onExpand</code> handler is called, and the <code>expandedKeys</code> state is updated.</li> <li>User Collapses: If the user tries to collapse a node, the <code>expandedKeys</code> will still hold the previously expanded keys, making it impossible to collapse a group.</li> </ol> <p>This way, the tree will always stay expanded, and users will not be able to collapse any of the groups.</p>"},{"location":"package/ui/antd/antd-tree/#option-2-use-expandedkeys-without-onexpand","title":"Option 2: Use <code>expandedKeys</code> Without <code>onExpand</code>","text":"<p>If you simply want to keep all nodes expanded without allowing collapsing, you can set <code>expandedKeys</code> dynamically and not provide the <code>onExpand</code> handler. The <code>expandedKeys</code> will be controlled solely by the state.</p> Example Code (Simplified):<pre><code>&lt;Tree\n  checkable\n  onCheck={onCheck}\n  expandedKeys={expandedKeys} // Make sure all groups stay expanded\n  treeData={treeData}\n/&gt;\n</code></pre> <p>This is simpler, but without the <code>onExpand</code> event, you'll need to ensure that the <code>expandedKeys</code> is always populated with all group keys that need to be expanded.</p> Summary: <ul> <li>If you don't want users to collapse nodes, use the <code>onExpand</code> prop and prevent the collapse by resetting <code>expandedKeys</code>.</li> <li>If you want full control, use <code>expandedKeys</code> directly without providing an <code>onExpand</code> handler.</li> </ul>"},{"location":"package/ui/antd/antd-tree/#reference","title":"Reference","text":"<ul> <li>Tree: Multiple-level structure list.</li> </ul>"},{"location":"package/ui/antd/controlled-components/","title":"Controlled Component","text":""},{"location":"package/ui/antd/controlled-components/#controlled-components-with-form-component","title":"Controlled Components with Form Component:","text":"<p>Ant Design provides a <code>Form</code> component that simplifies form handling. You can use controlled components and the <code>Form</code> component together to manage form state and validation easily.</p> jsx<pre><code>import { Form, Input, Button } from \"antd\";\nimport { useState } from \"react\";\n\nfunction MyForm() {\n  const [form] = Form.useForm();\n  const [formData, setFormData] = useState({});\n\n  const onFinish = (values) =&gt; {\n    console.log(\"Form submitted:\", values);\n    // Perform further actions with form data\n  };\n\n  return (\n    &lt;Form form={form} onFinish={onFinish}&gt;\n      &lt;Form.Item name=\"username\" label=\"Username\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item name=\"password\" label=\"Password\"&gt;\n        &lt;Input.Password /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n}\n</code></pre>"},{"location":"package/ui/antd/dayjs/","title":"Antd v5 dayjs","text":"<pre><code>npm install dayjs\n</code></pre> <p>Yes, as of Ant Design 5, the library has removed the <code>moment.js</code> dependency and recommends using alternatives like Day.js or date-fns for date handling. This is likely why you're encountering issues such as <code>date4.isValid is not a function</code> when trying to use Moment.js.</p> <p>The error <code>date4.isValid is not a function</code> occurs because Ant Design 5 is now expecting a different date library (like Day.js) that has the <code>.isValid()</code> method, and Moment.js is no longer being used in Ant Design's internal components.</p> <p>To solve this, you can switch to Day.js or another library supported by Ant Design 5.</p> <p>[[Why antd 5 removed moment.js from it dependency]]</p> <p>Now, we have two options to choose from:</p>"},{"location":"package/ui/antd/dayjs/#1-dayjs-supported-by-default","title":"1. dayjs (supported by default)","text":""},{"location":"package/ui/antd/dayjs/#2-date-fns","title":"2. date-fns","text":""},{"location":"package/ui/antd/dayjs/#why-the-error-occurs","title":"Why the error occurs:","text":"<p>Ant Design 5 ===doesn't support=== Moment.js out of the box anymore. If you want to continue using Moment.js despite Ant Design's switch to Day.js, you'd need to manually ensure compatibility by still importing Moment.js yourself. But it\u2019s generally recommended to switch to Day.js or another supported library to keep up with the new version of Ant Design.</p>"},{"location":"package/ui/antd/dayjs/#reference","title":"Reference","text":"<ul> <li>Installation dayjs</li> </ul>"},{"location":"package/ui/antd/dayjs/#misc","title":"MISC","text":"Criteria VirtualList Infinite Scroll Performance Excellent for large, static datasets (renders only visible items) Can cause performance issues with large datasets if not managed well User Experience Smooth scrolling with large data, but requires precise item height Seamless scroll experience but can be interrupted by loading states Implementation Complexity Requires more setup (especially with item sizes) Easy to implement with Ant Design's built-in <code>loadMore</code> prop Dynamic Content Better suited for fixed-length data, harder with dynamic sizes Works well for continuously loading dynamic data Memory Usage Optimized, low memory usage by rendering only visible items Can be higher if large datasets are loaded in memory <pre><code> &lt;List\n        dataSource={items}\n        renderItem={(item) =&gt; (\n          &lt;List.Item\n            key={item.id}\n            actions={[\n              // Individual checkbox for each item\n              &lt;Checkbox\n                checked={checkedItems.includes(item.id)}\n                onChange={(e) =&gt; handleCheckboxChange(item.id, e.target.checked)}\n              /&gt;\n            ]}\n</code></pre> <p>Which is better in Ant Design?</p> <pre><code>For performance with large static lists (like a product catalog, user list, or large table of items), VirtualList is usually the better choice. It optimizes rendering and minimizes memory usage by only rendering the items that are in the viewport.\n\nFor dynamic or continuously updating content (like a social media feed, chat app, or news feed), Infinite Scroll is a better fit as it provides a smooth, continuous experience as users scroll through content.\n</code></pre> <p>In Ant Design, VirtualList tends to be more performance-oriented and efficient for handling large, static datasets, while Infinite Scroll is great for user engagement with dynamic, constantly updating content. The choice ultimately depends on your application\u2019s needs, the size of your dataset, and whether the content is fixed or dynamically loaded.</p>"},{"location":"package/ui/antd/topic/","title":"Topic","text":"<p>Mastering Ant Design (antd) and reaching a \"god tier\" level involves a combination of understanding the core concepts, practicing extensively, and keeping up with best practices. Here\u2019s a structured approach to get you there:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li>Documentation: Start with the official Ant Design documentation. Familiarize yourself with the core components, layout system, and design principles.</li> <li>Components: Learn how to use basic components like Buttons, Forms, Tables, and Modals. Practice integrating these into a simple project.</li> </ul> </li> <li> <p>Dive Deeper</p> <ul> <li>Advanced Components: Explore more advanced components like DatePicker, Tree, and Cascader. Understand their props, events, and how they interact with other components.</li> <li>Customization: Learn how to customize Ant Design components. Understand theming and how to override default styles using Less or CSS-in-JS.</li> <li>Form Handling: Master the use of Form components for creating and validating forms, handling dynamic fields, and managing complex form layouts.</li> </ul> </li> <li> <p>Build Projects</p> <ul> <li>Small Projects: Start with small projects or components to practice what you\u2019ve learned. For example, build a dashboard using Ant Design\u2019s layout and table components.</li> <li>Complex Applications: Gradually work on more complex applications. Incorporate routing, state management (using libraries like <code>Redux</code> or <code>Zustand</code>), and API interactions.</li> </ul> </li> <li> <p>Optimize Performance</p> <ul> <li>Lazy Loading: Implement code splitting and lazy loading to optimize the performance of your application.</li> <li>Virtualization: Use techniques like windowing for rendering large lists efficiently. Libraries like <code>react-window</code> or <code>react-virtualized</code> can help.</li> </ul> </li> <li> <p>Keep Up with Updates</p> <ul> <li>Changelog: Regularly check Ant Design\u2019s changelog for updates and new features.</li> <li>Community: Engage with the community on forums, GitHub discussions, and social media to learn about best practices and emerging trends.</li> </ul> </li> <li> <p>Contribute and Collaborate</p> <ul> <li>Open Source Contribution: Contribute to the Ant Design library or its ecosystem. It\u2019s a great way to understand the internals and get feedback from other developers.</li> <li>Collaborate: Work on collaborative projects or contribute to open-source projects that use Ant Design.</li> </ul> </li> <li> <p>Best Practices</p> <ul> <li>Consistency: Maintain consistency in your UI design by following Ant Design\u2019s guidelines and patterns.</li> <li>Accessibility: Ensure your applications are accessible. Use tools and practices to make sure your UI is usable by everyone.</li> </ul> </li> <li> <p>Deepen Your Knowledge</p> <ul> <li>Source Code: Explore the source code of Ant Design to understand its inner workings.</li> <li>Performance Tuning: Learn advanced techniques for optimizing React applications, such as memoization, shouldComponentUpdate, and PureComponent.</li> </ul> </li> <li> <p>Teach and Share</p> <ul> <li>Write Articles: Share your knowledge by writing blog posts or creating tutorials.</li> <li>Talks and Workshops: Host talks or workshops to teach others and refine your understanding through teaching.</li> </ul> </li> <li> <p>Stay Curious and Experiment</p> <ul> <li>Experiment: Don\u2019t be afraid to experiment with new features or create custom components.</li> <li>Feedback Loop: Continuously seek feedback on your work and strive for improvement.</li> </ul> </li> </ol> <p>By following these steps, you\u2019ll not only master Ant Design but also become adept at creating high-quality, scalable, and maintainable user interfaces.</p>"},{"location":"package/ui/antd/twoTone-color/","title":"twoTone icon","text":""},{"location":"package/ui/antd/twoTone-color/#overview","title":"Overview","text":"<p>For <code>CloseCircleTwoTone</code>, by default, it has two colors: one for the icon's main fill and another for the outline. You can change the color of both parts using the twoToneColor prop.</p> <pre><code>&lt;CloseCircleTwoTone twoToneColor=\"red\" /&gt;\n</code></pre> <p><code>twoToneColor</code> accepts any valid CSS color value:</p> <ul> <li>Hex (\"<code>#FF0000</code>\" for red)</li> <li>RGB (\"<code>rgb(255, 0, 0)</code>\")</li> <li>Named colors (\"<code>red</code>\", \"<code>blue</code>\", etc.)</li> <li>HSL, and so on.</li> </ul> <p>How it works:</p> <ul> <li>When you use CloseCircleTwoTone, the first tone is typically the main fill, and the second tone is used for the stroke (outline) or background.</li> <li>By setting twoToneColor=\"red\", you change both the main fill and the stroke to red.</li> </ul> Example with customization<pre><code>import { CloseCircleTwoTone } from \"@ant-design/icons\";\n\n&lt;CloseCircleTwoTone twoToneColor=\"#FF0000\" /&gt;;\n</code></pre> <p>In this example, the icon will display in red with both the fill and the stroke being red.</p> <p>Default Behavior:</p> <p>If you don't specify <code>twoToneColor</code>, Ant Design uses its default color scheme (usually blue for the main tone and light gray for the secondary tone).</p> <p>So, <code>twoToneColor</code> is not a random property, but a predefined property of Ant Design icons for controlling the color scheme of two-tone icons.</p>"},{"location":"package/ui/antd/twoTone-color/#question","title":"Question","text":"<p>can't we use twoToneColor in SearchOutlined also like CloseCircleTwoTone</p> <p>No, the <code>twoToneColor</code> prop is specific to two-tone icons in Ant Design, such as <code>CloseCircleTwoTone</code>, <code>HeartTwoTone</code>, <code>CheckCircleTwoTone</code>, and other icons that are designed with two separate color tones (one for the fill and another for the outline or background).</p> <p>The <code>SearchOutlined</code> icon is a single-tone icon, which means it only uses one color for its appearance. Therefore, the <code>twoToneColor</code> prop does not work with single-tone icons like <code>SearchOutlined</code>.</p> <p>Why <code>twoToneColor</code> is not applicable to <code>SearchOutlined</code>:</p> <ul> <li><code>twoToneColor</code> is specifically intended for icons like CloseCircleTwoTone, where there are two separate color sections (e.g., the fill and the outline).</li> <li>Single-tone icons, like <code>SearchOutlined</code>, only have one color applied across the entire icon, which is why the <code>twoToneColor</code> prop is not available for them.</li> </ul> <p>How to Change the Color of SearchOutlined:</p> <p>You can still change the color of single-tone icons, including SearchOutlined, using the following methods:</p> <ol> <li> <p>Using Inline Styles (as mentioned earlier):</p> <ul> <li>Apply a custom color with the <code>style</code> prop.</li> </ul> </li> <li> <p>Using CSS Class:</p> <ul> <li>Apply a CSS class for more flexibility or dynamic styling.</li> </ul> <pre><code>/* styles.css */\n.green-icon {\n  color: green;\n}\n</code></pre> <pre><code>import { SearchOutlined } from \"@ant-design/icons\";\nimport \"./styles.css\"; // Make sure the CSS file is imported\n\n&lt;SearchOutlined className=\"green-icon\" /&gt;;\n</code></pre> </li> </ol> <p>Example with <code>SearchOutlined</code> in Green:</p> <pre><code>import { SearchOutlined } from \"@ant-design/icons\";\n\n&lt;SearchOutlined style={{ color: \"green\", fontSize: \"20px\" }} /&gt;;\n</code></pre> <p>This will apply the green color to the <code>SearchOutlined</code> icon, and you can also adjust other styles like <code>fontSize</code>, <code>padding</code>, etc.</p> <p>In Summary:</p> <ul> <li>No, you cannot use the <code>twoToneColor</code> prop with single-tone icons like <code>SearchOutlined</code>.</li> <li>To change the color of single-tone icons, you should use the <code>style</code> prop or a CSS class to set the color.</li> </ul>"},{"location":"package/ui/antd/why-antd5-removed-moment/","title":"Migration","text":"<pre><code>import dayjs from \"dayjs\";\n\n// Utility function to format a date to ISO string (UTC or local time)\nexport const formatDateToISO = (date, isUTC = true) =&gt; {\n  if (!date) return null; // Handle null or undefined input\n\n  const parsedDate = dayjs(date);\n\n  // Check if the date is valid\n  if (!parsedDate.isValid()) {\n    console.error(\"Invalid date format\", date);\n    return null;\n  }\n\n  // Convert to UTC if necessary, otherwise preserve local time\n  return isUTC ? parsedDate.utc().toISOString() : parsedDate.local().format(\"YYYY-MM-DDTHH:mm:ss.SSSZ\");\n};\n\n// Utility function to format back to 'YYYY-MM-DD'\nexport const formatDateToYMD = (date) =&gt; {\n  if (!date) return null; // Handle null or undefined input\n\n  const parsedDate = dayjs(date);\n\n  // Check if the date is valid\n  if (!parsedDate.isValid()) {\n    console.error(\"Invalid date format\", date);\n    return null;\n  }\n\n  // Format the date to 'YYYY-MM-DD'\n  return parsedDate.format(\"YYYY-MM-DD\");\n};\n\n// Example usage:\n\n// Converting to ISO (UTC or local)\nconst startDateUTC = formatDateToISO(\"2025-01-01T08:49:47.752+00:00\", true);\nconsole.log(startDateUTC);  // \"2025-01-01T08:49:47.752Z\"\n\n// Converting to local time (with timezone offset)\nconst startDateLocal = formatDateToISO(\"2025-01-01T08:49:47.752+00:00\", false);\nconsole.log(startDateLocal);  // \"2025-01-01T08:49:47.752+00:00\"\n\n// Convert back to 'YYYY-MM-DD'\nconst formattedDate = formatDateToYMD(\"2025-01-01T08:49:47.752+00:00\");\nconsole.log(formattedDate);  // \"2025-01-01\"\n</code></pre>"},{"location":"package/ui/antd/why-antd5-removed-moment/#reference","title":"Reference","text":"<ul> <li>Github: Consider removing moment.js dependence as it's now considered as a legacy project</li> <li>Docs: Migration Guide for antd5</li> <li>Docs: Moment to be a legacy project in maintenance mode.</li> </ul>"},{"location":"package/ui/antd/form/advanced-form-topic/","title":"Advanced Topic","text":""},{"location":"package/ui/antd/form/advanced-form-topic/#advanced-form-topic","title":"Advanced Form Topic","text":"<p>To make advanced forms using Ant Design (AntD) Form, it's important to understand not just how to build basic forms, but how to leverage AntD\u2019s full feature set effectively. Here are the most important things to know:</p>"},{"location":"package/ui/antd/form/advanced-form-topic/#1-form-instance-api-formuseform","title":"\ud83d\udd27 1. Form Instance API (<code>Form.useForm</code>)","text":"<ul> <li> <p>Gives you control over the form programmatically.</p> </li> <li> <p>Allows setting/getting values, triggering validation, resetting, etc.</p> </li> </ul> <pre><code>const [form] = Form.useForm();\nform.setFieldsValue({ name: \"John\" });\nform.getFieldValue(\"name\");\nform.validateFields();\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#2-validation-rules","title":"\ud83d\udcd0 2. Validation Rules","text":"<ul> <li>Use built-in validators (like <code>required</code>, <code>type</code>, <code>pattern</code>, <code>min</code>, <code>max</code>).</li> <li>For complex logic, use custom validator functions.</li> </ul> <pre><code>rules={[\n  { required: true, message: 'Name is required' },\n  {\n    validator: async (_, value) =&gt; {\n      if (!isValid(value)) return Promise.reject('Invalid!');\n    }\n  }\n]}\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#3-dynamic-fields-formlist","title":"\ud83d\udd04 3. Dynamic Fields (<code>Form.List</code>)","text":"<ul> <li>For repeating fields like adding/removing user roles, phone numbers, etc.</li> </ul> <pre><code>&lt;Form.List name=\"users\"&gt;\n  {(fields, { add, remove }) =&gt; (\n    &lt;&gt;\n      {fields.map(({ key, name }) =&gt; (\n        &lt;Form.Item name={[name, \"email\"]} key={key} /&gt;\n      ))}\n      &lt;Button onClick={() =&gt; add()}&gt;Add User&lt;/Button&gt;\n    &lt;/&gt;\n  )}\n&lt;/Form.List&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#4-dependencies-conditional-logic-dependencies-shouldupdate","title":"\ud83d\udd01 4. Dependencies &amp; Conditional Logic (<code>dependencies</code>, <code>shouldUpdate</code>)","text":"<ul> <li>Use <code>dependencies</code> to update fields based on others.</li> <li>Use <code>shouldUpdate</code> to re-render a part of the form when values change.</li> </ul> <pre><code>&lt;Form.Item noStyle shouldUpdate={(prev, curr) =&gt; prev.type !== curr.type}&gt;\n  {({ getFieldValue }) =&gt; {\n    return getFieldValue(\"type\") === \"advanced\" ? &lt;AdvancedSection /&gt; : null;\n  }}\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#5-form-state-synchronization","title":"\ud83d\udd04 5. Form State Synchronization","text":"<ul> <li>Use <code>onValuesChange</code>, <code>onFinish</code>, <code>onFieldsChange</code> for real-time sync.</li> </ul> <pre><code>&lt;Form onValuesChange={(changed, all) =&gt; console.log(all)} /&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#6-nested-fields","title":"\ud83e\uddf1 6. Nested Fields","text":"<ul> <li>Use array or dot notation for deeply nested objects.</li> </ul> <pre><code>&lt;Form.Item name={[\"user\", \"profile\", \"email\"]} /&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#7-custom-components-integration","title":"\ud83d\udcac 7. Custom Components Integration","text":"<ul> <li>Use <code>Form.Item</code> with <code>valuePropName</code> and <code>getValueFromEvent</code>.</li> </ul> <pre><code>&lt;Form.Item name=\"upload\" valuePropName=\"fileList\" getValueFromEvent={normFile}&gt;\n  &lt;Upload /&gt;\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#8-form-validation-triggers","title":"\ud83e\uddea 8. Form Validation Triggers","text":"<ul> <li>Control when validation happens with <code>validateTrigger</code>.</li> </ul> <pre><code>&lt;Form.Item name=\"email\" validateTrigger=\"onBlur\" /&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#9-initial-values","title":"\ud83d\udd04 9. Initial Values","text":"<ul> <li>Set with <code>initialValues</code> prop or <code>form.setFieldsValue</code>.</li> </ul> <pre><code>&lt;Form initialValues={{ remember: true }}&gt;\n</code></pre>"},{"location":"package/ui/antd/form/advanced-form-topic/#10-performance-optimization","title":"\ud83d\ude80 10. Performance Optimization","text":"<ul> <li>Use <code>shouldUpdate</code> or <code>Form.Item dependencies</code> carefully to prevent unnecessary re-renders.</li> <li>Use <code>memo/React.memo</code> for large or dynamic forms.</li> </ul>"},{"location":"package/ui/antd/form/advanced-form-topic/#bonus-handling-form-submission","title":"\u26a0\ufe0f Bonus: Handling Form Submission","text":"<pre><code>&lt;Form form={form} onFinish={handleSubmit}&gt;\n  &lt;Form.Item name=\"username\" /&gt;\n  &lt;Button htmlType=\"submit\" /&gt;\n&lt;/Form&gt;\n</code></pre> <p>Advanced Ant Design Form example that combines:</p> <ul> <li>\u2705 Dynamic Fields (<code>Form.List</code>)</li> <li>\u2699\ufe0f Conditional Logic (<code>shouldUpdate</code>)</li> <li>\u2705 Custom Validation</li> <li>\ud83c\udfaf Nested Fields</li> <li>\ud83d\udd04 Programmatic control using Form.useForm()</li> </ul>"},{"location":"package/ui/antd/form/antd-form-methods/","title":"Methods","text":""},{"location":"package/ui/antd/form/antd-form-methods/#form-methods","title":"Form Methods","text":"Method Purpose Use Case <code>onFinish</code> Triggered on successful form submission Handle form submission after validation <code>onFinishFailed</code> Triggered when form submission fails Handle errors on form submission <code>getFieldValue</code> Get value of a specific form field Retrieve field value programmatically <code>setFieldsValue</code> Set value for one or more form fields Update field values dynamically <code>resetFields</code> Reset the form fields to initial or empty values Reset form after submission or user action <code>validateFields</code> Manually trigger form validation Trigger validation before submitting or programmatically <code>getFieldError</code> Get error message(s) for a specific field Display errors for a field <code>getFieldsValue</code> Get values of all form fields Retrieve all form values <code>setFields</code> Set errors or other states for fields Programmatically update field errors or states <code>isFieldTouched</code> Check if a specific field has been touched Show error messages only after interaction <code>setFieldError</code> Set an error message for a specific field Trigger custom error messages for a field"},{"location":"package/ui/antd/form/antd-form-methods/#antd-form","title":"Antd Form","text":"<p>Ant Design provides the <code>form.getFieldValue</code> and <code>form.setFieldsValue</code> methods to get and set form field values, respectively</p> jsx<pre><code>const [form] = Form.useForm();\n\nconst otherFieldValue = form.getFieldValue(\"otherField\");\n\nform.setFieldsValue({\n    currentField: /* New value based on custom logic */,\n});\n\nuseEffect(() =&gt; {\n    // Set default values based on external data\n    form.setFieldsValue({\n      username: externalData.username,\n      email: externalData.email,\n    });\n}, [externalData, form]);\n</code></pre>"},{"location":"package/ui/antd/form/antd-form-methods/#antd-form-validation","title":"Antd Form Validation","text":"<p><code>Components/modals/quickAddPerson.js</code></p> Basic <pre><code>const validateEmail = (_, value) =&gt; {\n    // Basic email validation using a regular expression\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n    if (!value || emailRegex.test(value)) {\n        return Promise.resolve();\n    }\n\n    return Promise.reject(\"Invalid email address\");\n};\n\n&lt;Form.Item\n    name=\"email\"\n    label=\"Email\"\n    rules={[\n        {\n            required: true,\n            message: \"Please enter your email\",\n        },\n        {\n            validator: validateEmail,\n        },\n    ]}\n&gt;\n    &lt;Input placeholder=\"Email\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"package/ui/antd/form/antd-form-synchronus/","title":"Antd Form Synchronus","text":""},{"location":"package/ui/antd/form/antd-form-synchronus/#antd-form-is-synchronus","title":"Antd Form is Synchronus","text":"<p>In React, Ant Design's (<code>antd</code>) Form component's methods like <code>form.setFieldsValue()</code> and <code>form.getFieldValue()</code> are synchronous because they are designed to update the internal state of the form directly and trigger a re-render of the form components. This behavior aligns with how React's state management works, which is inherently synchronous.</p> <p>Here are the key reasons for this synchronous behavior:</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#1-state-management-in-react-is-synchronous","title":"1. State Management in React is Synchronous:","text":"<p>React state updates (including the internal state of an Ant Design form) are typically synchronous in the sense that when a state is updated (e.g., using <code>form.setFieldsValue()</code>), React schedules a re-render, but it doesn\u2019t immediately reflect changes within the same render cycle. The updates will be applied in the next render cycle.</p> <p>Since <code>form.setFieldsValue()</code> and similar methods are built on top of React\u2019s state management, they follow this same behavior. They set the state of the form synchronously, but the changes will be reflected after React processes the next render cycle.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#2-performance-considerations","title":"2. Performance Considerations:","text":"<p>Making form field updates asynchronous would mean additional complexity and potential performance issues because each update would have to be handled in a non-blocking way, which could potentially cause rendering inconsistencies or visual flickers. Ant Design's synchronous approach ensures that the form's state is consistently in sync with the UI and is easier to predict.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#3-reacts-virtual-dom","title":"3. React\u2019s Virtual DOM:","text":"<p>React uses a virtual DOM to optimize rendering and ensure that UI updates are efficient. When you call <code>form.setFieldsValue()</code>, the value of the form field changes, but this change is reflected when React compares the virtual DOM with the actual DOM during its reconciliation process.</p> <p>This reconciliation process is synchronous within a render cycle, and React only re-renders components after the changes have been made. The Ant Design form system is built around this pattern and relies on React's synchronous update mechanism.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#4-ant-designs-api-design","title":"4. Ant Design's API Design:","text":"<p>Ant Design\u2019s Form API, like <code>setFieldsValue()</code>, is designed to allow quick and predictable updates to form values. The form field values are set immediately, and React will re-render the form in the next cycle to reflect those changes. Making this asynchronous could complicate form state management, making it harder to track the order and timing of updates to form fields, and potentially leading to race conditions or issues with form validation.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#handling-asynchronous-form-field-updates","title":"Handling Asynchronous Form Field Updates:","text":"<p>While <code>form.setFieldsValue()</code> is synchronous, if you want to perform asynchronous operations (e.g., when fetching values from an API or performing calculations), you can manage them outside of the form's state. For example, you could use a <code>useEffect</code> hook or handle async logic before setting the form fields with the calculated data.</p> <pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    const data = await fetchSomeData();\n    form.setFieldsValue({ fieldName: data });\n  };\n\n  fetchData();\n}, []);\n</code></pre>"},{"location":"package/ui/antd/form/antd-form-synchronus/#example-of-async-handling","title":"Example of Async Handling:","text":"<p>To address situations where asynchronous data needs to be set into the form, you can perform asynchronous operations separately and then call <code>form.setFieldsValue()</code> to set the form's values once the data is ready. This makes sure the form remains consistent while respecting the synchronous nature of the form's update method.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#conclusion","title":"Conclusion:","text":"<p>In short, Ant Design's form methods are synchronous because they are tightly integrated with React's synchronous state management and rendering processes. This ensures predictable behavior and better performance. If you need to perform asynchronous operations (such as fetching data or performing calculations), you can handle that separately before updating the form values synchronously.</p>"},{"location":"package/ui/antd/form/antd-form-synchronus/#reference","title":"Reference","text":"<ul> <li>Medium, The Synchronous Nature of useState(): A Deep Dive with Code Examples</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/","title":"useWatch Hook","text":""},{"location":"package/ui/antd/form/antd-useWatch/#usewatch","title":"useWatch","text":"<pre><code>import { Form } from \"antd\";\n//\nimport { useForm, useWatch } from \"antd/es/form/Form\";\n\n// Create a form instance\nconst [form] = Form.useForm();\n// or\nconst [form] = useForm();\n\nconst dealType = Form.useWatch(\"dealType\", form);\n// or\n// Use useWatch to monitor the 'dealType' field\nconst dealType = useWatch(\"dealType\", form); // Watch 'dealType' field\n</code></pre>"},{"location":"package/ui/antd/form/antd-useWatch/#1-basic-usage-monitoring-a-single-field","title":"1. Basic Usage: Monitoring a Single Field","text":"<p>In this basic example, we'll monitor a single field, <code>dealType</code>, in a form and display its value as it changes.</p> ExampleExplanation <pre><code>import React, { useEffect } from 'react';\nimport { Form, Select, Button } from 'antd';\nimport { useForm, useWatch } from 'antd/es/form/Form';\n\nconst { Option } = Select;\n\nconst MoneyMarketDealModeEnum = {\n    Borrowing: 1,\n    Lending: 2,\n};\n\nconst BasicUseWatch = () =&gt; {\n    const [form] = useForm();\n\n    // Watch for 'dealType' field changes\n    const dealType = useWatch('dealType', form);\n\n    // Log dealType value whenever it changes\n    useEffect(() =&gt; {\n        console.log('Selected Deal Type:', dealType);\n    }, [dealType]);\n\n    return (\n        &lt;Form form={form} layout=\"vertical\"&gt;\n            &lt;Form.Item label=\"Deal Type\" name=\"dealType\" rules={[{ required: true, message: 'Please select a deal type!' }]}&gt;\n                &lt;Select placeholder=\"Select Deal Type\"&gt;\n                    &lt;Option value={MoneyMarketDealModeEnum.Borrowing}&gt;Borrowing&lt;/Option&gt;\n                    &lt;Option value={MoneyMarketDealModeEnum.Lending}&gt;Lending&lt;/Option&gt;\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n\n            &lt;Form.Item&gt;\n                &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default BasicUseWatch;\n</code></pre> <ul> <li>We used <code>useWatch</code> to track the <code>dealType</code> field.</li> <li><code>useEffect</code> hooks into the <code>dealType</code> state and logs the value every time it changes.</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/#2-watching-multiple-fields","title":"2. Watching Multiple Fields","text":"<p>If you need to watch multiple fields, you can pass an array of field names to <code>useWatch</code>. This allows you to monitor multiple values at once.</p> ExampleExplantion <pre><code>import React, { useEffect } from 'react';\nimport { Form, Input, Button, Row, Col } from 'antd';\nimport { useForm, useWatch } from 'antd/es/form/Form';\n\nconst MultipleFieldsUseWatch = () =&gt; {\n    const [form] = useForm();\n\n    // Watch multiple fields: 'dealType' and 'firstName'\n    const [dealType, firstName] = useWatch(['dealType', 'firstName'], form);\n\n    // Log values whenever any of the watched fields change\n    useEffect(() =&gt; {\n        console.log('Selected Deal Type:', dealType);\n        console.log('First Name:', firstName);\n    }, [dealType, firstName]);\n\n    return (\n        &lt;Form form={form} layout=\"vertical\"&gt;\n            &lt;Row gutter={16}&gt;\n                &lt;Col xs={24} sm={12}&gt;\n                    &lt;Form.Item label=\"Deal Type\" name=\"dealType\" rules={[{ required: true }]}&gt;\n                        &lt;Select placeholder=\"Select Deal Type\"&gt;\n                            &lt;Option value=\"Borrowing\"&gt;Borrowing&lt;/Option&gt;\n                            &lt;Option value=\"Lending\"&gt;Lending&lt;/Option&gt;\n                        &lt;/Select&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Col&gt;\n\n                &lt;Col xs={24} sm={12}&gt;\n                    &lt;Form.Item label=\"First Name\" name=\"firstName\"&gt;\n                        &lt;Input placeholder=\"Enter First Name\" /&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Col&gt;\n            &lt;/Row&gt;\n\n            &lt;Form.Item&gt;\n                &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                Submit\n                &lt;/Button&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default MultipleFieldsUseWatch;\n</code></pre> <ul> <li><code>useWatch(['dealType', 'firstName'], form)</code> allows you to watch both the <code>dealType</code> and <code>firstName</code> fields.</li> <li>The <code>useEffect</code> hook logs both values every time either field changes.</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/#3-conditional-rendering-based-on-watched-value","title":"3. Conditional Rendering Based on Watched Value","text":"<p>You can use <code>useWatch</code> to conditionally render elements based on a watched form value.</p> ExampleExplantion <pre><code>import React, { useEffect } from 'react';\nimport { Form, Input, Button, Select } from 'antd';\nimport { useForm, useWatch } from 'antd/es/form/Form';\n\nconst ConditionalRenderingUseWatch = () =&gt; {\n    const [form] = useForm();\n\n    // Watch 'dealType' to conditionally render fields\n    const dealType = useWatch('dealType', form);\n\n    return (\n        &lt;Form form={form} layout=\"vertical\"&gt;\n            &lt;Form.Item label=\"Deal Type\" name=\"dealType\" rules={[{ required: true }]}&gt;\n                &lt;Select placeholder=\"Select Deal Type\"&gt;\n                &lt;Option value=\"Borrowing\"&gt;Borrowing&lt;/Option&gt;\n                &lt;Option value=\"Lending\"&gt;Lending&lt;/Option&gt;\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n\n            {dealType === 'Borrowing' &amp;&amp; (\n                &lt;Form.Item label=\"Borrowing Amount\" name=\"amount\"&gt;\n                    &lt;Input placeholder=\"Enter Borrowing Amount\" /&gt;\n                &lt;/Form.Item&gt;\n            )}\n\n            {dealType === 'Lending' &amp;&amp; (\n                &lt;Form.Item label=\"Lending Rate\" name=\"rate\"&gt;\n                    &lt;Input placeholder=\"Enter Lending Rate\" /&gt;\n                &lt;/Form.Item&gt;\n            )}\n\n            &lt;Form.Item&gt;\n                &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                Submit\n                &lt;/Button&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default ConditionalRenderingUseWatch;\n</code></pre> <ul> <li>Depending on the value of <code>dealType</code>, different input fields (<code>amount</code> or <code>rate</code>) are conditionally rendered using <code>useWatch</code>.</li> <li>When <code>dealType</code> is \"Borrowing\", it shows the borrowing amount field. When it's \"Lending\", it shows the lending rate field.</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/#4-watching-nested-form-fields","title":"4. Watching Nested Form Fields","text":"<p>In some cases, you might want to watch nested fields in a form. This is particularly useful when you have complex forms with groups of fields.</p> ExampleExplanation <pre><code>import React, { useEffect } from 'react';\nimport { Form, Input, Button, Row, Col } from 'antd';\nimport { useForm, useWatch } from 'antd/es/form/Form';\n\nconst NestedFieldsUseWatch = () =&gt; {\n    const [form] = useForm();\n\n    // Watch nested fields inside an array or object\n    const contactInfo = useWatch('contactInfo', form);\n\n    useEffect(() =&gt; {\n        console.log('Contact Info:', contactInfo);\n    }, [contactInfo]);\n\n    return (\n        &lt;Form form={form} layout=\"vertical\" initialValues={{ contactInfo: { email: '', phone: '' } }}&gt;\n            &lt;Form.List name=\"contactInfo\"&gt;\n                {(fields) =&gt; (\n                &lt;&gt;\n                    {fields.map(({ key, fieldKey, name, field, ...restField }) =&gt; (\n                    &lt;Row key={key} gutter={16}&gt;\n                        &lt;Col span={12}&gt;\n                            &lt;Form.Item\n                                {...restField}\n                                label=\"Email\"\n                                name={[name, 'email']}\n                                fieldKey={[fieldKey, 'email']}\n                            &gt;\n                                &lt;Input placeholder=\"Enter Email\" /&gt;\n                            &lt;/Form.Item&gt;\n                        &lt;/Col&gt;\n                        &lt;Col span={12}&gt;\n                            &lt;Form.Item\n                                {...restField}\n                                label=\"Phone\"\n                                name={[name, 'phone']}\n                                fieldKey={[fieldKey, 'phone']}\n                            &gt;\n                                &lt;Input placeholder=\"Enter Phone\" /&gt;\n                            &lt;/Form.Item&gt;\n                        &lt;/Col&gt;\n                    &lt;/Row&gt;\n                    ))}\n                &lt;/&gt;\n                )}\n            &lt;/Form.List&gt;\n\n            &lt;Form.Item&gt;\n                &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                Submit\n                &lt;/Button&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default NestedFieldsUseWatch;\n</code></pre> <ul> <li><code>useWatch('contactInfo', form)</code> watches the <code>contactInfo</code> array inside the form.</li> <li>It is a good approach when dealing with dynamic form fields or form lists.</li> <li>This setup allows you to dynamically update or display data based on changes to nested fields.</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/#5-watching-form-values-for-complex-logic","title":"5. Watching Form Values for Complex Logic","text":"<p>You can use <code>useWatch</code> to implement more complex logic in your form, such as enabling/disabling fields based on multiple values.</p> ExampleExplanation <pre><code>import React, { useEffect } from 'react';\nimport { Form, Input, Button, Select, Checkbox } from 'antd';\nimport { useForm, useWatch } from 'antd/es/form/Form';\n\nconst ComplexLogicUseWatch = () =&gt; {\n    const [form] = useForm();\n\n    // Watch multiple fields to enable/disable a checkbox based on certain conditions\n    const [dealType, isLending] = useWatch(['dealType', 'isLending'], form);\n\n    useEffect(() =&gt; {\n        // You can implement complex logic based on the form values here\n        if (dealType === 'Lending' &amp;&amp; isLending) {\n            console.log('Lending logic triggered');\n        }\n    }, [dealType, isLending]);\n\n    return (\n        &lt;Form form={form} layout=\"vertical\"&gt;\n            &lt;Form.Item label=\"Deal Type\" name=\"dealType\" rules={[{ required: true }]}&gt;\n                &lt;Select placeholder=\"Select Deal Type\"&gt;\n                    &lt;Option value=\"Borrowing\"&gt;Borrowing&lt;/Option&gt;\n                    &lt;Option value=\"Lending\"&gt;Lending&lt;/Option&gt;\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n\n            &lt;Form.Item label=\"Is Lending\" name=\"isLending\" valuePropName=\"checked\"&gt;\n                &lt;Checkbox&gt;Enable Lending&lt;/Checkbox&gt;\n            &lt;/Form.Item&gt;\n\n            &lt;Form.Item&gt;\n                &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                    Submit\n                &lt;/Button&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default ComplexLogicUseWatch;\n</code></pre> <ul> <li>We're watching both <code>dealType</code> and <code>isLending</code> to implement more complex logic based on the form state.</li> <li>In this case, when <code>dealType</code> is \"Lending\" and <code>isLending</code> is checked, the console log is triggered.</li> </ul> Conclusion <ul> <li>Basic Usage: Monitoring a single field (<code>useWatch('fieldName')</code>).</li> <li>Multiple Fields: Watching multiple fields with <code>useWatch(['field1', 'field2'])</code>.</li> <li>Conditional Rendering: Dynamically render form elements based on the watched value.</li> <li>Nested Fields: Use <code>useWatch</code> for nested fields in complex forms.</li> <li>Complex Logic: Implement advanced form logic based on multiple values using <code>useWatch</code>.</li> </ul> <p>By combining <code>useWatch</code> with React's state and effects, you can build highly interactive and responsive forms in Ant Design.</p> <p>Is useWatch the Best Option?</p> <p>For most use cases, <code>useWatch</code> is highly efficient and works well with Ant Design forms, providing easy integration, real-time form value tracking, and minimal boilerplate. However, as your form grows more complex (e.g., requiring global state management, conditional logic, or field-level dependencies across various components), you might want to consider:</p> <ul> <li>Using context or state management libraries (e.g., Redux, React Context, or Recoil) for more complex or global form handling.</li> <li>Using third-party form libraries like Formik or React Hook Form if you need more advanced features like field validation, dynamic field rendering, or managing deeply nested forms.</li> <li>Optimizing with debouncing, throttling, and memoization for better performance.</li> </ul> <p>Ultimately, <code>useWatch</code> remains a solid choice for most scenarios, especially for forms where Ant Design's form system is used effectively.</p>"},{"location":"package/ui/antd/form/antd-useWatch/#throttling-or-debouncing-updates","title":"Throttling or Debouncing Updates","text":"<p>When working with dynamic forms or when fields are highly interdependent, you might experience performance issues as each field change triggers a form-wide re-render. In those cases, <code>debouncing</code> or <code>throttling</code> updates can help reduce unnecessary re-renders.</p> <ul> <li>Debouncing allows you to wait for the user to stop typing before triggering an update.</li> <li>Throttling ensures that updates occur at a fixed rate (e.g., once every 300ms).</li> </ul> Debouncing Form Value Updates with useWatch<pre><code>import React, { useState } from \"react\";\nimport { Input, Form, Button } from \"antd\";\nimport { useForm, useWatch } from \"antd/es/form/Form\";\nimport { debounce } from \"lodash\";\n\nconst DebouncedForm = () =&gt; {\n  const [form] = useForm();\n  const [inputValue, setInputValue] = useState(\"\");\n  const watchedValue = useWatch(\"inputField\", form);\n\n  const handleDebouncedChange = debounce((value) =&gt; {\n    setInputValue(value);\n  }, 500);\n\n  return (\n    &lt;Form form={form}&gt;\n      &lt;Form.Item label=\"Input Field\" name=\"inputField\"&gt;\n        &lt;Input onChange={(e) =&gt; handleDebouncedChange(e.target.value)} /&gt;\n      &lt;/Form.Item&gt;\n      &lt;div&gt;{watchedValue}&lt;/div&gt;\n      &lt;Button onClick={() =&gt; console.log(inputValue)}&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n  );\n};\n</code></pre>"},{"location":"package/ui/antd/form/antd-useWatch/#custom-hooks-for-form-state-management","title":"Custom Hooks for Form State Management","text":"<p>For more advanced state management or to avoid repeated logic across multiple forms, you can build custom hooks that combine <code>useWatch</code> and <code>useState</code> or use them with <code>useReducer</code>.</p> Custom Hook for Form State Management<pre><code>import { useState, useEffect } from \"react\";\n\nconst useFormState = (initialState = {}) =&gt; {\n  const [formValues, setFormValues] = useState(initialState);\n\n  const handleFieldChange = (fieldName, value) =&gt; {\n    setFormValues((prev) =&gt; ({\n      ...prev,\n      [fieldName]: value,\n    }));\n  };\n\n  return { formValues, handleFieldChange };\n};\n</code></pre> <p>You can integrate <code>useFormState</code> with Ant Design Form to track values manually or trigger certain behaviors when fields change.</p>"},{"location":"package/ui/antd/form/antd-useWatch/#using-useeffect-to-trigger-field-dependencies","title":"Using <code>useEffect</code> to Trigger Field Dependencies","text":"<p>For managing form fields that depend on each other (e.g., conditional fields), you might need to use <code>useEffect</code> to monitor the form values and perform some side effects.</p> <pre><code>import React, { useEffect } from \"react\";\nimport { useForm, Form, Input, Button, Select } from \"antd\";\n\nconst DependentFieldsForm = () =&gt; {\n  const [form] = useForm();\n\n  const selectedOption = form.getFieldValue(\"selectedOption\");\n\n  useEffect(() =&gt; {\n    if (selectedOption === \"option1\") {\n      form.setFieldsValue({ dependentField: \"Option 1 selected\" });\n    }\n  }, [selectedOption, form]);\n\n  return (\n    &lt;Form form={form}&gt;\n      &lt;Form.Item label=\"Select Option\" name=\"selectedOption\"&gt;\n        &lt;Select&gt;\n          &lt;Select.Option value=\"option1\"&gt;Option 1&lt;/Select.Option&gt;\n          &lt;Select.Option value=\"option2\"&gt;Option 2&lt;/Select.Option&gt;\n        &lt;/Select&gt;\n      &lt;/Form.Item&gt;\n\n      &lt;Form.Item label=\"Dependent Field\" name=\"dependentField\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n\n      &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n        Submit\n      &lt;/Button&gt;\n    &lt;/Form&gt;\n  );\n};\n\nexport default DependentFieldsForm;\n</code></pre> Best Practices for Optimizing Performance <ol> <li> <p>Avoid Overuse of <code>useWatch</code>:</p> <ul> <li>Use <code>useWatch</code> judiciously for fields that have real dependencies. Watching too many fields might lead to performance overhead. Instead, group related fields together in logical sections, and only watch the necessary fields.</li> </ul> </li> <li> <p>Memoization and <code>useMemo</code>:</p> <ul> <li>If you have complex conditional rendering or computations based on watched values, use <code>useMemo</code> to avoid unnecessary recalculations when watched values don\u2019t change.</li> </ul> </li> <li> <p>Lazy Loading/Virtualization for Large Forms:</p> <ul> <li>For extremely large forms with many fields, consider lazy loading sections or using virtualization to only render visible fields to improve performance.</li> </ul> </li> </ol>"},{"location":"package/ui/antd/form/antd-useWatch/#hooks","title":"Hooks","text":"<ul> <li>Form.useForm</li> <li>Form.useFormInstance</li> <li>Form.useWatch</li> <li>Form.Item.useStatus</li> </ul>"},{"location":"package/ui/antd/form/antd-useWatch/#reference","title":"Reference","text":"<ul> <li>Antd Form useWatch</li> </ul>"},{"location":"package/ui/antd/form/form-crud/","title":"Form CRUD","text":""},{"location":"package/ui/antd/form/form-crud/#overview","title":"Overview","text":"<p>Certainly! To create a CRUD (Create, Read, Update, Delete) interface using Ant Design (antd) with a component-based architecture, you can break down the application into reusable components. Here\u2019s a simplified example demonstrating this approach.</p>"},{"location":"package/ui/antd/form/form-crud/#1-setup","title":"1. Setup","text":"<p>First, make sure you have Ant Design installed in your project:</p> <pre><code>npm install antd\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#2-basic-structure","title":"2. Basic Structure","text":"<p>For this example, let\u2019s create a CRUD interface for managing a list of items. We will create the following components:</p> <ul> <li>ItemList: Displays the list of items.</li> <li>ItemForm: A form for creating or editing items.</li> <li>CRUDApp: The main component that ties everything together.</li> </ul>"},{"location":"package/ui/antd/form/form-crud/#3-code-example","title":"3. Code Example","text":"ItemList ComponentItemForm ComponentCRUDApp Component <p>This component will display a list of items and provide buttons to add or edit items.</p> <pre><code>// ItemList.js\nimport React from 'react';\nimport { Table, Button } from 'antd';\n\nconst ItemList = ({ items, onEdit, onDelete, onAdd }) =&gt; {\n    const columns = [\n        {\n            title: 'ID',\n            dataIndex: 'id',\n            key: 'id',\n        },\n        {\n            title: 'Name',\n            dataIndex: 'name',\n            key: 'name',\n        },\n        {\n            title: 'Actions',\n            key: 'actions',\n            render: (_, record) =&gt; (\n                &lt;&gt;\n                    &lt;Button onClick={() =&gt; onEdit(record)} style={{ marginRight: 8 }}&gt;\n                        Edit\n                    &lt;/Button&gt;\n                    &lt;Button onClick={() =&gt; onDelete(record.id)} type=\"danger\"&gt;\n                        Delete\n                    &lt;/Button&gt;\n                &lt;/&gt;\n            ),\n        },\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;Button onClick={onAdd} type=\"primary\" style={{ marginBottom: 16 }}&gt;\n                Add Item\n            &lt;/Button&gt;\n            &lt;Table dataSource={items} columns={columns} rowKey=\"id\" /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ItemList;\n</code></pre> <p>This component will handle the form for adding or editing items.</p> <pre><code>// ItemForm.js\nimport React from 'react';\nimport { Form, Input, Button, Modal } from 'antd';\n\nconst ItemForm = ({ visible, onCancel, onSubmit, initialValues }) =&gt; {\n    const [form] = Form.useForm();\n\n    React.useEffect(() =&gt; {\n        form.setFieldsValue(initialValues);\n    }, [initialValues, form]);\n\n    const handleSubmit = () =&gt; {\n        form.validateFields().then(values =&gt; {\n            onSubmit(values);\n        });\n    };\n\n    return (\n        &lt;Modal\n            visible={visible}\n            title={initialValues ? 'Edit Item' : 'Add Item'}\n            okText=\"Submit\"\n            cancelText=\"Cancel\"\n            onCancel={onCancel}\n            onOk={handleSubmit}\n        &gt;\n            &lt;Form form={form} layout=\"vertical\"&gt;\n                &lt;Form.Item name=\"id\" label=\"ID\" hidden&gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item\n                    name=\"name\"\n                    label=\"Name\"\n                    rules={[{ required: true, message: 'Please input the name!' }]}\n                &gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Modal&gt;\n    );\n};\n\nexport default ItemForm;\n</code></pre> <p>This is the main component that manages the state and handles CRUD operations.</p> <pre><code>// CRUDApp.js\nimport React, { useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport ItemList from './ItemList';\nimport ItemForm from './ItemForm';\n\nconst CRUDApp = () =&gt; {\n    const [items, setItems] = useState([]);\n    const [isFormVisible, setIsFormVisible] = useState(false);\n    const [currentItem, setCurrentItem] = useState(null);\n\n    const handleAdd = () =&gt; {\n        setCurrentItem(null);\n        setIsFormVisible(true);\n    };\n\n    const handleEdit = (item) =&gt; {\n        setCurrentItem(item);\n        setIsFormVisible(true);\n    };\n\n    const handleDelete = (id) =&gt; {\n        setItems(items.filter(item =&gt; item.id !== id));\n    };\n\n    const handleSubmit = (values) =&gt; {\n        if (currentItem) {\n            setItems(items.map(item =&gt; (item.id === values.id ? values : item)));\n        } else {\n            setItems([...items, { ...values, id: uuidv4() }]);\n        }\n        setIsFormVisible(false);\n    };\n\n    const handleCancel = () =&gt; {\n        setIsFormVisible(false);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;ItemList items={items} onAdd={handleAdd} onEdit={handleEdit} onDelete={handleDelete} /&gt;\n            &lt;ItemForm\n                visible={isFormVisible}\n                onCancel={handleCancel}\n                onSubmit={handleSubmit}\n                initialValues={currentItem}\n            /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CRUDApp;\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#4-integration","title":"4. Integration","text":"<p>Finally, use the <code>CRUDApp</code> component in your application entry point, such as <code>App.js</code>.</p> <pre><code>// App.js\nimport React from \"react\";\nimport \"antd/dist/reset.css\";\nimport CRUDApp from \"./CRUDApp\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;CRUDApp /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#explanation","title":"Explanation:","text":"<ul> <li> <p>Component-Based Architecture: The application is broken down into reusable components (<code>ItemList</code>, <code>ItemForm</code>, and <code>CRUDApp</code>). This separation of concerns helps maintain clarity and reusability.</p> </li> <li> <p>ItemList Component: Responsible for displaying a table of items and handling actions such as adding, editing, and deleting items.</p> </li> <li> <p>ItemForm Component: A modal form used for both adding new items and editing existing ones. It uses Ant Design's <code>Form</code> and <code>Modal</code> components.</p> </li> <li> <p>CRUDApp Component: Manages the application state and the interaction between <code>ItemList</code> and <code>ItemForm</code>. It handles CRUD operations and controls the visibility of the form.</p> </li> </ul> <p>This structure ensures that each component has a single responsibility, making the code easier to maintain and extend.</p>"},{"location":"package/ui/antd/form/form-crud/#improvement","title":"Improvement","text":"<p>To improve the CRUD example code provided, you can consider various enhancements for better maintainability, performance, and user experience. Here are several suggestions:</p>"},{"location":"package/ui/antd/form/form-crud/#1-add-validation-and-error-handling","title":"1. Add Validation and Error Handling:","text":"<p>Ensure robust validation and error handling to make the application more user-friendly and reliable.</p> <ul> <li>Enhanced Validation: Add more detailed validation rules in <code>ItemForm</code> to handle edge cases.</li> </ul> <pre><code>&lt;Form.Item\n  name=\"name\"\n  label=\"Name\"\n  rules={[\n    { required: true, message: \"Please input the name!\" },\n    { min: 3, message: \"Name must be at least 3 characters long!\" },\n  ]}\n&gt;\n  &lt;Input /&gt;\n&lt;/Form.Item&gt;\n</code></pre> <ul> <li>Error Handling in CRUD Operations: Implement error handling for CRUD operations, especially when integrating with an external API.</li> </ul> <pre><code>const handleSubmit = async (values) =&gt; {\n  try {\n    if (currentItem) {\n      // Update existing item\n      setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n    } else {\n      // Add new item\n      setItems([...items, { ...values, id: uuidv4() }]);\n    }\n    setIsFormVisible(false);\n  } catch (error) {\n    console.error(\"Failed to save item:\", error);\n    // Show user-friendly error message\n  }\n};\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#2-improve-user-experience","title":"2. Improve User Experience:","text":"<p>Enhance the user experience with better UI/UX practices.</p> <ul> <li>Loading States: Add loading indicators to inform users that an operation is in progress.</li> </ul> <pre><code>const [loading, setLoading] = useState(false);\n\nconst handleSubmit = async (values) =&gt; {\n  setLoading(true);\n  try {\n    // Perform the operation\n  } finally {\n    setLoading(false);\n  }\n};\n\nreturn (\n  &lt;Modal\n    visible={visible}\n    title={initialValues ? \"Edit Item\" : \"Add Item\"}\n    okText=\"Submit\"\n    cancelText=\"Cancel\"\n    onCancel={onCancel}\n    onOk={handleSubmit}\n    confirmLoading={loading}\n  &gt;\n    {/* Form content */}\n  &lt;/Modal&gt;\n);\n</code></pre> <ul> <li>Success Messages: Show success messages after successful operations.</li> </ul> <pre><code>import { message } from \"antd\";\n\nconst handleSubmit = async (values) =&gt; {\n  try {\n    if (currentItem) {\n      setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n    } else {\n      setItems([...items, { ...values, id: uuidv4() }]);\n    }\n    message.success(\"Item saved successfully!\");\n    setIsFormVisible(false);\n  } catch (error) {\n    message.error(\"Failed to save item.\");\n  }\n};\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#3-refactor-and-optimize","title":"3. Refactor and Optimize:","text":"<p>Refactor the code for better organization and performance.</p> <ul> <li>Extract Utility Functions: Move reusable logic into separate utility functions or hooks.</li> </ul> <pre><code>// utils.js\nexport const generateUniqueId = () =&gt; uuidv4();\n\n// CRUDApp.js\nimport { generateUniqueId } from \"./utils\";\n\nconst handleSubmit = (values) =&gt; {\n  if (currentItem) {\n    setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n  } else {\n    setItems([...items, { ...values, id: generateUniqueId() }]);\n  }\n  setIsFormVisible(false);\n};\n</code></pre> <ul> <li>Use Custom Hooks: Create custom hooks for managing form state or CRUD operations.</li> </ul> <pre><code>// useItems.js\nimport { useState } from \"react\";\n\nconst useItems = () =&gt; {\n  const [items, setItems] = useState([]);\n\n  const addItem = (item) =&gt; {\n    setItems([...items, { ...item, id: uuidv4() }]);\n  };\n\n  const updateItem = (item) =&gt; {\n    setItems(items.map((i) =&gt; (i.id === item.id ? item : i)));\n  };\n\n  const deleteItem = (id) =&gt; {\n    setItems(items.filter((item) =&gt; item.id !== id));\n  };\n\n  return {\n    items,\n    addItem,\n    updateItem,\n    deleteItem,\n  };\n};\n\nexport default useItems;\n</code></pre> <pre><code>// CRUDApp.js\nimport useItems from \"./useItems\";\n\nconst CRUDApp = () =&gt; {\n  const { items, addItem, updateItem, deleteItem } = useItems();\n  // ...\n};\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#4-enhance-accessibility","title":"4. Enhance Accessibility:","text":"<p>Ensure the application is accessible to all users.</p> <ul> <li>Accessible Forms: Add proper labels and ARIA attributes to form elements.</li> </ul> <pre><code>&lt;Form.Item\n  name=\"name\"\n  label=\"Name\"\n  rules={[{ required: true, message: \"Please input the name!\" }]}\n&gt;\n  &lt;Input aria-label=\"Name\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre> <ul> <li>Keyboard Navigation: Ensure that modals and forms can be navigated using the keyboard.</li> </ul>"},{"location":"package/ui/antd/form/form-crud/#5-add-testing","title":"5. Add Testing:","text":"<p>Implement tests to ensure the application works correctly and to catch regressions.</p> <ul> <li>Unit Tests: Write unit tests for individual components and functions using a testing library like Jest and React Testing Library.</li> </ul> <pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport CRUDApp from \"./CRUDApp\";\n\ntest(\"renders ItemList and shows form on Add\", () =&gt; {\n  render(&lt;CRUDApp /&gt;);\n  const addButton = screen.getByText(/Add Item/i);\n  fireEvent.click(addButton);\n  expect(screen.getByText(/Add Item/i)).toBeInTheDocument();\n});\n</code></pre> <ul> <li>Integration Tests: Test how different components work together.</li> </ul> <pre><code>// Test that adding an item updates the list\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#6-add-documentation","title":"6. Add Documentation:","text":"<p>Document your components and their usage to help future developers understand and use them effectively.</p> <ul> <li>Component Documentation: Use <code>comments</code> and <code>README</code> files to describe the purpose and usage of components.</li> </ul> <pre><code>/**\n * ItemForm Component\n * Displays a form for adding or editing an item.\n * Props:\n * - visible (boolean): Controls the visibility of the modal.\n * - onCancel (function): Callback when the form is canceled.\n * - onSubmit (function): Callback when the form is submitted.\n * - initialValues (object): Values to pre-fill the form.\n */\n</code></pre>"},{"location":"package/ui/antd/form/form-crud/#conclusion","title":"Conclusion:","text":"<p>By incorporating these improvements, you enhance the robustness, performance, and user experience of your CRUD application. These practices also make your codebase easier to maintain and extend in the future.</p>"},{"location":"package/ui/antd/form/form-useEffect-issue/","title":"Form useEffect Issue","text":""},{"location":"package/ui/antd/form/form-useEffect-issue/#form-useeffect-issue","title":"Form <code>useEffect</code> issue","text":"<p>Why this is an issue:</p> <pre><code>useEffect(() =&gt; {\n  setShowPref(form.getFieldValue(\"newsletter\"));\n}, [form.getFieldValue(\"newsletter\")]); // \u274c Problematic!\n</code></pre> <p>Problem:</p> <ul> <li> <p><code>form.getFieldValue('newsletter')</code> is a function call, which returns a value (like <code>true</code> or <code>false</code>).</p> </li> <li> <p>The dependency array expects variables or values that React can track for changes.</p> </li> <li> <p>React evaluates this at render time, so the dependency becomes a fixed value (e.g., <code>true</code>) at that moment.</p> </li> <li> <p>Because it's not a state or prop, React won't know when it changes later \u2014 the effect won't re-run properly.</p> </li> <li> <p>So, the effect runs once on mount, but not again when the newsletter value changes.</p> </li> </ul>"},{"location":"package/ui/antd/form/form-useEffect-issue/#whats-the-right-approach","title":"What\u2019s the right approach?","text":"<p>You need to listen to form value changes explicitly \u2014 for example:</p> <ol> <li>Use the form's <code>onValuesChange</code> callback to detect changes in form fields.</li> <li>Update your local state based on the changed values.</li> </ol> <pre><code>&lt;Form\n  form={form}\n  onValuesChange={(changedValues) =&gt; {\n    if (\"newsletter\" in changedValues) {\n      setShowPref(changedValues.newsletter);\n    }\n  }}\n&gt;\n  {/* form items */}\n&lt;/Form&gt;\n</code></pre> <p>This way:</p> <ul> <li>Whenever the <code>newsletter</code> field changes, <code>onValuesChange</code> triggers.</li> <li>You update <code>showPref</code> state accordingly.</li> <li>React re-renders with the correct conditional UI.</li> </ul> <pre><code>so we should add onlly primite values inside the useEffect dependeuncy not reference or function call non primitive data\n</code></pre> <p>Exactly! You got it.</p>"},{"location":"package/ui/antd/form/form-useEffect-issue/#best-practice-for-useeffect-dependencies","title":"\u2705 Best Practice for <code>useEffect</code> dependencies:","text":"<ul> <li> <p>Include only variables or expressions that are stable and represent the actual data/state you want to track.</p> </li> <li> <p>Avoid putting <code>function calls</code> or <code>objects/arrays</code> directly in the dependency array because:</p> </li> <li> <p>Function calls are executed immediately during render, returning a value (which might be primitive or not).</p> </li> <li> <p>Objects/arrays are reference types and might cause unnecessary re-renders if their reference changes even though content doesn't.</p> </li> </ul>"},{"location":"package/ui/antd/form/hooks/","title":"Hooks","text":""},{"location":"package/ui/antd/form/hooks/#form-hooks","title":"Form Hooks","text":""},{"location":"package/ui/antd/form/hooks/#reference","title":"Reference","text":"<ul> <li>Hooks</li> </ul>"},{"location":"package/ui/antd/form/intro/","title":"Intro","text":""},{"location":"package/ui/antd/form/intro/#example-form-layouts","title":"Example Form Layouts:","text":"<p>Ant Design offers multiple form layouts:</p> <ul> <li> <p>Horizontal Layout (default):</p> <pre><code>&lt;Form layout=\"horizontal\" ... /&gt;\n</code></pre> </li> <li> <p>Vertical Layout:</p> <pre><code>&lt;Form layout=\"vertical\" ... /&gt;\n</code></pre> </li> <li> <p>Inline Layout:</p> <pre><code>&lt;Form layout=\"inline\" ... /&gt;\n</code></pre> </li> </ul> <p>If you're building a larger form, consider exploring the <code>Form.List</code> for handling dynamic fields or nested forms!</p> Example ExampleExplanation <pre><code>// LoginForm.tsx\n\nimport React from \"react\";\nimport { Form, Input, Button } from \"antd\";\n\nconst LoginForm: React.FC = () =&gt; {\n    // Handle form submission\n    const onFinish = (values: { username: string; password: string }) =&gt; {\n        console.log(\"Received values:\", values);\n    };\n\n    return (\n        &lt;div style={{ maxWidth: \"300px\", margin: \"0 auto\" }}&gt;\n            &lt;h2 style={{ textAlign: \"center\" }}&gt;Login&lt;/h2&gt;\n            &lt;Form\n                name=\"login\"\n                initialValues={{ remember: true }}\n                onFinish={onFinish}\n                layout=\"vertical\"\n            &gt;\n                &lt;Form.Item\n                    name=\"username\"\n                    label=\"Username\"\n                    rules={[{ required: true, message: \"Please input your username!\" }]}\n                &gt;\n                    &lt;Input placeholder=\"Enter your username\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[{ required: true, message: \"Please input your password!\" }]}\n                &gt;\n                    &lt;Input.Password placeholder=\"Enter your password\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default LoginForm;\n</code></pre> <ol> <li> <p>Form Component: The <code>Form</code> component is used to create the form. It accepts several props:</p> <ul> <li><code>name</code>: The name of the form.</li> <li><code>initialValues</code>: The default values for the form fields (like <code>remember</code> here).</li> <li><code>onFinish</code>: The callback function that is triggered when the form is successfully submitted.</li> <li><code>layout=\"vertical\"</code>: This sets the layout of the form, where each label is placed above the input field.</li> </ul> </li> <li> <p>Form.Item: Each form field is wrapped in a <code>Form.Item</code> component, which corresponds to a single input or control. Each <code>Form.Item</code>:</p> <ul> <li><code>name</code>: Specifies the name of the field (used to reference it in the onFinish callback).</li> <li><code>label</code>: The label text for the field.</li> <li><code>rules</code>: An array that defines the validation rules for that field.</li> </ul> </li> <li> <p>Input &amp; Input.Password:</p> <ul> <li><code>Input</code> is used for regular text input.</li> <li><code>Input.Password</code> is used for password fields (it automatically hides the text).</li> </ul> </li> <li> <p>Button: The <code>Button</code> component is used to trigger the form submission when clicked. It uses the <code>htmlType=\"submit\"</code> attribute to trigger the onFinish function.</p> </li> <li> <p>Form Validation: The <code>rules</code> prop in each <code>Form.Item</code> handles form validation. In this case, both the <code>username</code> and <code>password</code> fields are required, and if the user doesn't fill them out, an error message will appear.</p> </li> </ol>"},{"location":"package/ui/antd/form/onValuesChange/","title":"onValuesChange","text":""},{"location":"package/ui/antd/form/onValuesChange/#onvalueschange-method","title":"<code>onValuesChange</code> Method","text":"<p>Yes, <code>onValuesChange</code> is a method that you can use with the Ant Design (antd) Form component.</p> When to use <ul> <li>For Forms: Use <code>onValuesChange</code> for managing form-level changes and state updates across multiple fields.</li> <li>For Individual Fields: Use <code>handleChange</code> when managing the state or behavior of a specific input field or component.</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#overview","title":"Overview","text":""},{"location":"package/ui/antd/form/onValuesChange/#what-is-onvalueschange","title":"What is onValuesChange?","text":"<p><code>onValuesChange</code> is a callback function that is triggered when the values of the form fields change. It is useful for capturing changes to form values in real-time, for example, to update other UI components or to validate inputs as they are modified.</p> <p>This method takes two arguments:</p> <ol> <li><code>changedValues</code>: An object that contains the fields that have been changed (the updated values).</li> <li><code>allValues</code>: An object containing the values of all fields in the form after the change.</li> </ol>"},{"location":"package/ui/antd/form/onValuesChange/#example-of-onvalueschange","title":"Example of <code>onValuesChange</code>","text":"<p>Here\u2019s a simple example of how to use <code>onValuesChange</code> in an Ant Design v4 or v5 form:</p> <pre><code>import React from \"react\";\nimport { Form, Input, Button } from \"antd\";\n\nconst MyForm = () =&gt; {\n  const onValuesChange = (changedValues, allValues) =&gt; {\n    console.log(\"Changed Values:\", changedValues);\n    console.log(\"All Values:\", allValues);\n  };\n\n  return (\n    &lt;Form onValuesChange={onValuesChange}&gt;\n      &lt;Form.Item label=\"Name\" name=\"name\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item label=\"Email\" name=\"email\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n};\n\nexport default MyForm;\n</code></pre> <p>How It Works:</p> <ul> <li><code>changedValues</code> will contain the specific form field(s) that were modified (e.g., <code>{ name: 'John' }</code>).</li> <li><code>allValues</code> will contain the current state of all form fields (e.g., <code>{ name: 'John', email: 'john@example.com' }</code>).</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#use-cases","title":"Use Cases:","text":"<ul> <li>Live Form Validation: You can use <code>onValuesChange</code> to perform live validation or to trigger actions based on the changes to certain fields.</li> <li>Dynamic Fields: If you have a dynamic form (e.g., showing/hiding fields based on previous inputs), you can use <code>onValuesChange</code> to manage which fields are visible.</li> <li>Form-dependent UI Updates: For example, if changing a specific field affects other UI elements or values, <code>onValuesChange</code> allows you to react to those changes in real-time.</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#notes","title":"Notes:","text":"<ul> <li>Performance: Keep in mind that this method will trigger every time a form value changes, so if your form is complex, make sure to optimize performance by controlling when and how you update the state.</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#optimization","title":"Optimization","text":"<p>Yes, you can definitely use <code>onValuesChange</code> in complex forms in Ant Design (antd). However, when dealing with more complex forms, there are a few considerations and techniques you should apply to ensure that your form remains performant, maintainable, and user-friendly.</p>"},{"location":"package/ui/antd/form/onValuesChange/#challenges-with-onvalueschange-in-complex-forms","title":"Challenges with <code>onValuesChange</code> in Complex Forms","text":"<ul> <li>Performance: In complex forms, you may have many form fields, and using <code>onValuesChange</code> to monitor each of them can lead to unnecessary re-renders and slower performance.</li> <li>State Management: Complex forms may require more sophisticated state management, such as conditionally showing or hiding fields based on other field values.</li> <li>Dynamic Form Fields: Complex forms often have dynamically added or removed form items, so handling field-level changes may become tricky.</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#how-to-use-onvalueschange-effectively-in-complex-forms","title":"How to Use onValuesChange Effectively in Complex Forms","text":"<p>Here are some best practices and techniques for using onValuesChange in complex forms:</p>"},{"location":"package/ui/antd/form/onValuesChange/#1-debouncing-onvalueschange","title":"1. Debouncing <code>onValuesChange</code>","text":"<p>Debouncing can significantly improve performance in complex forms by reducing the frequency of updates triggered by value changes.</p> <p>For example, if your form includes fields like <code>email</code>, <code>name</code>, and <code>phone</code>, and you want to perform some validations or call APIs when values change, debouncing helps reduce unnecessary operations.</p> <pre><code>import React, { useCallback } from \"react\";\nimport { Form, Input, Button } from \"antd\";\nimport { debounce } from \"lodash\";\n\nconst MyForm = () =&gt; {\n  const handleValuesChange = useCallback(\n    debounce((changedValues, allValues) =&gt; {\n      console.log(\"Changed Values:\", changedValues);\n      console.log(\"All Values:\", allValues);\n    }, 300),\n    []\n  );\n\n  return (\n    &lt;Form onValuesChange={handleValuesChange}&gt;\n      &lt;Form.Item label=\"Name\" name=\"name\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item label=\"Email\" name=\"email\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item label=\"Phone\" name=\"phone\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n};\n\nexport default MyForm;\n</code></pre> <ul> <li>Here, the <code>debounce</code> function will limit the execution of <code>handleValuesChange</code> to once every 300ms, reducing the number of times the function is called.</li> </ul>"},{"location":"package/ui/antd/form/onValuesChange/#2-using-usecallback-for-memoization","title":"2. Using <code>useCallback</code> for Memoization","text":"<p>For performance optimization, you can memoize the <code>onValuesChange</code> handler using <code>useCallback</code>. This prevents unnecessary re-renders and ensures that the function reference stays the same across renders.</p> <pre><code>const handleValuesChange = useCallback((changedValues, allValues) =&gt; {\n  console.log(\"Changed Values:\", changedValues);\n  console.log(\"All Values:\", allValues);\n}, []); // Empty dependency array means the function will not change between renders\n</code></pre>"},{"location":"package/ui/antd/form/onValuesChange/#3-handling-dynamic-fields","title":"3. Handling Dynamic Fields","text":"<p>If your form contains dynamic fields (fields that are added or removed based on user interaction), <code>onValuesChange</code> can still be used effectively, but you need to handle these changes carefully.</p> <p>For example, if you have a field that dynamically adds more inputs based on a checkbox selection, you might want to listen for changes and trigger updates accordingly.</p> <pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Checkbox } from \"antd\";\n\nconst MyForm = () =&gt; {\n  const [isAdditionalFieldsVisible, setIsAdditionalFieldsVisible] =\n    useState(false);\n\n  const onValuesChange = (changedValues, allValues) =&gt; {\n    if (changedValues.showAdditionalFields) {\n      setIsAdditionalFieldsVisible(changedValues.showAdditionalFields);\n    }\n  };\n\n  return (\n    &lt;Form onValuesChange={onValuesChange}&gt;\n      &lt;Form.Item name=\"showAdditionalFields\" valuePropName=\"checked\"&gt;\n        &lt;Checkbox&gt;Show additional fields&lt;/Checkbox&gt;\n      &lt;/Form.Item&gt;\n\n      {isAdditionalFieldsVisible &amp;&amp; (\n        &lt;&gt;\n          &lt;Form.Item label=\"Additional Info\" name=\"additionalInfo\"&gt;\n            &lt;Input /&gt;\n          &lt;/Form.Item&gt;\n          &lt;Form.Item label=\"More Details\" name=\"moreDetails\"&gt;\n            &lt;Input /&gt;\n          &lt;/Form.Item&gt;\n        &lt;/&gt;\n      )}\n\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n};\n\nexport default MyForm;\n</code></pre> <p>In this example, when the checkbox <code>showAdditionalFields</code> is checked, the form dynamically adds additional fields. The <code>onValuesChange</code> callback listens for changes in the checkbox value and updates the form accordingly.</p>"},{"location":"package/ui/antd/form/onValuesChange/#4-limit-re-renders-by-handling-specific-fields","title":"4. Limit Re-renders by Handling Specific Fields","text":"<p>In a complex form, you often don\u2019t need to react to every field change. Instead, you can restrict <code>onValuesChange</code> to only specific fields to avoid unnecessary logic execution for unrelated fields.</p> <p>For example, if you only need to monitor changes in the <code>name</code> and <code>email</code> fields, you can do so:</p> <pre><code>const handleValuesChange = (changedValues, allValues) =&gt; {\n  if (\"name\" in changedValues) {\n    console.log(\"Name changed:\", changedValues.name);\n  }\n  if (\"email\" in changedValues) {\n    console.log(\"Email changed:\", changedValues.email);\n  }\n};\n</code></pre>"},{"location":"package/ui/antd/form/onValuesChange/#5-use-useeffect-for-complex-form-actions","title":"5. Use <code>useEffect</code> for Complex Form Actions","text":"<p>In cases where you want to perform some side effects based on the form values (e.g., submitting data, calculating results), it might be better to use <code>useEffect</code> instead of handling everything in <code>onValuesChange</code>.</p> <p>For instance, if you only want to perform an action after form submission or when certain values change, using <code>useEffect</code> will allow you to perform these tasks efficiently:</p> <pre><code>import { useEffect, useState } from \"react\";\nimport { Form, Input, Button } from \"antd\";\n\nconst MyForm = () =&gt; {\n  const [formValues, setFormValues] = useState({});\n\n  // Store form values on change\n  const onValuesChange = (changedValues, allValues) =&gt; {\n    setFormValues(allValues);\n  };\n\n  useEffect(() =&gt; {\n    console.log(\"Form Values Changed:\", formValues);\n    // Trigger any additional logic (e.g., validation, API calls) based on form values\n  }, [formValues]); // Only runs when `formValues` changes\n\n  return (\n    &lt;Form onValuesChange={onValuesChange}&gt;\n      &lt;Form.Item label=\"Name\" name=\"name\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item label=\"Email\" name=\"email\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n};\n\nexport default MyForm;\n</code></pre> <p>This approach separates form handling logic (via <code>onValuesChange</code>) from side effects (via <code>useEffect</code>), making it easier to manage complex form behavior.</p>"},{"location":"package/ui/antd/form/onValuesChange/#6-avoid-overloading-onvalueschange","title":"6. Avoid Overloading <code>onValuesChange</code>","text":"<p>Avoid trying to do too much inside <code>onValuesChange</code>. If you need to handle complex logic, break it down into smaller functions or use <code>useEffect</code> for side effects. This ensures that <code>onValuesChange</code> remains a simple and efficient handler.</p>"},{"location":"package/ui/antd/form/onValuesChange/#summary","title":"Summary:","text":"<ul> <li>Debounce: Use <code>debounce</code> for costly operations like API calls or validations.</li> <li>Memoize: Use <code>useCallback</code> to prevent unnecessary re-renders of the <code>onValuesChange</code> handler.</li> <li>Dynamic Fields: Handle dynamic form fields by using state to control visibility or form structure based on user input.</li> <li>Optimize Logic: Only handle necessary fields in <code>onValuesChange</code>, and offload side effects to <code>useEffect</code>.</li> <li>Batching State Updates: Use useEffect or state management solutions for complex form logic instead of executing everything within <code>onValuesChange</code>.</li> </ul> <p>By following these best practices, you can ensure that <code>onValuesChange</code> remains efficient and manageable, even in complex forms.</p>"},{"location":"package/ui/antd/form/shouldUpdate-vs-useEffect/","title":"shouldUpdate vs useEffect","text":""},{"location":"package/ui/antd/form/shouldUpdate-vs-useEffect/#shouldupdate-vs-useeffect","title":"shouldUpdate vs useEffect","text":"<p>Here's a side-by-side demo of how to show/hide a form field based on another field \u2014 using both:</p> <p>\u2705 Scenario:</p> <p>When a user checks \"<code>Receive Newsletter</code>\", show an additional \"<code>Preferences</code>\" input field.</p>"},{"location":"package/ui/antd/form/shouldUpdate-vs-useEffect/#1-with-shouldupdate-recommended-antd-way","title":"\ud83e\udde9 1. With <code>shouldUpdate</code> (Recommended AntD Way)","text":"<pre><code>&lt;Form form={form} layout=\"vertical\"&gt;\n  &lt;Form.Item\n    name=\"newsletter\"\n    label=\"Receive Newsletter?\"\n    valuePropName=\"checked\"\n  &gt;\n    &lt;Switch /&gt;\n  &lt;/Form.Item&gt;\n\n  &lt;Form.Item shouldUpdate={(prev, curr) =&gt; prev.newsletter !== curr.newsletter}&gt;\n    {({ getFieldValue }) =&gt;\n      getFieldValue(\"newsletter\") ? (\n        &lt;Form.Item\n          name=\"preferences\"\n          label=\"Newsletter Preferences\"\n          rules={[{ required: true, message: \"Enter your preferences\" }]}\n        &gt;\n          &lt;Input.TextArea /&gt;\n        &lt;/Form.Item&gt;\n      ) : null\n    }\n  &lt;/Form.Item&gt;\n&lt;/Form&gt;\n</code></pre> <p>\ud83d\udd0d What happens:</p> <ul> <li><code>Form.Item</code> with <code>shouldUpdate</code> re-renders only when the <code>newsletter</code> value changes.</li> <li>Clean and declarative, no manual state tracking.</li> </ul>"},{"location":"package/ui/antd/form/shouldUpdate-vs-useEffect/#2-with-useeffect-manual-way","title":"\u26a0\ufe0f 2. With <code>useEffect</code> (Manual Way)","text":"<pre><code>const [showPref, setShowPref] = useState(false);\nconst [form] = Form.useForm();\n\nuseEffect(() =&gt; {\n  setShowPref(form.getFieldValue(\"newsletter\"));\n}, [form.getFieldValue(\"newsletter\")]); // \u274c This line won\u2019t actually re-trigger correctly\n\n// More correct approach:\n&lt;Form\n  form={form}\n  layout=\"vertical\"\n  onValuesChange={(changedValues) =&gt; {\n    if (\"newsletter\" in changedValues) {\n      setShowPref(changedValues.newsletter);\n    }\n  }}\n&gt;\n  &lt;Form.Item\n    name=\"newsletter\"\n    label=\"Receive Newsletter?\"\n    valuePropName=\"checked\"\n  &gt;\n    &lt;Switch /&gt;\n  &lt;/Form.Item&gt;\n\n  {showPref &amp;&amp; (\n    &lt;Form.Item\n      name=\"preferences\"\n      label=\"Newsletter Preferences\"\n      rules={[{ required: true, message: \"Enter your preferences\" }]}\n    &gt;\n      &lt;Input.TextArea /&gt;\n    &lt;/Form.Item&gt;\n  )}\n&lt;/Form&gt;;\n</code></pre> <p>\ud83d\udd0d What happens:</p> <ul> <li>Requires local state (<code>useState</code>) and syncing logic via <code>onValuesChange</code> or <code>useEffect</code>.</li> <li>More verbose and error-prone.</li> <li>Useful only if you need to trigger side effects outside the form.</li> </ul>"},{"location":"package/ui/antd/form/shouldUpdate-vs-useEffect/#summary","title":"\u2705 Summary","text":"Approach Pros Cons <code>shouldUpdate</code> Clean, form-aware, declarative Only for rendering/form logic <code>useEffect</code> Flexible, good for side effects Verbose, needs manual sync"},{"location":"package/ui/antd/form/shouldUpdate/","title":"shouldUpdate prop","text":""},{"location":"package/ui/antd/form/shouldUpdate/#should-update","title":"should Update","text":"<p>Question</p> <p>Yes \u2014 in the context of Ant Design Forms, using <code>shouldUpdate</code> in a <code>&lt;Form.Item&gt;</code> is often a cleaner and more declarative alternative to using <code>useEffect</code> when you're dealing with conditional rendering or logic based on form state.</p>"},{"location":"package/ui/antd/form/shouldUpdate/#comparison-shouldupdate-vs-useeffect","title":"\ud83d\udd04 Comparison: <code>shouldUpdate</code> vs <code>useEffect</code>","text":""},{"location":"package/ui/antd/form/shouldUpdate/#using-shouldupdate","title":"\u2705 Using <code>shouldUpdate</code>","text":"<ul> <li>Tells the <code>Form.Item</code> to re-render only when specified form values change.</li> <li>Keeps the logic co-located with the form.</li> <li>No external state or effect needed.</li> <li>Works reactively and declaratively inside the form.</li> </ul> <pre><code>&lt;Form.Item shouldUpdate={(prev, curr) =&gt; prev.newsletter !== curr.newsletter}&gt;\n  {({ getFieldValue }) =&gt;\n    getFieldValue(\"newsletter\") ? &lt;Input.TextArea /&gt; : null\n  }\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"package/ui/antd/form/shouldUpdate/#using-useeffect-instead","title":"\u26a0\ufe0f Using <code>useEffect</code> Instead","text":"<p>You\u2019d need to:</p> <ol> <li>Watch form values manually using <code>form.getFieldValue()</code>.</li> <li>Manage your own state for conditional rendering.</li> <li>Possibly duplicate logic across components.</li> </ol> <pre><code>const [showPreferences, setShowPreferences] = useState(false);\n\nuseEffect(() =&gt; {\n  const val = form.getFieldValue(\"newsletter\");\n  setShowPreferences(val);\n}, [form.getFieldValue(\"newsletter\")]);\n\n// then use showPreferences in render\n</code></pre> <p>\ud83d\udd34 This is more verbose and can be fragile.</p>"},{"location":"package/ui/antd/form/shouldUpdate/#so-yes-shouldupdate-a-form-specific-alternative-to-useeffect","title":"\u2705 So Yes: <code>shouldUpdate</code> \u2248 A Form-Specific Alternative to <code>useEffect</code>","text":"<p>It\u2019s purpose-built for:</p> <ul> <li>Reacting to form value changes.</li> <li>Avoiding prop-drilling or separate <code>useState</code>.</li> <li>Keeping form logic compact and declarative.</li> </ul>"},{"location":"package/ui/antd/form/shouldUpdate/#when-to-prefer-each","title":"\ud83d\udca1 When to Prefer Each:","text":"Use Case Prefer Rendering conditionally inside a form <code>shouldUpdate</code> Side effects (e.g., fetch data, analytics, state updates outside the form) <code>useEffect</code> Updating multiple form fields from one change <code>form.setFieldsValue</code> in <code>useEffect</code> or <code>onValuesChange</code> <p>Would you like a simple side-by-side demo of <code>shouldUpdate</code> vs <code>useEffect</code>?</p>"},{"location":"package/ui/antd/form/shouldUpdate/#shouldupdate-prop","title":"<code>shouldUpdate</code> prop","text":"<p>\u2705 <code>shouldUpdate</code> is a prop (property) of the <code>&lt;Form.Item&gt;</code> component \u2014 not a method or hook.</p> <p>\ud83d\udcd8 Explanation:</p> <p>\ud83d\udd39 What it is:</p> <ul> <li><code>shouldUpdate</code> is a Boolean or a function.</li> <li>It tells Ant Design whether to re-render this particular <code>Form.Item</code> when form values change.</li> </ul> <p>\ud83e\udde0 Syntax:</p> <p>Option 1: Boolean form</p> <pre><code>&lt;Form.Item shouldUpdate&gt;\n  {({ getFieldValue }) =&gt; {\n    // will re-render on any form change\n  }}\n&lt;/Form.Item&gt;\n</code></pre> <p>Option 2: Function form (recommended for performance)</p> <pre><code>&lt;Form.Item\n  shouldUpdate={(prevValues, nextValues) =&gt;\n    prevValues.newsletter !== nextValues.newsletter\n  }\n&gt;\n  {({ getFieldValue }) =&gt; {\n    return getFieldValue(\"newsletter\") ? &lt;Input.TextArea /&gt; : null;\n  }}\n&lt;/Form.Item&gt;\n</code></pre> <p>\ud83d\udee0\ufe0f So to clarify:</p> Concept Type Description <code>shouldUpdate</code> Prop On <code>&lt;Form.Item&gt;</code>, used to control conditional re-rendering <code>Form.useForm</code> Hook Returns a form instance for programmatic control <code>form.setFieldsValue</code> / <code>form.getFieldValue</code> Method Methods on the form instance <p>\u2705 Summary:</p> <ul> <li><code>shouldUpdate</code> = \ud83d\udce6 Form.Item prop</li> <li>Not a hook, not a method.</li> <li>Lets you conditionally render based on form values.</li> <li>Helps avoid manual <code>useEffect</code> and <code>useState</code>.</li> </ul>"},{"location":"package/ui/antd/sidebar/intro/","title":"Intro","text":""},{"location":"package/ui/antd/sidebar/intro/#overview","title":"Overview","text":"<p>To create a modular and reusable layout in React with Ant Design, we can break the layout into smaller, reusable components. This approach allows you to easily modify parts of the layout and reuse them in other parts of your application. Here's a way to structure your layout:</p>"},{"location":"package/ui/antd/sidebar/intro/#1-create-reusable-layout-components","title":"1. Create Reusable Layout Components","text":"<p>We will create modular components for:</p> <ul> <li>Sidebar: The sidebar component that will house the navigation.</li> <li>Header: A reusable header with options like logo or user profile.</li> <li>MainLayout: The main layout that combines the <code>Sidebar</code> and <code>Header</code> components.</li> <li>Content: A dynamic content area that changes based on routing or other conditions.</li> </ul>"},{"location":"package/ui/antd/sidebar/intro/#2-example-code","title":"2. Example Code","text":"Sidebar.jsHeader.jsMainLayout.jsContentArea.js <pre><code>import React from 'react';\nimport { Layout, Menu } from 'antd';\nimport { HomeOutlined, SearchOutlined, AppstoreAddOutlined } from '@ant-design/icons';\n\nconst { Sider } = Layout;\n\nconst Sidebar = ({ collapsed, onCollapse }) =&gt; (\n    &lt;Sider\n        collapsible\n        collapsed={collapsed}\n        onCollapse={onCollapse}\n        width={250}\n        style={{ background: '#fff' }}\n    &gt;\n        &lt;Menu mode=\"inline\" defaultSelectedKeys={['1']} theme=\"light\"&gt;\n            &lt;Menu.Item key=\"1\" icon={&lt;HomeOutlined /&gt;}&gt;\n                Home\n            &lt;/Menu.Item&gt;\n            &lt;Menu.Item key=\"2\" icon={&lt;SearchOutlined /&gt;}&gt;\n                Search\n            &lt;/Menu.Item&gt;\n            &lt;Menu.Item key=\"3\" icon={&lt;AppstoreAddOutlined /&gt;}&gt;\n                Add Item\n            &lt;/Menu.Item&gt;\n        &lt;/Menu&gt;\n    &lt;/Sider&gt;\n);\n\nexport default Sidebar;\n</code></pre> <pre><code>import React from 'react';\nimport { Layout, Button } from 'antd';\n\nconst { Header } = Layout;\n\nconst AppHeader = ({ onCollapse, collapsed }) =&gt; (\n    &lt;Header style={{ background: '#fff', padding: 0 }}&gt;\n        &lt;Button\n        type=\"primary\"\n        onClick={() =&gt; onCollapse(!collapsed)}\n        style={{ marginLeft: 16 }}\n        &gt;\n            {collapsed ? 'Expand' : 'Collapse'}\n        &lt;/Button&gt;\n    &lt;/Header&gt;\n    );\n\nexport default AppHeader;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport { Layout } from 'antd';\nimport Sidebar from './Sidebar';\nimport AppHeader from './Header';\nimport ContentArea from './ContentArea';\n\nconst { Content } = Layout;\n\nconst MainLayout = () =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    const handleCollapse = (collapsed) =&gt; {\n        setCollapsed(collapsed);\n    };\n\n    return (\n        &lt;Layout style={{ minHeight: '100vh' }}&gt;\n            &lt;AppHeader collapsed={collapsed} onCollapse={handleCollapse} /&gt;\n            &lt;Layout&gt;\n                &lt;Sidebar collapsed={collapsed} onCollapse={handleCollapse} /&gt;\n                &lt;Layout style={{ padding: '0 24px 24px' }}&gt;\n                    &lt;Content style={{ padding: 24, margin: 0 }}&gt;\n                        &lt;ContentArea /&gt;\n                    &lt;/Content&gt;\n                &lt;/Layout&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import React from 'react';\n\nconst ContentArea = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Content Area!&lt;/h1&gt;\n            &lt;p&gt;This section will change depending on the route or active content.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ContentArea;\n</code></pre>"},{"location":"package/ui/antd/sidebar/intro/#3-putting-it-together","title":"3. Putting It Together","text":"<p>Finally, in your main application file (e.g., <code>App.js</code>), import and use <code>MainLayout</code>:</p> App.js <pre><code>import React from 'react';\nimport MainLayout from './components/MainLayout';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;MainLayout /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> Explanation <ul> <li> <p>Modularity: Each part of the layout (<code>Sidebar</code>, <code>Header</code>, <code>MainLayout</code>, <code>ContentArea</code>) is separated into its own component, making the layout modular and easy to manage.</p> </li> <li> <p>Reusability: If you need to reuse the <code>Sidebar</code> or <code>Header</code> in other parts of the application, you can just import them as needed. This reduces duplication and makes your code more maintainable.</p> </li> <li> <p>Dynamic Content: The <code>ContentArea</code> component can be replaced with dynamic content based on routing (using react-router), user interaction, or other application states.</p> </li> <li> <p>State Management: The collapsed state of the sidebar is managed at the top level (<code>MainLayout</code>) and passed down to child components (<code>Sidebar</code> and <code>Header</code>) via props. This allows central control of the layout state.</p> </li> </ul>"},{"location":"package/ui/antd/sidebar/intro/#4-adding-responsiveness","title":"4. Adding Responsiveness","text":"<p>You can enhance responsiveness by adding breakpoints using Ant Design\u2019s <code>Sider</code> props like <code>breakpoint</code> and <code>collapsedWidth</code> or using CSS media queries for custom behavior.</p> <pre><code>&lt;Sider\n  collapsible\n  collapsed={collapsed}\n  onCollapse={onCollapse}\n  breakpoint=\"lg\" // Collapse at 'lg' breakpoint\n  collapsedWidth=\"80\"\n  style={{ background: \"#fff\" }}\n&gt;\n  {/* Menu items */}\n&lt;/Sider&gt;\n</code></pre> <p>This structure provides flexibility to modify, extend, and reuse the layout components across your application. Would you like more advanced features like routing or adding custom hooks to further enhance this layout?</p> <pre><code>/src\n  \u251c\u2500\u2500 /assets                # Static assets like images, fonts, etc.\n  \u251c\u2500\u2500 /components            # Reusable components (UI components unrelated to layout)\n  \u251c\u2500\u2500 /layout                # Folder containing all the sidebar layout components\n  \u2502   \u251c\u2500\u2500 Header.js          # Header component\n  \u2502   \u251c\u2500\u2500 Sidebar.js         # Sidebar component\n  \u2502   \u251c\u2500\u2500 MainLayout.js      # Main layout that combines Sidebar, Header, and Content\n  \u2502   \u2514\u2500\u2500 ContentArea.js     # Content area for dynamic content\n  \u251c\u2500\u2500 /pages                 # Page components (pages of your app)\n  \u2502   \u251c\u2500\u2500 HomePage.js\n  \u2502   \u251c\u2500\u2500 SearchPage.js\n  \u2502   \u2514\u2500\u2500 AddItemPage.js\n  \u251c\u2500\u2500 /styles                # Global styles (CSS, SCSS, styled-components)\n  \u2502   \u251c\u2500\u2500 global.css\n  \u2502   \u2514\u2500\u2500 theme.css\n  \u251c\u2500\u2500 /utils                 # Utility functions and helpers\n  \u251c\u2500\u2500 /App.js                # Main entry point for the app\n  \u2514\u2500\u2500 /index.js              # ReactDOM render entry point\n</code></pre>"},{"location":"package/ui/antd/table/filters/","title":"Filters","text":""},{"location":"package/ui/antd/table/filters/#simple","title":"Simple","text":"ExampleHow It Works <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Define columns with filters for name\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n            filters: [\n                { text: 'John Doe', value: 'John Doe' },\n                { text: 'Jane Smith', value: 'Jane Smith' },\n            ],\n            onFilter: (value, record) =&gt; record.name.includes(value),\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ol> <li>Data Source: The <code>data</code> array contains records with <code>name</code>, <code>age</code>, and <code>address</code>.</li> <li>Column Definitions:<ul> <li>The <code>name</code> column has filters that allow users to filter by specific names (e.g., \"John Doe\" or \"Jane Smith\").</li> <li>The <code>onFilter</code> function checks if the <code>name</code> of the record includes the selected filter value.</li> </ul> </li> <li>Rendering: The <code>Table</code> component displays the columns and data, enabling name-based filtering.</li> </ol>"},{"location":"package/ui/antd/table/filters/#age","title":"Age","text":"ExampleKey PointsModular <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Define columns with filters directly\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n            filters: [\n                { text: 'Under 30', value: 'under30' },\n                { text: '30 and above', value: '30plus' },\n            ],\n            onFilter: (value, record) =&gt; {\n                if (value === 'under30') return record.age &lt; 30;\n                if (value === '30plus') return record.age &gt;= 30;\n                return true;\n            },\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ol> <li>Data Source: The <code>data</code> array contains a list of users.</li> <li>Column Definitions:<ul> <li>The <code>age</code> column includes filters directly defined in the <code>filters</code> property.</li> <li>The <code>onFilter</code> function is specified inline, making it clear and concise.</li> </ul> </li> <li>Rendering: The <code>Table</code> component displays the columns and data, allowing users to filter by age.</li> </ol> <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Age filter options\n    const ageFilter = [\n        { text: 'Under 30', value: 'under30' },\n        { text: '30 and above', value: '30plus' },\n    ];\n\n    // Filter function for age\n    const onFilter = (value, record) =&gt; {\n        if (value === 'under30') {\n            return record.age &lt; 30;\n        }\n        if (value === '30plus') {\n            return record.age &gt;= 30;\n        }\n        return true;\n    };\n\n    // Define columns\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n            filters: ageFilter,\n            onFilter: onFilter,\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"package/ui/antd/table/filters/#mastering-filters-in-ant-design-tables","title":"Mastering filters in Ant Design tables","text":"<p>Mastering filters in Ant Design (antd) tables involves understanding their capabilities and utilizing advanced features for better data management. Here\u2019s a comprehensive guide to help you become proficient with filters in antd tables.</p>"},{"location":"package/ui/antd/table/filters/#1-basic-filtering","title":"1. Basic Filtering","text":"<p>Start with simple filters for specific columns, as shown in previous examples. You can set filters directly in the column definitions and handle filtering logic.</p> <pre><code>{\n  title: 'Name',\n  dataIndex: 'name',\n  filters: [\n    { text: 'John Doe', value: 'John Doe' },\n    { text: 'Jane Smith', value: 'Jane Smith' },\n  ],\n  onFilter: (value, record) =&gt; record.name.includes(value),\n}\n</code></pre>"},{"location":"package/ui/antd/table/filters/#2-multiple-filters","title":"2. Multiple Filters","text":"<p>You can implement multiple filters across different columns. Each column can have its own set of filters, allowing users to refine their searches.</p> <pre><code>{\n  title: 'Age',\n  dataIndex: 'age',\n  filters: [\n    { text: 'Under 30', value: 'under30' },\n    { text: '30 and above', value: '30plus' },\n  ],\n  onFilter: (value, record) =&gt; {\n    if (value === 'under30') return record.age &lt; 30;\n    if (value === '30plus') return record.age &gt;= 30;\n    return true;\n  },\n}\n</code></pre>"},{"location":"package/ui/antd/table/filters/#3-custom-filter-logic","title":"3. Custom Filter Logic","text":"<p>You can create more complex filter logic using custom functions. This is especially useful for non-standard data types or specific business rules.</p> <pre><code>const customFilter = (value, record) =&gt; {\n  // Custom logic based on some criteria\n  return record.age === value;\n};\n\n{\n  title: 'Age',\n  dataIndex: 'age',\n  filters: [\n    { text: '22', value: 22 },\n    { text: '32', value: 32 },\n  ],\n  onFilter: customFilter,\n}\n</code></pre>"},{"location":"package/ui/antd/table/filters/#4-dynamic-filters","title":"4. Dynamic Filters","text":"<p>You can generate filter options dynamically based on your data. This ensures users always have relevant options to choose from.</p> <pre><code>const uniqueNames = [...new Set(data.map((item) =&gt; item.name))];\n\nconst columns = [\n  {\n    title: \"Name\",\n    dataIndex: \"name\",\n    filters: uniqueNames.map((name) =&gt; ({ text: name, value: name })),\n    onFilter: (value, record) =&gt; record.name.includes(value),\n  },\n];\n</code></pre>"},{"location":"package/ui/antd/table/filters/#5-search-filtering","title":"5. Search Filtering","text":"<p>In addition to predefined filters, consider implementing a search input for user-friendly filtering. This allows users to search for specific text within a column.</p> <pre><code>import { Input } from \"antd\";\n\nconst App = () =&gt; {\n  const [searchText, setSearchText] = React.useState(\"\");\n\n  const filteredData = data.filter((item) =&gt;\n    item.name.toLowerCase().includes(searchText.toLowerCase())\n  );\n\n  return (\n    &lt;&gt;\n      &lt;Input\n        placeholder=\"Search by name\"\n        onChange={(e) =&gt; setSearchText(e.target.value)}\n      /&gt;\n      &lt;Table dataSource={filteredData} columns={columns} /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>"},{"location":"package/ui/antd/table/filters/#6-combining-filters","title":"6. Combining Filters","text":"<p>You can combine multiple filters across different columns, allowing users to filter based on multiple criteria simultaneously.</p> <pre><code>const combinedFilter = (filters) =&gt; (record) =&gt; {\n  const matchesName = filters.name ? record.name.includes(filters.name) : true;\n  const matchesAge = filters.age ? record.age === filters.age : true;\n  return matchesName &amp;&amp; matchesAge;\n};\n</code></pre>"},{"location":"package/ui/antd/table/filters/#7-resetting-filters","title":"7. Resetting Filters","text":"<p>Provide a way for users to reset filters easily. This improves usability and allows users to start fresh.</p> <pre><code>const resetFilters = () =&gt; {\n  setFilters({ name: \"\", age: null });\n};\n\n&lt;Button onClick={resetFilters}&gt;Reset Filters&lt;/Button&gt;;\n</code></pre>"},{"location":"package/ui/antd/table/filters/#conclusion","title":"Conclusion","text":"<p>Mastering filters in antd tables involves understanding how to implement basic filtering, create custom logic, generate dynamic options, and enhance user experience with search functionality. By combining these techniques, you can create powerful and user-friendly data tables in your applications!</p>"},{"location":"package/utility/jwt/","title":"JWT package","text":""},{"location":"package/utility/jwt/#jwt-overview","title":"JWT Overview","text":"<p>Decoding a JWT token in a React application using TypeScript, Redux Toolkit, and Axios can be done in a few steps. Here is the best approach to decoding JWT tokens in your application:</p> <p></p>"},{"location":"package/utility/jwt/#steps","title":"Steps:","text":""},{"location":"package/utility/jwt/#1-install-jwt-library","title":"1. Install JWT library:","text":"<p>To decode the JWT token, you can use a library like jsonwebtoken or jwt-decode. These libraries help decode JWT tokens without needing to manually parse the payload.</p> <pre><code>npm install jwt-decode\n</code></pre> <p>Or, you can use the jsonwebtoken library (though it's heavier and more feature-rich, including encoding/decoding and verifying tokens).</p> <pre><code>npm install jsonwebtoken\n</code></pre> <p>For simplicity, jwt-decode is the most common choice for decoding, as it\u2019s lightweight and easy to use.</p>"},{"location":"package/utility/jwt/#2-create-a-utility-function-for-decoding-the-jwt","title":"2. Create a utility function for decoding the JWT:","text":"<p>You can create a utility file where you define your JWT decoding function.</p> utils/jwtDecode.ts<pre><code>import jwtDecode from \"jwt-decode\";\n\nexport interface DecodedToken {\n  exp: number;\n  iat: number;\n  [key: string]: any;\n}\n\nexport const decodeToken = (token: string): DecodedToken | null =&gt; {\n  try {\n    const decoded = jwtDecode&lt;DecodedToken&gt;(token);\n    return decoded;\n  } catch (error) {\n    console.error(\"Invalid token:\", error);\n    return null;\n  }\n};\n</code></pre> <p>This utility will take in a JWT string and return the decoded payload, or <code>null</code> if the token is invalid.</p>"},{"location":"package/utility/jwt/#3-integrating-the-decoding-into-redux-state","title":"3. Integrating the decoding into Redux state:","text":"<p>If you need to store the decoded token (or certain parts of it, like user information or expiration) in your Redux store, you can use Redux Toolkit to store and manage the JWT data.</p> redux/slices/authSlice.ts<pre><code>import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { decodeToken, DecodedToken } from \"../../utils/jwtDecode\";\n\ninterface AuthState {\n  token: string | null;\n  decodedToken: DecodedToken | null;\n  isAuthenticated: boolean;\n}\n\nconst initialState: AuthState = {\n  token: null,\n  decodedToken: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: \"auth\",\n  initialState,\n  reducers: {\n    setToken: (state, action: PayloadAction&lt;string&gt;) =&gt; {\n      state.token = action.payload;\n      state.decodedToken = decodeToken(action.payload);\n      state.isAuthenticated = state.decodedToken ? true : false;\n    },\n    logout: (state) =&gt; {\n      state.token = null;\n      state.decodedToken = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setToken, logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <p>Here, the <code>setToken</code> action will update the token in the state and decode it using the decodeToken utility.</p>"},{"location":"package/utility/jwt/#4-dispatching-actions-after-login-or-token-update","title":"4. Dispatching actions after login or token update:","text":"<p>In your component or wherever you handle authentication (e.g., Axios interceptors or login logic), you will dispatch the action to set the token and store the decoded value in Redux.</p> <p>Example: Axios Interceptor for Token Handling</p> utils/axios.ts<pre><code>import axios from \"axios\";\nimport { store } from \"../store\";\nimport { setToken } from \"../redux/slices/authSlice\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n});\n\n// Interceptor to handle token storage and refresh\naxiosInstance.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    if (error.response?.status === 401) {\n      // Handle Unauthorized (token expired or invalid)\n      store.dispatch(setToken(\"\")); // Remove token and clear auth state\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n</code></pre> <p>After a successful login (e.g., from a <code>login</code> function), you will store the token in Redux:</p> <pre><code>// On successful login\nconst handleLogin = async (username: string, password: string) =&gt; {\n  try {\n    const response = await axiosInstance.post(\"/login\", { username, password });\n    const token = response.data.token;\n    store.dispatch(setToken(token)); // Dispatch the token to Redux\n  } catch (error) {\n    console.error(\"Login failed:\", error);\n  }\n};\n</code></pre>"},{"location":"package/utility/jwt/#5-accessing-the-decoded-token-in-a-component","title":"5. Accessing the decoded token in a component:","text":"<p>You can easily access the decoded token or any other properties from your Redux store using the <code>useSelector</code> hook in React components.</p> components/Profile.tsx<pre><code>import React from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { RootState } from \"../store\";\n\nconst Profile: React.FC = () =&gt; {\n  const { decodedToken, isAuthenticated } = useSelector(\n    (state: RootState) =&gt; state.auth\n  );\n\n  if (!isAuthenticated) {\n    return &lt;div&gt;Please log in&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Profile&lt;/h1&gt;\n      &lt;p&gt;User ID: {decodedToken?.userId}&lt;/p&gt;\n      &lt;p&gt;Expiration: {new Date(decodedToken?.exp * 1000).toLocaleString()}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Profile;\n</code></pre> <p>Key Points:</p> <ul> <li>Use jwt-decode to decode the JWT payload easily.</li> <li>Store the decoded JWT information in Redux using the Redux Toolkit (<code>setToken</code> action).</li> <li>Use Axios interceptors to handle token expiration or refresh.</li> <li>Access the decoded token in your React components via <code>useSelector</code>.</li> </ul>"},{"location":"package/utility/jwt/#alternative-jwt-decoding-without-redux","title":"Alternative (JWT Decoding without Redux):","text":"<p>If you just need to decode the token once in the component or in specific places, you can directly use the <code>jwt-decode</code> function without storing it in Redux.</p> <p>For example:</p> <pre><code>import jwtDecode from \"jwt-decode\";\n\nconst decodedToken = jwtDecode(token);\nconsole.log(decodedToken);\n</code></pre> <p>But using Redux for managing the JWT state is a good practice when you need to globally manage authentication state and access decoded token data across your application.</p>"},{"location":"package/utility/jwt/#conclusion","title":"Conclusion:","text":"<p>This approach allows you to decode JWT tokens efficiently, store decoded values in Redux, and manage authentication across your application. Using <code>jwt-decode</code> with Redux Toolkit provides a clear and maintainable structure for handling JWTs in a React app.</p>"},{"location":"package/utility/uuid-package/","title":"UUID","text":""},{"location":"package/utility/uuid-package/#uuid","title":"UUID","text":"<p>Generate RFC-compliant UUIDs in JavaScript </p>"},{"location":"package/utility/uuid-package/#1-install","title":"1. Install","text":"<pre><code>npm install uuid\n</code></pre>"},{"location":"package/utility/uuid-package/#2-create-a-uuid","title":"2. Create a UUID","text":"<p>ESM-syntax (must use named exports):</p> <pre><code>import { v4 as uuidv4 } from 'uuid';\nuuidv4(); // \u21e8 '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n</code></pre>"},{"location":"package/utility/uuid-package/#nil-uuid","title":"NIL <code>UUID</code>","text":"<p>uuid.NIL</p> <p>The nil UUID string (all zeros).</p> <pre><code>import { NIL as NIL_UUID } from 'uuid';\n\nNIL_UUID; // \u21e8 '00000000-0000-0000-0000-000000000000'\n</code></pre>"},{"location":"package/utility/uuid-package/#reference","title":"Reference","text":"<ul> <li>npm: uuid</li> <li>github: uuid</li> </ul>"},{"location":"package/utility/axios/axios-interceptors/","title":"Axios Interceptors","text":"<p>Here's how you can structure your application to ensure that the Axios interceptor works properly, along with an example.</p>"},{"location":"package/utility/axios/axios-interceptors/#overview","title":"Overview","text":"File Structure <pre><code>src/\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 axiosInstance.js\n\u2502   \u251c\u2500\u2500 axiosInterceptors.js\n\u2502   \u2514\u2500\u2500 dataService.js\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#1-axiosinstancejs","title":"1. axiosInstance.js","text":"Example <p>This sets up the Axios instance:</p> <pre><code>// services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n});\n\nexport default axiosInstance;\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#2-axiosinterceptorsjs","title":"2. axiosInterceptors.js","text":"Example <p>This configures the request interceptor:</p> <pre><code>// services/axiosInterceptors.js\nimport axiosInstance from \"./axiosInstance\";\n\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#3-dataservicejs","title":"3. dataService.js","text":"Example <p>This file handles API requests:</p> <pre><code>// services/dataService.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const fetchData = (url, signal) =&gt; {\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    return axiosInstance.get(url, {\n        cancelToken: signal,\n    });\n};\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#4-indexjs","title":"4. index.js","text":"Example <p>Make sure to import the interceptor setup here so it gets registered when your app starts:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport './services/axiosInterceptors'; // Import interceptors\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById(\"root\")\n);\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#5-appjs","title":"5. App.js","text":"Example <p>Now you can use the <code>fetchData</code> function in your components:</p> <pre><code>// App.js\nimport React, { useEffect } from \"react\";\nimport { fetchData } from \"./services/dataService\";\n\nconst App = () =&gt; {\n    useEffect(() =&gt; {\n        const controller = new AbortController();\n        const signal = controller.signal;\n\n        fetchData(\"/example-endpoint\", signal)\n            .then((response) =&gt; {\n                console.log(\"Data received:\", response.data);\n            })\n            .catch((error) =&gt; {\n                console.error(\"Error fetching data:\", error);\n            });\n\n            return () =&gt; {\n            controller.abort(); // Cleanup the signal on component unmount\n        };\n    }, []);\n\n    return &lt;div&gt;Check the console for logs!&lt;/div&gt;;\n};\n\nexport default App;\n</code></pre>"},{"location":"package/utility/axios/axios-interceptors/#explanation","title":"Explanation","text":"<ul> <li>Importing Interceptors: By importing <code>axiosInterceptors.js</code> in <code>index.js</code>, you ensure that the interceptors are set up before any API calls are made.</li> <li>Using the Instance: The <code>fetchData</code> function uses the configured Axios instance, meaning that any request made with it will trigger the interceptor.</li> <li>Logging: You should see the console logs from both the interceptor and the fetch function when the component mounts.</li> </ul>"},{"location":"package/utility/axios/axios-interceptors/#conclusion","title":"Conclusion","text":"<p>With this setup, you should be able to see the interceptor's log statements in the console when <code>fetchData</code> is called. Make sure your base API URL is set correctly in your environment variables for successful requests.</p>"},{"location":"package/utility/axios/axios-interceptors/#additional","title":"Additional","text":"<p>If you're not importing axiosInterceptors.js in your index.js, that would explain why the interceptor isn't working.</p> <p>Here's a quick recap of what you need to do to fix it:</p> <p>Steps to Fix the Issue</p> <ul> <li>Import the Interceptor File: Open your <code>index.js</code> file and make sure to import <code>axiosInterceptors.js</code> so that the interceptors get registered when your app starts.</li> </ul> Example Code for <code>index.js</code>Explanation <p>Here\u2019s how your index.js should look:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport './services/axiosInterceptors'; // Importing the interceptors\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById(\"root\")\n);\n</code></pre> <ul> <li> <p>Why Import It: By importing <code>axiosInterceptors.js</code>, you ensure that the interceptors are set up as soon as your application initializes. This allows them to intercept any API requests made afterward.</p> </li> <li> <p>No Other Changes Needed: You don't need to change anything else in your existing files. Just make sure the import statement is there.</p> </li> </ul> <p>After Making Changes</p> <p>Once you add the import, you should be able to see the console logs from the interceptor when you make API calls. If you still have issues, double-check that there are no other errors in your console that might be affecting the execution.</p>"},{"location":"package/utility/axios/axios-interceptors/#issue","title":"Issue","text":"<p>Understanding the Issue</p> <p>Since you've already imported <code>axiosInterceptors.js</code> in your <code>index.js</code>, importing it again in <code>axiosInstance.js</code> is unnecessary and can lead to problems, especially if both files depend on each other.</p> Recommended Approach <ul> <li> <p>Remove Import from <code>axiosInstance.js</code>: Since you are already importing <code>axiosInterceptors.js</code> in <code>index.js</code>, you can safely remove the import statement from <code>axiosInstance.js</code>.</p> </li> <li> <p>Order of Imports: Make sure <code>axiosInterceptors.js</code> is imported before any requests are made in your application. As long as you import it in <code>index.js</code>, it should work fine.</p> </li> </ul> <p>Updated <code>axiosInstance.js</code></p> axiosInstance.jsaxiosInterceptors.jsindex.jsSummary <p>Here's how <code>axiosInstance.js</code> should look:</p> <pre><code>// services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n});\n\nexport default axiosInstance;\n</code></pre> <p>This file remains unchanged:</p> <pre><code>// services/axiosInterceptors.js\nimport axiosInstance from \"./axiosInstance\";\n\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre> <p>Since you've already imported <code>axiosInterceptors.js</code> here, you're all set:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./redux/store/store\";\nimport \"./index.css\";\nimport \"./styles/global.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"./redux/services/axiosInterceptors\"; // Importing interceptors here\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n\n// Performance measurement code\nreportWebVitals();\n</code></pre> <ul> <li>Remove Import: Remove the import of <code>axiosInterceptors.js</code> from <code>axiosInstance.js</code>.</li> <li>Import in Index: Keep the import in <code>index.js</code>, ensuring that interceptors are set up before any API requests.</li> <li>Circular Dependency: This approach avoids circular dependency issues that can lead to initialization errors.</li> </ul> <p>With these changes, your application should work correctly without the errors you encountered.</p>"},{"location":"package/utility/axios/axios-interceptors/#great-solution","title":"Great Solution","text":"<p>To manage multiple APIs with different authentication methods in your <code>axiosInstance</code>, you can modify the request interceptor to check which API you're calling and set the <code>Authorization</code> header accordingly. You can achieve this by including an additional property in the config to identify which API is being used.</p> axiosInstance.jsaxiosInterceptors.jsExplanation <pre><code>import axiosInstance from \"./axiosInstance\";\n\nconst apiManager = {\n    base: axiosInstance.create({\n        baseURL: process.env.REACT_APP_BASE_API_URL,\n    }),\n    blog: axiosInstance.create({\n        baseURL: process.env.REACT_APP_BLOG_API_URL,\n    }),\n};\n\nexport default apiManager;\n</code></pre> <pre><code>import axiosInstance from \"./axiosInstance\";\n\n// Add a request interceptor\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n            const apiKey = process.env.REACT_APP_BLOG_API_KEY;\n\n            // Check if the request is to the blog API\n            if (config.baseURL === process.env.REACT_APP_BLOG_API_URL) {\n            if (apiKey) {\n                config.headers[\"Authorization\"] = `Bearer ${apiKey}`;\n            }\n        } else {\n            // Assuming you have a way to get the token (e.g., from localStorage or a global state)\n            const token = localStorage.getItem(\"your_token_key\"); // Replace with your method to get the token\n            if (token) {\n                config.headers[\"Authorization\"] = `Bearer ${token}`;\n            }\n        }\n\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre> <ol> <li> <p>Interceptor Logic: The interceptor checks the <code>baseURL</code> of the request. If it's the blog API URL, it sets the <code>Authorization</code> header using the <code>REACT_APP_BLOG_API_KEY</code>. For all other requests (like the base API for login), it retrieves the token from storage and sets it in the header.</p> </li> <li> <p>Token Storage: Ensure you replace <code>localStorage.getItem(\"your_token_key\")</code> with your actual logic for retrieving the user token.</p> </li> </ol> <p>This setup allows you to easily manage different authentication methods for multiple APIs within your application.</p>"},{"location":"package/utility/axios/intro/","title":"Intro","text":"<p>Mastering Axios in React involves understanding both the library itself and how to integrate it effectively in your applications.</p>"},{"location":"package/utility/axios/intro/#overview","title":"Overview","text":"<p>Here\u2019s a roadmap to help you become a top-level developer with Axios:</p>"},{"location":"package/utility/axios/intro/#1-basics-of-axios","title":"1. Basics of Axios","text":"<ul> <li>Installation: Install Axios via npm or yarn.</li> </ul> <pre><code>npm install axios\n</code></pre> <ul> <li>Making Requests: Understand <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> requests.</li> <li>Response Handling: Learn to handle responses and errors properly.</li> </ul>"},{"location":"package/utility/axios/intro/#2-setting-up-axios","title":"2. Setting Up Axios","text":"<ul> <li>Create an Axios Instance: Set default settings (base URL, headers, etc.).</li> </ul> <pre><code>import axios from \"axios\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n  timeout: 1000,\n  headers: { Authorization: \"Bearer token\" },\n});\n</code></pre> <ul> <li>Global Interceptors: Use interceptors for requests and responses to handle authentication, logging, etc.</li> </ul> <pre><code>axios.interceptors.request.use(\n  (config) =&gt; {\n    // Modify request\n    return config;\n  },\n  (error) =&gt; {\n    return Promise.reject(error);\n  }\n);\n</code></pre>"},{"location":"package/utility/axios/intro/#3-advanced-usage","title":"3. Advanced Usage","text":"<ul> <li>Cancellation of Requests: Use <code>CancelToken</code> to cancel requests.</li> <li>Concurrent Requests: Use <code>axios.all</code> and <code>axios.spread</code> for handling multiple requests simultaneously.</li> </ul> <pre><code>axios.all([request1, request2]).then(\n  axios.spread((response1, response2) =&gt; {\n    // Handle responses\n  })\n);\n</code></pre> <ul> <li>Error Handling: Create a centralized error handling system.</li> <li>Custom Transformations: Customize data transformation in requests/responses.</li> </ul>"},{"location":"package/utility/axios/intro/#4-react-integration","title":"4. React Integration","text":"<ul> <li>Using Axios with Hooks: Create custom hooks for API calls.</li> </ul> <pre><code>import { useEffect, useState } from \"react\";\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    axios\n      .get(url)\n      .then((response) =&gt; setData(response.data))\n      .catch((err) =&gt; setError(err));\n  }, [url]);\n\n  return { data, error };\n};\n</code></pre> <ul> <li>Context API for Global State: Manage API state using Context API.</li> <li>Error Boundaries: Implement error boundaries to catch errors in the API calls.</li> </ul>"},{"location":"package/utility/axios/intro/#5-testing","title":"5. Testing","text":"<ul> <li>Mocking Axios Requests: Use libraries like axios-mock-adapter or jest for testing your components and API calls.</li> </ul>"},{"location":"package/utility/axios/intro/#6-performance-optimization","title":"6. Performance Optimization","text":"<ul> <li>Debouncing Requests: Implement debouncing for search fields or high-frequency requests.</li> <li>Lazy Loading: Load data on-demand for better performance.</li> <li>Memoization: Use React's <code>useMemo</code> and <code>useCallback</code> to prevent unnecessary re-renders.</li> </ul>"},{"location":"package/utility/axios/intro/#7-security-best-practices","title":"7. Security Best Practices","text":"<ul> <li>Securing API Keys: Use environment variables to store sensitive data.</li> <li>Rate Limiting: Implement mechanisms to handle rate limits from APIs.</li> </ul>"},{"location":"package/utility/axios/intro/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<ul> <li>Log API Calls: Use logging tools to monitor API interactions.</li> <li>Analytics: Track user interactions and API usage for performance analysis.</li> </ul>"},{"location":"package/utility/axios/intro/#9-real-world-projects","title":"9. Real-World Projects","text":"<ul> <li>Build projects that require complex API interactions (e.g., e-commerce apps, social media apps).</li> <li>Contribute to open-source projects or create your own to practice and showcase your skills.</li> </ul>"},{"location":"package/utility/axios/intro/#10-continuous-learning","title":"10. Continuous Learning","text":"<ul> <li>Stay updated with the latest features and best practices.</li> <li>Engage with the developer community through forums, meetups, or conferences.</li> </ul>"},{"location":"package/utility/axios/intro/#resources","title":"Resources","text":"<ul> <li>Documentation: Read the Axios documentation for in-depth understanding.</li> <li>Tutorials: Follow advanced tutorials on platforms like YouTube, Udemy, or blogs.</li> <li>GitHub: Explore repositories using Axios for practical examples.</li> </ul> <p>By mastering these concepts and continually practicing, you\u2019ll be well on your way to becoming a top-level developer with Axios in React!</p>"},{"location":"package/utility/axios/sentry/","title":"Sentry","text":"<p>Error monitoring and analytics are crucial for maintaining the health of your applications and improving user experience. Here\u2019s how you can implement error monitoring and analytics in your React application using Axios:</p>"},{"location":"package/utility/axios/sentry/#error-monitoring-with-sentry","title":"Error Monitoring with Sentry","text":"<p>Sentry is a popular tool for monitoring and fixing crashes in real-time. You can integrate it with Axios to catch and report errors.</p> <p>Step 1: Install Sentry</p> <p>First, install Sentry in your project:</p> <pre><code>npm install @sentry/react @sentry/tracing\n</code></pre> <p>Step 2: Initialize Sentry</p> <p>Initialize Sentry in your application, usually in your main entry file (e.g., <code>index.js</code> or <code>App.js</code>):</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as Sentry from \"@sentry/react\";\nimport App from \"./App\";\n\nSentry.init({\n  dsn: \"YOUR_SENTRY_DSN\", // Replace with your DSN from Sentry\n  integrations: [\n    new Sentry.BrowserTracing({\n      tracingOrigins: [\"localhost\", \"https://yourapi.com\", /^\\//],\n    }),\n  ],\n  tracesSampleRate: 1.0, // Adjust this value in production\n});\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre> <p>Step 3: Capture Errors in Axios Requests</p> <p>You can set up a response interceptor in Axios to capture errors and send them to Sentry:</p> <pre><code>import axios from \"axios\";\nimport * as Sentry from \"@sentry/react\";\n\n// Create an Axios instance\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n});\n\n// Add a response interceptor\naxiosInstance.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    // Capture the error with Sentry\n    Sentry.captureException(error);\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n</code></pre> <p>Step 4: Use the Axios Instance</p> <p>Now, you can use this Axios instance throughout your application:</p> <pre><code>import React, { useEffect, useState } from \"react\";\nimport axiosInstance from \"./axiosInstance\";\n\nconst UserList = () =&gt; {\n  const [users, setUsers] = useState([]);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    axiosInstance\n      .get(\"/users\")\n      .then((response) =&gt; setUsers(response.data))\n      .catch((err) =&gt; {\n        setError(\"Failed to fetch users\");\n        console.error(err);\n      });\n  }, []);\n\n  if (error) return &lt;div&gt;{error}&lt;/div&gt;;\n\n  return (\n    &lt;ul&gt;\n      {users.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"package/utility/axios/sentry/#analytics-with-google-analytics","title":"Analytics with Google Analytics","text":"<p>You can also track user interactions and API call performance using Google Analytics.</p> <p>Step 1: Install Google Analytics</p> <p>If you haven\u2019t already set up Google Analytics, you can do so by following the official documentation.</p> <p>Step 2: Track API Calls</p> <p>You can use Google Analytics to track when API calls are made and their outcomes. Here's an example of how to integrate it:</p> <pre><code>import React, { useEffect, useState } from \"react\";\nimport axiosInstance from \"./axiosInstance\";\nimport ReactGA from \"react-ga\";\n\n// Initialize Google Analytics\nReactGA.initialize(\"YOUR_GA_TRACKING_ID\");\n\nconst UserList = () =&gt; {\n  const [users, setUsers] = useState([]);\n  const [error, setError] = useState(null);\n\n  const trackAPICall = (action, label) =&gt; {\n    ReactGA.event({\n      category: \"API\",\n      action,\n      label,\n    });\n  };\n\n  useEffect(() =&gt; {\n    trackAPICall(\"Fetch Users\", \"Started\");\n\n    axiosInstance\n      .get(\"/users\")\n      .then((response) =&gt; {\n        setUsers(response.data);\n        trackAPICall(\"Fetch Users\", \"Successful\"); // Successful API call\n      })\n      .catch((err) =&gt; {\n        setError(\"Failed to fetch users\");\n        console.error(err);\n        trackAPICall(\"Fetch Users\", \"Failed\"); // Failed API call\n      });\n  }, []);\n\n  if (error) return &lt;div&gt;{error}&lt;/div&gt;;\n\n  return (\n    &lt;ul&gt;\n      {users.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"package/utility/axios/sentry/#summary","title":"Summary","text":"<p>By integrating Sentry for error monitoring and Google Analytics for tracking API interactions, you can gain valuable insights into your application\u2019s performance and user experience. This not only helps in identifying and fixing issues but also provides data for making informed decisions about your application's direction.</p>"},{"location":"package/utility/axios/topic/","title":"Topic","text":"<p>To achieve a deep mastery of Axios, consider diving into the following topics:</p>"},{"location":"package/utility/axios/topic/#1-http-basics","title":"1. HTTP Basics","text":"<ul> <li>Understanding HTTP Protocol: Learn about request/response lifecycle, methods (GET, POST, etc.), and status codes.</li> <li>Headers and Content Types: Understand how to work with headers, including authorization and content negotiation.</li> </ul> Example <p>Example: Understand status codes</p> <pre><code>// Fetching user data\naxios.get('/api/users/1')\n    .then(response =&gt; {\n        console.log(response.status); // 200 for success\n    })\n    .catch(error =&gt; {\n        console.error(error.response.status); // e.g., 404 for not found\n    });\n</code></pre>"},{"location":"package/utility/axios/topic/#2-axios-fundamentals","title":"2. Axios Fundamentals","text":"<ul> <li>Installation and Setup: Basic installation and setup of Axios in a React project.</li> <li>Basic Requests: Familiarize yourself with making GET, POST, PUT, and DELETE requests.</li> <li>Handling Responses: Learn how to process and handle successful responses and errors.</li> </ul> Example <p>Example: Making a POST request</p> <pre><code>const newUser = { name: 'John Doe', email: 'john@example.com' };\naxios.post('/api/users', newUser)\n    .then(response =&gt; {\n        console.log(response.data); // Handle the new user data\n    })\n    .catch(error =&gt; {\n        console.error(error);\n    });\n</code></pre>"},{"location":"package/utility/axios/topic/#3-advanced-configuration","title":"3. Advanced Configuration","text":"<ul> <li>Creating Axios Instances: Set up custom instances with default configurations (base URL, headers).</li> <li>Interceptors: Implement request and response interceptors for logging, error handling, and authentication.</li> </ul> ExampleInterceptors <p>Example: Creating an Axios instance</p> <pre><code>const axiosInstance = axios.create({\n    baseURL: 'https://api.example.com',\n    timeout: 1000,\n    headers: { 'Authorization': 'Bearer YOUR_TOKEN' },\n});\n\naxiosInstance.get('/users')\n    .then(response =&gt; console.log(response.data));\n</code></pre> <p>Example: Adding a request interceptor</p> <pre><code>axios.interceptors.request.use(config =&gt; {\n    console.log('Request sent at:', new Date());\n    return config;\n});\n</code></pre>"},{"location":"package/utility/axios/topic/#4-error-handling-strategies","title":"4. Error Handling Strategies","text":"<ul> <li>Centralized Error Handling: Develop a system for managing API errors across your application.</li> <li>Retry Logic: Implement strategies for retrying failed requests with exponential backoff.</li> </ul> Example <p>Example: Centralized error handling</p> <pre><code>const handleError = (error) =&gt; {\n    console.error('API error:', error);\n    // Notify the user or log the error\n    };\n\naxios.get('/api/users')\n    .catch(handleError);\n</code></pre>"},{"location":"package/utility/axios/topic/#5-cancellation-and-throttling","title":"5. Cancellation and Throttling","text":"<ul> <li>CancelToken: Use CancelToken to abort requests and prevent memory leaks.</li> <li>Throttling/Debouncing: Optimize requests in high-frequency scenarios (like search inputs).</li> </ul> Example <p>Example: Using CancelToken</p> <pre><code>const CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/api/users', { cancelToken: new CancelToken(c =&gt; cancel = c) });\n// Cancel the request if needed\ncancel();\n</code></pre>"},{"location":"package/utility/axios/topic/#6-concurrent-requests","title":"6. Concurrent Requests","text":"<ul> <li>Using <code>axios.all</code>: Make multiple concurrent requests and handle them using <code>axios.spread</code>.</li> <li>Managing Promise States: Understand how to handle and display loading states and errors for concurrent requests.</li> </ul> Example <p>Example: Making multiple requests</p> <pre><code>axios.all([\n    axios.get('/api/users'),\n    axios.get('/api/posts'),\n]).then(axios.spread((users, posts) =&gt; {\n    console.log('Users:', users.data);\n    console.log('Posts:', posts.data);\n}));\n</code></pre>"},{"location":"package/utility/axios/topic/#7-custom-axios-functions","title":"7. Custom Axios Functions","text":"<ul> <li>Service Layer Design: Create a dedicated API service layer for managing Axios calls and endpoints.</li> <li>Utility Functions: Build custom functions for repetitive tasks (like handling token refresh).</li> </ul> Example <p>Example: Creating a service layer</p> <pre><code>const apiService = {\n    getUsers: () =&gt; axios.get('/api/users'),\n    createUser: (user) =&gt; axios.post('/api/users', user),\n};\n\napiService.getUsers().then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"package/utility/axios/topic/#8-data-transformation","title":"8. Data Transformation","text":"<ul> <li>Transforming Requests and Responses: Customize how data is sent to and received from the server.</li> <li>Parsing and Normalizing Data: Learn how to structure and normalize API responses for better state management.</li> </ul> Example <p>Example: Transforming response data</p> <pre><code>axios.get('/api/users', {\n    transformResponse: [(data) =&gt; {\n        const jsonData = JSON.parse(data);\n        return jsonData.map(user =&gt; ({ ...user, fullName: `${user.firstName} ${user.lastName}` }));\n    }]\n}).then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"package/utility/axios/topic/#9-integration-with-state-management","title":"9. Integration with State Management","text":"<ul> <li>Using Context API: Manage API data and state with React\u2019s Context API.</li> <li>Redux Integration: Implement Redux to handle complex state scenarios involving multiple API calls.</li> </ul> Example <p>Example: Using Context API</p> <pre><code>const UserContext = React.createContext();\n\nconst UserProvider = ({ children }) =&gt; {\n    const [users, setUsers] = useState([]);\n\n    useEffect(() =&gt; {\n        axios.get('/api/users').then(response =&gt; setUsers(response.data));\n    }, []);\n\n    return &lt;UserContext.Provider value={users}&gt;{children}&lt;/UserContext.Provider&gt;;\n};\n</code></pre>"},{"location":"package/utility/axios/topic/#10-testing","title":"10. Testing","text":"<ul> <li>Unit Testing: Write tests for Axios calls using libraries like Jest and Mock Service Worker (MSW).</li> <li>Integration Testing: Test components that interact with Axios and ensure proper rendering and state management.</li> </ul> Example <p>Example: Mocking Axios with Jest</p> <pre><code>import axios from 'axios';\nimport { fetchUsers } from './apiService'; // Assume this uses axios\n\njest.mock('axios');\n\ntest('fetches users successfully', async () =&gt; {\n    const users = [{ id: 1, name: 'John Doe' }];\n    axios.get.mockResolvedValueOnce({ data: users });\n\n    const result = await fetchUsers();\n    expect(result).toEqual(users);\n});\n</code></pre>"},{"location":"package/utility/axios/topic/#11-security-practices","title":"11. Security Practices","text":"<ul> <li>Securing API Calls: Understand how to manage tokens (like JWTs) and secure sensitive data.</li> <li>CORS: Learn about Cross-Origin Resource Sharing and how to handle related issues.</li> </ul> Example <p>Example: Securing API calls</p> <pre><code>const apiService = axios.create({\n    baseURL: 'https://api.example.com',\n});\n\napiService.interceptors.request.use(config =&gt; {\n    const token = localStorage.getItem('token'); // Retrieve token securely\n    if (token) {\n        config.headers['Authorization'] = `Bearer ${token}`;\n    }\n    return config;\n});\n</code></pre>"},{"location":"package/utility/axios/topic/#12-performance-optimization","title":"12. Performance Optimization","text":"<ul> <li>Caching Responses: Implement caching strategies for API responses to improve performance.</li> <li>Pagination and Infinite Scrolling: Efficiently handle large datasets with pagination and loading more data on scroll.</li> </ul> Example <p>Example: Implementing caching</p> <pre><code>const cache = {};\n\nconst fetchUsers = async () =&gt; {\n    if (cache.users) return cache.users;\n\n    const response = await axios.get('/api/users');\n    cache.users = response.data; // Cache response\n    return response.data;\n};\n</code></pre>"},{"location":"package/utility/axios/topic/#13-real-time-data-handling","title":"13. Real-time Data Handling","text":"<ul> <li>WebSockets vs. Axios: Explore using WebSockets for real-time updates in conjunction with Axios.</li> <li>Polling Techniques: Understand long polling and how to implement it when WebSockets aren't an option.</li> </ul> Example <p>Example: Using WebSockets with Axios</p> <pre><code>const socket = new WebSocket('ws://api.example.com/realtime');\n\nsocket.onmessage = (event) =&gt; {\n    const data = JSON.parse(event.data);\n    console.log('Real-time update:', data);\n};\n</code></pre>"},{"location":"package/utility/axios/topic/#14-error-monitoring-and-analytics","title":"14. Error Monitoring and Analytics","text":"<ul> <li>Logging Requests: Use logging libraries to track API calls and responses.</li> <li>Monitoring Tools: Integrate tools like Sentry or LogRocket to monitor API performance and errors in production.</li> </ul> Example"},{"location":"package/utility/axios/topic/#15-best-practices-and-design-patterns","title":"15. Best Practices and Design Patterns","text":"<ul> <li>Code Organization: Structure your API calls and components in a maintainable way.</li> <li>Design Patterns: Familiarize yourself with patterns like the Repository Pattern or Factory Pattern in the context of API calls.</li> </ul> Example <p>Example: Structuring your API layer</p> <pre><code>// api/userService.js\nexport const userService = {\n    getUsers: () =&gt; axios.get('/api/users'),\n    createUser: (user) =&gt; axios.post('/api/users', user),\n};\n\n// In a component\nimport { userService } from './api/userService';\n\nuserService.getUsers().then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"package/utility/axios/topic/#resources","title":"Resources","text":"<ul> <li>Official Documentation: Regularly reference the Axios documentation.</li> <li>Online Courses: Consider advanced courses on platforms like Udemy or Pluralsight focusing on React and API integration.</li> <li>Books: Read books on advanced JavaScript and React to deepen your understanding of the underlying technologies.</li> </ul> <p>By systematically exploring these topics, you'll develop a comprehensive and deep understanding of Axios and its capabilities in building robust React applications. Happy learning!</p>"},{"location":"package/utility/draft-js/overview/","title":"Overview","text":""},{"location":"package/utility/draft-js/overview/#overview","title":"Overview","text":"<p>Draft.js</p> <p>Rich Text Editor Framework for React</p> <ul> <li><code>draft-js</code>: A powerful React-based <code>WYSIWYG</code> editor used internally at Facebook.</li> </ul>"},{"location":"package/utility/draft-js/overview/#reference","title":"Reference","text":"<ul> <li>draftjs.org</li> </ul>"},{"location":"package/utility/lodash/debounce/","title":"debounce","text":"<p><code>npm install lodash</code></p> jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport { Select } from \"antd\";\nimport debounce from \"lodash/debounce\";\n\nconst { Option } = Select;\n\nconst DebouncedSelect = () =&gt; {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  const debouncedSearch = debounce((value) =&gt; {\n    // Your search logic here, e.g., making an API call\n    console.log(\"Searching for:\", value);\n  }, 300); // 300ms debounce delay\n\n  useEffect(() =&gt; {\n    debouncedSearch(searchTerm);\n  }, [searchTerm, debouncedSearch]);\n\n  const handleSearch = (value) =&gt; {\n    setSearchTerm(value);\n  };\n\n  return (\n    &lt;Select\n      showSearch\n      onSearch={handleSearch}\n      style={{ width: 200 }}\n      placeholder=\"Search...\"\n    &gt;\n      &lt;Option value=\"1\"&gt;Option 1&lt;/Option&gt;\n      &lt;Option value=\"2\"&gt;Option 2&lt;/Option&gt;\n      &lt;Option value=\"3\"&gt;Option 3&lt;/Option&gt;\n    &lt;/Select&gt;\n  );\n};\n\nexport default DebouncedSelect;\n</code></pre>"},{"location":"package/utility/lodash/debounce/#debounce-with-hoc","title":"Debounce with Hoc","text":"<p>separate the debounce logic and the HOC into separate files for better organization</p> 1. Debounce utility file2. HOC file3. Component file debounce.js<pre><code>// debounce.js\nconst debounce = (func, delay) =&gt; {\n    let timeoutId;\n    return function (...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n};\n\nexport default debounce;\n</code></pre> withDebounce.js<pre><code>import React from 'react';\nimport debounce from './debounce';\n\nconst withDebounce = (WrappedComponent) =&gt; {\n    return class WithDebounce extends React.Component {\n        debouncedFunction = debounce((...args) =&gt; {\n            console.log('Debounced function called with args:', args);\n        }, 500); // 500ms debounce delay\n\n        render() {\n            return (\n                &lt;WrappedComponent\n                    {...this.props}\n                    onDebouncedAction={this.debouncedFunction}\n                /&gt;\n            );\n        }\n    };\n};\n\nexport default withDebounce;\n</code></pre> MyComponent.js<pre><code>import React from 'react';\nimport withDebounce from './withDebounce';\n\nconst MyComponent = ({ onDebouncedAction }) =&gt; {\n    const handleClick = () =&gt; {\n        onDebouncedAction('Click event');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default withDebounce(MyComponent);\n</code></pre> <p>Now you can import and use the <code>MyComponent</code> in your main application file:</p> App.js<pre><code>import React from \"react\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This structure helps maintain a clean separation of concerns, making each file focused on its specific responsibility. The debounce utility is isolated in its own file, and the HOC is defined separately, promoting code modularity and reusability.</p>"},{"location":"package/utility/pdf/overview/","title":"Overview","text":""},{"location":"package/utility/pdf/overview/#overview","title":"Overview","text":"<p>Sample PDF URL</p> <pre><code>https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf\n</code></pre> <pre><code>npm install react-pdf pdfjs-dist\n</code></pre> Why? <ul> <li><code>react-pdf</code> relies on <code>pdfjs-dist</code> for the actual PDF rendering.</li> <li>They don\u2019t bundle <code>pdfjs-dist</code> inside react-pdf so you can choose a compatible version.</li> <li>This way you have control over the version of <code>pdfjs-dist</code> and can avoid version mismatches.</li> </ul> <pre><code>npm list pdfjs-dist\n\n# You\u2019ll see something like:\npdfjs-dist@3.11.174\n</code></pre> Quote <p>Ah, yes \u2014 you're seeing the version mismatch error between <code>pdfjs-dist</code> used by the PDF viewer component and the worker script. This happens when:</p> <ul> <li>Your project is using a newer version of <code>pdfjs-dist</code>, e.g., <code>3.11.174</code></li> <li>But your <code>&lt;Worker&gt;</code> component is loading an older <code>pdf.worker.min.js</code>, e.g., <code>3.4.120</code></li> </ul>"},{"location":"package/utility/pdf/overview/#react-pdf","title":"\u2705 react-pdf","text":"<p>A popular and actively maintained PDF viewer for React, built on top of <code>pdf.js</code>.</p> <p>\ud83d\udce6 Install it:</p> <pre><code>npm install @react-pdf-viewer/core\nnpm install react-pdf\n</code></pre> <p>Or, for Yarn:</p> <pre><code>yarn add @react-pdf-viewer/core\nyarn add react-pdf\n</code></pre> \ud83d\udcdd Notes <ul> <li>Works well with React 18+.</li> <li>Internally uses Mozilla's pdf.js (which is very reliable).</li> <li>Supports features like zoom, navigation, and text layer rendering.</li> <li>If you want more UI controls (pagination, zoom buttons, etc.), consider using:</li> </ul>"},{"location":"package/utility/pdf/overview/#alternative-full-featured","title":"\ud83c\udf1f Alternative (Full-Featured):","text":"<p><code>@react-pdf-viewer</code></p> <pre><code>npm install @react-pdf-viewer/core @react-pdf-viewer/default-layout\n</code></pre> <pre><code>import { Viewer, Worker } from \"@react-pdf-viewer/core\";\nimport \"@react-pdf-viewer/core/lib/styles/index.css\";\nimport \"@react-pdf-viewer/default-layout/lib/styles/index.css\";\n\nconst PDFViewer = () =&gt; (\n  &lt;Worker\n    workerUrl={`https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js`}\n  &gt;\n    &lt;Viewer fileUrl=\"/sample.pdf\" /&gt;\n  &lt;/Worker&gt;\n);\n</code></pre> <pre><code>import \"./App.css\";\n\nimport * as test from \"react\";\nimport { Viewer, Worker } from \"@react-pdf-viewer/core\";\nimport \"@react-pdf-viewer/core/lib/styles/index.css\";\n\nfunction App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;header className=\"App-header\"&gt;\n        &lt;img src=\"Octocat.png\" className=\"App-logo\" alt=\"logo\" /&gt;\n        &lt;p&gt;\n          GitHub Codespaces &lt;span className=\"heart\"&gt;\u2665\ufe0f&lt;/span&gt; React\n        &lt;/p&gt;\n        &lt;p className=\"small\"&gt;\n          Edit &lt;code&gt;src/App.jsx&lt;/code&gt; and save to reload.\n        &lt;/p&gt;\n        &lt;p&gt;\n          &lt;a\n            className=\"App-link\"\n            href=\"https://reactjs.org\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          &gt;\n            Learn React\n          &lt;/a&gt;\n        &lt;/p&gt;\n        {console.log(\"react\", test)}\n        &lt;Worker\n          workerUrl={`https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js`}\n        &gt;\n          &lt;div style={{ height: \"750px\" }}&gt;\n            &lt;Viewer fileUrl=\"https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf\" /&gt;\n          &lt;/div&gt;\n        &lt;/Worker&gt;\n      &lt;/header&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre> <pre><code>// src/PDFViewer.jsx (or .tsx)\nimport React from \"react\";\nimport { Document, Page, pdfjs } from \"react-pdf\";\nimport pdfWorkerUrl from \"pdfjs-dist/build/pdf.worker.min.js?url\";\n\npdfjs.GlobalWorkerOptions.workerSrc = pdfWorkerUrl;\n\nexport default function PDFViewer() {\n  return (\n    &lt;Document file=\"https://arxiv.org/pdf/quant-ph/0410100.pdf\"&gt;\n      &lt;Page pageNumber={1} /&gt;\n    &lt;/Document&gt;\n  );\n}\n</code></pre>"},{"location":"package/utility/pdf/overview/#how-to-know-which-version-is-compatible-to-which-version","title":"How to know which version is compatible to which version","text":"<p>Since <code>react-pdf</code> does NOT bundle <code>pdfjs-dist</code>, you need to pick a compatible <code>pdfjs-dist</code> version for the <code>react-pdf</code> version you\u2019re using. Here\u2019s how you can find out which versions match:</p> <ol> <li> <p>Check the <code>react-pdf</code> official docs and release notes</p> <p>The official <code>react-pdf</code> README often mentions the recommended <code>pdfjs-dist</code> version.</p> <p>Look under installation instructions or peer dependencies sections.</p> <p>For example, <code>react-pdf@7.x</code> typically works with <code>pdfjs-dist@2.16.x</code>.</p> <p>You can find this info here:</p> <ul> <li><code>react-pdf</code> GitHub</li> <li><code>react-pdf</code> npm page</li> </ul> </li> <li> <p>Check <code>peerDependencies</code> of <code>react-pdf</code></p> <pre><code>npm info react-pdf peerDependencies\n\npnpm info react-pdf peerDependencies\n</code></pre> <p>It shows which versions of <code>pdfjs-dist</code> the package expects.</p> <p>Example output might look like:</p> <pre><code>{\n  \"pdfjs-dist\": \"^2.6.347\"\n}\n</code></pre> <p>This means any version <code>2.6.x</code> or above (but still 2.x) is expected.</p> </li> <li> <p>Look inside your <code>node_modules/react-pdf/package.json</code></p> <p>If you want to check locally, open:</p> <pre><code>node_modules/react-pdf/package.json\n</code></pre> <p>and find the <code>peerDependencies</code> section.</p> </li> <li> <p>Align major versions</p> </li> <li> <p>Avoid mixing major versions!</p> <p>Using <code>react-pdf@7.x</code> with <code>pdfjs-dist@3.x</code> causes version mismatch errors.</p> <p>Stick to matching <code>2.x</code> versions for now, unless <code>react-pdf</code> docs say otherwise.</p> </li> </ol> <p>Bonus: How to keep versions compatible automatically?</p> <p>Use <code>pnpm</code> or <code>npm</code> resolutions/overrides to force one version across dependencies:</p> <pre><code>\"pnpm\": {\n  \"overrides\": {\n    \"pdfjs-dist\": \"2.16.105\"\n  }\n}\n</code></pre> Summary <ul> <li>Check react-pdf docs or peerDependencies for recommended <code>pdfjs-dist</code> version.</li> <li>Use compatible major versions (e.g. react-pdf 7.x + pdfjs-dist 2.16.x).</li> <li>Use <code>?url</code> import to load the worker from the installed <code>pdfjs-dist</code>.</li> <li>Use package manager overrides to enforce consistent versions if needed.</li> </ul>"},{"location":"package/utility/react-infinite-scroll-component/","title":"Intro","text":""},{"location":"package/utility/react-infinite-scroll-component/#overview","title":"Overview","text":"<p>A component to make all your infinite scrolling woes go away with just 4.15 kB! <code>Pull Down to Refresh</code> feature added. An infinite-scroll that actually works and super-simple to integrate!</p>"},{"location":"package/utility/react-infinite-scroll-component/#install","title":"Install","text":"<pre><code>npm install --save react-infinite-scroll-component\n\n# or\n\nyarn add react-infinite-scroll-component\n\n# in code ES6\nimport InfiniteScroll from 'react-infinite-scroll-component';\n\n# or commonjs\nvar InfiniteScroll = require('react-infinite-scroll-component');\n</code></pre>"},{"location":"package/utility/react-infinite-scroll-component/#using","title":"Using","text":"<pre><code>&lt;InfiniteScroll\n  dataLength={items.length} //This is important field to render the next data\n  next={fetchData}\n  hasMore={true}\n  loader={&lt;h4&gt;Loading...&lt;/h4&gt;}\n  endMessage={\n    &lt;p style={{ textAlign: \"center\" }}&gt;\n      &lt;b&gt;Yay! You have seen it all&lt;/b&gt;\n    &lt;/p&gt;\n  }\n  // below props only if you need pull down functionality\n  refreshFunction={this.refresh}\n  pullDownToRefresh\n  pullDownToRefreshThreshold={50}\n  pullDownToRefreshContent={\n    &lt;h3 style={{ textAlign: \"center\" }}&gt;&amp;#8595; Pull down to refresh&lt;/h3&gt;\n  }\n  releaseToRefreshContent={\n    &lt;h3 style={{ textAlign: \"center\" }}&gt;&amp;#8593; Release to refresh&lt;/h3&gt;\n  }\n&gt;\n  {items}\n&lt;/InfiniteScroll&gt;\n</code></pre>"},{"location":"package/utility/react-infinite-scroll-component/#using-scroll-on-top","title":"Using scroll on top","text":"<pre><code>&lt;div\n  id=\"scrollableDiv\"\n  style={{\n    height: 300,\n    overflow: \"auto\",\n    display: \"flex\",\n    flexDirection: \"column-reverse\",\n  }}\n&gt;\n  {/*Put the scroll bar always on the bottom*/}\n  &lt;InfiniteScroll\n    dataLength={this.state.items.length}\n    next={this.fetchMoreData}\n    style={{ display: \"flex\", flexDirection: \"column-reverse\" }} //To put endMessage and loader to the top.\n    inverse={true} //\n    hasMore={true}\n    loader={&lt;h4&gt;Loading...&lt;/h4&gt;}\n    scrollableTarget=\"scrollableDiv\"\n  &gt;\n    {this.state.items.map((_, index) =&gt; (\n      &lt;div style={style} key={index}&gt;\n        div - #{index}\n      &lt;/div&gt;\n    ))}\n  &lt;/InfiniteScroll&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>InfiniteScroll</code> component can be used in three ways.</p> <ol> <li>Specify a value for the <code>height</code> prop if you want your scrollable content to have a specific height, providing scrollbars for scrolling your content and fetching more data.</li> <li>If your scrollable content is being rendered within a parent element that is already providing overflow scrollbars, you can set the <code>scrollableTarget</code> prop to reference the DOM element and use it's scrollbars for fetching more data.</li> <li>Without setting either the <code>height</code> or <code>scrollableTarget</code> props, the scroll will happen at <code>document.body</code> like Facebook's timeline scroll.</li> </ol>"},{"location":"package/utility/react-infinite-scroll-component/#props-table","title":"Props Table","text":"Prop Type Default Description <code>dataLength</code> <code>number</code> <code>0</code> The length of the data currently loaded. <code>next</code> <code>function</code> <code>required</code> The function to be called when the user scrolls to the bottom. It should load more data. <code>hasMore</code> <code>boolean</code> <code>true</code> Whether there is more data to load or not. If <code>false</code>, scrolling will stop. <code>loader</code> <code>ReactNode</code> <code>null</code> The element or component to show while loading. <code>endMessage</code> <code>ReactNode</code> <code>null</code> A message to display when all items are loaded. <code>scrollThreshold</code> <code>number</code> or <code>string</code> <code>0.9</code> The scroll position at which <code>next</code> is called, usually expressed as a percentage of the viewport. <code>scrollableTarget</code> <code>string</code> or <code>ref</code> <code>null</code> The id or reference to the scrollable element. <code>scrollThreshold</code> <code>number</code> <code>0.9</code> The percentage of the scroll container\u2019s height before <code>next</code> is called. <code>initialScrollY</code> <code>number</code> <code>0</code> The scroll position to start with when the page first loads. <code>pullDownToRefresh</code> <code>boolean</code> <code>false</code> If <code>true</code>, enables pull down to refresh behavior. <code>pullDownToRefreshThreshold</code> <code>number</code> <code>50</code> The distance in pixels that the user must pull down to trigger the refresh action. <code>releaseToRefresh</code> <code>boolean</code> <code>false</code> If <code>true</code>, the user must release the scroll to trigger the refresh action. <code>refreshFunction</code> <code>function</code> <code>null</code> The function to be called when the user pulls down to refresh. <code>header</code> <code>ReactNode</code> <code>null</code> An optional header to be displayed at the top of the scrollable area. <code>style</code> <code>object</code> <code>null</code> Optional inline styles for the component. <code>className</code> <code>string</code> <code>null</code> Optional class names to apply to the root element of the component."},{"location":"package/utility/react-infinite-scroll-component/#reference","title":"Reference","text":"<ul> <li>react-infinite-scroll-component: npmjs</li> <li>react-infinite-scroll-component: github</li> </ul>"},{"location":"package/utility/react-infinite-scroll-component/resuable/","title":"Resuable","text":"Companies.js<pre><code>&lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n  {activeKey === \"4\" &amp;&amp; (\n    &lt;LogList\n      // loading={getCircularPlanningLoading}\n      // data={getCircularPlanningResp}\n      referenceId={getDetails?.referenceId}\n    /&gt;\n  )}\n&lt;/TabPane&gt;\n</code></pre>"},{"location":"package/utility/react-infinite-scroll-component/resuable/#parentwrapper-component","title":"Parent/Wrapper Component\"","text":"ComponentAPIACTIONREDUCERTYPES LogList/index.js<pre><code>import React, { useEffect, useState, useReducer } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { Table } from \"antd\";\nimport moment from \"moment\";\nimport InfiniteScrollTable from \"components/Fallback/InfiniteScrollTable\";\nimport { isEmpty } from \"lodash\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\";\nimport { SearchOutlined } from \"@ant-design/icons\";\n\nconst LogList = (props) =&gt; {\n    let { loading, data, referenceId } = props;\n    const LogoImage = \"assets/images/loader.gif\";\n\n    // added for infinite scroll\n    const dispatch = useDispatch();\n    const [logData, setLogData] = useState([]);\n    const [currentPage, setCurrentpage] = useState(1);\n    const pageSize = 10;\n\n    const { getCircularPlanningResp, getCircularPlanningLoading } = useSelector(\n        (state) =&gt; state.reference\n    );\n\n    const columns = [\n        {\n            title: \"S.N\",\n            dataIndex: \"key\",\n            width: \"8%\",\n            render: (_, __, index) =&gt; index + 1,\n            },\n        {\n            title: (\n                &lt;div\n                style={{\n                    display: \"flex\",\n                    justifyContent: \"space-between\",\n                    alignItems: \"center\",\n                }}\n                &gt;\n                &lt;span&gt;Remarks&lt;/span&gt;\n                &lt;SearchOutlined /&gt;\n                &lt;/div&gt;\n            ),\n            dataIndex: \"remarks\",\n            key: \"remarks\",\n        },\n        {\n            title: \"Creation Time\",\n            dataIndex: \"creationTime\",\n            key: \"creationTime\",\n            render: (text) =&gt; {\n                const formattedDate = moment(text).format(\"YYYY-MM-DD\");\n                const formattedTime = moment(text).format(\"hh:mm A\");\n                return (\n                &lt;span&gt;\n                    {formattedDate}{\" \"}\n                    &lt;span style={{ color: \"red\" }}&gt;{formattedTime}&lt;/span&gt;\n                &lt;/span&gt;\n                );\n            },\n        },\n    ];\n\n    // added for infinit scroll\n    useEffect(() =&gt; {\n        dispatch(\n            actionForCircularPlanningLog(\n                {\n                    ReferenceId: referenceId,\n                    MaxResultCount: pageSize,\n                    SkipCount: 0,\n                },\n                false\n            )\n        );\n    }, [referenceId]);\n\n    useEffect(() =&gt; {\n        if (!isEmpty(getCircularPlanningResp?.items)) {\n            setLogData(getCircularPlanningResp?.items);\n            const newCurrentPage = getCircularPlanningResp?.items?.length / pageSize;\n            setCurrentpage(newCurrentPage);\n        } else {\n            setLogData([]);\n        }\n    }, [getCircularPlanningResp, currentPage, pageSize]);\n\n    const getData = (MaxResultCount = pageSize, SkipCount, loadMore = true) =&gt; {\n        dispatch(\n            actionForCircularPlanningLog(\n                {\n                    ReferenceId: referenceId,\n                    MaxResultCount,\n                    SkipCount,\n                },\n                loadMore\n            )\n        );\n    };\n\n    const getMoreData = () =&gt; {\n        getData(pageSize, currentPage * pageSize, true);\n    };\n\n    return (\n        &lt;&gt;\n            &lt;InfiniteScrollTable\n                fetchData={getMoreData}\n                hasMore={\n                    getCircularPlanningResp?.totalCount &gt;\n                    getCircularPlanningResp?.items?.length\n                }\n                columns={columns}\n                data={logData}\n                loading={getCircularPlanningLoading}\n            /&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default LogList;\n</code></pre> <pre><code>getCircularPlanningLog(q) {\n    let query = queryString.stringify(q);\n    let url = `${appBaseUrl}/referenceManagement/circularplanninglogsGetAllData?${query}`;\n    let data = getService(url, query);\n    return data;\n}\n</code></pre> <pre><code>export const actionForCircularPlanningLog = (q, loadMore) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch(init(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n        const response = await referencesService.getCircularPlanningLog(q);\n        if (response.isSuccess) {\n            if (loadMore) {\n                console.log(\"loadMore\");\n                dispatch(\n                    success(\n                        REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_MORE,\n                        response.data\n                    )\n                );\n            } else {\n                dispatch(\n                success(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG, response.data)\n                );\n            }\n        } else if (!response.isSuccess) {\n            dispatch(error(response.errorMessage));\n        }\n        dispatch(finish(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n    };\n}\n</code></pre> <pre><code>import { uniqBy, sortBy } from \"lodash\";\n\ncase REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS:\n  return {\n    ...state,\n    getCircularPlanningResp: state.getCircularPlanningResp\n      ? {\n          items: uniqBy(\n            state.getCircularPlanningResp?.items.concat(\n              action.payload.items\n            ),\n            \"id\"\n          ),\n          totalCount: action.payload.totalCount,\n        }\n      : action.payload,\n    getCircularPlanningLoading: action.payload ? false : true,\n};\n</code></pre> <pre><code>let REFERENCE__TYPES = {\n    GET_CIRCULAR_PLANNING_LOG: \"GET_CIRCULAR_PLANNING_LOG\",\n    GET_CIRCULAR_PLANNING_LOG_INIT: \"GET_CIRCULAR_PLANNING_LOG_INIT\",\n    GET_CIRCULAR_PLANNING_LOG_SUCCESS: \"GET_CIRCULAR_PLANNING_LOG_SUCCESS\",\n    GET_CIRCULAR_PLANNING_LOG_FINISH: \"GET_CIRCULAR_PLANNING_LOG_FINISH\",\n    GET_CIRCULAR_PLANNING_LOG_MORE: \"GET_CIRCULAR_PLANNING_LOG_MORE\",\n    GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS:\n        \"GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS\",\n}\n</code></pre>"},{"location":"package/utility/react-infinite-scroll-component/resuable/#infinite-scroll-reuable-component","title":"Infinite Scroll Reuable Component","text":"InfiniteScrollTable.jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport InfiniteScroll from \"react-infinite-scroll-component\";\nimport { Table, Spin, Skeleton, message } from \"antd\";\n\nconst InfiniteScrollTable = ({\n  fetchData,\n  hasMore,\n  columns,\n  data,\n  loading = false,\n}) =&gt; {\n  return (\n    &lt;div\n      id=\"scrollable-table\"\n      style={{\n        height: 200,\n        overflow: \"auto\",\n        display: \"flex\",\n        flexDirection: \"column\",\n      }}\n    &gt;\n      &lt;InfiniteScroll\n        dataLength={data?.length}\n        next={fetchData}\n        // next={() =&gt; {\n        //   console.log(\"Scroll triggered\");\n        //   fetchData();\n        // }}\n        hasMore={hasMore}\n        loader={&lt;Skeleton active={4} /&gt;}\n        endMessage={&lt;p style={{ textAlign: \"center\" }}&gt;No more data&lt;/p&gt;}\n        scrollThreshold={0.6}\n        scrollableTarget=\"scrollable-table\"\n      &gt;\n        &lt;Table\n          columns={columns}\n          dataSource={data}\n          pagination={false}\n          loading={loading}\n          rowKey=\"id\"\n          // scroll={{ y: 200 }}\n        /&gt;\n      &lt;/InfiniteScroll&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default InfiniteScrollTable;\n</code></pre>"},{"location":"package/utility/react-infinite-scroll-component/resuable/#update-with-searchkeyword","title":"Update with <code>SearchKeyword</code>","text":"index.jsLogModal.jsx <pre><code>// Added the Modal &amp; Search\nconst [formLog] = Form.useForm();\nconst [visibleLogModal, setVisibleLogModal] = useState(false);\nconst [searchKeyWord, setSearchKeyWord] = useState(null);\n\n\n// added\nuseEffect(() =&gt; {\n    dispatch(\n    actionForCircularPlanningLog(\n        {\n            ReferenceId: referenceId,\n            MaxResultCount: pageSize,\n            SkipCount: 0,\n            SearchKeyword: searchKeyWord,\n        },\n        false\n    )\n    );\n}, [referenceId, searchKeyWord]);\n\nconst getData = (\n    MaxResultCount = pageSize,\n    SkipCount,\n    // added\n    SearchKeyword,\n    loadMore = true\n) =&gt; {\n    dispatch(\n    actionForCircularPlanningLog(\n        {\n            ReferenceId: referenceId,\n            MaxResultCount,\n            SkipCount,\n            // added\n            SearchKeyword,\n        },\n        loadMore\n    )\n    );\n};\n\nconst getMoreData = () =&gt; {\n    // added searchKeyword\n    getData(pageSize, currentPage * pageSize, searchKeyWord, true);\n};\n\n\n// Handle\nconst handleOk = async () =&gt; {\n    try {\n        const values = await formLog.validateFields();\n        const formattedDate = moment(values.date).format(\"YYYY-MM-DD\");\n\n        setSearchKeyWord(values?.title);\n        handleCancel();\n        formLog.resetFields();\n    } catch (error) {\n        console.log(\"Failed to submit:\", error);\n    }\n};\n\nconst handleCancel = () =&gt; {\n    setVisibleLogModal(false);\n};\n\n\nconst columns = [\n    {\n        title: (\n            &lt;div\n                style={{\n                display: \"flex\",\n                justifyContent: \"space-between\",\n                alignItems: \"center\",\n                }}\n            &gt;\n                &lt;span&gt;Remarks&lt;/span&gt;\n                {isNull(searchKeyWord) ? (\n                    &lt;SearchOutlined\n                        style={{ color: \"blue\" }}\n                        onClick={() =&gt; setVisibleLogModal(true)}\n                    /&gt;\n                    ) : (\n                    &lt;CloseCircleTwoTone\n                        onClick={() =&gt; {\n                        setSearchKeyWord(null);\n                        }}\n                        twoToneColor=\"red\"\n                    /&gt;\n                )}\n            &lt;/div&gt;\n        ),\n        width: \"70%\",\n        dataIndex: \"remarks\",\n        key: \"remarks\",\n    },\n]\n</code></pre> <pre><code>import React from \"react\";\nimport { Modal, Form, Input, DatePicker } from \"antd\";\n\nconst LogModal = ({ visible, form, onOk, onCancel }) =&gt; {\n\n    return (\n        &lt;Modal\n            title=\"Log Information\"\n            visible={visible}\n            onOk={onOk}\n            onCancel={onCancel}\n            okText=\"Submit\"\n            cancelText=\"Cancel\"\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" name=\"log_form\"&gt;\n                &lt;Form.Item\n                    name=\"title\"\n                    label=\"Title\"\n                    rules={[{ required: true, message: \"Please enter a title!\" }]}\n                &gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n\n                {/* &lt;Form.Item\n                name=\"date\"\n                label=\"Date\"\n                rules={[{ required: true, message: \"Please select a date!\" }]}\n                &gt;\n                &lt;DatePicker style={{ width: \"100%\" }} /&gt;\n                &lt;/Form.Item&gt; */}\n            &lt;/Form&gt;\n        &lt;/Modal&gt;\n    );\n};\n\nexport default LogModal;\n</code></pre> <p>Optional Enhancements</p> <ul> <li>Tooltips for icons: If you want to add tooltips for better UX, you can wrap the icons in Ant Design's Tooltip component:</li> </ul> <pre><code>import { Tooltip } from \"antd\";\n\n{\n  searchKeyWord ? (\n    &lt;Tooltip title=\"Clear search\"&gt;\n      &lt;CloseCircleTwoTone\n        style={{ cursor: \"pointer\" }}\n        onClick={() =&gt; setSearchKeyWord(null)}\n        twoToneColor=\"red\"\n      /&gt;\n    &lt;/Tooltip&gt;\n  ) : (\n    &lt;Tooltip title=\"Search\"&gt;\n      &lt;SearchOutlined\n        style={{ cursor: \"pointer\", color: \"blue\" }}\n        onClick={() =&gt; setVisibleLogModal(true)}\n      /&gt;\n    &lt;/Tooltip&gt;\n  );\n}\n</code></pre> <ul> <li>Adding a Loading State: If there\u2019s a need to indicate loading or processing, you can conditionally render the icons based on a loading state.</li> </ul>"},{"location":"package/utility/tinymce/tinymce/","title":"Intro","text":"<p>TinyMCE is a popular WYSIWYG editor that can be integrated into React applications. To add a template inside the TinyMCE editor in a React project, you can follow these general steps:</p> <ol> <li> <p>Install TinyMCE:     If you haven't already, install the TinyMCE editor in your React project using a package manager like npm or yarn. Here's an example using npm:</p> <pre><code>npm install tinymce\n</code></pre> </li> <li> <p>Import TinyMCE in your React component:     Import TinyMCE in the React component where you want to use the editor.</p> <pre><code>import { Editor } from \"@tinymce/tinymce-react\";\n</code></pre> </li> <li> <p>Configure TinyMCE:     Set up the TinyMCE configuration in your component. This is where you can define the template and other settings.</p> <pre><code>const TinyMCEEditor = () =&gt; {\n  const handleEditorChange = (content, editor) =&gt; {\n    // Handle content changes here\n    console.log(\"Content:\", content);\n  };\n\n  const templateContent = `\n    &lt;p&gt;This is a template content&lt;/p&gt;\n`;\n\n  return (\n    &lt;Editor\n      apiKey=\"YOUR_API_KEY\" // You can obtain an API key by creating a TinyMCE account\n      initialValue={templateContent}\n      init={{\n        height: 500,\n        menubar: false,\n        plugins: [\n          \"advlist autolink lists link image charmap print preview anchor\",\n          \"searchreplace visualblocks code fullscreen\",\n          \"insertdatetime media table paste code help wordcount\",\n        ],\n        toolbar:\n          \"undo redo | formatselect | bold italic backcolor | \\\n        alignleft aligncenter alignright alignjustify | \\\n        bullist numlist outdent indent | removeformat | help\",\n        content_style:\n          \"body { font-family:Helvetica,Arial,sans-serif; font-size:14px }\",\n      }}\n      onChange={handleEditorChange}\n    /&gt;\n  );\n};\n\nexport default TinyMCEEditor;\n</code></pre> <p>In the above example, templateContent is the initial content of the editor, and you can customize the init object to include the desired plugins, toolbar buttons, and other configurations.</p> </li> <li> <p>Handle Template Insertion:</p> <p>You can provide a button or some other user interaction to insert the template content into the editor. For example, you can add a button that, when clicked, inserts the template content at the current cursor position.</p> <pre><code>const insertTemplate = () =&gt; {\n  const editor = tinymce.activeEditor;\n  if (editor) {\n    editor.insertContent(templateContent);\n  }\n};\n\n// ...\n\n&lt;button onClick={insertTemplate}&gt;Insert Template&lt;/button&gt;;\n</code></pre> <p>Make sure to adapt the code according to your specific requirements and integrate it seamlessly into your React application. Adjust the TinyMCE configuration and event handlers based on your needs.</p> </li> </ol>"},{"location":"pattern/antipattern/","title":"Anti Pattern","text":"<ol> <li> <p>Using <code>indexes</code> as a key</p> <p>Bug</p> <pre><code>return (\n&lt;div&gt;\n    &lt;ul&gt;\n    {items.map((item, index) =&gt; (\n        &lt;li key={index}&gt;\n            {item}\n            &lt;input type=\"text\" /&gt;\n        &lt;/li&gt;\n    ))}\n    &lt;/ul&gt;\n\n    &lt;button onClick={handleClick}&gt;+&lt;/button&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>To solve this problem, we can, for example, use the value of the item if we expect it not to be repeated within the list, or create a unique identifier, for example:</p> <p>Success</p> <pre><code>{items.map((item, index) =&gt; (\n    &lt;li key={`${item}-${index}`}&gt;\n        {item}\n        &lt;input type=\"text\" /&gt;\n    &lt;/li&gt;\n))}\n</code></pre> </li> <li> <p>Spreading properties on DOM elements</p> </li> </ol>"},{"location":"pattern/compound-pattern/","title":"Compound Pattern","text":"<p>Let's create a compound component for a <code>Modal</code> that can be used to display various types of content. The compound components will include <code>Modal</code>, <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code>.</p> Modal.jsModalHeader.jsModalBody.jsModalFooter.js <pre><code>import React, { useState } from 'react';\n\nconst Modal = ({ children, isOpen, onClose }) =&gt; {\n    return isOpen ? (\n        &lt;div className=\"modal-overlay\" onClick={onClose}&gt;\n            &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n                {children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    ) : null;\n};\n\nexport default Modal;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalHeader = ({ children }) =&gt; {\n    return &lt;div className=\"modal-header\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalHeader;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalBody = ({ children }) =&gt; {\n    return &lt;div className=\"modal-body\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalBody;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalFooter = ({ children }) =&gt; {\n    return &lt;div className=\"modal-footer\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalFooter;\n</code></pre> <p>Now, let's use these components in an example application:</p> App.js<pre><code>// App.js\nimport React, { useState } from \"react\";\nimport Modal from \"./Modal\";\nimport ModalHeader from \"./ModalHeader\";\nimport ModalBody from \"./ModalBody\";\nimport ModalFooter from \"./ModalFooter\";\n\nconst App = () =&gt; {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const openModal = () =&gt; {\n    setIsModalOpen(true);\n  };\n\n  const closeModal = () =&gt; {\n    setIsModalOpen(false);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Compound Pattern in React - Modal Example&lt;/h1&gt;\n      &lt;button onClick={openModal}&gt;Open Modal&lt;/button&gt;\n\n      &lt;Modal isOpen={isModalOpen} onClose={closeModal}&gt;\n        &lt;ModalHeader&gt;\n          &lt;h2&gt;Modal Title&lt;/h2&gt;\n        &lt;/ModalHeader&gt;\n        &lt;ModalBody&gt;\n          &lt;p&gt;This is the content of the modal.&lt;/p&gt;\n        &lt;/ModalBody&gt;\n        &lt;ModalFooter&gt;\n          &lt;button onClick={closeModal}&gt;Close&lt;/button&gt;\n        &lt;/ModalFooter&gt;\n      &lt;/Modal&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Modal</code> component serves as the container for the modal content. The <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code> components are used within the <code>Modal</code> component to structure and style the different parts of the modal.</p> <p>This compound pattern allows you to create a reusable and flexible modal component by composing smaller components together. Each smaller component focuses on a specific part of the modal, making the code more modular and maintainable.</p>"},{"location":"pattern/container-presentational-patterns/","title":"container presentational patterns","text":"<p>React components typically contain a mix of logic and presentation. By logic, we refer to anything that is unrelated to the UI, such as API calls, data manipulation, and event handlers. The presentation is the part of the render where we create the elements to be displayed on the UI.</p> <p>In React, there are simple and powerful patterns, known as container and presentational, which we can apply when creating components that help us to separate those two concerns.</p>"},{"location":"pattern/function-as-child/","title":"FaC Pattern","text":""},{"location":"pattern/function-as-child/#function-as-child-fac-pattern","title":"Function as Child (FaC) pattern","text":"<p>In React, the \"<code>Function as Child</code>\" (FaC) pattern involves passing a function as a child of a component. This pattern is also known as \"Render Props.\" The basic idea is to pass a function as a child to a component, allowing the component to render content or behavior based on the result of that function.</p> <p>Here's a simple example to illustrate the Function as Child pattern:</p> ParentComponent.js<pre><code>import React from \"react\";\n\nconst ParentComponent = ({ children }) =&gt; {\n  // Execute the function (child) and pass data to it\n  return &lt;div&gt;{children(\"Data from Parent\")}&lt;/div&gt;;\n};\n\nexport default ParentComponent;\n</code></pre> <p>Now, you can use <code>ParentComponent</code> in another component and pass a function as its child:</p> App.js<pre><code>import React from \"react\";\nimport ParentComponent from \"./ParentComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern&lt;/h1&gt;\n\n      {/* Using ParentComponent and passing a function as its child */}\n      &lt;ParentComponent&gt;\n        {(dataFromParent) =&gt; (\n          &lt;p&gt;{`Received data in child component: ${dataFromParent}`}&lt;/p&gt;\n        )}\n      &lt;/ParentComponent&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>ParentComponent</code> takes a <code>children</code> prop, which is a function. Inside <code>ParentComponent</code>, it calls the <code>children</code> function and passes some data (\"<code>Data from Parent</code>\" in this case). The child component (the function passed as a child) then receives this data and can use it to render content.</p> <p>The main benefit of the Function as Child pattern is that it allows you to inject dynamic behavior or data into a component from its parent without the need for complex props or state management. It provides a way to share functionality between components in a more flexible and composable manner.</p> <p>This pattern is commonly used in React, especially in cases where you want to abstract away some logic or behavior into a component but allow customization in its usage by passing functions as children.</p> <p>Real Example</p> <p>Lets create <code>Toggle</code> component that can be used to toggle the visibility of content.</p> Toggle.js<pre><code>import React, { useState } from \"react\";\n\nconst Toggle = ({ children }) =&gt; {\n  const [isVisible, setIsVisible] = useState(false);\n\n  const toggleVisibility = () =&gt; {\n    setIsVisible(!isVisible);\n  };\n\n  // Render the child function and pass the toggleVisibility function and the current visibility state\n  return children({ isVisible, toggleVisibility });\n};\n\nexport default Toggle;\n</code></pre> <p>Now, let's use the <code>Toggle</code> component in another component:</p> App.js<pre><code>import React from \"react\";\nimport Toggle from \"./Toggle\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern - Toggle Example&lt;/h1&gt;\n\n      {/* Using Toggle and passing a function as its child */}\n      &lt;Toggle&gt;\n        {({ isVisible, toggleVisibility }) =&gt; (\n          &lt;div&gt;\n            &lt;button onClick={toggleVisibility}&gt;Toggle Visibility&lt;/button&gt;\n\n            {isVisible &amp;&amp; &lt;p&gt;This content is now visible!&lt;/p&gt;}\n          &lt;/div&gt;\n        )}\n      &lt;/Toggle&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Toggle</code> component encapsulates the state and logic for toggling visibility. It takes a function as a child, and that function receives an object with two properties: <code>isVisible</code> (a boolean indicating whether the content is visible) and <code>toggleVisibility</code> (a function to toggle the visibility).</p> <p>The <code>App</code> component uses the <code>Toggle</code> component, passing a function as its child. Inside the function, it receives the <code>isVisible</code> state and the <code>toggleVisibility</code> function, and it uses these to conditionally render content.</p> <p>This pattern is powerful because it allows you to encapsulate state and behavior within a component while giving the consumer of that component full control over the rendering and customization of the UI based on the component's state.</p>"},{"location":"pattern/hoc-pattern/","title":"HoC Pattern","text":"<p>Higher-Order Components (HOCs) are a design pattern in React that allows the reuse of component logic.</p> <p>A Higher-Order Component is a function that takes a component and returns a new component with additional props or behavior. HOCs are commonly used for cross-cutting concerns such as authentication, logging, and data fetching.</p> <p>Here's an example of a Higher-Order Component using a functional component:</p> withLogging.js (HOC file):MyComponent.jsApp.js jsx<pre><code>import React, { useEffect } from 'react';\n\nconst withLogging = (WrappedComponent) =&gt; {\n    const WithLogging = (props) =&gt; {\n        useEffect(() =&gt; {\n            console.log(`Component ${WrappedComponent.name || 'Anonymous'} is mounted`);\n            return () =&gt; {\n                console.log(`Component ${WrappedComponent.name || 'Anonymous'} is unmounted`);\n            };\n        }, []);\n\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n\n    return WithLogging;\n};\n\nexport default withLogging;\n</code></pre> jsx<pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n    return &lt;div&gt;Hello, I'm a functional component!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> jsx<pre><code>import React from 'react';\nimport withLogging from './withLogging';\nimport MyComponent from './MyComponent';\n\nconst MyComponentWithLogging = withLogging(MyComponent);\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;MyComponentWithLogging /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>In this structure:</p> <ul> <li><code>withLogging.js</code> contains the HOC (withLogging).</li> <li><code>MyComponent.js</code> contains the functional component (MyComponent).</li> <li><code>App.js</code> uses the HOC by importing it and applying it to MyComponent.</li> </ul> <p>This modular approach allows you to organize your code better and promotes reusability. You can easily apply the withLogging HOC to other components in different files without duplicating the logic.</p>"},{"location":"pattern/hoc-pattern/#when-naming-higher-order-component-hoc-files-in-a-react-application","title":"When naming Higher-Order Component (HOC) files in a React application","text":"<ul> <li> <p>Prefix with \"with\":</p> <p>It's a common convention to prefix the HOC file name with \"with\" to indicate that it is a Higher-Order Component.</p> <pre><code>withExampleHOC.js\nwithAuthentication.js\nwithTheme.js\n</code></pre> </li> <li> <p>Suffix with \"HOC\":</p> <p>Optionally, you can suffix the file name with \"HOC\" to make it explicit that it is a Higher-Order Component.</p> <pre><code>ExampleComponentHOC.js\nAuthenticationHOC.js\n</code></pre> </li> </ul>"},{"location":"pattern/hoc-pattern/#real-example","title":"Real Example","text":"<p>You can organize your code in a way that makes sense for your project structure. Here's an example of how you might structure the file:</p> withConditionalFormItem.js<pre><code>import React from \"react\";\nimport { Form } from \"antd\";\n\nconst withConditionalFormItem = (WrappedComponent, condition) =&gt; {\n  return (props) =&gt; {\n    if (condition) {\n      return &lt;WrappedComponent {...props} /&gt;;\n    } else {\n      return null; // or you can render an alternative component/message\n    }\n  };\n};\n\nexport default withConditionalFormItem;\n</code></pre> <p>Then, in your main component file:</p> YourFormComponent.js<pre><code>//\nimport React from \"react\";\nimport { Form, Input } from \"antd\";\nimport withConditionalFormItem from \"./withConditionalFormItem\";\n\n// Usage\nconst ConditionalRemarksFormItem = withConditionalFormItem(\n  Form.Item,\n  !isCircular // Condition based on your boolean value\n);\n\nconst YourFormComponent = () =&gt; {\n  return (\n    &lt;Form&gt;\n      {/* Other Form items */}\n      &lt;ConditionalRemarksFormItem label=\"Remarks\" name=\"remarks\"&gt;\n        &lt;Input.TextArea rows={4} placeholder=\"Remarks\" /&gt;\n      &lt;/ConditionalRemarksFormItem&gt;\n      {/* Other Form items */}\n    &lt;/Form&gt;\n  );\n};\n\nexport default YourFormComponent;\n</code></pre> <p>This way, you have a separate file for the higher-order component, making it easy to reuse across different components in your project.</p>"},{"location":"pattern/misc/","title":"Misc","text":""},{"location":"pattern/misc/#conditional-rendering-pattern","title":"<code>Conditional Rendering</code> pattern","text":"<pre><code>import React from \"react\";\n\nconst YourComponent = ({ singleCircularReferenceTemplateResponse }) =&gt; {\n  // Check if the response is still loading\n  const isLoading = !singleCircularReferenceTemplateResponse;\n\n  // Check if the response has content\n  const hasContent = !!singleCircularReferenceTemplateResponse?.content;\n\n  return (\n    &lt;div&gt;\n      {isLoading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {!isLoading &amp;&amp; !hasContent &amp;&amp; &lt;p&gt;No Content available.&lt;/p&gt;}\n      {!isLoading &amp;&amp; hasContent &amp;&amp; (\n        &lt;div\n          dangerouslySetInnerHTML={{\n            __html: singleCircularReferenceTemplateResponse.content,\n          }}\n        &gt;&lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"pattern/react-pattern-intro/","title":"Introduction","text":""},{"location":"pattern/react-pattern-intro/#react-design-patterns","title":"React Design Patterns","text":"<ul> <li><code>Compound</code> Pattern</li> <li><code>HOC</code> Pattern</li> <li><code>Hooks</code> Pattern</li> <li><code>Container/Presentational</code> Pattern</li> <li><code>Render Props</code> Pattern</li> </ul>"},{"location":"pattern/react-pattern-intro/#reference","title":"Reference","text":"<ul> <li>reactpatterns.js.org</li> <li>patterns.dev</li> <li> <p>reactpatterns.com</p> </li> <li> <p>React Design Patterns</p> </li> </ul>"},{"location":"react/business-logic/","title":"Business Logic Separation","text":""},{"location":"react/business-logic/#separate-business-logic-from-ui-logic","title":"Separate Business Logic from UI Logic","text":"<p>Best Practices for Organizing Business Logic in a React Application</p> <p>Organizing business logic effectively is crucial for building scalable, maintainable, and testable React applications. Here are the most widely recommended best practices, supported by expert sources:</p>"},{"location":"react/business-logic/#1-separate-business-logic-from-ui","title":"1. Separate Business Logic from UI","text":"<ul> <li> <p>Encapsulate business logic (such as API calls, data transformations, and state management) outside of UI components. This keeps components focused on rendering and user interaction, improving modularity and maintainability.</p> </li> <li> <p>Use custom hooks to abstract business logic from components, making your codebase cleaner and more reusable</p> </li> </ul>"},{"location":"react/business-logic/#2-use-custom-hooks-for-reusable-logic","title":"2. Use Custom Hooks for Reusable Logic","text":"<ul> <li>Identify logic related to data fetching, state management, or side effects, and move it into custom hooks. This pattern allows you to reuse logic across multiple components and keeps UI components simple.</li> <li>Compose multiple custom hooks for complex business requirements, further enhancing code modularity.</li> </ul>"},{"location":"react/business-logic/#3-adopt-a-layered-architecture","title":"3. Adopt a Layered Architecture","text":"<ul> <li> <p>Organize your code into clear layers, such as:</p> </li> <li> <p>Presentation Layer: UI components (stateless, focused on rendering).</p> </li> <li> <p>Application/Domain Layer: Business logic, state management, and data manipulation (custom hooks, services, or context).</p> </li> <li> <p>This separation of concerns makes the codebase easier to scale and maintain.</p> </li> </ul>"},{"location":"react/business-logic/#4-feature-based-or-domain-driven-folder-structure","title":"4. Feature-Based or Domain-Driven Folder Structure","text":"<ul> <li> <p>Structure your project by features or domains rather than by type (e.g., group related components, hooks, and services for a feature together).</p> </li> <li> <p>Example structure:</p> </li> </ul> <pre><code>src/\n\u251c\u2500\u2500 features/\n\u2502     \u2514\u2500\u2500 product/\n\u2502           \u251c\u2500\u2500 ProductView.js\n\u2502           \u251c\u2500\u2500 useProduct.js\n\u2502           \u251c\u2500\u2500 productService.js\n\u251c\u2500\u2500 components/\n\u251c\u2500\u2500 hooks/\n\u251c\u2500\u2500 services/\n\u251c\u2500\u2500 utils/\n</code></pre> <p>This approach keeps related business logic and UI close, while still separated.</p>"},{"location":"react/business-logic/#5-use-state-management-wisely","title":"5. Use State Management Wisely","text":"<ul> <li>For global or cross-cutting business logic, consider state management libraries like Redux, Zustand, or Context API. Place business logic in selectors, reducers, or context providers, not in UI components.</li> <li>For local or feature-specific logic, custom hooks and local state are often sufficient.</li> </ul>"},{"location":"react/business-logic/#6-keep-business-logic-dry-and-testable","title":"6. Keep Business Logic DRY and Testable","text":"<ul> <li>Extract pure business logic into standalone functions or service modules (e.g., in a <code>services/</code> or <code>utils/</code> folder). This makes them easier to test and reuse.</li> <li>Avoid duplicating logic across components; centralize it in hooks or services.</li> </ul>"},{"location":"react/business-logic/#7-consistent-naming-and-clear-responsibility","title":"7. Consistent Naming and Clear Responsibility","text":"<ul> <li>Use descriptive, consistent naming conventions for files, hooks, and services to improve code readability and maintainability.</li> <li>Ensure each module or file has a clear, single responsibility.</li> </ul>"},{"location":"react/business-logic/#summary-table","title":"Summary Table","text":"Practice Benefit Custom hooks for business logic Reusability, clean UI components Layered/feature-based structure Scalability, separation of concerns State management for global logic Predictability, maintainability Standalone services/utilities Testability, DRY code Consistent naming conventions Readability, collaboration <p>By following these practices\u2014separating business logic from UI, using custom hooks, adopting a layered and feature-based structure, and keeping logic DRY and testable\u2014you ensure your React application remains robust, maintainable, and scalable as it grows.</p>"},{"location":"react/business-logic/#keeping-state-business-logic-away-from-components","title":"Keeping State Business Logic Away from Components","text":"<p>Separate the state management logic from the UI logic that can help you in multiple ways. Components that do both are not impactful as they make them less reusable, more difficult to test, and difficult to refactor, especially when you\u2019re looking for state management.</p> <p>Rather than writing the logic for placement of the state inside a component, the best move is to extract it into a hook of its own.and another child component that contains the user interface. Then, call the child inside while the adult hands over all the necessary props.</p> <pre><code>// BAD\n\nconst App = () =&gt; {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [status, setStatus] = useState(\"idle\");\n\n  useEffect(() =&gt; {\n    setStatus(\"loading\");\n\n    fetch(\"https://api.example.com/data\")\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setStatus(\"success\");\n      })\n      .catch((error) =&gt; {\n        setError(error);\n        setStatus(\"error\");\n      });\n  }, []);\n\n  if (status === \"idle\" || status === \"loading\") {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  if (status === \"error\") {\n    return &lt;div&gt;{error}&lt;/div&gt;;\n  }\n\n  if (status === \"success\") {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n  }\n};\n\n// GOOD\n\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [status, setStatus] = useState(\"idle\");\n\n  useEffect(() =&gt; {\n    setStatus(\"loading\");\n\n    fetch(url)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setStatus(\"success\");\n      })\n      .catch((error) =&gt; {\n        setError(error);\n        setStatus(\"error\");\n      });\n  }, []);\n\n  return { data, error, status };\n};\n\nconst App = () =&gt; {\n  const { data, error, status } = useFetch(\"https://api.example.com/data\");\n\n  if (status === \"idle\" || status === \"loading\") {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  if (status === \"error\") {\n    return &lt;div&gt;{error}&lt;/div&gt;;\n  }\n\n  if (status === \"success\") {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n  }\n};\n</code></pre>"},{"location":"react/business-logic/#related-blog-posts","title":"Related Blog Posts","text":"<ul> <li>Path To A Clean(er) React Architecture (Part 6)Business Logic Separation</li> <li>Where do you put your business logic in your React app?</li> <li> <p>Mastering the Art of Separating UI and Logic in React: A Comprehensive Guide</p> </li> <li> <p>Mastering React: Proven Strategies and Best Practices </p> </li> <li>The right way to place business logic in your React application</li> <li>How to Organize a Large React Application and Make It Scale</li> <li>8 ReactJS Best Practices for Writing Better Code</li> <li>From Angular to React - how to decouple business logic from components?</li> <li>React Architecture Best Practices and Tips from Community Experts</li> <li>Best Practices for Writing Clean React Code with Examples</li> </ul>"},{"location":"react/intro/","title":"Intro","text":""},{"location":"react/intro/#programming-paradigm","title":"Programming Paradigm","text":"<ul> <li>imperative (how to do)</li> <li>declarative (what to do)</li> </ul>"},{"location":"react/intro/#react-is-declarative","title":"React is declarative","text":"<p>In declarative programming, you concentrate on the \"<code>what</code>\". Not the \"<code>how</code>\". For instance, the following snippet tells your app to serve certain pages at the given route-paths.</p> <p>Libraries:</p> <ul> <li>React</li> <li>React-Router</li> <li>React-Apollo (GraphQL)</li> <li>Styled-Components</li> <li>Express</li> <li>Infrastructure-Components</li> </ul> <p>Notes</p> <ul> <li> <p><code>React.js</code> removed the boundaries between HTML and JavaScript. It uses the Javascript   Syntax Extension (JSX) that complements basic Javascript source code with HTML.</p> </li> <li> <p><code>Styled-Components</code> added a convenient way of styling your React-components. There\u2019s no   need for global style sheets anymore.</p> </li> <li> <p>With <code>Infrastructure-Components</code>, you can integrate REST-services into your React app. As   well as database schemes and queries. You can even configure your serverless infrastructure.</p> </li> </ul> <p>life is an experiment. The more experiments you make the better. - Ralph Waldo Emerson</p>"},{"location":"react/intro/#different-ways-to-scaffold-a-react-application","title":"Different Ways to Scaffold a React Application","text":"<p>There are several ways to create and scaffold a React application. Here are some of the most popular methods:</p>"},{"location":"react/intro/#1-create-react-app-cra","title":"1. Create React App (CRA)","text":"<p>Create React App is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration.</p> Installation:<pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre>"},{"location":"react/intro/#2-vite","title":"2. Vite","text":"<p>Vite is a fast build tool that offers an alternative to Create React App with a focus on speed and performance.</p> Installation:<pre><code>npm create vite@latest my-app --template react\ncd my-app\nnpm install\nnpm run dev\n</code></pre>"},{"location":"react/intro/#3-nextjs","title":"3. Next.js","text":"<p>Next.js is a powerful framework built on top of React for building server-side rendered (SSR) and statically generated (SSG) websites.</p> Installation:<pre><code>npx create-next-app@latest my-app\ncd my-app\nnpm run dev\n</code></pre>"},{"location":"react/intro/#4-gatsby","title":"4. Gatsby","text":"<p>Gatsby is a React-based framework for building fast static websites and apps.</p> Installation:<pre><code>npm install -g gatsby-cli\ngatsby new my-app\ncd my-app\ngatsby develop\n</code></pre>"},{"location":"react/intro/#5-parcel","title":"5. Parcel","text":"<p>Parcel is a web application bundler that can also be used to scaffold a React project with zero configuration.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom parcel\n</code></pre> Project Structure: <ol> <li> <p>Create an <code>index.html</code> file:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create an <code>index.js</code> file:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"app\"));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx parcel index.html\n</code></pre>"},{"location":"react/intro/#6-manual-setup-with-webpack-and-babel","title":"6. Manual Setup with Webpack and Babel","text":"<p>For more control over the configuration, you can set up a React project manually using Webpack and Babel.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin\n</code></pre> Configuration <ol> <li> <p>Create a <code>webpack.config.js</code> file:</p> <pre><code>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist'\n  }\n};\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n</code></pre> </li> <li> <p>Create an <code>index.html</code> file in src:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('app'));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx webpack serve\n</code></pre> <p>These methods cover a range of scenarios from quick setups with Create React App to more complex configurations with Next.js and manual setups using Webpack. Choose the one that best fits your project's needs.</p>"},{"location":"react/intro/#recommendation","title":"Recommendation","text":"<p>For most modern React projects, Next.js is a highly recommended choice due to its flexibility, performance benefits, and future-proof features. It supports a wide range of use cases, from simple SPAs to complex, SEO-friendly applications.</p> <p>Create React App is also a solid choice for simpler projects or for those who prefer minimal configuration and an easy setup process. However, as projects scale, you might find the need to switch to a more flexible solution like Next.js.</p> <p>Vite is gaining traction and can be an excellent choice for developers who prioritize build speed and modern tooling.</p> <p>Gatsby remains a strong option for static site generation and content-driven projects.</p> <p>Ultimately, the choice depends on your project requirements, team familiarity, and long-term goals. All of these tools have strong communities and regular updates, ensuring they remain relevant and useful for years to come.</p>"},{"location":"react/intro/#reference","title":"Reference","text":"<ul> <li> <p>React-Architect by Dr.Frank Zickert</p> </li> <li> <p>What is Programming Paradigm?</p> </li> </ul>"},{"location":"react/philosophy/","title":"Philosophy","text":"<p>The main philosophy of React revolves around several key principles that shape how it addresses user interface development. Here\u2019s a summary of the core philosophies behind React:</p>"},{"location":"react/philosophy/#1-declarative-ui","title":"1. Declarative UI:","text":"<p>React emphasizes a declarative approach to building user interfaces. Instead of describing the sequence of steps needed to achieve a result (imperative programming), you describe what the UI should look like based on the current state (declarative programming). React then handles the process of updating the UI efficiently when the state changes.</p> <ul> <li> <p>Declarative Example:</p> <pre><code>function MyComponent({ isVisible }) {\n    return isVisible ? &lt;div&gt;Visible&lt;/div&gt; : &lt;div&gt;Hidden&lt;/div&gt;;\n}\n</code></pre> <p>In this example, you describe what the UI should look like based on the <code>isVisible</code> prop, and React takes care of updating the DOM accordingly.</p> </li> </ul>"},{"location":"react/philosophy/#2-component-based-architecture","title":"2. Component-Based Architecture:","text":"<p>React promotes building user interfaces through reusable components. Each component is a self-contained piece of the UI that manages its own state and logic. Components can be composed together to build more complex UIs.</p> <ul> <li> <p>Component Example:</p> <pre><code>function Button({ onClick, children }) {\n    return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;\n}\n\nfunction App() {\n    return &lt;Button onClick={() =&gt; alert('Clicked!')}&gt;Click Me&lt;/Button&gt;;\n}\n</code></pre> <p>Here, <code>Button</code> is a reusable component that can be used throughout your application.</p> </li> </ul>"},{"location":"react/philosophy/#3-virtual-dom","title":"3. Virtual DOM:","text":"<p>React uses a virtual DOM to optimize rendering performance. Instead of directly manipulating the browser\u2019s DOM, React maintains a lightweight virtual representation of the UI. When a component\u2019s state changes, React updates the virtual DOM first and then efficiently applies the changes to the real DOM. This minimizes the number of costly DOM operations and improves performance.</p> <ul> <li>Virtual DOM Example: When state changes, React calculates the difference between the current virtual DOM and the new virtual DOM and updates only the parts of the real DOM that have changed.</li> </ul>"},{"location":"react/philosophy/#4-unidirectional-data-flow","title":"4. Unidirectional Data Flow:","text":"<p>React enforces a unidirectional data flow, meaning that data flows from parent components to child components through props. This makes the data flow predictable and easier to debug, as you can trace how data changes across the component tree.</p> <ul> <li> <p>Data Flow Example:</p> <pre><code>function ParentComponent() {\n    const [value, setValue] = React.useState('Hello');\n\n    return &lt;ChildComponent text={value} /&gt;;\n}\n\nfunction ChildComponent({ text }) {\n    return &lt;div&gt;{text}&lt;/div&gt;;\n}\n</code></pre> <p>In this example, <code>ParentComponent</code> passes <code>value</code> as a prop to <code>ChildComponent</code>, ensuring a clear and predictable flow of data.</p> </li> </ul>"},{"location":"react/philosophy/#5-single-responsibility-principle","title":"5. Single Responsibility Principle:","text":"<p>Each component in React is designed to have a single responsibility. This means components should do one thing and do it well. This principle encourages modular and maintainable code.</p> <ul> <li> <p>Single Responsibility Example:</p> <p>A component should ideally focus on one aspect of the UI, such as rendering a list, handling user input, or displaying a form. Combining multiple responsibilities into a single component can lead to complexity and difficulty in managing and testing the component.</p> </li> </ul>"},{"location":"react/philosophy/#6-reusability-and-composition","title":"6. Reusability and Composition:","text":"<p>React encourages the creation of reusable components that can be composed to build complex UIs. By composing smaller, reusable components, you can create more maintainable and scalable applications.</p> <ul> <li> <p>Composition Example:</p> <pre><code>function Layout({ header, main, footer }) {\n    return (\n        &lt;div&gt;\n            &lt;header&gt;{header}&lt;/header&gt;\n            &lt;main&gt;{main}&lt;/main&gt;\n            &lt;footer&gt;{footer}&lt;/footer&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction App() {\n    return (\n        &lt;Layout\n            header={&lt;Header /&gt;}\n            main={&lt;MainContent /&gt;}\n            footer={&lt;Footer /&gt;}\n        /&gt;\n    );\n}\n</code></pre> <p>Here, <code>Layout</code> is a component that composes other components (<code>Header</code>, <code>MainContent</code>, <code>Footer</code>) to create a complete layout.</p> </li> </ul>"},{"location":"react/philosophy/#summary","title":"Summary:","text":"<p>The philosophy of React centers around:</p> <ul> <li>Declarative UI: Describe what the UI should look like.</li> <li>Component-Based Architecture: Build UIs from reusable components.</li> <li>Virtual DOM: Optimize updates and rendering.</li> <li>Unidirectional Data Flow: Maintain predictable data flow.</li> <li>Single Responsibility Principle: Focus each component on a single task.</li> <li>Reusability and Composition: Create modular and scalable UIs.</li> </ul> <p>These principles together enable developers to build complex, interactive, and high-performance user interfaces efficiently and maintainably.</p>"},{"location":"react/react-batching/","title":"React Batching","text":""},{"location":"react/react-batching/#react-batching-updates","title":"React Batching Updates","text":"<p>IMPORANT Question</p> <p>React Docs - Batching</p> <p>URL.createObjectURL</p> State<pre><code>const [x, setX] = useState(0);\n</code></pre> <p></p> <p>React waits until all code in the event handlers has run before processing your state updates.</p> Updating the same state multiple times before the next render <p>It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing the next state value like <code>setNumber(number + 1)</code>, you can pass a function that calculates the next state based on the previous one in the queue, like <code>setNumber(n =&gt; n + 1)</code>. It is a way to tell React to \u201cdo something with the state value\u201d instead of just replacing it.</p> <pre><code>import { useState } from 'react';\n\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n\n    return (\n        &lt;&gt;\n            &lt;h1&gt;{number}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; {\n                setNumber(n =&gt; n + 1);\n                setNumber(n =&gt; n + 1);\n                setNumber(n =&gt; n + 1);\n            }}&gt;+3&lt;/button&gt;\n        &lt;/&gt;\n    )\n}\n</code></pre> <p>Here, <code>n =&gt; n + 1</code> is called an updater function. When you pass it to a state setter:</p> <ol> <li>React queues this function to be processed after all the other code in the event handler has run.</li> <li>During the next render, React goes through the queue and gives you the final updated state.</li> </ol> <pre><code>setNumber(n =&gt; n + 1);\nsetNumber(n =&gt; n + 1);\nsetNumber(n =&gt; n + 1);\n</code></pre> <p>Here\u2019s how React works through these lines of code while executing the event handler:</p> <ol> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> <li><code>setNumber(n =&gt; n + 1)</code>: <code>n =&gt; n + 1</code> is a function. React adds it to a queue.</li> </ol> <p>When you call <code>useState</code> during the next render, React goes through the queue. The previous <code>number</code> state was <code>0</code>, so that\u2019s what React passes to the first updater function as the <code>n</code> argument. Then React takes the return value of your previous updater function and passes it to the next updater as <code>n</code>, and so on:</p> <p>React stores <code>3</code> as the final result and returns it from <code>useState</code>.</p> <p>This is why clicking \u201c+3\u201d in the above example correctly increments the value by 3.</p> <ul> <li>Updating the same state multiple times before the next render </li> </ul>"},{"location":"react/react-batching/#react-v180-march-29-2022-by-the-react-team","title":"<code>React v18.0</code>, March 29, 2022 by The React Team","text":""},{"location":"react/react-batching/#the-role-of-updater-functions-in-react-state","title":"The Role of Updater Functions in React State","text":"<p>Updater functions are a more reliable way to update state variables when the new state is derived from the previous state. This is because updater functions receive the previous state as their argument, ensuring the update is based on the most recent state value.</p> <pre><code>this.setState((prevState) =&gt; ({\n  count: prevState.count + 1,\n}));\n</code></pre>"},{"location":"react/react-batching/#can-you-await-a-setstate-function","title":"Can you await a <code>setState</code> function?","text":"<p>The <code>setState</code> function in React does not return a promise, so it cannot be awaited. React's design does not support the <code>await</code> keyword for state updates. Instead, developers should use the <code>callback</code> function or the <code>useEffect</code> hook to handle actions waiting for a state update.</p>"},{"location":"react/react-batching/#state-as-a-snapshot","title":"State as a Snapshot","text":""},{"location":"react/react-batching/#rendering-takes-a-snapshot-in-time","title":"Rendering takes a snapshot in time","text":"<p>\u201cRendering\u201d means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated using its state at the time of the render.</p> Method Description <code>GET</code>  Fetch resource"},{"location":"react/react-batching/#usestate-guide","title":"useState Guide","text":""},{"location":"react/react-batching/#implementing-an-object-as-a-state-variable-with-usestate-hook","title":"Implementing an object as a state variable with useState Hook","text":"<p>There are two things you need to keep in mind about updates when using objects:</p> <ul> <li>The importance of immutability.</li> <li>The fact that the setter returned by useState doesn\u2019t merge objects like <code>setState()</code> does in class components.</li> </ul> <p>Regarding the first point; if you use the same value as the current state to update the state (React uses Object.is() for comparing), React won\u2019t trigger a re-render.</p> When working with objects, it\u2019s easy to make the following mistake: <pre><code>const Message = () =&gt; {\n    const [messageObj, setMessage] = useState({ message: \"\" });\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                type=\"text\"\n                value={messageObj.message}\n                placeholder=\"Enter a message\"\n                onChange={(e) =&gt; {\n                    messageObj.message = e.target.value;\n                    setMessage(messageObj); // Doesn't work\n                }}\n            /&gt;\n            &lt;p&gt;\n                &lt;strong&gt;{messageObj.message}&lt;/strong&gt;\n            &lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> Success Array <pre><code>const MessageList = () =&gt; {\n    const [message, setMessage] = useState(\"\");\n    const [messageList, setMessageList] = useState([]);\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                type=\"text\"\n                value={message}\n                placeholder=\"Enter a message\"\n                onChange={(e) =&gt; {\n                    setMessage(e.target.value);\n                }}\n            /&gt;\n            &lt;input\n                type=\"button\"\n                value=\"Add\"\n                onClick={(e) =&gt; {\n                    setMessageList([\n                        ...messageList,\n                        {\n                            // Use the current size as ID (needed to iterate the list later)\n                            id: messageList.length + 1,\n                            message: message,\n                        },\n                    ]);\n                    setMessage(\"\"); // Clear the text box\n                }}\n            /&gt;\n            &lt;ul&gt;\n                {messageList.map((m) =&gt; (\n                &lt;li key={m.id}&gt;{m.message}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"react/react-batching/#how-to-update-state-in-a-nested-object-in-react-with-hooks","title":"How to update state in a nested object in React with Hooks","text":"<pre><code>const [messageObj, setMessage] = useState({\n  author: \"\",\n  message: {\n    id: 1,\n    text: \"\",\n  },\n});\n</code></pre> <p>The following code snippets show some incorrect ways to update the <code>text</code> field:</p> Bug <pre><code>// Wrong\nsetMessage((prevState) =&gt; ({\n    ...prevState,\n    text: \"My message\",\n}));\n\n// Wrong\nsetMessage((prevState) =&gt; ({\n    ...prevState.message,\n    text: \"My message\",\n}));\n\n// Wrong\nsetMessage((prevState) =&gt; ({\n    ...prevState,\n    message: {\n        text: \"My message\",\n    },\n}));\n</code></pre> <p>To properly update the <code>text</code> field, we need to create a new object that includes all fields and nested objects from the original object:</p> Success <pre><code>// Correct\nsetMessage(prevState =&gt; ({\n    ...prevState,           // copy all other field/objects\n    message: {              // recreate the object that contains the field to update\n        ...prevState.message, // copy all the fields of the object\n        text: 'My message'    // overwrite the value of the field to update\n    }\n}));\n</code></pre> <p>In the same way, here\u2019s how you\u2019d update the <code>author</code> field of the <code>state</code> object:</p> <pre><code>// Correct\nsetMessage((prevState) =&gt; ({\n  author: \"Joe\", // overwrite the value of the field to update\n  ...prevState.message, // copy all other field/objects\n}));\n</code></pre> <p>However, this is assuming the <code>message</code> object doesn\u2019t change. If it does change, you\u2019d have to update the object this way:</p> <pre><code>// Correct\nsetMessage((prevState) =&gt; ({\n  author: \"Joe\", // update the value of the field\n  message: {\n    // recreate the object that contains the field to update\n    ...prevState.message, // copy all the fields of the object\n    text: \"My message\", // overwrite the value of the field to update\n  },\n}));\n</code></pre>"},{"location":"react/react-batching/#rules-for-using-usestate","title":"Rules for using useState","text":"<p><code>useState</code> abides by the same rules that all React Hooks follow:</p> <ul> <li>Only call hooks at the top level</li> <li>Only call hooks from React functions</li> </ul>"},{"location":"react/react-batching/#reference","title":"Reference","text":"<ul> <li>Stackoverflow: Why is React useState with functional update form is needed?</li> <li>react.dev: Queueing a Series of State Updates</li> <li>react.dev: Updating Objects in State</li> <li>Youtube: React State Are Sync/Async? Behavior's of useState Hook | Right method of updating state? #react </li> <li>dev.to: Functional State Update in React. </li> <li>Linkedin: Choosing the Right State Update Method Normal vs. Functional State Updates in React</li> <li>geeksforgeeks.org: What is Automatic Batching in React 18</li> <li> <p>dev.to: React Batching and how it can make your page faster</p> </li> <li> <p>Understanding the Importance of State Updates in React Applications</p> </li> <li> <p>Medium (paid-only): Understanding State Batching in React: A Simple Explanation</p> </li> <li> <p> Hindi: React Hooks - useState in Hindi (setState is not updating state value | setState is sync or async) \ud83e\udd14</p> </li> <li> <p>blog.logrocket.com, useState in React: A complete guide</p> </li> <li> <p>emgoto.com, Functional Updates</p> </li> </ul>"},{"location":"react/example/breaking-react-component-pattern/","title":"How to break react components","text":"<pre><code>Component Decomposition\nContainer and Presentational Components\nHigher-Order Components (HOCs)\nRender Props\nCustom Hooks\nContext API\nComposition Over Inheritance\n</code></pre> <p>Breaking components into smaller, manageable pieces is essential for maintaining a clean and scalable React application. Here are some of the most useful React patterns for breaking components effectively:</p>"},{"location":"react/example/breaking-react-component-pattern/#1-component-decomposition","title":"1. Component Decomposition","text":"<p>Break down large components into smaller, reusable ones based on their functionality or UI elements. This makes each component simpler and easier to maintain.</p> Example jsx<pre><code>// Large Component\nconst UserProfile = () =&gt; (\n    &lt;div&gt;\n        &lt;Avatar /&gt;\n        &lt;UserInfo /&gt;\n        &lt;UserPosts /&gt;\n    &lt;/div&gt;\n);\n\n// Smaller Components\nconst Avatar = () =&gt; &lt;img src=\"avatar.jpg\" alt=\"User Avatar\" /&gt;;\n    const UserInfo = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;John Doe&lt;/h2&gt;\n        &lt;p&gt;john.doe@example.com&lt;/p&gt;\n    &lt;/div&gt;\n    );\n    const UserPosts = () =&gt; (\n    &lt;ul&gt;\n        &lt;li&gt;First Post&lt;/li&gt;\n        &lt;li&gt;Second Post&lt;/li&gt;\n    &lt;/ul&gt;\n);\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#2-container-and-presentational-components","title":"2. Container and Presentational Components","text":"<p>Separate components into container (stateful) and presentational (stateless) components. Containers handle logic and state, while presentational components handle rendering.</p> Example jsx<pre><code>// Container Component\nconst UserProfileContainer = () =&gt; {\n    const [user, setUser] = useState({ name: 'John Doe', email: 'john.doe@example.com' });\n    return &lt;UserProfile user={user} /&gt;;\n};\n\n// Presentational Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user.name}&lt;/h2&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#3-higher-order-components-hocs","title":"3. Higher-Order Components (HOCs)","text":"<p>Use HOCs to enhance components with additional functionality, such as adding authentication or fetching data.</p> Example jsx<pre><code>// Higher-Order Component\nconst withUserData = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        const [user, setUser] = useState(null);\n\n        useEffect(() =&gt; {\n        // Fetch user data\n        setUser({ name: 'John Doe', email: 'john.doe@example.com' });\n        }, []);\n\n        return &lt;WrappedComponent user={user} {...props} /&gt;;\n    };\n};\n\n// Wrapped Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user ? user.name : 'Loading...'}&lt;/h2&gt;\n        &lt;p&gt;{user ? user.email : ''}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nconst EnhancedUserProfile = withUserData(UserProfile);\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#4-render-props","title":"4. Render Props","text":"<p>Use render props to share code between components by passing a function as a prop that returns React elements.</p> Example jsx<pre><code>// Component with Render Props\nconst DataProvider = ({ render }) =&gt; {\n    const [data, setData] = useState('Hello World');\n\n    return render(data);\n};\n\n// Usage\nconst App = () =&gt; (\n    &lt;DataProvider render={(data) =&gt; &lt;div&gt;{data}&lt;/div&gt;} /&gt;\n);\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#5-custom-hooks","title":"5. Custom Hooks","text":"<p>Create custom hooks to encapsulate reusable logic and state management, which can then be used across multiple components.</p> Example jsx<pre><code>// Custom Hook\nconst useCounter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const decrement = () =&gt; setCount(count - 1);\n\n    return { count, increment, decrement };\n};\n\n// Component using Custom Hook\nconst Counter = () =&gt; {\n    const { count, increment, decrement } = useCounter();\n\n    return (\n        &lt;div&gt;\n        &lt;p&gt;Count: {count}&lt;/p&gt;\n        &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#6-context-api","title":"6. Context API","text":"<p>Use the Context API to manage global state and avoid prop drilling by providing data to all components within a provider.</p> Example jsx<pre><code>// Context\nconst ThemeContext = createContext();\n\n// Provider Component\nconst ThemeProvider = ({ children }) =&gt; {\n    const [theme, setTheme] = useState('light');\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;\n        {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n};\n\n// Consuming Context\nconst ThemedComponent = () =&gt; {\n    const { theme } = useContext(ThemeContext);\n\n    return &lt;div className={theme}&gt;Current Theme: {theme}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#7-composition-over-inheritance","title":"7. Composition Over Inheritance","text":"<p>Leverage composition to build components with flexible and reusable parts, rather than relying on inheritance or deeply nested components.</p> Example jsx<pre><code>// Composition\nconst Panel = ({ header, children }) =&gt; (\n    &lt;div className=\"panel\"&gt;\n        &lt;div className=\"panel-header\"&gt;{header}&lt;/div&gt;\n        &lt;div className=\"panel-body\"&gt;{children}&lt;/div&gt;\n    &lt;/div&gt;\n);\n\n// Usage\nconst App = () =&gt; (\n    &lt;Panel header=\"Panel Header\"&gt;\n        &lt;p&gt;Panel Body Content&lt;/p&gt;\n    &lt;/Panel&gt;\n);\n</code></pre>"},{"location":"react/example/breaking-react-component-pattern/#summary","title":"Summary","text":"<p>By using these patterns, you can create more maintainable, reusable, and modular React components. Each pattern has its own use cases and benefits, and often, a combination of these patterns will be used to achieve the desired structure and behavior in a React application.</p>"},{"location":"react/example/children-prop/","title":"Children Prop","text":"<p>In React, children is a special prop that allows you to pass components or elements to a component as its children. This enables the creation of more flexible and reusable components by allowing them to render nested content. What is children?</p> <p>The children prop is a special prop in React that represents the content between the opening and closing tags of a component. This content can be other React components, elements, or plain text.</p>"},{"location":"react/example/children-prop/#how-children-relates-to-react","title":"How <code>children</code> Relates to React","text":"<p>The <code>children</code> prop is a core feature of React's composition model. It enables components to:</p> <ul> <li>Encapsulate and Render Nested Content: Components can render nested elements or components within their own output.</li> <li>Create Reusable Layouts: Layout components like modals, dialogs, or containers can use children to render dynamic content.</li> </ul>"},{"location":"react/example/children-prop/#how-to-use-children","title":"How to Use children","text":"<ol> <li> <p>Basic Usage:</p> <p>You can use <code>children</code> to render any content that is passed between the opening and closing tags of a component.</p> Example<pre><code>const Wrapper = ({ children }) =&gt; (\n    &lt;div className=\"wrapper\"&gt;\n        {children}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Wrapper&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n        &lt;p&gt;This is some content inside the Wrapper component.&lt;/p&gt;\n    &lt;/Wrapper&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the Wrapper component uses the children prop to render whatever is passed inside its tags.</p> </li> <li> <p>Rendering Multiple Children:</p> <p>children can be a single element, a list of elements, or even a mix of both.</p> jsx<pre><code>const List = ({ children }) =&gt; (\n    &lt;ul&gt;\n        {React.Children.map(children, (child) =&gt; (\n        &lt;li&gt;{child}&lt;/li&gt;\n        ))}\n    &lt;/ul&gt;\n);\n\nconst App = () =&gt; (\n    &lt;List&gt;\n        &lt;span&gt;Item 1&lt;/span&gt;\n        &lt;span&gt;Item 2&lt;/span&gt;\n        &lt;span&gt;Item 3&lt;/span&gt;\n    &lt;/List&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the <code>List</code> component takes multiple <code>children</code> elements and renders them as list items.</p> </li> <li> <p>Using <code>React.Children</code> Utilities:</p> <p>React provides utility methods for working with <code>children</code>, such as <code>React.Children.map</code>, <code>React.Children.forEach</code>, and <code>React.Children.toArray</code>.</p> jsx<pre><code>const Parent = ({ children }) =&gt; (\n    &lt;div&gt;\n        {React.Children.map(children, (child, index) =&gt; (\n        &lt;div key={index}&gt;{child}&lt;/div&gt;\n        ))}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Parent&gt;\n        &lt;p&gt;First Child&lt;/p&gt;\n        &lt;p&gt;Second Child&lt;/p&gt;\n    &lt;/Parent&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, <code>React.Children.map</code> is used to iterate over and render each child within a <code>div</code>.</p> </li> <li> <p>Conditional Rendering of <code>children</code>:</p> <p>You can conditionally render <code>children</code> based on some logic.</p> <pre><code>const ConditionalWrapper = ({ condition, children }) =&gt; (\n    &lt;div&gt;\n        {condition ? children : &lt;p&gt;No content available&lt;/p&gt;}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;ConditionalWrapper condition={true}&gt;\n        &lt;p&gt;This content will be displayed.&lt;/p&gt;\n    &lt;/ConditionalWrapper&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"react/example/children-prop/#summary","title":"Summary","text":"<p>The <code>children</code> prop in React is a powerful feature that allows components to render nested content dynamically. It helps in creating flexible and reusable components by enabling them to accept and render various types of content. By understanding and utilizing <code>children</code>, you can build more modular and maintainable React applications.</p>"},{"location":"react/example/component-composition/","title":"Component Composition","text":"<p>Component composition is a fundamental concept in React that involves building complex UIs by combining smaller, reusable components. It allows developers to create more manageable, modular, and maintainable code. Instead of creating large monolithic components, you can break them down into smaller, self-contained components that can be composed together to form the final UI.</p> <p>Practice creating small, reusable components and composing them into larger components.</p>"},{"location":"react/example/component-composition/#react-patterns-for-breaking-down-components","title":"React Patterns for Breaking Down Components","text":"<ul> <li> <p> 1. Presentational and Container Components:</p> <p>how things look &amp; how things work</p> <p> Getting started</p> </li> <li> <p> 2. Higher-Order Components (HOCs)</p> <p>Use HOCs to add common functionality to components. For example, you might have an HOC to handle form submission logic.</p> <p> Getting started</p> </li> <li> <p> 3. Render Props</p> <p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> <p> Getting started</p> </li> </ul>"},{"location":"react/example/component-composition/#key-principles-of-component-composition","title":"Key Principles of Component Composition","text":"<ol> <li>Reusability: Create components that can be reused across different parts of your application.</li> <li>Single Responsibility: Each component should have a single responsibility, making it easier to understand and maintain.</li> <li>Separation of Concerns: Separate the concerns of different parts of your application into different components.</li> <li>Declarative Syntax: Use a declarative syntax to define how components should be composed together.</li> </ol>"},{"location":"react/example/component-composition/#example","title":"Example","text":"<p>Let's look at an example where we compose a user profile page using smaller components.</p> <ol> <li> <p>Basic Components:</p> jsx<pre><code>// Avatar.js\nconst Avatar = ({ url }) =&gt; &lt;img src={url} alt=\"User Avatar\" /&gt;;\n\n// UserInfo.js\nconst UserInfo = ({ name, email }) =&gt; (\n&lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    &lt;p&gt;{email}&lt;/p&gt;\n&lt;/div&gt;\n);\n\n// UserPosts.js\nconst UserPosts = ({ posts }) =&gt; (\n&lt;ul&gt;\n    {posts.map(post =&gt; (\n    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n    ))}\n&lt;/ul&gt;\n);\n</code></pre> </li> <li> <p>Composing the Components:</p> jsx<pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n&lt;div&gt;\n    &lt;Avatar url={user.avatarUrl} /&gt;\n    &lt;UserInfo name={user.name} email={user.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre> </li> <li> <p>Using the Composed Component:</p> jsx<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\nname: 'John Doe',\nemail: 'john.doe@example.com',\navatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n{ id: 1, title: 'First Post' },\n{ id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n&lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"react/example/component-composition/#benefits-of-component-composition","title":"Benefits of Component Composition","text":"<ul> <li>Maintainability: Smaller components are easier to understand and maintain.</li> <li>Reusability: Reusable components can be used in different parts of the application.</li> <li>Testability: Smaller components are easier to test individually.</li> <li>Scalability: Composing components makes it easier to scale the application as it grows.</li> </ul>"},{"location":"react/example/component-composition/#tips-for-effective-component-composition","title":"Tips for Effective Component Composition","text":"<ul> <li>Identify Common Patterns: Look for patterns in your UI that can be abstracted into reusable components.</li> <li>Use Prop Drilling and Context: Pass data and callbacks down the component tree via props or use React Context for deeper hierarchies.</li> <li>Follow Naming Conventions: Use clear and consistent naming conventions for your components to improve readability.</li> <li>Modularity: Keep components focused and modular, avoiding unnecessary dependencies between them.</li> </ul> <p>By mastering component composition, you can create a flexible and maintainable React application, leveraging the power of reusable components to build complex UIs efficiently.</p>"},{"location":"react/example/component-composition/#handling-missing-prop-values-in-react-components","title":"Handling Missing Prop Values in React Components","text":"<p>To handle cases where the props might not contain values, you can use default values, conditional rendering, and prop type validation. Here's how you can address these scenarios:</p> 1. Using Default Props <p>You can set default props to provide default values for your component's props. This way, if a prop is not provided, the component will use the default value.</p> jsx<pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 2. Conditional Rendering <p>You can also use conditional rendering to handle cases where the props might not contain values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ? name : 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ? email : 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 3. Combining Default Props and Conditional Rendering <p>Combining both approaches can provide a robust solution for handling missing prop values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 4. Using Nullish Coalescing Operator (Optional) <p>For modern JavaScript, you can use the nullish coalescing operator (??) to provide fallback values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ?? 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ?? 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre>"},{"location":"react/example/component-composition/#example-usage-in-userprofile-component","title":"Example Usage in UserProfile Component","text":"<p>Here's how you might use the <code>UserInfo</code> component in the UserProfile component with potential missing values.</p> <pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n  &lt;div&gt;\n    &lt;Avatar url={user?.avatarUrl ?? 'default-avatar.jpg'} /&gt;\n    &lt;UserInfo name={user?.name} email={user?.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre>"},{"location":"react/example/component-composition/#example-usage-in-app-component","title":"Example Usage in App Component","text":"<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  avatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n  { id: 1, title: 'First Post' },\n  { id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n    {/* UserProfile with missing values */}\n    &lt;UserProfile user={{}} posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <p>By using these techniques, you can ensure that your components handle missing prop values gracefully, improving the robustness and user experience of your application.</p>"},{"location":"react/example/hoc/","title":"High Order Component","text":"<p>High-order components (HOCs) in React are a pattern where a function takes a component and returns a new component with enhanced functionality. Here are examples categorized into basic, intermediate, and advanced HOCs:</p> <p>Use HOCs to add common functionality to components.</p> simple example <p>Use HOCs to add common functionality to components.</p> <p>For example, you might have an HOC to handle form submission logic.</p> jsx<pre><code>// withFormSubmission.js\nconst withFormSubmission = (WrappedComponent) =&gt; {\nreturn (props) =&gt; {\n    const handleSubmit = (values) =&gt; {\n    // handle form submission logic here\n    console.log('Form submitted:', values);\n    };\n\n    return &lt;WrappedComponent {...props} onSubmit={handleSubmit} /&gt;;\n};\n};\n\nexport default withFormSubmission;\n\n// EnhancedUserForm.js\nimport withFormSubmission from './withFormSubmission';\nimport UserForm from './UserForm';\n\nconst EnhancedUserForm = withFormSubmission(UserForm);\n\nexport default EnhancedUserForm;\n</code></pre> Abstract <p>Why High-Order Component Naming Starts with \"with\"</p> <p>The convention of naming higher-order components (HOCs) with a prefix \"with\" comes from the idea of enhancing or augmenting the base component with additional functionality. This naming convention makes it clear that the HOC is wrapping and modifying the behavior or appearance of the original component.</p> <p>For example:</p> <ul> <li>withLogging indicates that the wrapped component will have logging functionality added.</li> <li>withAuthentication indicates that the wrapped component will have authentication checking added.</li> <li>withDataFetching indicates that the wrapped component will have data fetching capabilities added.</li> </ul> <p>Using \"with\" helps developers quickly understand that the function is not just a regular function but an HOC that will provide additional capabilities to the component it wraps.</p> <p>When to Use HOCs</p> <p>HOCs are useful in a variety of scenarios where you want to reuse component logic or behavior across multiple components without repeating code. Here are some common use cases for HOCs:</p> <ol> <li> <p>Cross-Cutting Concerns:</p> <ul> <li>Logging: Adding logging functionality to monitor the props being passed to the component.</li> <li>Error Handling: Wrapping a component in an error boundary to catch JavaScript errors anywhere in their child component tree.</li> </ul> </li> <li> <p>Code Reuse:</p> <ul> <li>Data Fetching: Encapsulating data fetching logic and reusing it across multiple components.</li> <li>Form Handling: Managing form state and submission logic that can be reused in different forms.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>Authorization: Restricting access to certain components based on user roles or permissions.</li> <li>Feature Flags: Conditionally rendering components based on feature flags or configuration.</li> </ul> </li> <li> <p>Enhancing Components:</p> <ul> <li>Styling: Adding or modifying styles dynamically based on props or state.</li> <li>Animation: Adding animation logic to components.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Global State: Connecting components to a global state management system (e.g., Redux).</li> </ul> </li> </ol>"},{"location":"react/example/hoc/#basic-hocs","title":"Basic HOCs","text":""},{"location":"react/example/hoc/#1-logging-props","title":"1. Logging Props","text":"Asbtract ExampleUsage javascript<pre><code>const withLogging = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        console.log(props);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst LoggedSimpleComponent = withLogging(SimpleComponent);\n\n// Usage\n&lt;LoggedSimpleComponent message=\"Hello, World!\" /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#2-default-props","title":"2. Default Props","text":"Asbtract ExampleUsage javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst DefaultPropsComponent = withDefaultProps({ message: \"Default Message\" })(SimpleComponent);\n\n// Usage\n&lt;DefaultPropsComponent /&gt;; // Renders \"Default Message\"\n&lt;DefaultPropsComponent message=\"Custom Message\" /&gt;; // Renders \"Custom Message\"\n</code></pre>"},{"location":"react/example/hoc/#3-conditional-rendering","title":"3. Conditional Rendering","text":"Asbtract ExampleUsage javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        if (conditionFn(props)) {\n            return &lt;WrappedComponent {...props} /&gt;;\n        } else {\n            return null;\n        }\n    };\n};\n\n// or\n\nconst withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n</code></pre> javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst ConditionalComponent = withConditionalRendering((props) =&gt; props.show)(SimpleComponent);\n\n// Usage\n&lt;ConditionalComponent show={true} message=\"Visible Message\" /&gt;; // Renders \"Visible Message\"\n&lt;ConditionalComponent show={false} message=\"Invisible Message\" /&gt;; // Renders null\n</code></pre>"},{"location":"react/example/hoc/#4-adding-class-name","title":"4. Adding Class Name","text":"Asbtract ExampleUsage javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...props} className={className} /&gt;;\n    };\n};\n\n// or\n\nconst withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n</code></pre> javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div className={props.className}&gt;{props.message}&lt;/div&gt;;\n\nconst ClassNameComponent = withClassName(\"custom-class\")(SimpleComponent);\n\n// Usage\n&lt;ClassNameComponent message=\"Styled Message\" /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#5-simple-error-boundary","title":"5. Simple Error Boundary","text":"Note Functional ComponentClass ComponentUsage javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\n    const [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n</code></pre> javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { hasError: false };\n\n        static getDerivedStateFromError() {\n            return { hasError: true };\n        }\n\n        componentDidCatch(error, errorInfo) {\n        console.error(error, errorInfo);\n        }\n\n        render() {\n            if (this.state.hasError) {\n                return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n            }\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\nconst [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n\nconst SimpleComponent = (props) =&gt; {\n    if (props.throwError) {\n        throw new Error(\"Error triggered\");\n    }\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n};\n\nconst ErrorBoundaryComponent = withErrorBoundary(SimpleComponent);\n\n// Usage\n&lt;ErrorBoundaryComponent throwError={true} message=\"This will throw an error\" /&gt;; // Renders error message\n&lt;ErrorBoundaryComponent throwError={false} message=\"No error\" /&gt;; // Renders \"No error\"\n</code></pre>"},{"location":"react/example/hoc/#intermediate-hocs","title":"Intermediate HOCs","text":""},{"location":"react/example/hoc/#1-data-fetching","title":"1. Data Fetching","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { data: null, loading: true };\n\n        componentDidMount() {\n        fetch(url)\n            .then((response) =&gt; response.json())\n            .then((data) =&gt; this.setState({ data, loading: false }));\n        }\n\n        render() {\n        return &lt;WrappedComponent {...this.props} {...this.state} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n\nconst DataComponent = ({ data, loading }) =&gt; {\n    if (loading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nconst FetchedDataComponent = withDataFetching(\"https://api.example.com/data\")(DataComponent);\n\n// Usage\n&lt;FetchedDataComponent /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#2-authentication-check","title":"2. Authentication Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!this.props.isAuthenticated) {\n            return &lt;div&gt;Please log in&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthenticatedComponent = (props) =&gt; &lt;div&gt;Authenticated Content&lt;/div&gt;;\n\nconst AuthCheckComponent = withAuthentication(AuthenticatedComponent);\n\n// Usage\n&lt;AuthCheckComponent isAuthenticated={true} /&gt;; // Renders \"Authenticated Content\"\n&lt;AuthCheckComponent isAuthenticated={false} /&gt;; // Renders \"Please log in\"\n</code></pre>"},{"location":"react/example/hoc/#3-form-handling","title":"3. Form Handling","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\n    const [formData, setFormData] = React.useState({});\n\n    const handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        setFormData({ ...formData, [name]: value });\n    };\n\n    const handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n    };\n\n    return (\n        &lt;WrappedComponent\n        {...props}\n        formData={formData}\n        handleChange={handleChange}\n        handleSubmit={handleSubmit}\n        /&gt;\n    );\n};\n</code></pre> javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { formData: {} };\n\n        handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        this.setState({ formData: { ...this.state.formData, [name]: value } });\n        };\n\n        handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n        };\n\n        render() {\n        return (\n            &lt;WrappedComponent\n            {...this.props}\n            formData={this.state.formData}\n            handleChange={this.handleChange}\n            handleSubmit={this.handleSubmit}\n            /&gt;\n        );\n        }\n    };\n};\n</code></pre> <pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\nconst [formData, setFormData] = React.useState({});\n\nconst handleChange = (event) =&gt; {\n    const { name, value } = event.target;\n    setFormData({ ...formData, [name]: value });\n};\n\nconst handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    console.log(\"Form submitted with data:\", formData);\n};\n\nreturn (\n    &lt;WrappedComponent\n    {...props}\n    formData={formData}\n    handleChange={handleChange}\n    handleSubmit={handleSubmit}\n    /&gt;\n);\n};\n\nconst FormComponent = ({ formData, handleChange, handleSubmit }) =&gt; (\n&lt;form onSubmit={handleSubmit}&gt;\n    &lt;input name=\"name\" value={formData.name || ''} onChange={handleChange} /&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n\nconst HandledFormComponent = withFormHandling(FormComponent);\n\n// Usage\n&lt;HandledFormComponent /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#4-authorization-check","title":"4. Authorization Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!allowedRoles.includes(this.props.role)) {\n            return &lt;div&gt;Access Denied&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthorizedComponent = (props) =&gt; &lt;div&gt;Authorized Content&lt;/div&gt;;\n\nconst RoleCheckComponent = withAuthorization(['admin'])(AuthorizedComponent);\n\n// Usage\n&lt;RoleCheckComponent role=\"admin\" /&gt;; // Renders \"Authorized Content\"\n&lt;RoleCheckComponent role=\"user\" /&gt;; // Renders \"Access Denied\"\n</code></pre>"},{"location":"react/example/hoc/#5-redux-connect-hoc","title":"5. Redux Connect HOC","text":"Success ExampleUsage javascript<pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n</code></pre> <pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n\nconst SimpleComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst mapStateToProps = (state) =&gt; ({\n    message: state.message,\n});\n\nconst mapDispatchToProps = (dispatch) =&gt; ({\n    updateMessage: (msg) =&gt; dispatch({ type: 'UPDATE_MESSAGE', payload: msg }),\n});\n\nconst ReduxConnectedComponent = withReduxConnect(mapStateToProps, mapDispatchToProps)(SimpleComponent);\n\n// Usage\n&lt;ReduxConnectedComponent /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#advanced-hocs","title":"Advanced HOCs","text":""},{"location":"react/example/hoc/#1-dynamic-module-loader","title":"1. Dynamic Module Loader","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { Module: null };\n\n        componentDidMount() {\n        importModule().then((mod) =&gt; this.setState({ Module: mod.default }));\n        }\n\n        render() {\n        const { Module } = this.state;\n        return Module ? &lt;Module {...this.props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n\nconst DynamicComponent = (props) =&gt; &lt;div&gt;{props.dynamicContent}&lt;/div&gt;;\n\nconst DynamicLoadedComponent = withDynamicModule(() =&gt; import('./DynamicComponent'))(DynamicComponent);\n\n// Usage\n&lt;DynamicLoadedComponent dynamicContent=\"This is dynamically loaded\" /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#2-performance-optimization-with-memoization","title":"2. Performance Optimization with Memoization","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    // Add custom comparison logic here\n    return prevProps === nextProps;\n});\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; {\n    return React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n        // Add custom comparison logic here\n        return prevProps === nextProps;\n    });\n};\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    return prevProps === nextProps;\n});\n\nconst MemoizedComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst OptimizedComponent = withMemoization(MemoizedComponent);\n\n// Usage\n&lt;OptimizedComponent message=\"Memoized Content\" /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#3-internationalization-i18n","title":"3. Internationalization (i18n)","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n</code></pre> javascript<pre><code>import { withTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; {\n    return withTranslation()(WrappedComponent);\n};\n</code></pre> javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n\nconst TranslatedComponent = ({ t }) =&gt; &lt;div&gt;{t('welcome_message')}&lt;/div&gt;;\n\nconst I18nComponent = withI18n(TranslatedComponent);\n\n// Usage\n&lt;I18nComponent /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#4-analytics-tracking","title":"4. Analytics Tracking","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        // Simulate sending event to analytics service\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        componentDidMount() {\n            // Simulate sending event to analytics service\n            console.log(`Event: ${eventName}`);\n        }\n\n        render() {\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AnalyticsComponent = (props) =&gt; &lt;div&gt;{props.content}&lt;/div&gt;;\n\nconst TrackedComponent = withAnalytics('ComponentLoaded')(AnalyticsComponent);\n\n// Usage\n&lt;TrackedComponent content=\"Analytics Tracked Content\" /&gt;;\n</code></pre>"},{"location":"react/example/hoc/#5-drag-and-drop","title":"5. Drag and Drop","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n            &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> javascript<pre><code>import { DragSource, DropTarget } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; {\n    const dragSpec = {\n        beginDrag: (props) =&gt; ({ id: props.id })\n    };\n\n    const dropSpec = {\n        drop: (props, monitor) =&gt; {\n            const item = monitor.getItem();\n            props.onDrop(item.id, props.id);\n        }\n    };\n\n    const collectDrag = (connect) =&gt; ({\n        connectDragSource: connect.dragSource()\n    });\n\n    const collectDrop = (connect) =&gt; ({\n        connectDropTarget: connect.dropTarget()\n    });\n\n    const DraggableComponent = DragSource('ITEM', dragSpec, collectDrag)(WrappedComponent);\n    return DropTarget('ITEM', dropSpec, collectDrop)(DraggableComponent);\n};\n</code></pre> javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n        &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst DraggableComponent = ({ content }) =&gt; &lt;div&gt;{content}&lt;/div&gt;;\n\nconst DragDropComponent = withDragAndDrop(DraggableComponent);\n\n// Usage\n&lt;DragDropComponent id=\"1\" content=\"Drag me\" onDrop={(sourceId, targetId) =&gt; console.log(`Dropped ${sourceId} on ${targetId}`)} /&gt;;\n</code></pre> <p>These examples should cover a wide range of scenarios and illustrate how HOCs can be used to enhance and reuse component functionality at different levels of complexity.</p>"},{"location":"react/example/hoc/#folder-structure-of-hocs","title":"Folder Structure of HOCs","text":"<p>The folder structure for Higher-Order Components (HOCs) in a React project can vary depending on the complexity and size of your project. However, a common and organized way to structure your folders and files can look like this:</p>"},{"location":"react/example/hoc/#1-basic-folder-structure","title":"1. Basic Folder Structure","text":"<p>A simple structure for a small to medium-sized project might look like this:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2514\u2500\u2500 withLogging.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"react/example/hoc/#2-advanced-folder-structure","title":"2. Advanced Folder Structure","text":"<p>For larger projects, it might make sense to have a more detailed structure:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 AnotherComponent/\n\u2502       \u251c\u2500\u2500 AnotherComponent.js\n\u2502       \u251c\u2500\u2500 AnotherComponent.css\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth/\n\u2502   \u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 withLogging/\n\u2502   \u2502   \u251c\u2500\u2500 withLogging.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 withAnotherFeature/\n\u2502       \u251c\u2500\u2500 withAnotherFeature.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 helper1.js\n\u2502   \u2514\u2500\u2500 helper2.js\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 useCustomHook.js\n\u2502   \u2514\u2500\u2500 useAnotherHook.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"react/example/hoc/#explanation-of-each-folder","title":"Explanation of Each Folder:","text":"<ol> <li> <p>components/:</p> <ul> <li>Contains all your React components.</li> <li>Each component has its own folder which may contain its JavaScript file, CSS file, and an <code>index.js</code> for easier imports.</li> </ul> </li> <li> <p>hocs/:</p> <ul> <li>Contains all your Higher-Order Components.</li> <li>Each HOC can have its own folder if it consists of multiple files or just a single file if it's simple.</li> <li>Each HOC folder typically has an <code>index.js</code> file for easier imports.</li> </ul> </li> <li> <p>utils/:</p> <ul> <li>Contains utility functions that can be reused throughout your project.</li> </ul> </li> <li> <p>hooks/:</p> <ul> <li>Contains custom React hooks.</li> </ul> </li> </ol>"},{"location":"react/example/hoc/#hocs","title":"HOCs","text":"<p>Higher-Order Components (HOCs) are a pattern in React for reusing component logic. They are functions that take a component and return a new component with added functionality. HOCs are particularly useful in various scenarios, and they are commonly used for the following purposes:</p>"},{"location":"react/example/hoc/#scenarios-for-using-hocs","title":"Scenarios for Using HOCs","text":"<ol> <li> <p>Code Reuse, Logic, and Bootstrap Abstraction:</p> <ul> <li>HOCs allow you to reuse code across multiple components. This is particularly useful for logic that needs to be shared, such as fetching data, managing state, or subscribing to events.</li> </ul> </li> <li> <p>Manipulating Props:</p> <ul> <li>HOCs can manipulate the props passed to a component. This can include adding new props, modifying existing ones, or filtering out unnecessary props.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>HOCs can be used to conditionally render components based on certain criteria, such as user authentication, feature flags, or permission levels.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>They can manage state and pass it down as props to the wrapped component. This is useful for scenarios where state management logic needs to be shared across multiple components.</li> </ul> </li> <li> <p>Handling Side Effects:</p> <ul> <li>HOCs can handle side effects like data fetching, subscriptions, or logging. This is useful for abstracting side effects out of the component, keeping them clean and focused on rendering UI.</li> </ul> </li> </ol>"},{"location":"react/example/hoc/#common-uses-of-hocs","title":"Common Uses of HOCs","text":"<ol> <li> <p>Authentication:</p> <ul> <li>Wrapping components to ensure that only authenticated users can access certain parts of an application.</li> <li>Example: <code>withAuth(Component)</code></li> </ul> </li> <li> <p>Logging:</p> <ul> <li>Adding logging functionality to components for debugging or analytics.</li> <li>Example: <code>withLogging(Component)</code></li> </ul> </li> <li> <p>Data Fetching:</p> <ul> <li>Fetching data from an API and passing it as props to the wrapped component.</li> <li>Example: <code>withDataFetching(Component, apiEndpoint)</code></li> </ul> </li> <li> <p>Theming:</p> <ul> <li>Providing theme-related props to components.</li> <li>Example: <code>withTheme(Component)</code></li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Wrapping components with error boundaries to catch and handle errors in a standardized way.</li> <li>Example: <code>withErrorBoundary(Component)</code></li> </ul> </li> <li> <p>Access Control:</p> <ul> <li>Enforcing role-based access control by conditionally rendering components based on user roles.</li> <li>Example: <code>withRole(Component, allowedRoles)</code></li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Managing form state and validation logic.</li> <li>Example: <code>withFormHandling(Component)</code></li> </ul> </li> </ol>"},{"location":"react/example/lifting-state-up/","title":"Lifting State Up","text":""},{"location":"react/example/lifting-state-up/#theory-of-lifting-state-up-in-react","title":"Theory of Lifting State Up in React","text":"<p>Lifting state up is a pattern in React where you move state from <code>child components</code> to a common <code>parent component</code>. This pattern is necessary for managing state that needs to be shared among multiple child components. By lifting the state up to a common ancestor, you create a single source of truth, ensuring that all child components that need the state have access to the same data.</p>"},{"location":"react/example/lifting-state-up/#why-is-it-necessary","title":"Why Is It Necessary?","text":"<p>When multiple components need to share and synchronize state, managing the state within each component individually can lead to inconsistencies and complexity. Lifting the state up solves these issues by:</p> <ul> <li>Ensuring Consistency: By having a single source of truth for the state, you avoid the risk of components having out-of-sync data.</li> <li>Simplifying State Management: It becomes easier to manage and update the state from one place, reducing the complexity of your application.</li> <li>Avoiding Prop Drilling: While lifting state up does require passing state down as props, it helps avoid deeper and more convoluted prop drilling in larger component trees.</li> </ul>"},{"location":"react/example/lifting-state-up/#how-does-it-solve-the-problem","title":"How Does It Solve the Problem?","text":"<p>Problem: </p> <p>Imagine two sibling components need to share and synchronize some state. If each component maintains its own state, it becomes challenging to keep them in sync.</p> <p>Solution: </p> <p>Lift the state up to their common parent, and pass the state and state-updating functions down to the child components via props. This way, the parent component manages the state, and the child components simply use the state and functions passed to them.</p>"},{"location":"react/example/lifting-state-up/#example","title":"Example","text":"<p>Let's consider a more detailed example:</p> Tip Without Lifting State UpWith Lifting State Up <p>We have two sibling components: TemperatureInput for Celsius and Fahrenheit. Each component maintains its own state.</p> <pre><code>function TemperatureInputCelsius() {\n    const [celsius, setCelsius] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setCelsius(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={celsius} onChange={handleChange} /&gt;;\n}\n\nfunction TemperatureInputFahrenheit() {\n    const [fahrenheit, setFahrenheit] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setFahrenheit(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={fahrenheit} onChange={handleChange} /&gt;;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInputCelsius /&gt;\n        &lt;TemperatureInputFahrenheit /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>In this setup, the components have their own state and do not share data. Converting between Celsius and Fahrenheit requires extra logic in each component and makes it hard to keep them in sync.</p> <p>Lift the state up to the App component and pass the necessary state and handlers down to the child components.</p> <pre><code>function TemperatureInput({ scale, temperature, handleChange }) {\n    return (\n        &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scale}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={handleChange} /&gt;\n        &lt;/fieldset&gt;\n    );\n}\n\n// main function\nfunction App() {\n    const [temperature, setTemperature] = useState('');\n    const [scale, setScale] = useState('c');\n\n    const handleCelsiusChange = (e) =&gt; {\n        setScale('c');\n        setTemperature(e.target.value);\n    };\n\n    const handleFahrenheitChange = (e) =&gt; {\n        setScale('f');\n        setTemperature(e.target.value);\n    };\n\n    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInput\n            scale=\"Celsius\"\n            temperature={celsius}\n            handleChange={handleCelsiusChange}\n        /&gt;\n        &lt;TemperatureInput\n            scale=\"Fahrenheit\"\n            temperature={fahrenheit}\n            handleChange={handleFahrenheitChange}\n        /&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction toCelsius(fahrenheit) {\n    return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n    return (celsius * 9) / 5 + 32;\n}\n\nfunction tryConvert(temperature, convert) {\n    const input = parseFloat(temperature);\n    if (Number.isNaN(input)) {\n        return '';\n    }\n    const output = convert(input);\n    const rounded = Math.round(output * 1000) / 1000;\n    return rounded.toString();\n}\n</code></pre> <p>In this example, the <code>App</code> component maintains the state for the temperature and the scale. The <code>TemperatureInput</code> components are now stateless and receive the necessary state and handlers as props. The conversion functions ensure that both input fields stay in sync.</p>"},{"location":"react/example/lifting-state-up/#summary","title":"Summary","text":"<ul> <li>Lifting state up means moving the state to the closest common ancestor of components that need to share the state.</li> <li>It ensures consistency, simplifies state management, and avoids deep prop drilling.</li> <li>By lifting state up, you centralize the state management, making your application more predictable and easier to maintain.</li> </ul> <p>This approach is essential for managing shared state in React applications, particularly as they grow in complexity.</p>"},{"location":"react/example/passing-props/","title":"Passing Props","text":""},{"location":"react/example/passing-props/#passing-props","title":"passing props","text":"<p>Yes, you can pass state and functions to other components in React, and this is a common practice. The standard approach typically involves the following methods:</p>"},{"location":"react/example/passing-props/#1-props","title":"1. Props","text":"<p>Passing state and functions through props is the most straightforward method. This is done by passing them from a parent component to its child components.</p> <pre><code>function ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;ChildComponent state={state} handleAction={handleAction} /&gt;\n  );\n}\n\nfunction ChildComponent({ state, handleAction }) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/example/passing-props/#2-context","title":"2. Context","text":"<p>For passing state and functions down the component tree without prop drilling (passing through many intermediary components), React's Context API can be used.</p> <pre><code>const MyContext = React.createContext();\n\nfunction ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ state, handleAction }}&gt;\n      &lt;ChildComponent /&gt;\n    &lt;/MyContext.Provider&gt;\n  );\n}\n\nfunction ChildComponent() {\n  const { state, handleAction } = React.useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/example/passing-props/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>For reusable logic that involves state and functions, you can create custom hooks.</p> <pre><code>function useCustomHook() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return { state, handleAction };\n}\n\nfunction Component() {\n  const { state, handleAction } = useCustomHook();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/example/passing-props/#standard-practices","title":"Standard Practices:","text":""},{"location":"react/example/passing-props/#lift-state-up","title":"Lift State Up:","text":"<p>Keep the state in the closest common ancestor of the components that need access to the state. This helps in avoiding unnecessary re-renders and makes the state management simpler.</p>"},{"location":"react/example/passing-props/#prop-drilling","title":"Prop Drilling:","text":"<p>If prop drilling (passing props through multiple levels of components) becomes cumbersome, consider using Context API or state management libraries like Redux.</p>"},{"location":"react/example/passing-props/#descriptive-props","title":"Descriptive Props:","text":"<p>When passing functions and state as props, use descriptive names to make the code more readable and maintainable.</p>"},{"location":"react/example/passing-props/#minimize-context-use","title":"Minimize Context Use:","text":"<p>Use context sparingly to avoid performance issues related to unnecessary re-renders. For global state management, consider state management libraries.</p> <p>By following these methods and practices, you can effectively manage and pass state and functions between components in your React application.</p>"},{"location":"react/example/passing-props/#naming-conventions-for-passing-props","title":"Naming Conventions for Passing Props","text":"Tip <ol> <li> <p>Descriptive Names:</p> <ul> <li>Use clear, descriptive names that convey the purpose of the prop.</li> <li>For state values, use the noun form.</li> <li>For functions (handlers), use the verb form, often prefixed with on or handle.</li> </ul> </li> <li> <p>State Props:</p> <ul> <li>Use the exact name of the state variable.</li> <li>Example: If the state variable is <code>user</code>, pass it as <code>user</code>.</li> </ul> </li> <li> <p>Function Props:</p> <ul> <li>Prefix functions with on if they are event handlers.</li> <li>Prefix with handle if they are general purpose functions.</li> <li>Example: onClick, onChange, handleSubmit.</li> </ul> </li> <li> <p>Boolean Props:</p> <ul> <li>Use prefixes like is, has, should, etc., to indicate boolean nature.</li> <li>Example: isOpen, hasError.</li> </ul> </li> </ol>"},{"location":"react/example/passing-props/#examples","title":"Examples","text":"<p>Here are examples demonstrating these conventions:</p> Basic Example Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    const incrementCount = () =&gt; {\n        setCount(count + 1);\n    };\n\n    return (\n        &lt;ChildComponent count={count} onIncrement={incrementCount} /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function ChildComponent({ count, onIncrement }) {\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={onIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> Advanced Example with Multiple Props Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [username, setUsername] = useState('');\n    const [email, setEmail] = useState('');\n\n    const handleUsernameChange = (e) =&gt; {\n        setUsername(e.target.value);\n    };\n\n    const handleEmailChange = (e) =&gt; {\n        setEmail(e.target.value);\n    };\n\n    return (\n        &lt;FormComponent\n            username={username}\n            email={email}\n            onUsernameChange={handleUsernameChange}\n            onEmailChange={handleEmailChange}\n        /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function FormComponent({ username, email, onUsernameChange, onEmailChange }) {\n    return (\n        &lt;form&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={onUsernameChange} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Email:&lt;/label&gt;\n                &lt;input type=\"email\" value={email} onChange={onEmailChange} /&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    );\n}\n</code></pre>"},{"location":"react/example/passing-props/#summary-of-naming-conventions","title":"Summary of Naming Conventions","text":"<ul> <li>State Values: Use the exact name of the state variable (e.g., <code>count</code>, <code>username</code>).</li> <li>Function Props: Prefix with on for <code>event handlers</code> and handle for <code>general functions</code> (e.g., <code>onClick</code>, <code>handleSubmit</code>).</li> <li>Boolean Props: Use prefixes like is, has, should to indicate their nature (e.g., <code>isOpen</code>, <code>hasError</code>).</li> </ul> <p>Following these conventions makes your code more predictable, readable, and easier to maintain, especially when working in teams or on large projects.</p>"},{"location":"react/example/presentational-and-container/","title":"Presentation & Container","text":""},{"location":"react/example/presentational-and-container/#presentational-components","title":"Presentational Components:","text":"<p>These components focus on how things look. They receive data and callbacks exclusively via props and rarely have their own state.</p>"},{"location":"react/example/presentational-and-container/#container-components","title":"Container Components:","text":"<p>These components focus on how things work. They manage state and handle logic, passing data and callbacks down to presentational components.</p>"},{"location":"react/example/presentational-and-container/#example","title":"Example","text":"jsx<pre><code>// UserForm.js (Presentational Component)\nimport { Form, Input, Button } from 'antd';\n\nconst UserForm = ({ form, onSubmit }) =&gt; (\n  &lt;Form form={form} layout=\"vertical\" onFinish={onSubmit}&gt;\n    &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n  &lt;/Form&gt;\n);\n\nexport default UserForm;\n\n// UserFormContainer.js (Container Component)\nimport React from 'react';\nimport { Form, message } from 'antd';\nimport UserForm from './UserForm';\n\nconst UserFormContainer = () =&gt; {\n  const [form] = Form.useForm();\n\n  const handleSubmit = (values) =&gt; {\n    message.success('Form submitted: ' + JSON.stringify(values));\n    // handle form submission logic here\n  };\n\n  return &lt;UserForm form={form} onSubmit={handleSubmit} /&gt;;\n};\n\nexport default UserFormContainer;\n</code></pre>"},{"location":"react/example/prop-drilling/","title":"Props Drilling","text":"<p>Prop drilling is a pattern in React where you pass data and functions from a parent component through multiple levels of intermediate components down to a deeply nested child component. This can become cumbersome and make the component tree harder to manage, especially as the application grows.</p>"},{"location":"react/example/prop-drilling/#what-is-prop-drilling","title":"What is Prop Drilling?","text":"<p>Prop drilling occurs when you need to pass data or callbacks through many layers of components, even if those intermediate components don\u2019t need to use the data themselves. It can lead to:</p> <ul> <li>Complex Component Trees: Passing props through many layers can make components less reusable and harder to maintain.</li> <li>Unnecessary Re-renders: Intermediate components may re-render unnecessarily if the props change.</li> <li>Increased Boilerplate: You may need to add boilerplate code for passing props through each component layer.</li> </ul>"},{"location":"react/example/prop-drilling/#example","title":"Example","text":"Parent Component: <pre><code>const Parent = () =&gt; {\n    const [data, setData] = useState('Hello');\n\n    return &lt;Intermediate data={data} /&gt;;\n};\n</code></pre> Intermediate Component: <pre><code>const Intermediate = ({ data }) =&gt; {\n    return &lt;DeepChild data={data} /&gt;;\n};\n</code></pre> Deep Child Component: <pre><code>const DeepChild = ({ data }) =&gt; {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n};\n</code></pre> <p>In this example, <code>data</code> is drilled down from <code>Parent</code> through <code>Intermediate</code> to <code>DeepChild</code>.</p>"},{"location":"react/example/prop-drilling/#how-to-avoid-prop-drilling","title":"How to Avoid Prop Drilling","text":"<p>There are several strategies to avoid prop drilling, making your component tree cleaner and more maintainable:</p>"},{"location":"react/example/prop-drilling/#1-react-context-api","title":"1. React Context API:","text":"<p>React Context allows you to share values and functions across the component tree without passing props explicitly through every level.</p> jsx<pre><code>// Create a Context\nconst DataContext = createContext();\n\n// Provider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n\n  return (\n    &lt;DataContext.Provider value={{ data, setData }}&gt;\n      {children}\n    &lt;/DataContext.Provider&gt;\n  );\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useContext(DataContext);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"react/example/prop-drilling/#2-custom-hooks","title":"2. Custom Hooks:","text":"<p>Use custom hooks to encapsulate and share logic across components.</p> <pre><code>// useData.js\nimport { useState } from 'react';\n\nexport const useData = () =&gt; {\n  const [data, setData] = useState('Hello');\n  return { data, setData };\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useData();\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;DeepChild /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"react/example/prop-drilling/#3-state-management-libraries","title":"3. State Management Libraries:","text":"<p>Use state management libraries like Redux, Zustand, or Recoil to manage and access state globally.</p> Redux<pre><code>// actions.js\nexport const setData = (data) =&gt; ({\n  type: 'SET_DATA',\n  payload: data,\n});\n\n// reducer.js\nconst initialState = { data: 'Hello' };\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case 'SET_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Deep Component\nimport { useSelector } from 'react-redux';\n\nconst DeepChild = () =&gt; {\n  const data = useSelector((state) =&gt; state.data);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { dataReducer } from './reducer';\n\nconst store = createStore(dataReducer);\n\nconst App = () =&gt; (\n  &lt;Provider store={store}&gt;\n    &lt;DeepChild /&gt;\n  &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"react/example/prop-drilling/#4-composition","title":"4. Composition:","text":"<p>Sometimes, restructuring components to use composition rather than hierarchical prop drilling can simplify the design.</p> <pre><code>// DataProvider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n  return React.cloneElement(children, { data, setData });\n};\n\n// Deep Component\nconst DeepChild = ({ data }) =&gt; {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"react/example/prop-drilling/#summary","title":"Summary","text":"<p>While prop drilling is a common pattern in React, it can be managed more effectively by leveraging Context API, custom hooks, state management libraries, and component composition. These strategies help maintain a clean and manageable component tree, avoiding the pitfalls of deep prop drilling.</p>"},{"location":"react/example/render-props/","title":"Render Props","text":"<p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> Example jsx<pre><code>// FormContainer.js\nconst FormContainer = ({ children }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleSubmit = (values) =&gt; {\n        console.log('Form submitted:', values);\n    };\n\n    return children({ form, handleSubmit });\n};\n\n// UserForm.js\nconst UserForm = ({ form, handleSubmit }) =&gt; (\n    &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n        &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n);\n\n// Usage in a component\n&lt;FormContainer&gt;\n    {({ form, handleSubmit }) =&gt; (\n        &lt;UserForm form={form} handleSubmit={handleSubmit} /&gt;\n    )}\n&lt;/FormContainer&gt;\n</code></pre> <p>Render props is a pattern in React that allows sharing code between components using a prop whose value is a function. It\u2019s commonly used to provide data and behavior to a component in a way that is flexible and reusable. While \"render props\" is the most widely recognized term, there are a few other names and related concepts that describe similar patterns:</p>"},{"location":"react/example/render-props/#other-names-and-related-concepts","title":"Other Names and Related Concepts","text":""},{"location":"react/example/render-props/#1-function-as-child-component-facc","title":"1. Function as Child Component (FaCC):","text":"<p>This term describes a pattern where a function is used as a child of a component. It\u2019s conceptually similar to render props, but with the function passed as a child rather than a prop.</p> Example<pre><code>const UserProfile = ({ children }) =&gt; {\nconst user = { name: 'John Doe', email: 'john.doe@example.com' };\nreturn children(user);\n};\n\nconst App = () =&gt; (\n&lt;UserProfile&gt;\n    {user =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;{user.name}&lt;/h1&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n    )}\n&lt;/UserProfile&gt;\n);\n</code></pre>"},{"location":"react/example/render-props/#2-controlled-components","title":"2. Controlled Components:","text":"<p>Controlled components use props to control their behavior and render output. While this term is often associated with form elements, it can also apply to the render props pattern where a component is controlled via functions.</p>"},{"location":"react/example/render-props/#3-function-render-pattern","title":"3. Function Render Pattern:","text":"<p>This term is used interchangeably with render props to describe the pattern of using a function to determine what should be rendered.</p>"},{"location":"react/example/render-props/#4-function-as-children-pattern","title":"4. Function-as-Children Pattern:","text":"<p>Similar to function as child components, this pattern involves passing a function as a child to render UI based on some state or logic.</p> <pre><code>const DataProvider = ({ children }) =&gt; {\n  const data = ['Item 1', 'Item 2', 'Item 3'];\n  return children(data);\n};\n\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    {data =&gt; (\n      &lt;ul&gt;\n        {data.map((item, index) =&gt; (\n          &lt;li key={index}&gt;{item}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    )}\n  &lt;/DataProvider&gt;\n);\n</code></pre>"},{"location":"react/example/render-props/#5-render-function-pattern","title":"5. Render Function Pattern:","text":"<p>This term emphasizes the use of a function to handle the rendering logic within a component. It is another way to refer to the render props pattern.</p>"},{"location":"react/example/render-props/#summary","title":"Summary","text":"<p>The render props pattern is known by various names and is conceptually related to several other patterns that involve passing functions to control rendering and behavior. These patterns provide flexibility and reusability in React component design.</p>"},{"location":"react/fake-api/intro/","title":"Intro","text":"<p>Faking an API in a React application is useful for testing and development purposes. Here are a few common methods:</p>"},{"location":"react/fake-api/intro/#1-using-mock-service-workers-msw","title":"1. Using Mock Service Workers (MSW)","text":"<p>MSW is a powerful library for mocking API requests. It intercepts requests at the network level and returns mock responses. This is especially useful for integration testing and development.</p> Setup MSW: <ol> <li> <p>Install the library:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock handler file (<code>mocks/handlers.js</code>):</p> <pre><code>import { rest } from 'msw';\n\nexport const handlers = [\n    rest.get('/api/your-endpoint', (req, res, ctx) =&gt; {\n        return res(ctx.json({ message: 'This is a mock response' }));\n    }),\n    // Add more handlers for different endpoints and methods\n];\n</code></pre> </li> <li> <p>Setup the mock server in your application (<code>mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from 'msw';\nimport { handlers } from './handlers';\n\nconst worker = setupWorker(...handlers);\n\nworker.start();\n</code></pre> </li> <li> <p>Include the mock server setup in your application entry point (<code>index.js</code> or <code>App.js</code>):</p> <pre><code>import './mocks/browser';\n</code></pre> </li> </ol>"},{"location":"react/fake-api/intro/#2-using-json-server","title":"2. Using json-server","text":"<p>json-server is a simple tool to create a fake REST API using a JSON file.</p> <pre><code>your-project/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 layouts/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 views/\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ... (other source files)\n\u251c\u2500\u2500 db/\n\u2502   \u251c\u2500\u2500 db.json\n\u2502   \u2514\u2500\u2500 start-mock-api.js\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 webpack.config.js\n\u2514\u2500\u2500 ... (other configuration files)\n</code></pre> db.jsonstart-mock-api.jspackage.json <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" },\n        { \"id\": 2, \"title\": \"json-server is awesome\" }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n    ],\n    \"profile\": { \"name\": \"typicode\" }\n}\n</code></pre> <pre><code>const jsonServer = require('json-server');\nconst path = require('path');\nconst server = jsonServer.create();\nconst router = jsonServer.router(path.join(__dirname, 'db.json'));\nconst middlewares = jsonServer.defaults();\n\nserver.use(middlewares);\nserver.use(router);\n\nconst PORT = 5000;\nserver.listen(PORT, () =&gt; {\n    console.log(`JSON Server is running on port ${PORT}`);\n});\n</code></pre> <pre><code>\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"dockerbuild\": \"react-scripts --openssl-legacy-provider build\",\n    \"mac-start-run\": \"react-scripts --openssl-legacy-provider start\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"product\": \"set PORT=4200 &amp;&amp; react-scripts start\",\n    \"start:mock-api\": \"node db/start-mock-api.js\",\n    \"start:all\": \"concurrently \\\"npm run product\\\" \\\"npm run start:mock-api\\\"\"\n}\n</code></pre> Setup json-server: <ol> <li> <p>Install <code>json-server</code>:</p> <pre><code>npm install json-server --save-dev\n\n//or\n\nnpm install json-server@0.16.3 --save-dev\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with your mock data:</p> <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" }\n    ]\n}\n</code></pre> </li> <li> <p>Add a script to your <code>package.json</code> to start the server:</p> <pre><code>\"scripts\": {\n    \"start:mock-api\": \"json-server --watch db.json --port 5000\"\n}\n</code></pre> </li> <li> <p>Run the mock API server:</p> <pre><code>npm run start:mock-api\n</code></pre> </li> </ol> <p>You can now make requests to <code>http://localhost:5000/posts</code>.</p> <p>Start Both Servers:</p> <p>Use <code>concurrently</code> to start both the React app and the mock API server.</p> <pre><code>npm run start:all\n</code></pre>"},{"location":"react/fake-api/intro/#3-using-a-simple-mock-with-axios-or-fetch","title":"3. Using a Simple Mock with Axios or Fetch","text":"<p>You can create a simple mock directly in your React application by intercepting API calls with Axios or Fetch.</p> Example using Axios: <ol> <li> <p>Install Axios:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Create a mock API file (<code>apiMock.js</code>):</p> <pre><code>import axios from 'axios';\n\nconst mockResponse = {\n    data: { message: 'This is a mock response' },\n};\n\naxios.interceptors.request.use(request =&gt; {\n    if (request.url === '/api/your-endpoint') {\n        return Promise.resolve(mockResponse);\n    }\n    return request;\n});\n</code></pre> </li> <li> <p>Import and use the mock API file in your application (<code>App.js</code>):</p> <pre><code>import './apiMock';\n</code></pre> </li> </ol> <p>Now, when your app makes requests to <code>/api/your-endpoint</code>, it will receive the mock response.</p> <p>These methods allow you to simulate API responses and test how your React application handles different scenarios without needing a real backend.</p>"},{"location":"react/fake-api/intro/#among-the-methods-mentioned","title":"Among the methods mentioned:","text":"<ol> <li> <p>Mock Service Workers (MSW) is the most popular and widely used method for mocking APIs in modern React applications. It provides a comprehensive and flexible solution for intercepting network requests and mocking responses. MSW is especially popular in testing environments due to its ability to handle various HTTP methods and work with both REST and GraphQL APIs. It integrates well with testing libraries like Jest and React Testing Library.</p> </li> <li> <p>json-server is also popular, particularly for creating a quick and simple REST API with a JSON file. It is commonly used for local development and prototyping. While it\u2019s less flexible compared to MSW in terms of handling different types of requests and responses, it's still a useful tool for generating mock data and endpoints quickly.</p> </li> <li> <p>Using a Simple Mock with Axios or Fetch is less common compared to the other methods but can be useful for very basic scenarios or when you need a quick solution without setting up additional libraries. It\u2019s typically used for simpler use cases or when integrating mocks directly into the application code is sufficient.</p> </li> </ol> <p>For most React applications, MSW is the go-to choice due to its robust features and flexibility in handling various mocking scenarios.</p>"},{"location":"react/fake-api/json-server/","title":"Use Mocking Libraries","text":""},{"location":"react/fake-api/json-server/#2-use-mocking-libraries-eg-json-server-miragejs","title":"2. Use Mocking Libraries (e.g., <code>json-server</code>, <code>MirageJS</code>):","text":"<ul> <li><code>json-server</code>: A full fake REST API server that you can run locally.</li> </ul> <pre><code>npm install json-server\n</code></pre> Steps: <ol> <li> <p>Install json-server:</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with some mock data:</p> json<pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\" },\n        { \"id\": 2, \"name\": \"Jane Smith\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run the server:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Now, you can access your API at <code>http://localhost:5000/users</code>.</p> </li> </ol> Example in Vue/React/Angular: <pre><code>fetch(\"http://localhost:5000/users\")\n.then((response) =&gt; response.json())\n.then((data) =&gt; console.log(data));\n</code></pre>"},{"location":"react/fake-api/json-server/#example","title":"Example","text":"Abstract 1. Basic Example2. Intermediate Example3. Advanced Example <p>This example will create a simple REST API using json-server to serve basic user data.</p> Steps: <ol> <li> <p>Install <code>json-server</code> globally (if not already installed):</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code>:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Access the API:</p> <ul> <li><code>GET http://localhost:5000/users</code> will return the list of users.</li> <li><code>GET http://localhost:5000/users/1</code> will return the user with id <code>1</code>.</li> <li><code>POST</code>, <code>PUT</code>, <code>DELETE</code> operations will work automatically for <code>users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Simple API with RESTful routes for basic CRUD operations.</li> </ul> <p>In this example, we\u2019ll add:</p> <ul> <li>Custom Routes for more control over the API.</li> <li>Pagination and Filtering using query parameters.</li> </ul> Steps: <ol> <li> <p>Create an extended <code>db.json</code> file with multiple resources:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" },\n        { \"id\": 3, \"name\": \"Bill Gates\", \"email\": \"bill@microsoft.com\" },\n        { \"id\": 4, \"name\": \"Elon Musk\", \"email\": \"elon@spacex.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"content\": \"Lorem Ipsum\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"content\": \"Dolor Sit\", \"userId\": 2 },\n        { \"id\": 3, \"title\": \"Post 3\", \"content\": \"Amet Consectetur\", \"userId\": 1 }\n    ]\n}\n</code></pre> </li> <li> <p>Add a <code>routes.json</code> file to define custom routes:</p> <pre><code>{\n    \"/api/users\": \"/users\",\n    \"/api/posts\": \"/posts\"\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code> with the custom routes:</p> <pre><code>json-server --watch db.json --routes routes.json --port 5000\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Pagination: <code>GET http://localhost:5000/users?_page=1&amp;_limit=2</code> will return 2 users per page.</li> <li>Filtering: <code>GET http://localhost:5000/posts?userId=1</code> will return all posts for user with <code>userId=1</code>.</li> <li>Custom Routes: Access users via <code>GET http://localhost:5000/api/users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>More control over API routes.</li> <li>Added pagination and filtering for more realistic data operations.</li> </ul> <p>In this example, we\u2019ll demonstrate:</p> <ul> <li>Custom Middlewares for request logging.</li> <li>Delayed Responses to simulate network delays.</li> <li>Advanced Relationships between resources (users and posts).</li> </ul> Steps: <ol> <li> <p>Create a <code>db.json</code> file with more complex relationships:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"userId\": 1 },\n        { \"id\": 3, \"title\": \"Post 3\", \"userId\": 2 }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"Nice post!\", \"postId\": 1 },\n        { \"id\": 2, \"body\": \"Thanks for sharing!\", \"postId\": 1 },\n        { \"id\": 3, \"body\": \"Great article\", \"postId\": 2 }\n    ]\n}\n</code></pre> </li> <li> <p>Create a <code>server.js</code> file to customize the server:</p> <pre><code>const jsonServer = require('json-server');\nconst server = jsonServer.create();\nconst router = jsonServer.router('db.json');\nconst middlewares = jsonServer.defaults();\nconst port = 5000;\n\n// Custom middleware to log requests\nserver.use(middlewares);\nserver.use((req, res, next) =&gt; {\n    console.log(`[LOG] Request: ${req.method} ${req.url}`);\n    next();\n});\n\n// Custom route for delayed response\nserver.get('/api/delayed-response', (req, res) =&gt; {\n    setTimeout(() =&gt; {\n        res.status(200).jsonp({ message: \"This response is delayed!\" });\n    }, 3000); // 3-second delay\n});\n\n// Use default router with pagination, filters, etc.\nserver.use(router);\n\n// Start server\nserver.listen(port, () =&gt; {\n    console.log(`JSON Server is running on http://localhost:${port}`);\n});\n</code></pre> </li> <li> <p>Run the custom server:</p> <pre><code>node server.js\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Logging Middleware: Logs all incoming requests with their method and URL.</li> <li>Delayed Response: <code>GET http://localhost:5000/api/delayed-response</code> simulates a 3-second delay before responding.</li> <li>Relationships: <code>GET http://localhost:5000/posts?userId=1</code> will fetch posts for a specific user, and you can fetch comments for a post with <code>GET http://localhost:5000/comments?postId=1</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Advanced API with custom middlewares, delayed responses, and relationships between entities.</li> <li>You can simulate real-world scenarios with complex data structures.</li> </ul> <p>Summary:</p> <ul> <li>Basic Example: Simple CRUD operations using <code>json-server</code>.</li> <li>Intermediate Example: Added custom routes, pagination, and filtering.</li> <li>Advanced Example: Custom middlewares, delayed responses, and more complex relationships between entities.</li> </ul> <p>These progressively advanced examples help you mock an API for frontend development, simulate realistic scenarios, and add more flexibility to your workflow.</p>"},{"location":"react/fake-api/json-server/#my-json-server","title":"My JSON Server","text":"How to <ol> <li>Create a repository on GitHub (<code>&lt;your-username&gt;/&lt;your-repo&gt;</code>)</li> <li>Create a <code>db.json</code> file</li> <li>Visit https://my-json-server.typicode.com// to access your server</li> </ol> <p>No registration. Nothing to install.</p> <ul> <li>my-json-server: github</li> </ul>"},{"location":"react/fake-api/json-server/#reference","title":"Reference","text":"<ul> <li>json server: github</li> <li>my-json-server.typicode.com</li> </ul>"},{"location":"react/fake-api/topic/","title":"Topic","text":""},{"location":"react/fake-api/topic/#overview","title":"Overview","text":"<p>Mocking APIs in a React application using Redux Toolkit, Axios, and Ant Design can be effectively done using a few different approaches. Here are some of the best methods:</p>"},{"location":"react/fake-api/topic/#1-using-mock-service-worker-msw","title":"1. Using Mock Service Worker (MSW)","text":"<p>Mock Service Worker is a powerful tool for mocking API requests at the network level. It allows you to intercept network requests and provide mock responses without changing your application code.</p> <p>Setup:</p> <ol> <li> <p>Install MSW:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock service worker: Create a file (e.g., <code>src/mocks/handlers.js</code>) to define your request handlers.</p> <pre><code>import { rest } from \"msw\";\n\nexport const handlers = [\n  rest.get(\"/api/data\", (req, res, ctx) =&gt; {\n    return res(ctx.status(200), ctx.json({ message: \"Success\" }));\n  }),\n  // Add more handlers as needed\n];\n</code></pre> </li> <li> <p>Set up the MSW in your application: Create a file (e.g., <code>src/mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from \"msw\";\nimport { handlers } from \"./handlers\";\n\nexport const worker = setupWorker(...handlers);\n</code></pre> </li> <li> <p>Start the worker: In your main entry file (e.g., <code>index.js</code>), start the MSW worker:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { worker } from \"./mocks/browser\";\n\n// Start the Mock Service Worker\nworker.start();\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre> </li> </ol>"},{"location":"react/fake-api/topic/#2-using-axios-mock-adapter","title":"2. Using Axios Mock Adapter","text":"<p>If you prefer a simpler solution, you can use the Axios Mock Adapter to mock requests.</p> <p>Setup:</p> <ol> <li> <p>Install Axios Mock Adapter:</p> <pre><code>npm install axios-mock-adapter --save-dev\n</code></pre> </li> <li> <p>Create a mock instance: You can create a file to configure your mock adapter (e.g., <code>src/mocks/axiosMock.js</code>):</p> <pre><code>import axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nconst mock = new MockAdapter(axios);\n\nmock.onGet(\"/api/data\").reply(200, {\n  message: \"Success\",\n});\n\nexport default mock;\n</code></pre> </li> <li> <p>Import the mock in your main entry file: Ensure that the mock is set up before your application runs:</p> <pre><code>import './mocks/axiosMock';\n</code></pre> </li> <li> <p>Static JSON Files</p> <p>For simple use cases, you can also serve static JSON files from your public folder.</p> <ol> <li> <p>Create a JSON file: Place a JSON file (e.g., <code>public/mockData.json</code>) with your mock data.</p> </li> <li> <p>Fetch the data: Use Axios to fetch this static JSON file:</p> </li> </ol> <pre><code>const fetchData = async () =&gt; {\n  const response = await axios.get(\"/mockData.json\");\n  console.log(response.data);\n};\n</code></pre> </li> </ol>"},{"location":"react/fake-api/topic/#choosing-the-best-method","title":"Choosing the Best Method","text":"<ul> <li>MSW is recommended for its flexibility and ability to simulate various scenarios (errors, delays, etc.) without changing the code.</li> <li>Axios Mock Adapter is suitable for quick setups and smaller projects where you want to mock only Axios requests.</li> <li>Static JSON files are great for very basic needs but might not cover all edge cases.</li> </ul>"},{"location":"react/fake-api/topic/#conclusion","title":"Conclusion","text":"<p>For a robust solution that integrates well with your Redux and Axios setup, Mock Service Worker is generally the best choice. It allows for easy testing and simulating real-world scenarios without much overhead.</p>"},{"location":"react/fake-api/topic/#only-run-in-development","title":"Only run in development","text":"<pre><code>// src/index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { worker } from \"./mocks/browser\";\n\nif (process.env.NODE_ENV === \"development\") {\n  worker.start();\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre>"},{"location":"react/fake-api/msw/msw-version/","title":"Version","text":""},{"location":"react/fake-api/msw/msw-version/#key-changes-in-msw-v2x","title":"Key Changes in MSW <code>v2.x</code>:","text":"<p>In MSW v2.x, you\u2019ll notice the following updates compared to v1.x:</p> <ol> <li> <p>Module Name Change: rest is replaced by http. This is now a more general and flexible approach.</p> Example <ul> <li> <p>v1.x:</p> <pre><code>import { rest } from 'msw';\n</code></pre> </li> <li> <p>v2.x:</p> <pre><code>import { http } from 'msw';\n</code></pre> </li> </ul> </li> <li> <p>HTTP Method Changes: CRUD operations are handled using the new http methods: <code>.get</code>, <code>.post</code>, <code>.put</code>, <code>.delete</code>.</p> </li> <li> <p>Better Flexibility: The <code>http</code> module gives you a more consistent and extendable way to mock requests across different types of HTTP methods.</p> </li> </ol>"},{"location":"react/fake-api/msw/msw-version/#curd-in-msw","title":"CURD in msw","text":"<pre><code>import { http } from \"msw\";\n\nconst handlers = [\n  // Create: POST\n  http.post(\"/create\", (req, res, ctx) =&gt; {\n    const { name, email } = req.body;\n    return res(\n      ctx.status(201),\n      ctx.json({ message: \"User created\", name, email })\n    );\n  }),\n\n  // Read: GET\n  http.get(\"/user\", (req, res, ctx) =&gt; {\n    return res(\n      ctx.status(200),\n      ctx.json({ name: \"John Doe\", email: \"john@example.com\" })\n    );\n  }),\n\n  // Update: PUT\n  http.put(\"/update\", (req, res, ctx) =&gt; {\n    const { name, email } = req.body;\n    return res(\n      ctx.status(200),\n      ctx.json({ message: \"User updated\", name, email })\n    );\n  }),\n\n  // Delete: DELETE\n  http.delete(\"/delete\", (req, res, ctx) =&gt; {\n    return res(ctx.status(200), ctx.json({ message: \"User deleted\" }));\n  }),\n];\n\nexport { handlers };\n</code></pre>"},{"location":"react/fake-api/msw/msw-version/#reference","title":"Reference","text":"<ul> <li>msw 2.0</li> </ul>"},{"location":"react/fake-api/msw/msw/","title":"Mock Services with Browser APIs","text":"<p>To fake an API for consumption in your frontend (React, Vue, Angular), you can use different tools and techniques, such as setting up a mock server or using third-party libraries. Here are a few common approaches:</p> 1. Use Mock Services in JavaScript: <p>You can define mock data directly in your frontend project for development and testing.</p> <pre><code>// Sample mock data\nconst mockData = [\n{ id: 1, name: \"John Doe\", age: 30 },\n{ id: 2, name: \"Jane Smith\", age: 25 },\n];\n\n// Mock API call\nexport const fetchMockData = () =&gt; {\nreturn new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n    resolve(mockData);\n    }, 1000); // Simulating network delay\n});\n};\n\n// In your React component\nuseEffect(() =&gt; {\nfetchMockData().then((data) =&gt; {\n    console.log(data); // Handle the data\n});\n}, []);\n</code></pre> 3. Use Axios Interceptors (or Fetch Mocking): <p>You can intercept network requests in your frontend using Axios or Fetch to return fake responses.</p> Axios Example:<pre><code>import axios from 'axios';\n\n// Create a mock Axios instance\nconst mockAxios = axios.create();\n\n// Intercept requests and return mock data\nmockAxios.interceptors.request.use((config) =&gt; {\n    if (config.url === '/api/users') {\n        return Promise.resolve({\n            data: [{ id: 1, name: 'John Doe' }, { id: 2, name: 'Jane Smith' }],\n        });\n    }\n    return config;\n});\n\n// In your component\nuseEffect(() =&gt; {\n    mockAxios.get('/api/users').then((response) =&gt; {\n        console.log(response.data); // Fake data\n    });\n}, []);\n</code></pre>"},{"location":"react/fake-api/msw/msw/#4-mock-services-with-browser-apis-eg-fetch-mock-msw","title":"4. Mock Services with Browser APIs (e.g., <code>fetch-mock</code>, <code>msw</code>):","text":"<ul> <li><code>fetch-mock</code>: Mock fetch requests.</li> <li>MSW (Mock Service Worker): An API mocking library that works by intercepting requests via Service Workers.</li> </ul> MSW Example: <ol> <li> <p>Install <code>msw</code>:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Setup <code>msw</code>:</p> <pre><code>import { setupWorker, rest } from \"msw\";\n\n// Define request handlers\nconst worker = setupWorker(\n    rest.get(\"/api/users\", (req, res, ctx) =&gt; {\n        return res(\n            ctx.json([\n                { id: 1, name: \"John Doe\" },\n                { id: 2, name: \"Jane Smith\" },\n            ])\n        );\n    })\n);\n\n// Start the worker\nworker.start();\n</code></pre> <p>These methods let you easily fake APIs to speed up frontend development without depending on a backend. You can choose the best approach depending on your stack and workflow!</p> </li> <li> <p>Browser integration </p> <pre><code>npx msw init &lt;PUBLIC_DIR&gt; --save\n\nnpx msw init public --save\n</code></pre> </li> </ol>"},{"location":"react/folder-structure/feature-based-pattern/","title":"Feature Based","text":""},{"location":"react/folder-structure/feature-based-pattern/#overview","title":"Overview","text":"<pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-wide configuration and logic\n\u2502   \u251c\u2500\u2500 api/                          # RTK Query base API and custom APIs\n\u2502   \u2502   \u251c\u2500\u2500 apiSlice.js               # Base RTK Query API slice\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js                # Custom RTK Query API for auth\n\u2502   \u2502   \u2514\u2500\u2500 balanceApi.js             # Custom RTK Query API for balance\n\u2502   \u251c\u2500\u2500 socket.js                     # WebSocket setup and instance\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store configuration\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.js            # Hook for authentication logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginPage.js          # Login page\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupPage.js         # Signup page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable dashboard components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary card component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ActivityTable.js      # Table for recent activities\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Graph for balance tracking\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.js   # Hook for fetching dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardPage.js      # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Form for balance management\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useBalance.js         # Hook for balance-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalancePage.js        # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Table for spending breakdown\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useSpending.js        # Hook for spending-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingPage.js       # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 reports/                      # Reports feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsChart.js       # Chart for reports\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useReports.js         # Hook for reports data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsPage.js        # Reports main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 profile/                      # User profile feature\n\u2502       \u251c\u2500\u2500 components/               # Components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfileForm.js        # Form for editing user profile\n\u2502       \u251c\u2500\u2500 hooks/                    # Hooks for profile logic\n\u2502       \u2502   \u2514\u2500\u2500 useProfile.js         # Hook for user profile logic\n\u2502       \u251c\u2500\u2500 pages/                    # Page components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfilePage.js        # User profile page\n\u2502       \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock APIs using MSW\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW setup for the browser\n\u2502   \u251c\u2500\u2500 handlers/                     # Handlers for API routes\n\u2502   \u2502   \u251c\u2500\u2500 balanceHandlers.js        # Handlers for balance routes\n\u2502   \u2502   \u251c\u2500\u2500 spendingHandlers.js       # Handlers for spending routes\n\u2502   \u2502   \u2514\u2500\u2500 userHandlers.js           # Handlers for user routes\n\u2502   \u2514\u2500\u2500 mockData/                     # Predefined mock data\n\u2502       \u2514\u2500\u2500 users.js                  # Sample user data\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized routing logic\n\u2502   \u251c\u2500\u2500 AppRoutes.js                  # Application routes\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Auth-guarded route\n\u2502   \u251c\u2500\u2500 Layout.js                     # Layout component for nested routes\n\u2502   \u2514\u2500\u2500 SidebarConfig.js              # Configuration for sidebar navigation\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources\n\u2502   \u251c\u2500\u2500 components/                   # Generic components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Footer.js                 # App footer\n\u2502   \u2502   \u2514\u2500\u2500 Sidebar.js                # Sidebar navigation\n\u2502   \u251c\u2500\u2500 constants/                    # Constants and enums\n\u2502   \u2502   \u2514\u2500\u2500 roles.js                  # User role definitions\n\u2502   \u251c\u2500\u2500 hooks/                        # Shared hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket connection hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js             # Date formatting\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Currency formatting\n\u2502   \u251c\u2500\u2500 HOC/                          # Higher-order components\n\u2502   \u2502   \u2514\u2500\u2500 withErrorBoundary.js      # Error boundary wrapper\n\u2502   \u251c\u2500\u2500 styles/                       # Global styles\n\u2502   \u2502   \u2514\u2500\u2500 variables.less            # Ant Design style overrides\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme setup\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styling\n\u2502   \u251c\u2500\u2500 index.css                     # Base styles\n\u2502   \u251c\u2500\u2500 overrides.css                 # Ant Design overrides\n\u2502   \u2514\u2500\u2500 themes/                       # Additional themes\n\u2502       \u2514\u2500\u2500 dark.css                  # Dark theme styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u251c\u2500\u2500 main.js                           # React and Redux entry point\n\u2514\u2500\u2500 index.html                        # HTML entry point . give me code example of balance pages example and components example\n</code></pre> <p>Here's an example of how the code for the Balance feature in your structure might look. I'll provide the following:</p> <ul> <li><code>BalancePage.js</code> \u2014 A page component that uses the balance-related functionality.</li> <li><code>BalanceForm.js</code> \u2014 A form component for adding or managing balance.</li> </ul> BalancePage.jsBalanceForm.jsuseBalance.js (Hook)store.js (Redux store) <pre><code>// src/features/balance/pages/BalancePage.js\n\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { fetchBalance } from \"../hooks/useBalance\";\nimport BalanceForm from \"../components/BalanceForm\";\nimport { Card, Typography, Spin } from \"antd\";\n\nconst { Title } = Typography;\n\nconst BalancePage = () =&gt; {\n    const dispatch = useDispatch();\n\n    // Assuming you have a balance state in the store\n    const balanceData = useSelector((state) =&gt; state.balance.data);\n    const isLoading = useSelector((state) =&gt; state.balance.isLoading);\n    const error = useSelector((state) =&gt; state.balance.error);\n\n    useEffect(() =&gt; {\n        dispatch(fetchBalance());\n    }, [dispatch]);\n\n    if (isLoading) {\n        return &lt;Spin size=\"large\" /&gt;;\n    }\n\n    if (error) {\n        return &lt;div&gt;Error loading balance: {error.message}&lt;/div&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;Title level={2}&gt;Manage Balance&lt;/Title&gt;\n\n            {/* Display balance summary */}\n            &lt;Card title=\"Current Balance\"&gt;\n                &lt;p&gt;\n                {balanceData\n                    ? `Balance: $${balanceData.amount}`\n                    : \"No balance available\"}\n                &lt;/p&gt;\n            &lt;/Card&gt;\n\n            {/* Balance management form */}\n            &lt;BalanceForm /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default BalancePage;\n</code></pre> <p>This is the form component for managing the balance, including updating the balance.</p> <pre><code>// src/features/balance/components/BalanceForm.js\n\nimport React, { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { Form, Input, Button, message } from \"antd\";\nimport { updateBalance } from \"../hooks/useBalance\";\n\nconst BalanceForm = () =&gt; {\n    const [form] = Form.useForm();\n    const dispatch = useDispatch();\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    const handleSubmit = async (values) =&gt; {\n        setIsSubmitting(true);\n        try {\n            // Dispatch action to update balance\n            await dispatch(updateBalance(values.amount));\n            message.success(\"Balance updated successfully!\");\n            form.resetFields();\n        } catch (error) {\n            message.error(\"Failed to update balance\");\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n\n    return (\n        &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n            &lt;Form.Item\n                label=\"Amount\"\n                name=\"amount\"\n                rules={[\n                    { required: true, message: \"Please input the balance amount!\" },\n                ]}\n            &gt;\n                &lt;Input type=\"number\" placeholder=\"Enter amount\" /&gt;\n            &lt;/Form.Item&gt;\n\n            &lt;Button type=\"primary\" htmlType=\"submit\" loading={isSubmitting}&gt;\n                Update Balance\n            &lt;/Button&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default BalanceForm;\n</code></pre> <p>To handle the logic for fetching and updating the balance, you would typically use a custom hook like <code>useBalance.js</code>. Here's an example of that:</p> <pre><code>// src/features/balance/hooks/useBalance.js\n\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { api } from '../../app/api/apiSlice';  // Assuming apiSlice is configured\n\n// Thunk for fetching balance\nexport const fetchBalance = createAsyncThunk(\n    'balance/fetchBalance',\n    async () =&gt; {\n        const response = await api.get('/balance');  // Replace with actual endpoint\n        return response.data;\n    }\n);\n\n// Thunk for updating balance\nexport const updateBalance = createAsyncThunk(\n    'balance/updateBalance',\n    async (amount) =&gt; {\n        const response = await api.post('/balance/update', { amount });\n        return response.data;\n    }\n);\n\n// Slice for balance state\nconst balanceSlice = createSlice({\n    name: 'balance',\n    initialState: {\n        data: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {},\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchBalance.pending, (state) =&gt; {\n                state.isLoading = true;\n            })\n            .addCase(fetchBalance.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.data = action.payload;\n            })\n            .addCase(fetchBalance.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error;\n            })\n            .addCase(updateBalance.pending, (state) =&gt; {\n                state.isLoading = true;\n            })\n            .addCase(updateBalance.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.data = action.payload;\n            })\n            .addCase(updateBalance.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error;\n            });\n    },\n});\n\nexport default balanceSlice.reducer;\n</code></pre> <p>Make sure the balance slice is added to the Redux store configuration.</p> <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport balanceReducer from '../features/balance/hooks/useBalance';\n\nexport const store = configureStore({\n    reducer: {\n        balance: balanceReducer,\n    },\n});\n</code></pre>"},{"location":"react/folder-structure/feature-based-pattern/#explanation","title":"Explanation:","text":"<ul> <li><code>BalancePage.js</code>: This page is responsible for fetching and displaying balance-related data, including rendering the <code>BalanceForm</code> for updating the balance.</li> <li><code>BalanceForm.js</code>: A form that allows the user to update their balance. It uses Ant Design's <code>Form</code> and <code>Button</code> components to handle the input and submit functionality.</li> <li><code>useBalance.js</code>: A custom hook that manages state related to fetching and updating the balance. It uses Redux Toolkit's <code>createSlice</code> and <code>createAsyncThunk</code> to handle asynchronous operations such as fetching and updating the balance from an API.</li> </ul> <p>This setup provides a clean structure for managing balance-related logic, API calls, and UI components in your application.</p>"},{"location":"react/folder-structure/feature-based-pattern/#feature-based-folder-structure","title":"Feature-Based Folder Structure","text":"ExampleAdvanced <pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-level configuration\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store setup with RTK Query\n\u2502   \u251c\u2500\u2500 apiSlice.js                   # Base API slice for RTK Query\n\u2502   \u2514\u2500\u2500 socket.js                     # WebSocket configuration (if needed)\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form component\n\u2502   \u2502   \u251c\u2500\u2500 authApiSlice.js           # RTK Query slice for authentication\n\u2502   \u2502   \u251c\u2500\u2500 AuthPage.js               # Authentication page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for dashboard\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary cards component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Balance chart component\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApiSlice.js      # RTK Query slice for dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 DashboardPage.js          # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Balance update form component\n\u2502   \u2502   \u251c\u2500\u2500 balanceApiSlice.js        # RTK Query slice for balance data\n\u2502   \u2502   \u251c\u2500\u2500 BalancePage.js            # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Spending table component\n\u2502   \u2502   \u251c\u2500\u2500 spendingApiSlice.js       # RTK Query slice for spending data\n\u2502   \u2502   \u251c\u2500\u2500 SpendingPage.js           # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 reports/                      # Reports feature\n\u2502       \u251c\u2500\u2500 components/               # Reusable components for reports\n\u2502       \u2502   \u2514\u2500\u2500 ReportsChart.js       # Reports chart component\n\u2502       \u251c\u2500\u2500 reportsApiSlice.js        # RTK Query slice for reports data\n\u2502       \u251c\u2500\u2500 ReportsPage.js            # Reports main page\n\u2502       \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock Service Worker setup\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW browser setup\n\u2502   \u251c\u2500\u2500 handlers.js                   # API handlers\n\u2502   \u2514\u2500\u2500 mockData.js                   # Mock data for testing\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized route definitions\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Route guard for authenticated access\n\u2502   \u2514\u2500\u2500 AppRoutes.js                  # Application route definitions\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources across features\n\u2502   \u251c\u2500\u2500 components/                   # Reusable components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Sidebar.js                # Navigation sidebar\n\u2502   \u2502   \u2514\u2500\u2500 Footer.js                 # App footer\n\u2502   \u251c\u2500\u2500 hooks/                        # Custom hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Utility for formatting currency\n\u2502   \u251c\u2500\u2500 constants.js                  # Shared constants\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styles\n\u2502   \u2514\u2500\u2500 index.css                     # Global CSS styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u2514\u2500\u2500 main.js                           # Entry point for React and MSW\n</code></pre> <pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-wide configuration and logic\n\u2502   \u251c\u2500\u2500 api/                          # RTK Query base API and custom APIs\n\u2502   \u2502   \u251c\u2500\u2500 apiSlice.js               # Base RTK Query API slice\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js                # Custom RTK Query API for auth\n\u2502   \u2502   \u2514\u2500\u2500 balanceApi.js             # Custom RTK Query API for balance\n\u2502   \u251c\u2500\u2500 socket.js                     # WebSocket setup and instance\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store configuration\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.js            # Hook for authentication logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginPage.js          # Login page\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupPage.js         # Signup page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable dashboard components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary card component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ActivityTable.js      # Table for recent activities\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Graph for balance tracking\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.js   # Hook for fetching dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardPage.js      # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Form for balance management\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useBalance.js         # Hook for balance-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalancePage.js        # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Table for spending breakdown\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useSpending.js        # Hook for spending-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingPage.js       # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 reports/                      # Reports feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsChart.js       # Chart for reports\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useReports.js         # Hook for reports data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsPage.js        # Reports main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 profile/                      # User profile feature\n\u2502       \u251c\u2500\u2500 components/               # Components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfileForm.js        # Form for editing user profile\n\u2502       \u251c\u2500\u2500 hooks/                    # Hooks for profile logic\n\u2502       \u2502   \u2514\u2500\u2500 useProfile.js         # Hook for user profile logic\n\u2502       \u251c\u2500\u2500 pages/                    # Page components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfilePage.js        # User profile page\n\u2502       \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock APIs using MSW\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW setup for the browser\n\u2502   \u251c\u2500\u2500 handlers/                     # Handlers for API routes\n\u2502   \u2502   \u251c\u2500\u2500 balanceHandlers.js        # Handlers for balance routes\n\u2502   \u2502   \u251c\u2500\u2500 spendingHandlers.js       # Handlers for spending routes\n\u2502   \u2502   \u2514\u2500\u2500 userHandlers.js           # Handlers for user routes\n\u2502   \u2514\u2500\u2500 mockData/                     # Predefined mock data\n\u2502       \u2514\u2500\u2500 users.js                  # Sample user data\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized routing logic\n\u2502   \u251c\u2500\u2500 AppRoutes.js                  # Application routes\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Auth-guarded route\n\u2502   \u251c\u2500\u2500 Layout.js                     # Layout component for nested routes\n\u2502   \u2514\u2500\u2500 SidebarConfig.js              # Configuration for sidebar navigation\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources\n\u2502   \u251c\u2500\u2500 components/                   # Generic components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Footer.js                 # App footer\n\u2502   \u2502   \u2514\u2500\u2500 Sidebar.js                # Sidebar navigation\n\u2502   \u251c\u2500\u2500 constants/                    # Constants and enums\n\u2502   \u2502   \u2514\u2500\u2500 roles.js                  # User role definitions\n\u2502   \u251c\u2500\u2500 hooks/                        # Shared hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket connection hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js             # Date formatting\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Currency formatting\n\u2502   \u251c\u2500\u2500 HOC/                          # Higher-order components\n\u2502   \u2502   \u2514\u2500\u2500 withErrorBoundary.js      # Error boundary wrapper\n\u2502   \u251c\u2500\u2500 styles/                       # Global styles\n\u2502   \u2502   \u2514\u2500\u2500 variables.less            # Ant Design style overrides\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme setup\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styling\n\u2502   \u251c\u2500\u2500 index.css                     # Base styles\n\u2502   \u251c\u2500\u2500 overrides.css                 # Ant Design overrides\n\u2502   \u2514\u2500\u2500 themes/                       # Additional themes\n\u2502       \u2514\u2500\u2500 dark.css                  # Dark theme styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u251c\u2500\u2500 main.js                           # React and Redux entry point\n\u2514\u2500\u2500 index.html                        # HTML entry point\n</code></pre>"},{"location":"react/folder-structure/feature-based-pattern/#feature-based-application","title":"Feature Based Application","text":"BasicExpanded <pre><code>src/\n\u251c\u2500\u2500 assets/               # Static assets like images, fonts, etc.\n\u2502   \u251c\u2500\u2500 images/           # Image assets\n\u2502   \u2514\u2500\u2500 fonts/            # Font assets\n\u251c\u2500\u2500 components/           # Shared UI components\n\u2502   \u251c\u2500\u2500 Button/           # Button component (reusable)\n\u2502   \u251c\u2500\u2500 Card/             # Card component (reusable)\n\u2502   \u2514\u2500\u2500 Sidebar/          # Sidebar component\n\u251c\u2500\u2500 features/             # Feature-based folder structure\n\u2502   \u251c\u2500\u2500 auth/             # Authentication-related feature\n\u2502   \u2502   \u251c\u2500\u2500 components/   # UI components for auth (Login, Register)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Login.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Register.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/        # Custom hooks related to auth (useAuth)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.ts\n\u2502   \u2502   \u251c\u2500\u2500 services/     # API calls related to authentication\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authService.ts\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.ts  # Redux slice for auth state\n\u2502   \u2502   \u251c\u2500\u2500 types.ts      # Auth-related types (e.g., User type)\n\u2502   \u2502   \u2514\u2500\u2500 Auth.tsx      # Auth page or container\n\u2502   \u251c\u2500\u2500 dashboard/        # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/   # Dashboard-specific components (e.g., widgets, stats)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Widget.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 StatsCard.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/        # Custom hooks for dashboard (useDashboardData)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.ts\n\u2502   \u2502   \u251c\u2500\u2500 services/     # API calls related to dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardService.ts\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.ts  # Redux slice for dashboard state\n\u2502   \u2502   \u251c\u2500\u2500 types.ts      # Dashboard-related types (e.g., WidgetData type)\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.tsx # Main dashboard page\n\u2502   \u251c\u2500\u2500 settings/         # Settings feature\n\u2502   \u2502   \u251c\u2500\u2500 components/   # Components for settings page (e.g., Profile Settings)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ProfileSettings.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 NotificationSettings.tsx\n\u2502   \u2502   \u251c\u2500\u2500 hooks/        # Custom hooks for settings (useSettings)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useSettings.ts\n\u2502   \u2502   \u251c\u2500\u2500 services/     # API calls related to settings\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 settingsService.ts\n\u2502   \u2502   \u251c\u2500\u2500 settingsSlice.ts  # Redux slice for settings state\n\u2502   \u2502   \u251c\u2500\u2500 types.ts      # Settings-related types (e.g., SettingsData type)\n\u2502   \u2502   \u2514\u2500\u2500 Settings.tsx  # Settings page component\n\u2502   \u2514\u2500\u2500 userManagement/   # User management feature\n\u2502       \u251c\u2500\u2500 components/   # UI components for user management (e.g., UserTable)\n\u2502       \u2502   \u251c\u2500\u2500 UserTable.tsx\n\u2502       \u2502   \u2514\u2500\u2500 UserCard.tsx\n\u2502       \u251c\u2500\u2500 hooks/        # Custom hooks for user management (useUsers)\n\u2502       \u2502   \u2514\u2500\u2500 useUsers.ts\n\u2502       \u251c\u2500\u2500 services/     # API calls related to user management\n\u2502       \u2502   \u2514\u2500\u2500 userService.ts\n\u2502       \u251c\u2500\u2500 userSlice.ts  # Redux slice for user management state\n\u2502       \u251c\u2500\u2500 types.ts      # User-related types (e.g., User type)\n\u2502       \u2514\u2500\u2500 UserManagement.tsx # User management page component\n\u251c\u2500\u2500 hooks/                # Global custom hooks (non-feature specific)\n\u2502   \u251c\u2500\u2500 useAuth.ts        # Hook to manage authentication (could be global)\n\u2502   \u251c\u2500\u2500 useTheme.ts       # Hook for theme management (e.g., light/dark mode)\n\u2502   \u2514\u2500\u2500 useFetch.ts       # Generic data fetching hook\n\u251c\u2500\u2500 layouts/              # Layout components (e.g., sidebar, header, footer)\n\u2502   \u251c\u2500\u2500 MainLayout.tsx    # Main layout for dashboard pages (with sidebar, header)\n\u2502   \u2514\u2500\u2500 AuthLayout.tsx    # Layout for authentication pages (login, register)\n\u251c\u2500\u2500 pages/                # Pages that represent different routes\n\u2502   \u251c\u2500\u2500 Dashboard.tsx     # Dashboard main page\n\u2502   \u251c\u2500\u2500 Login.tsx         # Login page\n\u2502   \u251c\u2500\u2500 Register.tsx      # Register page\n\u2502   \u251c\u2500\u2500 Profile.tsx       # Profile page\n\u2502   \u2514\u2500\u2500 NotFound.tsx      # 404 page (page not found)\n\u251c\u2500\u2500 services/             # Global services, API calls, or utilities\n\u2502   \u251c\u2500\u2500 apiClient.ts      # Axios or other API client setup\n\u2502   \u2514\u2500\u2500 notificationService.ts # Service for notifications\n\u251c\u2500\u2500 store/                # Redux or state management (e.g., context, Redux)\n\u2502   \u251c\u2500\u2500 rootReducer.ts    # Root reducer combining all slices\n\u2502   \u251c\u2500\u2500 store.ts          # Redux store configuration\n\u2502   \u2514\u2500\u2500 middleware.ts     # Custom Redux middleware (e.g., logging, thunk)\n\u251c\u2500\u2500 styles/               # Global styles and theme configuration\n\u2502   \u251c\u2500\u2500 index.scss        # Global SCSS or CSS\n\u2502   \u2514\u2500\u2500 theme.ts          # Theme configuration (light/dark mode)\n\u251c\u2500\u2500 types/                # Global TypeScript types/interfaces\n\u2502   \u251c\u2500\u2500 commonTypes.ts    # Reusable types (e.g., API response types)\n\u2502   \u2514\u2500\u2500 app.d.ts          # Global app types (e.g., AppState)\n\u251c\u2500\u2500 utils/                # Utility functions (helpers, date formatting, etc.)\n\u2502   \u251c\u2500\u2500 formatDate.ts     # Date formatting utility\n\u2502   \u251c\u2500\u2500 validateEmail.ts  # Email validation utility\n\u2502   \u2514\u2500\u2500 generateUUID.ts   # UUID generation utility\n\u251c\u2500\u2500 App.tsx               # Main app component\n\u251c\u2500\u2500 index.tsx             # Entry point for the application\n\u2514\u2500\u2500 routes.tsx            # Route definitions (for React Router)\n</code></pre> <pre><code>src/\n\u251c\u2500\u2500 assets/                    # Static assets\n\u2502   \u251c\u2500\u2500 images/                # Image assets\n\u2502   \u2502   \u2514\u2500\u2500 logo.png\n\u2502   \u2514\u2500\u2500 fonts/                 # Font assets\n\u2502       \u2514\u2500\u2500 roboto.ttf\n\u251c\u2500\u2500 components/                # Reusable UI components\n\u2502   \u251c\u2500\u2500 Button/                # Button component\n\u2502   \u2502   \u2514\u2500\u2500 Button.tsx         # Reusable Button component\n\u2502   \u251c\u2500\u2500 Card/                  # Card component\n\u2502   \u2502   \u2514\u2500\u2500 Card.tsx           # Reusable Card component\n\u2502   \u2514\u2500\u2500 Sidebar/               # Sidebar component\n\u2502       \u2514\u2500\u2500 Sidebar.tsx        # Sidebar component\n\u251c\u2500\u2500 features/                  # Feature-based folder structure\n\u2502   \u251c\u2500\u2500 auth/                  # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/        # Auth-related UI components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Login.tsx      # Login form component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Register.tsx   # Register form component\n\u2502   \u2502   \u251c\u2500\u2500 hooks/             # Custom hooks for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.ts     # useAuth hook\n\u2502   \u2502   \u251c\u2500\u2500 services/          # API services for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authService.ts # Auth API service\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.ts       # Redux slice for auth\n\u2502   \u2502   \u251c\u2500\u2500 types.ts           # Auth-related types\n\u2502   \u2502   \u2514\u2500\u2500 Auth.tsx           # Auth page\n\u2502   \u251c\u2500\u2500 dashboard/             # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/        # Dashboard UI components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Widget.tsx     # Widget component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 StatsCard.tsx  # Stats Card component\n\u2502   \u2502   \u251c\u2500\u2500 hooks/             # Custom hooks for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.ts # Hook for fetching dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 services/          # Dashboard-related API services\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardService.ts # Dashboard API service\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.ts  # Redux slice for dashboard state\n\u2502   \u2502   \u251c\u2500\u2500 types.ts           # Dashboard-related types\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.tsx      # Dashboard page component\n\u2502   \u2514\u2500\u2500 userManagement/        # User Management feature\n\u2502       \u251c\u2500\u2500 components/        # User management UI components\n\u2502       \u2502   \u251c\u2500\u2500 UserTable.tsx  # User table component\n\u2502       \u2502   \u2514\u2500\u2500 UserCard.tsx   # User card component\n\u2502       \u251c\u2500\u2500 hooks/             # Custom hooks for user management\n\u2502       \u2502   \u2514\u2500\u2500 useUsers.ts    # Hook to fetch user data\n\u2502       \u251c\u2500\u2500 services/          # API services for user management\n\u2502       \u2502   \u2514\u2500\u2500 userService.ts # User management API service\n\u2502       \u251c\u2500\u2500 userSlice.ts       # Redux slice for user management state\n\u2502       \u251c\u2500\u2500 types.ts           # User-related types\n\u2502       \u2514\u2500\u2500 UserManagement.tsx # User Management page\n\u251c\u2500\u2500 hooks/                     # Global custom hooks\n\u2502   \u251c\u2500\u2500 useTheme.ts            # Hook for theme management\n\u2502   \u2514\u2500\u2500 useFetch.ts            # Generic data fetching hook\n\u251c\u2500\u2500 layouts/                   # Layout components (Sidebar, Header, etc.)\n\u2502   \u251c\u2500\u2500 MainLayout.tsx         # Layout for dashboard pages\n\u2502   \u2514\u2500\u2500 AuthLayout.tsx         # Layout for authentication pages\n\u251c\u2500\u2500 pages/                     # Pages for different routes\n\u2502   \u251c\u2500\u2500 Dashboard.tsx          # Main dashboard page\n\u2502   \u251c\u2500\u2500 Login.tsx              # Login page\n\u2502   \u251c\u2500\u2500 Register.tsx           # Register page\n\u2502   \u251c\u2500\u2500 Profile.tsx            # Profile page\n\u2502   \u2514\u2500\u2500 NotFound.tsx           # 404 page\n\u251c\u2500\u2500 services/                  # Global services\n\u2502   \u251c\u2500\u2500 apiClient.ts           # Axios API client configuration\n\u2502   \u2514\u2500\u2500 notificationService.ts # Service for notifications\n\u251c\u2500\u2500 store/                     # State management (Redux, Context)\n\u2502   \u251c\u2500\u2500 rootReducer.ts         # Combine reducers\n\u2502   \u251c\u2500\u2500 store.ts               # Store configuration\n\u2502   \u2514\u2500\u2500 middleware.ts          # Custom middleware\n\u251c\u2500\u2500 styles/                    # Global styles\n\u2502   \u251c\u2500\u2500 index.scss             # Global styles\n\u2502   \u2514\u2500\u2500 theme.ts               # Theme configuration (light/dark mode)\n\u251c\u2500\u2500 types/                     # Global TypeScript types\n\u2502   \u251c\u2500\u2500 commonTypes.ts         # Reusable types (e.g., API responses)\n\u2502   \u2514\u2500\u2500 app.d.ts               # Global types (e.g., AppState)\n\u251c\u2500\u2500 utils/                     # Utility functions\n\u2502   \u251c\u2500\u2500 formatDate.ts          # Date formatting utility\n\u2502   \u251c\u2500\u2500 validateEmail.ts       # Email validation utility\n\u2502   \u2514\u2500\u2500 generateUUID.ts        # UUID generation utility\n\u251c\u2500\u2500 App.tsx                    # Main application component\n\u251c\u2500\u2500 index.tsx                  # Entry point for the app\n\u2514\u2500\u2500 routes.tsx                 # Route definitions for React Router\n</code></pre>"},{"location":"react/folder-structure/feature-based-pattern/#related-blogs","title":"Related Blogs","text":"<ul> <li>Application Structure for React</li> </ul>"},{"location":"react/folder-structure/intro/","title":"Intro","text":"<p>React Folder Structure Patterns Explained: From Simple to Scalable Architectures</p> <p>Choosing the right folder structure depends on the size of your project, the complexity of the app, and how you intend to scale it. Here's a recap of which structure works best for which scenario:</p> <ul> <li>Flat Structure: Good for small apps and quick prototypes.</li> <li>Feature-Based Structure: Ideal for medium to large apps, especially for teams working on separate features.</li> <li>Domain-Based Structure: Best for large apps with multiple business domains.</li> <li>Component-Based Structure: Great for smaller apps or component libraries where reuse is key.</li> <li>Container/Presentational: Useful for separating UI from logic, especially in larger apps.</li> <li>Atomic Design: Perfect for design systems or large applications with a need for reusable UI components.</li> </ul> <p>In the end, choose a structure that balances maintainability, scalability, and the ability for your team to work independently</p>"},{"location":"react/folder-structure/react-architecture/","title":"Architecture","text":""},{"location":"react/folder-structure/react-architecture/#overview","title":"Overview","text":"<p>When designing a web application with React, it's crucial to establish a solid architecture that promotes maintainability, scalability, and reusability. Below is an architecture that works well for most medium-to-large-scale React applications. This architecture is modular, separates concerns, and is flexible enough to adapt to changes as your app grows.</p>"},{"location":"react/folder-structure/react-architecture/#1-folder-structure","title":"1. Folder Structure","text":"<p>Here's a common folder structure for a React web application:</p> <pre><code>/src\n  /assets               # Images, fonts, icons, etc.\n  /components           # Reusable UI components (buttons, modals, etc.)\n  /hooks                # Custom hooks\n  /pages                # Components tied to routes (representing a screen)\n  /services             # API calls, data fetching logic\n  /store                # State management (Redux, Zustand, Recoil, etc.)\n  /utils                # Utility functions (helpers, formatters, validators, etc.)\n  /context              # React Context providers\n  /styles               # Global CSS, or styled-components\n  /tests                # Unit and integration tests\n  App.js                # Root component, can include global layout\n  index.js              # Entry point for React (where rendering occurs)\n</code></pre>"},{"location":"react/folder-structure/react-architecture/#2-key-architectural-concepts","title":"2. Key Architectural Concepts","text":"<p>2.1 Component-Based Architecture</p> <p>React encourages a component-based structure. Components are modular, self-contained pieces of UI and logic. In large applications, it's common to break down components into:</p> <ul> <li>Atomic Components: These are small UI building blocks, like buttons, inputs, modals, etc.</li> <li>Container/Presentational Components: Container components handle business logic (state, side effects), while presentational components focus solely on rendering.</li> <li>Page Components: Components tied to routes, representing whole pages or sections of the app.</li> </ul> <p>2.2 State Management</p> <p>State management is key to a React app\u2019s scalability. You have several options:</p> <ul> <li>Local State: Managed using React's <code>useState</code> and <code>useReducer</code>.</li> <li>Context API: Good for passing down state globally (e.g., for authentication state or theme).</li> <li>External State Management (e.g., Redux, Zustand, Recoil): If your app grows complex with a lot of shared state, using a more robust state management solution like Redux or Zustand might be necessary.</li> </ul> <p>Consider the complexity of your app before jumping into a large state management library like Redux. If the app is small to medium-sized, React's built-in <code>useState</code>, <code>useContext</code>, or <code>useReducer</code> might suffice.</p> <p>2.3 Routing</p> <p>For routing, use a library like react-router-dom to handle different pages in the application. The routes are typically defined at a higher level in your app, often in App.js or a dedicated Routes.js file.</p> <p>2.4 Component Libraries and Design Systems</p> <p>To speed up UI development, you can use a component library or build your own design system. Popular libraries include:</p> <ul> <li>Material-UI: A popular React component library.</li> <li>Chakra UI: A flexible, accessible UI library.</li> <li>Ant Design: A robust set of UI components.</li> </ul> <p>You can also design a custom UI kit with styled-components or Tailwind CSS.</p> <p>2.5 API Layer</p> <p>For API calls, abstract the logic in separate services (in <code>/services</code>) to keep components decoupled from data-fetching logic. Use libraries like axios or the native fetch API.</p> <p>A service file could look like this:</p> <pre><code>// services/api.js\nimport axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"https://api.example.com\",\n  timeout: 5000,\n});\n\nexport const fetchData = async () =&gt; {\n  try {\n    const response = await api.get(\"/data\");\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n};\n</code></pre> <p>2.6 Styling</p> <p>There are several approaches to styling React apps:</p> <ul> <li>CSS-in-JS: Use libraries like styled-components or emotion for scoped, dynamic styling.</li> <li>CSS Modules: Localized CSS scoped to a component, which avoids global CSS conflicts.</li> <li>Tailwind CSS: A utility-first CSS framework that speeds up UI development with pre-defined classes.</li> <li>Traditional CSS: If you prefer, you can still stick to regular CSS files (but using scoped styles with CSS Modules is recommended).</li> </ul> <p>Example of a styled-component:</p> <pre><code>import styled from \"styled-components\";\n\nconst Button = styled.button`\n  background-color: ${(props) =&gt; (props.primary ? \"blue\" : \"gray\")};\n  color: white;\n  padding: 10px 20px;\n  border-radius: 5px;\n`;\n\nexport default Button;\n</code></pre> <p>2.7 Testing</p> <p>Testing your React app is essential. There are several tools available for this:</p> <ul> <li>Jest: A test runner that works well with React applications.</li> <li>React Testing Library: Focuses on testing components in a way that mimics user interaction.</li> <li>Cypress: For end-to-end testing.</li> </ul> <p>Write unit tests for components, integration tests for API services, and end-to-end tests for user workflows.</p>"},{"location":"react/folder-structure/react-architecture/#3-folder-breakdown-example","title":"3. Folder Breakdown Example","text":"<p>Let\u2019s look at an example of the folder structure with files inside it:</p> <pre><code>/src\n  /assets\n    /images           # Image assets used throughout the app\n    /icons            # Icons for different UI elements\n  /components\n    Button.js         # Atomic component for button UI\n    Modal.js          # Reusable modal component\n    Navbar.js         # Navigation bar component\n  /hooks\n    useAuth.js        # Custom hook for authentication logic\n    useFetch.js       # Custom hook for fetching data\n  /pages\n    HomePage.js       # Page component for the homepage\n    Dashboard.js      # Page component for the user dashboard\n  /services\n    api.js            # API service for managing HTTP requests\n  /store\n    authSlice.js      # Redux slice for auth state\n    userSlice.js      # Redux slice for user data\n  /styles\n    global.css        # Global CSS file or base styles\n  /tests\n    Button.test.js    # Test for the Button component\n    HomePage.test.js  # Test for the HomePage component\n  App.js              # Main App component, contains routes\n  index.js            # App entry point\n</code></pre>"},{"location":"react/folder-structure/react-architecture/#4-development-best-practices","title":"4. Development Best Practices","text":"<ul> <li>Separation of Concerns: Keep business logic separate from UI. For example, use container components for stateful logic and pass props down to presentational components.</li> <li>Component Reusability: Break down your UI into reusable, atomic components.</li> <li>Error Boundaries: Use error boundaries to catch JavaScript errors in components and display fallback UI.</li> <li>Code Splitting: Use React's built-in support for lazy loading and code-splitting (e.g., <code>React.lazy</code> and <code>Suspense</code>) to load only the necessary parts of your app.</li> <li>Environment Variables: Use <code>.env</code> files to manage environment-specific configurations, such as API keys.</li> </ul>"},{"location":"react/folder-structure/react-architecture/#5-example-code-snippet-appjs","title":"5. Example Code Snippet (App.js)","text":"<p>Here\u2019s how your <code>App.js</code> might look with routing and basic state management:</p> <pre><code>import React, { useState, useEffect } from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { fetchData } from \"./services/api\";\nimport HomePage from \"./pages/HomePage\";\nimport Dashboard from \"./pages/Dashboard\";\nimport Navbar from \"./components/Navbar\";\nimport Loading from \"./components/Loading\";\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    async function loadData() {\n      try {\n        const response = await fetchData();\n        setData(response);\n      } catch (error) {\n        console.error(\"Error loading data:\", error);\n      }\n    }\n    loadData();\n  }, []);\n\n  if (!data) {\n    return &lt;Loading /&gt;;\n  }\n\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/home\" component={HomePage} /&gt;\n        &lt;Route path=\"/dashboard\" component={Dashboard} /&gt;\n        &lt;Route path=\"/\" exact component={HomePage} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"react/folder-structure/react-architecture/#conclusion","title":"Conclusion","text":"<p>The best architecture for your React web app should aim to be modular, maintainable, and scalable. By structuring your app with clear separation of concerns, reusable components, centralized state management, and a clean routing structure, you can ensure your app is easy to develop and scale in the future.</p>"},{"location":"react/folder-structure/react-architecture/#reference","title":"Reference","text":"<ul> <li>A Definitive Guide to React Architecture Patterns</li> <li>React JS Architecture: Implementation &amp; Best Practices in 2024</li> <li>React Architecture Patterns for Your Projects</li> <li>Reactjs Architecture</li> <li>A Comprehensive Guide to React Architecture: Building Scalable Web Applications with CronJ</li> </ul>"},{"location":"react/miscellaneous/books/","title":"Books","text":""},{"location":"react/miscellaneous/books/#api-refresh-logic","title":"API Refresh Logic","text":"store.jsapiMiddleware.js <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport {\n    persistStore,\n    persistReducer,\n    FLUSH,\n    REHYDRATE,\n    PAUSE,\n    PERSIST,\n    PURGE,\n    REGISTER,\n} from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport { authApi } from \"@features/auth/services/authApi\";\nimport { postsApi } from \"@features/dashboard/services/dashboardApi\";\nimport authReducer from \"@features/auth/services/authSlice\";\nimport { combineReducers } from \"@reduxjs/toolkit\";\nimport apiRefreshMiddleware from \"./apiMiddleware\"; // Import the custom API middleware\n\n// Persist config for redux-persist\nconst persistConfig = {\n    key: \"root\",\n    storage,\n    whitelist: [\"auth\"], // Only persist the auth state\n};\n\n// Combine your reducers (if using multiple slices)\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    [authApi.reducerPath]: authApi.reducer,\n    [postsApi.reducerPath]: postsApi.reducer,\n});\n\n// Persisted reducer configuration\nconst persistedAuthReducer = persistReducer(persistConfig, rootReducer);\n\n// Configure the Redux store\nexport const store = configureStore({\n    reducer: persistedAuthReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware({\n            serializableCheck: {\n                ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n            },\n        }).concat(\n        // Add the custom apiRefreshMiddleware along with RTK Query middlewares\n            apiRefreshMiddleware,\n            authApi.middleware,\n            postsApi.middleware\n        ),\n});\n\n// Create the persistor for redux-persist\nexport const persistor = persistStore(store);\n</code></pre> <pre><code>const apiRefreshMiddleware = (store) =&gt; (next) =&gt; async (action) =&gt; {\n    if (action.type === 'API_CALL') {\n        const state = store.getState();\n        const token = state.auth.token;\n        const refreshToken = state.auth.refreshToken;\n\n        try {\n            const response = await fetch(action.payload.url, {\n                method: action.payload.method || 'GET',\n                headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n                },\n                body: JSON.stringify(action.payload.body),\n            });\n\n            if (response.status === 401) {\n                // Handle token refresh\n                const refreshResponse = await fetch('/refresh', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ refreshToken }),\n                });\n\n                if (refreshResponse.ok) {\n                    const { token: newToken } = await refreshResponse.json();\n                    store.dispatch({ type: 'SET_TOKEN', payload: newToken });\n\n                    // Retry the original request with the new token\n                    return next({\n                        ...action,\n                        payload: { ...action.payload, headers: { Authorization: `Bearer ${newToken}` } },\n                    });\n                } else {\n                    store.dispatch({ type: 'CLEAR_TOKEN' });\n                }\n            }\n\n            return response;\n        } catch (error) {\n            console.error('API Error:', error);\n        }\n    }\n\n    return next(action);\n};\n\nexport default apiRefreshMiddleware;\n</code></pre> <pre><code>const customMiddlewares = [\n  apiMiddleware,\n  authApi.middleware,\n  postsApi.middleware,\n  // Add more middlewares here as needed\n];\n\nexport const store = configureStore({\n  reducer: persistedAuthReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }).concat(...customMiddlewares), // Spread the array of middlewares\n});\n</code></pre>"},{"location":"react/miscellaneous/books/#overview","title":"Overview","text":"<p>The best option to inject a JWT token into headers and handle token refresh depends on your project's requirements. Here's a comparison of the options and recommendations for handling token expiration with Axios, fetchBaseQuery, and Redux Toolkit Middleware.</p>"},{"location":"react/miscellaneous/books/#use-environment-variables-for-different-environments","title":"Use Environment Variables for Different Environments","text":"<p>You can also set different base URLs for different environments (e.g., development, staging, production) by using environment variables.</p> <p>In your .env files (e.g., <code>.env</code>, <code>.env.development</code>, <code>.env.production</code>), set the <code>REACT_APP_API_BASE_URL</code> like so:</p> <pre><code>// .env\nVITE_API_BASE_URLL=https://cqnovalid.info.com.np/connect/token\n</code></pre> <p>For different environments, you can have different <code>.env</code> files:</p> <pre><code>// .env.production\nVITE_API_BASE_URL=https://prod-api.example.com/connect/token\n\n// .env.development\nVITE_API_BASE_URL=https://dev-api.example.com/connect/token\n</code></pre> <p>Make sure you restart your development server after changing <code>.env</code> files so that the environment variables are properly loaded.</p>"},{"location":"react/miscellaneous/books/#centralized-config-file","title":"Centralized Config File","text":"<p>Create a separate <code>config.js</code> file to handle different environment URLs and any other configuration, and export them as needed.</p> <pre><code>// config.js\nexport const CONFIG = {\n  BASE_URL: import.meta.env.VITE_API_BASE_URL,\n  LOGIN_URL: import.meta.env.VITE_LOGIN_URL,\n  // Add other URLs or settings here\n};\n</code></pre> <p>You can then import <code>CONFIG</code> throughout your app:</p> <pre><code>import { CONFIG } from \"./config\";\n\nconst loginUrl = CONFIG.LOGIN_URL;\nconst apiUrl = CONFIG.BASE_URL;\n</code></pre>"},{"location":"react/miscellaneous/books/#feature-based-folder-structure","title":"feature-based folder structure","text":"Folder Structure <pre><code>src/\n\u251c\u2500\u2500 shared/                          # Shared resources across the app\n\u2502   \u251c\u2500\u2500 components/                  # Reusable UI components\n\u2502   \u2502   \u251c\u2500\u2500 Button.jsx               # Button component\n\u2502   \u2502   \u251c\u2500\u2500 InputField.jsx           # Input field component\n\u2502   \u2502   \u251c\u2500\u2500 Modal.jsx                # Modal component\n\u2502   \u2502   \u2514\u2500\u2500 Header.jsx               # Header component\n\u2502   \u251c\u2500\u2500 routes/                      # Shared routing logic (e.g., private/public routes)\n\u2502   \u2502   \u251c\u2500\u2500 PrivateRoute.jsx         # Route that requires authentication\n\u2502   \u2502   \u251c\u2500\u2500 PublicRoute.jsx          # Route accessible without authentication\n\u2502   \u2502   \u2514\u2500\u2500 AppRoutes.jsx            # Centralized route management\n\u2502   \u251c\u2500\u2500 utils/                       # Utility functions/helpers\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js            # Utility to format dates\n\u2502   \u2502   \u251c\u2500\u2500 validateEmail.js         # Utility to validate email format\n\u2502   \u2502   \u2514\u2500\u2500 localStorageHelper.js    # Helper for localStorage operations\n\u2502   \u251c\u2500\u2500 store/                       # Global state management (Redux slices, context)\n\u2502   \u2502   \u251c\u2500\u2500 store.js                 # Redux store configuration\n\u2502   \u2502   \u251c\u2500\u2500 rootReducer.js           # Root reducer combining all slices\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js             # Redux slice for authentication state\n\u2502   \u2502   \u2514\u2500\u2500 userSlice.js             # Redux slice for user data\n\u2502   \u2514\u2500\u2500 hooks/                       # Reusable hooks\n\u2502       \u251c\u2500\u2500 useAuth.js               # Custom hook for authentication logic\n\u2502       \u251c\u2500\u2500 useFetch.js              # Custom hook for fetching data\n\u2502       \u2514\u2500\u2500 useLocalStorage.js       # Custom hook for managing localStorage\n\u2502\n\u251c\u2500\u2500 features/                        # Feature-based organization\n\u2502   \u251c\u2500\u2500 auth/                        # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/              # UI components specific to auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.jsx        # Login form component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SignupForm.jsx       # Signup form component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ForgotPassword.jsx   # Forgot password component\n\u2502   \u2502   \u251c\u2500\u2500 api/                     # API logic for authentication\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 authApi.js           # Authentication API slice (authApi)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authService.js       # Auth service for handling login/signup\n\u2502   \u2502   \u251c\u2500\u2500 store/                   # Auth-specific Redux logic\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 authSlice.js         # Auth Redux slice\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authSelectors.js     # Selectors for auth state\n\u2502   \u2502   \u251c\u2500\u2500 routes/                  # Feature-specific routes for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authRoutes.js        # Routes like /login, /signup, /forgot-password\n\u2502   \u2502   \u2514\u2500\u2500 utils/                   # Utility functions specific to auth\n\u2502   \u2502       \u2514\u2500\u2500 validateCredentials.js # Validation utility for auth forms\n\u2502   \u251c\u2500\u2500 dashboard/                   # Dashboard feature (example)\n\u2502   \u2502   \u251c\u2500\u2500 components/              # Dashboard UI components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 DashboardHeader.jsx  # Dashboard header component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Sidebar.jsx          # Sidebar component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardContent.jsx # Dashboard main content\n\u2502   \u2502   \u251c\u2500\u2500 api/                     # Dashboard-related API calls\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js      # API logic for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardService.js  # Service to fetch dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 store/                   # Redux slice for dashboard\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js    # Dashboard Redux slice\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardSelectors.js # Selectors for dashboard state\n\u2502   \u2502   \u2514\u2500\u2500 routes/                  # Routes for dashboard feature\n\u2502   \u2502       \u2514\u2500\u2500 dashboardRoutes.js   # Dashboard routes\n\u2502   \u2514\u2500\u2500 user/                         # User profile feature (example)\n\u2502       \u251c\u2500\u2500 components/               # User-related UI components\n\u2502       \u2502   \u251c\u2500\u2500 UserProfile.jsx       # User profile component\n\u2502       \u2502   \u251c\u2500\u2500 EditProfile.jsx       # Edit profile component\n\u2502       \u2502   \u2514\u2500\u2500 UserSettings.jsx      # User settings component\n\u2502       \u251c\u2500\u2500 api/                      # User-related API logic\n\u2502       \u2502   \u251c\u2500\u2500 userApi.js            # User-related API calls\n\u2502       \u2502   \u2514\u2500\u2500 userService.js        # Service to fetch and update user data\n\u2502       \u251c\u2500\u2500 store/                    # Redux slice for user state\n\u2502       \u2502   \u251c\u2500\u2500 userSlice.js          # User state slice\n\u2502       \u2502   \u2514\u2500\u2500 userSelectors.js      # Selectors for user state\n\u2502       \u2514\u2500\u2500 routes/                   # Routes specific to user profile\n\u2502           \u2514\u2500\u2500 userRoutes.js         # Routes for user profile pages\n\u2502\n\u251c\u2500\u2500 types/                           # TypeScript types (if applicable)\n\u2502   \u251c\u2500\u2500 auth.d.ts                    # Types for auth state or API responses\n\u2502   \u251c\u2500\u2500 user.d.ts                    # Types for user-related data\n\u2502   \u2514\u2500\u2500 api.d.ts                     # Types for API responses\n\u2514\u2500\u2500 App.jsx                           # Root application component\n</code></pre> <p>Example Usage:</p> authApi.jsauthSlice.jsuseAuth.js <p>authApi.js (API slice for auth)</p> <pre><code>// src/features/auth/api/authApi.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nimport { BASE_URL } from '../../../shared/utils/config';\n\nexport const authApi = createApi({\n    reducerPath: 'authApi',\n    baseQuery: fetchBaseQuery({ baseUrl: BASE_URL }),\n    endpoints: (builder) =&gt; ({\n        login: builder.mutation({\n            query: (credentials) =&gt; ({\n                url: '/login',\n                method: 'POST',\n                body: credentials,\n            }),\n        }),\n    }),\n});\n\nexport const { useLoginMutation } = authApi;\n</code></pre> <p>authSlice.js (Redux slice for auth state)</p> <pre><code>// src/features/auth/store/authSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    user: null,\n    isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState,\n    reducers: {\n        setUser: (state, action) =&gt; {\n            state.user = action.payload;\n            state.isAuthenticated = true;\n        },\n        logout: (state) =&gt; {\n            state.user = null;\n            state.isAuthenticated = false;\n        },\n    },\n});\n\nexport const { setUser, logout } = authSlice.actions;\nexport default authSlice.reducer;\n</code></pre> <p>useAuth.js (Custom hook to manage authentication)</p> <pre><code>// src/shared/hooks/useAuth.js\nimport { useSelector, useDispatch } from 'react-redux';\nimport { setUser, logout } from '../../features/auth/store/authSlice';\n\nexport const useAuth = () =&gt; {\n    const dispatch = useDispatch();\n    const user = useSelector((state) =&gt; state.auth.user);\n\n    const login = (userData) =&gt; {\n        dispatch(setUser(userData));\n    };\n\n    const logoutUser = () =&gt; {\n        dispatch(logout());\n    };\n\n    return { user, login, logoutUser };\n};\n</code></pre> <p>Conclusion:</p> <p>This file and folder structure follows a feature-based approach, making it scalable and maintainable. Each feature (e.g., authentication, dashboard, user profile) has its own folder containing related components, services, store, and routes. Shared resources such as UI components, hooks, and utilities are centralized in the shared/ folder for reuse across the app.</p> <p>This organization will help you manage a growing codebase as your application scales.</p> <p></p>"},{"location":"react/miscellaneous/handling-side-effects/","title":"Handling Side Effects","text":"<p>Handling side effects in React is crucial for building robust and maintainable applications. Side effects are operations that affect something outside the scope of the function being executed, such as data fetching, subscriptions, or manually changing the DOM. Here\u2019s a breakdown of techniques and standards to manage side effects effectively in React:</p> Handling Side Effects <p>In React, side effects are operations that interact with the outside world or affect other parts of your application, such as:</p> <ul> <li>API Calls: Fetching data from a server.</li> <li>Subscriptions: Setting up connections to external services.</li> <li>Manual DOM Manipulation: Directly modifying the DOM outside of React\u2019s typical rendering flow.</li> <li>Timers: Using <code>setTimeout</code> or <code>setInterval</code>.</li> </ul> <p>These side effects can\u2019t be managed directly within the pure functions of React components because they need to be handled at specific points in the component lifecycle.</p>"},{"location":"react/miscellaneous/handling-side-effects/#choosing-between-react-hooks-and-redux-middleware","title":"Choosing Between React Hooks and Redux Middleware","text":"<p>In React applications, managing side effects can be done using various approaches, and React hooks and Redux are two prominent tools for handling side effects. Here\u2019s a breakdown of how each approach works and when you might use them:</p> Use React Hooks WhenUse Redux Middleware WhenSummary <ul> <li>You need to manage side effects within individual components.</li> <li>Your side effects are specific to component logic and don\u2019t require global state management.</li> <li>You want a straightforward, declarative approach to handling side effects directly within your components.</li> </ul> <ul> <li>You have a more complex application with global state management needs.</li> <li>Side effects involve multiple components or require coordinating between various parts of your application. You need to manage actions and state updates across different parts of your app in a more centralized manner.</li> </ul> <ul> <li>React Hooks are great for managing side effects within individual components or when creating reusable logic with custom hooks.</li> <li>Redux Middleware (like Thunk or Saga) is useful for managing complex asynchronous flows and side effects that involve global state or require coordination across multiple components.</li> </ul> <p>In practice, you might use both approaches together in a single application: React hooks for local component-level effects and Redux for global state management and complex side effects.</p>"},{"location":"react/miscellaneous/handling-side-effects/#using-redux-middleware-eg-redux-thunk-redux-saga","title":"Using Redux Middleware (e.g., Redux Thunk, Redux Saga)","text":"Redux ThunkRedux Saga <ul> <li>Purpose: Middleware for handling asynchronous actions in Redux, such as data fetching.</li> <li>Usage: Allows you to write action creators that return functions instead of action objects, enabling async logic.</li> </ul> <pre><code>// actions.js\nexport const fetchData = () =&gt; {\n    return dispatch =&gt; {\n        dispatch({ type: 'FETCH_DATA_REQUEST' });\n            fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data }))\n            .catch(error =&gt; dispatch({ type: 'FETCH_DATA_FAILURE', error }));\n    };\n};\n</code></pre> <ul> <li>Purpose: A middleware library for managing side effects in Redux applications using generator functions.</li> <li>Usage: Ideal for complex asynchronous flows, handling multiple actions, and performing more advanced control flow.</li> </ul> <pre><code>import { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchData() {\n    try {\n        const response = yield call(fetch, 'https://api.example.com/data');\n        const data = yield response.json();\n        yield put({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        yield put({ type: 'FETCH_DATA_FAILURE', error });\n    }\n}\n\nfunction* watchFetchData() {\n    yield takeEvery('FETCH_DATA_REQUEST', fetchData);\n}\n\nexport default watchFetchData;\n</code></pre>"},{"location":"react/miscellaneous/namespace-import/","title":"Namespace Import","text":""},{"location":"react/miscellaneous/namespace-import/#overview","title":"Overview","text":"<pre><code>import * as test from \"react\";\nconsole.log(test);\n</code></pre> <p>The line <code>import * as test from \"react\";</code> imports everything from the <code>react</code> package and assigns it to the <code>test</code> object. So, when you log <code>test</code> to the console, it will display an object that contains all of React's exports.</p> <p>The output of <code>console.log(test)</code> would be an object that looks like this (depending on the version of React you're using):</p> <p>So, when you run <code>console.log(test)</code>, the output will be an object with these categories of exports, including <code>functions</code>, <code>hooks</code>, <code>components</code>, and <code>utilities</code>. Here's a basic idea of what it might look like in the console:</p> <pre><code>{\n  Component: [Function: Component],\n  createElement: [Function: createElement],\n  Fragment: [Function: Fragment],\n  PureComponent: [Function: PureComponent],\n  useState: [Function: useState],\n  useEffect: [Function: useEffect],\n  useContext: [Function: useContext],\n  useReducer: [Function: useReducer],\n  useRef: [Function: useRef],\n  useMemo: [Function: useMemo],\n  useCallback: [Function: useCallback],\n  useLayoutEffect: [Function: useLayoutEffect],\n  createContext: [Function: createContext],\n  forwardRef: [Function: forwardRef],\n  memo: [Function: memo],\n  StrictMode: [Function: StrictMode],\n  Children: { /* methods for working with children */ },\n  isValidElement: [Function: isValidElement],\n  cloneElement: [Function: cloneElement],\n  version: 'X.X.X',  // The version of React you're using\n  PropTypes: { /* PropTypes validation methods */ },\n  ... // Other internal or exported methods.\n}\n</code></pre>"},{"location":"react/miscellaneous/namespace-import/#categories-of-react-exports","title":"Categories of React Exports","text":"<ol> <li> <p>React Component Functions:</p> <p>React's component-related functions are often part of the exports. For example:</p> <ul> <li><code>React.Component</code> (the base class for class components)</li> <li><code>React.createElement</code> (to create JSX elements)</li> <li><code>React.Fragment</code> (used to group multiple children without adding extra nodes to the DOM)</li> <li><code>React.PureComponent</code> (a version of Component that implements shouldComponentUpdate with shallow props and state comparison)</li> </ul> </li> <li> <p>Hooks (from React 16.8 onwards):</p> <ul> <li><code>useState</code> (a hook for managing state in functional components)</li> <li><code>useEffect</code> (a hook for side-effects in functional components)</li> <li><code>useContext</code> (a hook for accessing context values)</li> <li><code>useReducer</code> (for complex state logic in functional components)</li> <li><code>useRef</code> (for creating mutable references that persist across renders)</li> <li><code>useMemo</code> (for optimizing expensive calculations)</li> <li><code>useCallback</code> (for memoizing functions)</li> <li><code>useLayoutEffect</code> (similar to <code>useEffect</code>, but it fires synchronously after all DOM mutations)</li> </ul> </li> <li> <p>Context API:</p> <ul> <li><code>React.createContext</code> (to create a context object)</li> <li><code>React.useContext</code> (hook for consuming context)</li> </ul> </li> <li> <p>Higher-Order Components (HOCs):</p> <ul> <li><code>React.forwardRef</code> (to forward refs in functional components)</li> <li><code>React.memo</code> (to memoize a component and prevent unnecessary re-renders)</li> </ul> </li> <li> <p>Error Boundaries and Lifecycle:</p> <ul> <li><code>React.Component</code> (class component with lifecycle methods)</li> <li><code>React.StrictMode</code> (a wrapper component that helps with development issues)</li> </ul> </li> <li> <p>Utilities:</p> <ul> <li><code>React.Children</code> (API for dealing with props.children)</li> <li><code>React.isValidElement</code> (to check if an object is a valid React element)</li> <li><code>React.cloneElement</code> (to clone and modify React elements)</li> </ul> </li> <li> <p>PropTypes (for type checking props in non-TypeScript React applications):</p> <ul> <li><code>React.PropTypes</code> (deprecated but still available for validation of component props)</li> </ul> </li> <li> <p>Version and Miscellaneous:</p> <p>You might see <code>React.version</code> (which holds the version of React being used). Also, potentially some other internal utilities, although most of these aren't meant to be used directly by developers.</p> </li> </ol>"},{"location":"react/miscellaneous/namespace-import/#summary-of-features-you-still-use-in-react-besides-hooks","title":"Summary of Features You Still Use in React Besides Hooks","text":"<ul> <li>Class Components: Sometimes necessary for legacy support or when you need lifecycle methods.</li> <li>JSX: Core syntax for writing components.</li> <li>Context API: For managing shared state across components.</li> <li>Error Boundaries: To catch errors in the component tree.</li> <li>Refs: For directly interacting with the DOM or class component instances.</li> <li>PropTypes: For runtime type-checking in non-TypeScript applications.</li> <li>HOCs (Higher-Order Components): For reusing component logic and behavior.</li> <li>React.memo: For performance optimization, especially for functional components.</li> <li>StrictMode: A development tool to help find potential issues.</li> <li>React Router: For managing routing and navigation in React applications.</li> </ul> <p>Long-Term Memory Tips:</p> <ul> <li>Group related concepts: Try to remember concepts based on their purpose. For example, lifecycle and state management together under class components or performance optimization under React.memo.</li> <li>Use real-world analogies: For instance, consider HOCs as \u201cenhancers\u201d that give additional power to components, much like how a superhero can get enhanced abilities.</li> <li>Practice regularly: As you build React apps, you'll naturally encounter and use these features.</li> <li>Focus on common patterns: React\u2019s ecosystem encourages reusable patterns like higher-order components, memoization, and context for managing state, so you\u2019ll encounter these regularly.</li> </ul> <p>By recognizing when to use these features and their specific purposes, you\u2019ll have a more complete understanding of React that will help you in both current and future projects.</p>"},{"location":"react/miscellaneous/namespace-import/#additional","title":"Additional","text":"<p>Core React Functions</p> <p>Yes, Core React Functions (like <code>React.createElement</code>, <code>React.Component</code>, <code>React.PureComponent</code>, <code>React.Fragment</code>, etc.) can still be relevant to functional components, although their usage has evolved in the context of modern React development.</p> <p>Here's how each core function relates to functional components:</p> <p>1. React.createElement</p> <ul> <li> <p>Relevance: While you rarely call <code>React.createElement</code> directly in your code (because JSX compiles to it), it\u2019s still important to understand that this function is used internally to create elements.</p> </li> <li> <p>In Functional Components: JSX in functional components is ultimately compiled to calls to <code>React.createElement</code>.</p> </li> </ul> <pre><code>const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;;\n// Internally, JSX compiles to:\nconst element = React.createElement(\"h1\", null, \"Hello, World!\");\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Directly using <code>React.createElement</code> is rare unless you are working with more complex dynamic JSX generation. But it\u2019s useful to understand how React transforms your JSX code into React elements.</li> </ul> <p>2. React.Fragment</p> <ul> <li> <p>Relevance: <code>React.Fragment</code> is commonly used in functional components when you need to return multiple elements from a component without adding an extra node to the DOM.</p> </li> <li> <p>In Functional Components: It's extremely useful for wrapping multiple elements that you want to return without introducing an unnecessary wrapper (like a <code>&lt;div&gt;</code>).</p> </li> </ul> <pre><code>const MyComponent = () =&gt; (\n  &lt;React.Fragment&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;This is a fragment example&lt;/p&gt;\n  &lt;/React.Fragment&gt;\n);\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Wrapping multiple elements in a component without introducing an extra DOM node. You can also use the shorthand <code>&lt;&gt;...</code> for fragments.</li> </ul> <pre><code>const MyComponent = () =&gt; (\n  &lt;&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;This is a fragment example&lt;/p&gt;\n  &lt;/&gt;\n);\n</code></pre> <p>3. React.Component &amp; React.PureComponent</p> <ul> <li>Relevance: These are primarily used for class-based components, but functional components can achieve similar behavior through hooks and the <code>React.memo</code> higher-order component.</li> <li>In Functional Components: While functional components don\u2019t use React.Component directly, <code>React.memo</code> provides a performance optimization for functional components similar to <code>React.PureComponent</code>.</li> </ul> Example <pre><code>const MyComponent = React.memo((props) =&gt; {\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n});\n</code></pre> <p>Use case in functional components:</p> <ul> <li>You can use <code>React.memo</code> to avoid unnecessary re-renders in functional components, which mimics the behavior of <code>React.PureComponent</code> (which compares props shallowly to avoid re-renders).</li> </ul> <p>4. <code>React.createRef()</code> and <code>useRef</code></p> <ul> <li>Relevance: <code>React.createRef()</code> is used with class components to get references to DOM elements or class instances, but for functional components, you generally use the <code>useRef</code> hook.</li> <li>In Functional Components: You use <code>useRef</code> to persist a reference across renders without triggering re-renders.</li> </ul> <pre><code>import { useRef } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const inputRef = useRef();\n\n  const focusInput = () =&gt; {\n    inputRef.current.focus();\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} /&gt;\n      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Use case in functional components:</p> <ul> <li><code>useRef</code> is a direct replacement for <code>createRef</code> in class components and allows you to keep a reference to DOM elements or mutable values in a way that doesn\u2019t cause re-renders.</li> </ul> <p>5. React.StrictMode</p> <ul> <li>Relevance: <code>React.StrictMode</code> is a wrapper component that helps with identifying potential problems in your React codebase. It is typically used in development to highlight issues but does not affect production builds.</li> <li>In Functional Components: <code>React.StrictMode</code> is used in the same way for functional components. It\u2019s a development-only feature to catch unsafe lifecycle methods and other potential issues.</li> </ul> <pre><code>import React from \"react\";\n\nconst App = () =&gt; (\n  &lt;React.StrictMode&gt;\n    &lt;MyComponent /&gt;\n  &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>Use case in functional components:</p> <ul> <li><code>React.StrictMode</code> helps ensure that your functional components adhere to best practices and provides warnings for potential issues in development.</li> </ul> <p>6. React.isValidElement</p> <ul> <li>Relevance: <code>React.isValidElement</code> is used to check whether an object is a valid React element. This can still be useful for functional components, especially when you're dealing with dynamic content and want to check if something is a valid React element before rendering it.</li> <li>In Functional Components: If you're building a library or working with dynamic data, you may need to validate whether something is a valid React element.</li> </ul> <pre><code>const MyComponent = ({ children }) =&gt; {\n  if (React.isValidElement(children)) {\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n  return &lt;div&gt;Invalid child element&lt;/div&gt;;\n};\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Useful when building dynamic UI elements or libraries that involve checking if something is a React element before rendering it.</li> </ul> Summary of Core React Functions in Functional Components <ul> <li><code>React.createElement</code>: Compiled from JSX. Typically not used directly, but important to understand how React elements are created.</li> <li><code>React.Fragment</code>: Commonly used to group multiple elements without adding extra nodes to the DOM.</li> <li><code>React.Component</code> &amp; <code>React.PureComponent</code>: Not used directly in functional components, but similar behavior can be achieved with hooks (e.g., <code>React.memo</code> for optimization).</li> <li><code>useRef</code> (or <code>React.createRef</code>): Used to reference DOM elements or persist values across renders without triggering re-renders.</li> <li><code>React.StrictMode</code>: Used for development to catch potential issues.</li> <li><code>React.isValidElement</code>: Can be used to check if a value is a valid React element, useful for dynamic rendering.</li> <li><code>React.memo</code>: Used to memoize functional components and prevent unnecessary re-renders, similar to React.PureComponent for class components.</li> </ul> Conclusion <ul> <li>Core React functions like <code>createElement</code>, <code>Fragment</code>, and <code>React.memo</code> are still used in functional components, though in modern React, they are often abstracted away in the form of JSX or hooks. Understanding these functions helps deepen your understanding of how React works under the hood, but in most day-to-day coding with functional components, you will use JSX, <code>useRef</code>, <code>React.memo</code>, and <code>React.Fragment</code> the most.</li> </ul>"},{"location":"react/miscellaneous/react-depth/","title":"React Depth","text":"<p>React is a powerful JavaScript library used to build user interfaces, but beyond its fundamental concepts, there are deeper aspects and lesser-known features that can help developers better understand and utilize its full potential. These \"deep secrets\" can improve performance, maintainability, and the flexibility of your applications. Let's explore some of these:</p>"},{"location":"react/miscellaneous/react-depth/#overview","title":"Overview","text":""},{"location":"react/miscellaneous/react-depth/#1-react-fiber-architecture","title":"1. React Fiber Architecture","text":"<ul> <li>What it is: The React Fiber architecture is a complete rewrite of React's core algorithm for rendering. It allows React to break down rendering work into smaller chunks, which helps improve performance, especially for complex UI updates.</li> <li>Why it\u2019s a secret: Fiber enables features like asynchronous rendering, which helps React avoid blocking the UI thread and gives it the ability to prioritize work. This is particularly important for React\u2019s performance optimizations, such as Concurrent Mode and Suspense.</li> <li>How to use it: Fiber is used automatically when React is in Concurrent Mode, but to fully exploit this, you need to leverage the right patterns (like Suspense for data fetching or lazy loading).</li> </ul>"},{"location":"react/miscellaneous/react-depth/#2-reacts-reconciliation-process","title":"2. React\u2019s Reconciliation Process","text":"<ul> <li>What it is: The reconciliation process is how React compares the new virtual DOM with the previous one and decides how to update the real DOM efficiently.</li> <li>Why it\u2019s a secret: React\u2019s algorithm tries to minimize changes to the DOM by applying heuristics (e.g., comparing the type of elements or the keys of lists), but understanding how reconciliation works can help you optimize rendering and reduce unnecessary updates.</li> <li>How to use it: Use keys when rendering lists to help React identify which items have changed. Also, avoid using the <code>index</code> as a key in dynamic lists, as it can break the reconciliation process.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#3-hooks-internals","title":"3. Hooks Internals","text":"<ul> <li>What it is: React\u2019s hooks API provides a way to manage state, side effects, context, and other features in functional components, but their internal implementation can reveal interesting insights.</li> <li>Why it\u2019s a secret: Under the hood, hooks like <code>useState</code> and <code>useEffect</code> rely on a linked list of \"work in progress\" for each component instance, allowing React to track and manage the state across multiple renders.</li> <li>How to use it: Understanding this helps you avoid anti-patterns such as improper hook dependencies or unnecessary re-renders. <code>useCallback</code>, <code>useMemo</code>, and <code>React.memo</code> are crucial tools for preventing unnecessary re-renders.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#4-react-suspense-and-concurrent-mode","title":"4. React Suspense and Concurrent Mode","text":"<p>What it is: React Suspense is a way to handle asynchronous data fetching, allowing you to defer rendering parts of the UI until data is ready. When combined with Concurrent Mode, it can make rendering more responsive and less jarring for users. Why it\u2019s a secret: Although still considered experimental in some cases, when used correctly, Concurrent Mode allows React to work on multiple tasks at once, prioritizing urgent updates (such as user input) while rendering other components in the background. How to use it: Suspense allows you to wrap async components and show loading states while waiting for the data to be fetched. To use it effectively, you need to ensure your app is ready for async rendering, which may involve careful data-fetching strategies.</p>"},{"location":"react/miscellaneous/react-depth/#5-custom-hooks-for-reusable-logic","title":"5. Custom Hooks for Reusable Logic","text":"<ul> <li>What it is: Custom hooks are a way to reuse stateful logic across components without modifying the component hierarchy.</li> <li>Why it\u2019s a secret: Many developers use built-in hooks, but few tap into the power of custom hooks. Custom hooks can encapsulate complex logic such as form handling, fetching data, or managing component lifecycle effects in a modular and reusable way.</li> <li>How to use it: A custom hook is just a JavaScript function that starts with <code>use</code>, and you can include any logic or hook calls that you want to share between components. This is particularly useful for separating concerns and promoting code reuse.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#6-context-api-for-global-state","title":"6. Context API for Global State","text":"<ul> <li>What it is: React\u2019s Context API provides a way to pass data through the component tree without having to manually prop-drill.</li> <li>Why it\u2019s a secret: While many use Context for theming or localization, its real potential shines when used for global state management (like user authentication or settings). However, if used improperly, it can lead to performance issues, as all components that consume context will re-render whenever the context value changes.</li> <li>How to use it: Use <code>React.memo</code> and <code>useMemo</code> in combination with context to prevent unnecessary re-renders. For large-scale apps, you might want to pair the Context API with a state management library like Redux or Recoil.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#7-reacts-useeffect-dependency-array","title":"7. React\u2019s useEffect Dependency Array","text":"<ul> <li>What it is: The useEffect hook runs after every render, and the second argument (dependency array) determines when the effect should run.</li> <li>Why it\u2019s a secret: Developers often get confused with the dependency array. Omitting dependencies or setting them incorrectly can lead to bugs (e.g., stale closures or unnecessary re-renders).</li> <li>How to use it: Always ensure the dependencies are correctly set, and when necessary, use the useCallback or useMemo hooks to ensure that stable references are passed to useEffect to avoid unnecessary side effects.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#8-error-boundaries","title":"8. Error Boundaries","text":"<ul> <li>What it is: Error boundaries are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the app.</li> <li>Why it\u2019s a secret: While error boundaries are widely used for catching UI errors, they are often overlooked when building robust error-handling systems. Additionally, they only catch errors in the render phase, not during event handlers or async functions.</li> <li>How to use it: Use error boundaries around critical UI sections to avoid app crashes. Make sure to integrate them with logging systems to capture detailed error information.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#9-reactmemo-for-performance-optimization","title":"9. React.memo for Performance Optimization","text":"<ul> <li>What it is: <code>React.memo</code> is a higher-order component that helps optimize the performance of functional components by preventing unnecessary re-renders when props have not changed.</li> <li>Why it\u2019s a secret: While <code>React.memo</code> can drastically reduce render times, it\u2019s often underused. Developers sometimes don't apply it correctly or use it where it's not needed.</li> <li>How to use it: Wrap stateless components in <code>React.memo</code> if they only render based on props that are unlikely to change often. It\u2019s important to remember that <code>React.memo</code> only shallowly compares props, so if deep objects or arrays are passed, you may still need to use <code>useMemo</code> or <code>useCallback</code> to optimize performance.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#10-react-server-side-rendering-ssr-and-static-site-generation-ssg","title":"10. React Server-Side Rendering (SSR) and Static Site Generation (SSG)","text":"<ul> <li>What it is: Server-Side Rendering (SSR) and Static Site Generation (SSG) are techniques for rendering React applications on the server before sending them to the client.</li> <li>Why it\u2019s a secret: SSR and SSG improve performance and SEO by sending fully rendered HTML to the client instead of JavaScript, but implementing them correctly requires some understanding of React's hydration process and how data fetching works.</li> <li>How to use it: React can be set up with frameworks like Next.js, which simplifies SSR and SSG. Use SSR when you need to render dynamic content based on user interaction or data, and SSG for static content that doesn\u2019t change often.</li> </ul>"},{"location":"react/miscellaneous/react-depth/#conclusion","title":"Conclusion:","text":"<p>While React is widely known for its core concepts like components, JSX, and hooks, diving deeper into the architecture and advanced features such as Suspense, Concurrent Mode, and React\u2019s reconciliation process can unlock significant performance improvements and new capabilities. By leveraging these deep features thoughtfully, you can build more optimized, scalable, and responsive applications.</p>"},{"location":"react/optimization/code-splitting/","title":"Code Splitting","text":"<pre><code>import React, { Suspense } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst Login = React.lazy(() =&gt; import(\"../features/auth/components/Login\"));\nconst Dashboard = React.lazy(() =&gt;\n  import(\"../features/dashboard/components/Dashboard\")\n);\n\nconst AppRoutes = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Suspense&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"react/optimization/code-splitting/#techniques-and-patterns","title":"Techniques and patterns","text":"<p>Below are some advanced code splitting techniques and patterns that you can use in large applications.</p>"},{"location":"react/optimization/code-splitting/#1-split-by-routes-route-based-code-splitting","title":"1. Split by Routes (Route-based Code Splitting)","text":"<p>The most common and effective form of code splitting in React is <code>route-based splitting</code>. Each route is dynamically loaded, meaning that only the JavaScript required for the current route is loaded.</p> <p>This pattern reduces the initial loading time because the user only downloads the JavaScript they need for the page they are visiting.</p> <pre><code>import React, { Suspense } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\n// Lazily load components\nconst Login = React.lazy(() =&gt; import(\"../features/auth/components/Login\"));\nconst Dashboard = React.lazy(() =&gt;\n  import(\"../features/dashboard/components/Dashboard\")\n);\nconst Profile = React.lazy(() =&gt;\n  import(\"../features/profile/components/Profile\")\n);\nconst Settings = React.lazy(() =&gt;\n  import(\"../features/settings/components/Settings\")\n);\n\nconst AppRoutes = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n          &lt;Route path=\"/profile\" element={&lt;Profile /&gt;} /&gt;\n          &lt;Route path=\"/settings\" element={&lt;Settings /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Suspense&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"react/optimization/code-splitting/#2-split-by-component-component-level-code-splitting","title":"2. Split by Component (Component-level Code Splitting)","text":"<p>If you have a large component that isn't needed immediately on the first render but may be required later, you can split those components into separate bundles. You can use <code>React.lazy</code> for this.</p> <p>For example, let's say you have a large admin panel or a settings page that isn't needed on the first load.</p> <pre><code>const AdminPanel = React.lazy(() =&gt; import(\"../features/admin/AdminPanel\"));\nconst SettingsPage = React.lazy(() =&gt;\n  import(\"../features/settings/SettingsPage\")\n);\n</code></pre> <p>You can conditionally load these components on demand based on user interaction:</p> <pre><code>const SettingsButton = () =&gt; {\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n\n  const openSettings = () =&gt; {\n    setIsSettingsOpen(true);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={openSettings}&gt;Open Settings&lt;/button&gt;\n      {isSettingsOpen &amp;&amp; (\n        &lt;Suspense fallback={&lt;div&gt;Loading Settings...&lt;/div&gt;}&gt;\n          &lt;SettingsPage /&gt;\n        &lt;/Suspense&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>This ensures that the <code>SettingsPage</code> component is only loaded when the user clicks the button, thus improving the performance.</p>"},{"location":"react/optimization/code-splitting/#3-lazy-loading-non-ui-code-utility-functions-services-and-api-calls","title":"3. Lazy Loading Non-UI Code (Utility Functions, Services, and API Calls)","text":"<p>Sometimes, your application might have large utility libraries, API calls, or configuration files that aren\u2019t immediately needed when the page loads. By using <code>dynamic imports</code> for these non-UI assets, you can defer loading until they're actually needed.</p> <pre><code>const fetchData = React.lazy(() =&gt; import(\"../services/fetchData\"));\nconst userService = React.lazy(() =&gt; import(\"../services/userService\"));\n</code></pre> <p>Then, you can load and use these services inside your components:</p> <pre><code>import React, { Suspense, useState, useEffect } from \"react\";\n\nconst App = () =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    // Lazy load the fetchData service\n    const loadData = async () =&gt; {\n      const { fetchData } = await import(\"../services/fetchData\");\n      const result = await fetchData();\n      setData(result);\n    };\n\n    loadData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Data: {data ? JSON.stringify(data) : \"Loading...\"}&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This ensures that your data-fetching logic and services are loaded only when needed, reducing the bundle size.</p>"},{"location":"react/optimization/code-splitting/#4-lazy-loading-large-third-party-libraries","title":"4. Lazy Loading Large Third-Party Libraries","text":"<p>Some third-party libraries can be quite large and are not always needed immediately. Using <code>dynamic imports</code> for these libraries will ensure that they are only loaded when required.</p> <p>For instance, let's say you are using a large charting library like <code>Chart.js</code> or <code>D3.js</code> that\u2019s only required for a particular section of the app (e.g., a dashboard):</p> <pre><code>const ChartJS = React.lazy(() =&gt; import(\"chart.js\"));\n\nconst Dashboard = () =&gt; (\n  &lt;Suspense fallback={&lt;div&gt;Loading Chart...&lt;/div&gt;}&gt;\n    &lt;ChartJS /&gt;\n  &lt;/Suspense&gt;\n);\n</code></pre> <p>This ensures that <code>Chart.js</code> is only loaded when the user navigates to the dashboard or a page that requires the chart.</p>"},{"location":"react/optimization/code-splitting/#5-split-css-files-css-code-splitting","title":"5. Split CSS Files (CSS Code Splitting)","text":"<p>You can dynamically load styles along with components using libraries like <code>styled-components</code>, <code>@emotion/css</code>, or using Webpack's splitChunks feature to split CSS for components that are lazily loaded.</p> <p>For example, with <code>styled-components</code>, you could dynamically load a component and apply its styles:</p> <pre><code>import styled from \"styled-components\";\n\nconst Button = styled.button`\n  background-color: blue;\n  color: white;\n`;\n\nconst LazyLoadedComponent = React.lazy(() =&gt; import(\"./LazyComponent\"));\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Button&gt;Click Me&lt;/Button&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading Component...&lt;/div&gt;}&gt;\n        &lt;LazyLoadedComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Alternatively, with Webpack's <code>splitChunks</code> option, you can configure CSS and JavaScript to be split into separate chunks based on routes or other criteria.</p>"},{"location":"react/optimization/code-splitting/#6-lazy-load-images-and-assets","title":"6. Lazy Load Images and Assets","text":"<p>For media-heavy applications, images and assets can significantly increase the page load time. You can <code>lazy-load images</code> to ensure they are only loaded when they appear in the viewport.</p> <p>You can use a package like react-lazyload to implement this:</p> <pre><code>import LazyLoad from \"react-lazyload\";\n\nconst MyComponent = () =&gt; (\n  &lt;div&gt;\n    &lt;LazyLoad height={200} offset={100}&gt;\n      &lt;img src=\"large-image.jpg\" alt=\"Lazy loaded\" /&gt;\n    &lt;/LazyLoad&gt;\n  &lt;/div&gt;\n);\n</code></pre> Summary of Code Splitting Techniques: <ul> <li>Route-based Code Splitting: Split code by routes to load JavaScript for each page only when the user visits that page.</li> <li>Component-level Code Splitting: Lazy-load heavy components only when needed.</li> <li>Lazy-load Non-UI Code: Defer loading of utility functions, services, or data files.</li> <li>Lazy-load Third-Party Libraries: Dynamically load large libraries that are not needed immediately.</li> <li>CSS Code Splitting: Split CSS files for components that are loaded lazily.</li> <li>Preloading and Prefetching: Preload or prefetch resources for anticipated user interactions.</li> <li>Split by Dependencies: Use shared libraries across pages to reduce duplication and leverage caching.</li> <li>Lazy-load Images/Assets: Load images and media only when they enter the viewport to improve page load time.</li> </ul> <p>By combining these strategies, you can significantly reduce the initial load time and improve the performance of large React applications.</p> Code Splitting <pre><code>Show me differenet patterns and ways to use code-splitting in react large applications.\n</code></pre> <p>Questions to ask yourself when applying code-splitting:</p> <ul> <li>When should I split my code? Code-splitting should be used for large, non-essential parts of your app that aren't needed on initial load.</li> <li>How can I test the performance improvement? Use tools like Webpack Bundle Analyzer to see if your bundle size has been reduced.</li> <li>Should I preload or <code>prefetch</code> some parts? Use preload for critical resources needed soon and <code>prefetch</code> for resources that might be needed in the future.</li> </ul> <ul> <li>React Suspense explained: How to use it for lazy loading and data fetching</li> <li>Code splitting with React.lazy and Suspense </li> <li>How to Use React Suspense to Improve your React Projects</li> <li>Code-Splitting: legacy.reactjs.org</li> <li>A Guide on React Lazy Loading: refine.dev</li> </ul>"},{"location":"react/optimization/error-boundaries/","title":"Error Boundaries","text":""},{"location":"react/optimization/error-boundaries/#overview","title":"Overview","text":"<p>Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI. They help prevent the entire app from crashing when an error occurs in a part of the UI.</p> <p></p> Note <ul> <li> <p>When to use it? Use error boundaries around components that may throw errors, especially in production apps, to improve the user experience and prevent a full app crash.</p> </li> <li> <p>Why use it? They allow you to handle runtime errors gracefully and keep your app functional even when some parts break.</p> </li> <li> <p>When not to use it? You don\u2019t need an error boundary in every component, only around parts of your app where errors are more likely or critical.</p> </li> <li> <p>Example: In functional components, you can't use class-based error boundaries directly, but you can use <code>React.ErrorBoundary</code> from libraries like react-error-boundary.</p> </li> </ul>"},{"location":"react/optimization/error-boundaries/#react-version-that-introduced-error-boundaries","title":"React Version that Introduced Error Boundaries","text":"<p>Error boundaries were introduced in React 16 (released in September 2017). They provide a way to catch JavaScript errors anywhere in a component tree and log those errors, preventing them from crashing the entire app.</p> <p>Key Changes in React 16:</p> <ul> <li><code>getDerivedStateFromError()</code>: A static method that allows you to update the state when an error occurs.</li> <li><code>componentDidCatch()</code>: A lifecycle method that is called when an error is thrown in a descendant component.</li> </ul> Summary <ul> <li>Error boundaries were introduced in React 16 (2017) and are primarily used in class components.</li> <li>In functional components, React doesn't directly support error boundaries, but you can use libraries like react-error-boundary for a hook-based approach.</li> <li>If you're using React 16.6 or later, you can safely use error boundaries to catch errors in components and display fallback UI to improve the user experience.</li> </ul>"},{"location":"react/optimization/error-boundaries/#advanced","title":"Advanced","text":"<p>In a React functional component, error boundaries were traditionally implemented using class components. However, with the introduction of hooks, you can use libraries like react-error-boundary to implement error boundaries in a more idiomatic way for functional components.</p>"},{"location":"react/optimization/error-boundaries/#basic-example-using-react-error-boundary","title":"Basic Example Using react-error-boundary","text":"<p>To handle errors in a functional component, you can use the ErrorBoundary component from the react-error-boundary package. First, you'll need to install it:</p> <pre><code>npm install react-error-boundary\n</code></pre> 1. ErrorBoundary Setup2. When to Use 3. Where to Place 4. When NOT to Use  <p>Here's a simple example of how to create an error boundary around a component in a functional component setup.</p> <pre><code>import React, { useState } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\n\n// This will be the component that might throw an error\nconst BuggyComponent = () =&gt; {\n    const [counter, setCounter] = useState(0);\n\n    if (counter === 3) {\n        // Simulate an error\n        throw new Error('Oops! Something went wrong');\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Buggy Component&lt;/h2&gt;\n            &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Increment&lt;/button&gt;\n            &lt;p&gt;Counter: {counter}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\n// This is a fallback UI to show in case of an error\nconst FallbackComponent = ({ error, resetErrorBoundary }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Something went wrong: {error.message}&lt;/h2&gt;\n            &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// Main App Component with ErrorBoundary around BuggyComponent\nconst App = () =&gt; {\n    return (\n        &lt;ErrorBoundary FallbackComponent={FallbackComponent}&gt;\n            &lt;BuggyComponent /&gt;\n        &lt;/ErrorBoundary&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>Key Concepts</p> <ul> <li> <p><code>ErrorBoundary</code> Component: This component will catch any errors that happen in its child components (like <code>BuggyComponent</code>) and display a fallback UI (<code>FallbackComponent</code>) instead of the default error screen.</p> </li> <li> <p><code>FallbackComponent</code>: This is a custom fallback UI that will be shown when an error is caught. It has access to the error object and a <code>resetErrorBoundary</code> function that can be used to retry or reset the error state.</p> </li> <li> <p><code>BuggyComponent</code>: A sample component that simulates an error when the counter reaches 3.</p> </li> </ul> <p>When to Use Error Boundaries in a Large Codebase</p> <p>In a large codebase, you would want to use error boundaries strategically rather than wrapping every single component in one. Here\u2019s when and how to use them effectively:</p> <ul> <li> <p>Around Critical Sections: If you have areas in your app that are particularly prone to errors (e.g., third-party integrations, dynamic data fetching, complex UI rendering), wrap those sections in error boundaries to prevent them from breaking the entire app.</p> </li> <li> <p>Higher-Level Component Wrapping: Rather than placing an error boundary around every component, it's more common to wrap major sections or \"features\" of the app. For example:</p> <ul> <li>Top-level error boundaries: You could place an error boundary around the entire app or major sections (e.g., routing, page components, etc.).</li> <li>Nested error boundaries: You can have smaller, more focused error boundaries around specific parts of the UI, like a widget or a specific feature page (e.g., a user profile page or a dashboard).</li> </ul> </li> <li> <p>Fallback UI: Make sure to provide user-friendly fallback UIs. This is where you can show a message like \"Something went wrong\" or a \"Retry\" button that gives the user an option to attempt the operation again. This makes the app feel more resilient.</p> </li> </ul> <p>Where to Place Error Boundaries in a Large Codebase</p> <ul> <li> <p>At the Route Level: If you're using React Router, you can wrap each route in an error boundary. This helps isolate errors that occur in different parts of the app, like in the ProfilePage or DashboardPage, without crashing the whole app.</p> <pre><code>&lt;ErrorBoundary FallbackComponent={FallbackComponent}&gt;\n    &lt;Route path=\"/profile\" component={ProfilePage} /&gt;\n&lt;/ErrorBoundary&gt;\n</code></pre> </li> <li> <p>At the Feature Level: If you have specific components or feature areas that are more complex or prone to errors (e.g., components with lots of state or interaction), wrap them individually.</p> </li> <li> <p>Around Data Fetching Logic: Components that fetch data (e.g., using useEffect) may throw errors in case of network failures or unexpected responses. Wrapping those components in an error boundary can help manage those errors gracefully.</p> </li> </ul> <p>When NOT to Use Error Boundaries</p> <p>While error boundaries are great, there are scenarios where they may not be needed:</p> <ul> <li> <p>Inside Event Handlers: You don\u2019t need an error boundary around event handlers (e.g., button clicks, form submissions). Errors inside event handlers don't propagate to the component tree; they are caught by React's built-in error handling.</p> </li> <li> <p>For Expected Errors: If you know a component might fail, it might be better to handle those errors directly with <code>try-catch</code> or conditional rendering rather than relying on an error boundary. For example, if you are fetching data and know that a network request might fail, you can use state and <code>try-catch</code> logic to handle it locally.</p> </li> <li> <p>For Every Component: You don't need to add error boundaries around every component in your app. It's better to apply them where they make the most sense (e.g., critical UI, third-party integrations).</p> </li> </ul>"},{"location":"react/optimization/error-boundaries/#conclusion","title":"Conclusion","text":"<p>In a large React app, you should use error boundaries to catch and handle errors gracefully, but not everywhere. Focus on wrapping parts of your app where errors are likely or critical. Keep your app responsive and user-friendly by providing fallback UI, and consider using libraries like react-error-boundary to make it easier to work with error boundaries in functional components.</p> <p>If you want more control over specific error handling, you can use the <code>componentDidCatch</code> and <code>getDerivedStateFromError</code> methods in class-based error boundaries, or you can combine error boundaries with your custom error-handling logic.</p>"},{"location":"react/optimization/error-boundaries/#reference","title":"Reference","text":"<ul> <li>Error Boundaries in React - Handling Errors Gracefully</li> <li>Error Handling in React With Error Boundary</li> <li>Mastering Advanced Error Handling in Functional React Components</li> </ul> <p>Video</p> <p> </p> <p> </p>"},{"location":"react/optimization/intro/","title":"Intro","text":"<p>Optimizing performance in functional components in React involves a variety of techniques to prevent unnecessary re-renders and ensure efficient rendering. Here\u2019s a detailed look at some key strategies:</p>"},{"location":"react/optimization/intro/#1-memoization","title":"1. Memoization:","text":"<ul> <li> <p><code>React.memo()</code>: Wrap functional components with React.memo() to prevent unnecessary re-renders if the props haven't changed.</p> <pre><code>const MyComponent = React.memo((props) =&gt; {\n    // component code\n});\n</code></pre> </li> <li> <p><code>React.memo()</code> performs a shallow comparison of props by default. For custom comparison logic, pass a second argument, areEqual:</p> <pre><code>const MyComponent = React.memo((props) =&gt; {\n    // component code\n    }, (prevProps, nextProps) =&gt; {\n    // custom comparison logic\n    return prevProps.someValue === nextProps.someValue;\n});\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#2-callback-memoization","title":"2. Callback Memoization:","text":"<ul> <li> <p><code>useCallback()</code>: Use <code>useCallback()</code> to memoize callback functions, preventing them from being recreated on every render unless dependencies change.</p> <pre><code>const handleClick = useCallback(() =&gt; {\n    // handle click\n}, [dependencies]);\n</code></pre> <p>This ensures that the function identity remains stable, which is especially useful when passing callbacks to child components.</p> </li> </ul>"},{"location":"react/optimization/intro/#3-memoizing-computed-values","title":"3. Memoizing Computed Values:","text":"<ul> <li> <p><code>useMemo()</code>: Use <code>useMemo()</code> to memoize expensive computations, so they are only recalculated when their dependencies change.</p> <pre><code>const computedValue = useMemo(() =&gt; {\n    return expensiveFunction(input);\n}, [input]);\n</code></pre> <p>This can help avoid recalculating values on every render.</p> </li> </ul>"},{"location":"react/optimization/intro/#4-avoid-inline-functions-and-objects","title":"4.  Avoid Inline Functions and Objects:","text":"<ul> <li> <p>Avoid Creating New References: Inline functions and objects can create new references on each render, causing unnecessary re-renders of child components.</p> <pre><code>// Instead of this\n&lt;ChildComponent onClick={() =&gt; doSomething()} /&gt;\n\n// Do this\nconst handleClick = useCallback(() =&gt; {\n    doSomething();\n}, []);\n\n&lt;ChildComponent onClick={handleClick} /&gt;\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#5-optimize-context-usage","title":"5. Optimize Context Usage:","text":"<p>Minimize Context Updates: Passing large objects or frequently changing values through context can cause performance issues. Keep context values as stable and minimal as possible.</p> <p>Split Contexts: Use multiple contexts if needed to avoid unnecessary re-renders.</p>"},{"location":"react/optimization/intro/#6-reactlazy-and-suspense-for-code-splitting","title":"6. React.lazy and Suspense for Code Splitting:","text":"<ul> <li> <p>Lazy Loading Components: Use <code>React.lazy()</code> to dynamically import components, reducing the initial bundle size and improving load times.</p> <pre><code>const LazyComponent = React.lazy(() =&gt; import('./LazyComponent'));\n\nfunction App() {\n    return (\n        &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;LazyComponent /&gt;\n        &lt;/React.Suspense&gt;\n    );\n}\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#7-avoid-expensive-operations-in-render","title":"7. Avoid Expensive Operations in Render:","text":"<ul> <li> <p>Move Computations Out of Render: Perform expensive operations outside the render method or inside <code>useMemo</code> to avoid recalculating them on every render.</p> <pre><code>const expensiveValue = useMemo(() =&gt; calculateExpensiveValue(data), [data]);\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#8-optimize-lists-and-keys","title":"8. Optimize Lists and Keys:","text":"<ul> <li> <p>Provide Unique Keys: Ensure that list items have unique and stable keys to help React efficiently manage list updates.</p> <pre><code>{items.map(item =&gt; (\n    &lt;ListItem key={item.id} item={item} /&gt;\n))}\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#9-debounce-or-throttle-expensive-operations","title":"9. Debounce or Throttle Expensive Operations:","text":"<ul> <li> <p>Debouncing and Throttling: Use debouncing or throttling for input handlers or scroll events to limit the frequency of function calls.</p> <pre><code>const handleChange = useDebounce((event) =&gt; {\n    // handle change\n}, 300);\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#10-avoid-frequent-re-renders","title":"10. Avoid Frequent Re-renders:","text":"<ul> <li>Component Design: Design components to avoid frequent re-renders. Use React DevTools to inspect render behavior and optimize accordingly.</li> </ul>"},{"location":"react/optimization/intro/#11-conditional-rendering","title":"11. Conditional Rendering:","text":"<ul> <li> <p>Render Only What\u2019s Needed: Use conditional rendering to display only what is necessary, reducing the amount of work React has to do.</p> <pre><code>return isVisible ? &lt;Component /&gt; : null;\n</code></pre> </li> </ul>"},{"location":"react/optimization/intro/#12-clean-up-with-useeffect","title":"12. Clean Up with useEffect:","text":"<ul> <li> <p>Proper Cleanup: Use the cleanup function in useEffect to avoid memory leaks and unnecessary operations on component unmount.</p> <pre><code>useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n        // do something\n    }, 1000);\n\n    return () =&gt; clearTimeout(timer);\n}, []);\n</code></pre> </li> </ul> <p>By applying these techniques, you can enhance the performance of your React functional components, leading to faster and more efficient applications.</p>"},{"location":"react/optimization/react-suspense/","title":"React Suspense","text":""},{"location":"react/optimization/react-suspense/#react-lazy-suspense-vs-error-boundaries-an-overview","title":"React Lazy &amp; Suspense vs Error Boundaries: An Overview","text":"<p>React provides several tools to handle component loading and error handling in modern web applications. React Lazy and Suspense help with lazy loading components and improving the performance of your React application. On the other hand, Error Boundaries are used to catch errors that occur in the rendering process, lifecycle methods, and constructors of React components, allowing the app to recover gracefully from crashes.</p> <p>Let's break these down to understand their purpose, differences, and use cases:</p>"},{"location":"react/optimization/react-suspense/#react-lazy-suspense","title":"React Lazy &amp; Suspense","text":""},{"location":"react/optimization/react-suspense/#1-react-lazy","title":"1. React Lazy","text":"<ul> <li> <p>Purpose: <code>React.lazy()</code> allows you to dynamically import a component only when it is needed (i.e., lazy loading). This is useful for code splitting, where components or sections of your app are only loaded when required, improving the initial loading time of your application.</p> </li> <li> <p>How it works: You use <code>React.lazy()</code> to import a component, and React will automatically load it when the component is rendered. It defers the loading of components to reduce the initial bundle size.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>import React, { lazy } from \"react\";\n\nconst MyComponent = lazy(() =&gt; import(\"./MyComponent\"));\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li><code>React.lazy</code> works with default exports only.</li> <li>This is particularly useful for larger applications where loading everything upfront would negatively impact performance.</li> </ul>"},{"location":"react/optimization/react-suspense/#2-react-suspense","title":"2. React Suspense","text":"<ul> <li> <p>Purpose: <code>React.Suspense</code> is a higher-order component that you wrap around components that are being lazy-loaded (using <code>React.lazy()</code>) to handle the loading state (e.g., a spinner or a loading message) while the lazy-loaded component is being fetched.</p> </li> <li> <p>How it works: When a lazy-loaded component is still being downloaded (i.e., not yet available), <code>Suspense</code> shows a fallback UI (like a loading spinner). Once the component is ready, it renders normally.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>import React, { lazy, Suspense } from \"react\";\n\nconst MyComponent = lazy(() =&gt; import(\"./MyComponent\"));\n\nfunction App() {\n  return (\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;MyComponent /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li>The <code>fallback</code> prop in <code>Suspense</code> is a UI element or component that will be shown until the wrapped component is ready.</li> <li><code>Suspense</code> can also be used with other asynchronous operations like data fetching (though data fetching with Suspense is still experimental).</li> </ul>"},{"location":"react/optimization/react-suspense/#error-boundaries","title":"Error Boundaries","text":""},{"location":"react/optimization/react-suspense/#1-purpose-of-error-boundaries","title":"1. Purpose of Error Boundaries","text":"<ul> <li> <p>An Error Boundary is a React component that catches JavaScript errors anywhere in the component tree, logs those errors, and displays a fallback UI instead of crashing the whole app.</p> </li> <li> <p>Use Case: Error boundaries are used to prevent your app from crashing when an error occurs in a part of the component tree. Instead of the entire UI breaking, you can show an error message or an alternative UI.</p> </li> <li> <p>How it works: You define an error boundary by implementing a component with <code>componentDidCatch()</code> lifecycle method (in class components) or static <code>getDerivedStateFromError()</code> method (in functional components). If any error occurs in the component tree, the error boundary catches the error and allows you to handle it gracefully.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // You can log error information to an external service here\n    console.log(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return &lt;h1&gt;Something went wrong!&lt;/h1&gt;;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage:\nfunction App() {\n  return (\n    &lt;ErrorBoundary&gt;\n      &lt;MyComponent /&gt;\n    &lt;/ErrorBoundary&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li>Error boundaries do not catch errors in event handlers, asynchronous code (e.g., <code>setTimeout</code>, <code>fetch</code>), or server-side rendering (SSR) unless you wrap those calls in specific try-catch blocks or handle them separately.</li> <li>The purpose of error boundaries is to avoid entire app crashes by isolating errors to parts of the UI, allowing the rest of the application to continue running.</li> </ul>"},{"location":"react/optimization/react-suspense/#differences-between-react-lazy-suspense-and-error-boundaries","title":"Differences Between React Lazy &amp; Suspense and Error Boundaries","text":"Aspect React Lazy &amp; Suspense Error Boundaries Purpose Lazy loading components and displaying a loading fallback while components are loading. Catching JavaScript errors in components and displaying a fallback UI when errors occur. When used Used for performance optimization by splitting your app\u2019s code into smaller bundles and loading them on demand. Used to handle runtime errors in the UI so the app doesn't crash unexpectedly. Error Handling Does not handle runtime errors. It only helps to load components lazily. Catches JavaScript errors during rendering, lifecycle methods, and constructors in the React component tree. Use case Useful for code-splitting to improve performance by loading components only when needed. Useful for gracefully handling errors that might occur during rendering and lifecycle events. Fallback UI Shows a fallback UI (e.g., loading spinner) while a lazy-loaded component is being fetched. Shows a fallback UI (e.g., error message) if an error occurs in the child components. Where to use Wrap components or sections of your app that can be lazily loaded. Wrap entire sections or the whole app to catch and handle errors in any component. Works with Works with lazy-loaded components using <code>React.lazy()</code>. Works with any component in the React tree, catching errors during rendering and lifecycle methods."},{"location":"react/optimization/react-suspense/#key-differences-summarized","title":"Key Differences Summarized:","text":"<ul> <li>React.lazy &amp; Suspense are primarily concerned with performance optimization through code splitting and displaying a loading state when a component is being fetched.</li> <li>Error Boundaries are about error handling, catching runtime errors that might occur during component rendering or lifecycle methods and ensuring the rest of the app doesn\u2019t crash.</li> </ul>"},{"location":"react/optimization/react-suspense/#example-scenario","title":"Example Scenario:","text":"<ul> <li> <p>React.lazy + Suspense: If you have a large, resource-intensive component that you want to load only when the user visits a particular part of your app, you would use <code>React.lazy</code> and wrap it with <code>Suspense</code> to show a loading spinner while the component is being fetched.</p> </li> <li> <p>Error Boundary: If there\u2019s a bug in one of your components (say a JavaScript error occurs), you would use an <code>Error Boundary</code> to prevent the entire app from crashing, and instead, display a fallback UI like \"Something went wrong.\"</p> </li> </ul>"},{"location":"react/optimization/react-suspense/#conclusion","title":"Conclusion:","text":"<p>Both React.lazy &amp; Suspense and Error Boundaries improve your React app in different ways. React.lazy &amp; Suspense focus on loading performance, while Error Boundaries focus on error resilience. They are not mutually exclusive and can be used together in the same app to enhance both performance and error handling.</p>"},{"location":"react/optimization/react-suspense/#questions","title":"Questions","text":"<p>React.lazy works with default exports only. what does it mean explain me clearly</p> <p>When we say that <code>React.lazy()</code> works with default exports only, it refers to the way JavaScript modules are exported and imported. Let\u2019s break this down to understand what this means in simple terms:</p> <p>Understanding Exports and Imports in JavaScript:</p> <p>In JavaScript, when you want to share a piece of code (like a function, class, or object) between different files, you need to export it from one file and import it in another.</p> <p>There are two primary ways to export and import things in JavaScript: default exports and named exports.</p> Example 1. Default Export:2. Named Export: <ul> <li>You can export a single value, function, or class as the \"default\" export from a module.</li> <li>There can be only one default export in a module.</li> </ul> <p>Example of default export:</p> <pre><code>// File: MyComponent.js\nexport default function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <p>When importing this in another file, you can use any name for the import (the name does not need to match the name of the exported function or class):</p> <pre><code>// File: App.js\nimport MyComponent from './MyComponent';  // Importing default export\n</code></pre> <ul> <li>You can export multiple named values from a module. Each export must be explicitly named.</li> <li>Named exports can be used in any combination (you can export many things).</li> </ul> <p>Example of named export:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n\nexport function AnotherComponent() {\n    return &lt;div&gt;Goodbye World&lt;/div&gt;;\n}\n</code></pre> <p>When importing, you must use the same name as the one you used in the export:</p> <pre><code>// File: App.js\nimport { MyComponent, AnotherComponent } from './MyComponents';  // Named imports\n</code></pre> <p>Why React.lazy() Works with Default Exports Only</p> <p><code>React.lazy()</code> is a function provided by React that allows you to <code>dynamically load components</code> (lazy loading) only when they are needed. This helps improve your app's performance by reducing the initial bundle size.</p> <p>However, <code>React.lazy()</code> expects the modules to be exported as default exports, not named exports. This is due to the way <code>React.lazy()</code> is designed to handle the default import of a module.</p> <p>Let\u2019s look at how this plays out:</p> Example 1. Works with Default Export:2. Does Not Work with Named Export: <pre><code>// File: MyComponent.js\nexport default function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <p>Now, you can use <code>React.lazy()</code> with the default export:</p> <pre><code>// File: App.js\nimport React, { Suspense, lazy } from 'react';\n\nconst MyComponent = lazy(() =&gt; import('./MyComponent'));  // Default import\n\nfunction App() {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;MyComponent /&gt;\n        &lt;/Suspense&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>In this case, <code>React.lazy()</code> works fine because <code>MyComponent</code> is the default export of <code>./MyComponent</code>, so <code>import('./MyComponent')</code> will load the default export.</p> <p>If you try to use <code>React.lazy()</code> with a named export, it will not work correctly. For example:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n\n// File: App.js\nconst MyComponent = lazy(() =&gt; import('./MyComponents'));  // Incorrect: Named export doesn't work here\n</code></pre> <p>This will not work because <code>React.lazy()</code> expects the module to have a default export. In the example above, <code>MyComponent</code> is a named export, not the default export, so it won't be properly loaded by <code>React.lazy()</code>.</p> <p>Correct Way to Use Named Exports with React.lazy()</p> <p>If you want to use named exports in conjunction with <code>React.lazy()</code>, you need to import the named export explicitly using the standard JavaScript import syntax. Here's how you can do it:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n  return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <pre><code>// File: App.js\nimport React, { Suspense, lazy } from \"react\";\n\n// To use a named export, you need to import it like this:\nconst MyComponent = lazy(() =&gt;\n  import(\"./MyComponents\").then((module) =&gt; ({ default: module.MyComponent }))\n);\n\nfunction App() {\n  return (\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;MyComponent /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>Why Is This the Case?</p> <ul> <li><code>React.lazy()</code> is designed to work with default exports for simplicity and to make it easier to load a single module.</li> <li>JavaScript's dynamic <code>import()</code> syntax can handle both default and named imports, but <code>React.lazy()</code> is simplified to expect just one export: the default.</li> <li>If you want to dynamically load named exports, you need to use a slightly more complex approach (as shown above).</li> </ul> <p>Summary</p> <ul> <li><code>React.lazy()</code> expects the module to have a default export because it simplifies the process of dynamic importing and rendering.</li> <li>If you try to import a module that uses named exports directly with <code>React.lazy()</code>, it won't work.   To use named exports with <code>React.lazy()</code>, you would have to rewrite the import to map the named export to a default one, as shown in the example.</li> </ul> <p>In practice, this is why default exports are often recommended when using <code>React.lazy()</code> for code splitting in React applications.</p>"},{"location":"react/optimization/topic/","title":"Topic","text":""},{"location":"react/optimization/topic/#overview","title":"Overview","text":"<p>In modern React development, there are several advanced concepts and patterns that can help you build more efficient, scalable, and maintainable applications. Below are some advanced topics, including React Suspense, that can elevate your React skills:</p>"},{"location":"react/optimization/topic/#1-react-suspense-and-concurrent-mode","title":"1. React Suspense and Concurrent Mode","text":"<ul> <li> <p>React Suspense: Suspense is used for data fetching and code splitting. It allows components to \"wait\" for some asynchronous operation (like fetching data) before rendering. This helps in improving the user experience by avoiding loading states scattered throughout the app.</p> <ul> <li>Data Fetching with Suspense: Paired with tools like React Query or Relay, you can use Suspense to handle asynchronous data fetching.</li> <li>Code Splitting: Suspense can also be used with <code>React.lazy</code> to lazy load components, showing a loading fallback until the component has been fetched.</li> </ul> </li> <li> <p>Concurrent Mode: This is an experimental feature that optimizes React rendering for smoother interactions. When enabled, React can work on multiple tasks at once, prioritizing important updates over less important ones. Features like Concurrent Rendering, Concurrent Suspense, and- Transitions can help you build highly responsive applications.</p> <ul> <li>Enables interruptible rendering, where React can pause, resume, and prioritize updates.</li> <li>React 18 introduces features like Automatic Batching and Suspense for Data Fetching that take full advantage of Concurrent Mode.</li> </ul> </li> </ul>"},{"location":"react/optimization/topic/#2-react-server-components","title":"2. React Server Components","text":"<ul> <li>React Server Components allow you to render parts of your React app on the server while still delivering an interactive, client-side experience. This can significantly reduce the amount of JavaScript sent to the client, improving initial load performance.</li> <li>You can offload heavy rendering work (e.g., complex layouts or static content) to the server, while keeping the interactivity on the client.</li> </ul>"},{"location":"react/optimization/topic/#3-context-api-usereducer-for-state-management","title":"3. Context API + useReducer for State Management","text":"<ul> <li> <p>React Context: React\u2019s built-in Context API can be used for global state management, although it\u2019s generally recommended for lower-level global state (like theme, user authentication, etc.). For larger applications, combine it with <code>useReducer</code> for more complex state management that mimics the Redux pattern without needing an external library.</p> </li> <li> <p>useReducer: A hook that\u2019s especially useful for managing state with more complicated logic (e.g., multiple actions or deep state changes) within a component or an app. It integrates seamlessly with <code>Context</code> for a global store.</p> </li> </ul>"},{"location":"react/optimization/topic/#4-custom-hooks-and-hook-composition","title":"4. Custom Hooks and Hook Composition","text":"<ul> <li>Custom Hooks: Create reusable logic for components. Custom hooks abstract away common functionality into functions that you can use across different components.</li> <li> <p>Hook Composition: This involves using multiple hooks together to compose functionality in your components. It enables you to create clean and modular code by combining small pieces of logic into reusable hooks.</p> </li> <li> <p>Example: <code>useFetch</code>, <code>useLocalStorage</code>, or <code>useOnClickOutside</code>.</p> </li> </ul>"},{"location":"react/optimization/topic/#5-react-memoization-reactmemo-usememo-usecallback","title":"5. React Memoization (React.memo, useMemo, useCallback)","text":"<ul> <li>React.memo: A higher-order component that optimizes functional components by memoizing them. If the props don't change, React skips re-rendering the component.</li> <li>useMemo: A hook that memoizes a computed value so it doesn't need to be recalculated on every render, which can improve performance for expensive calculations.</li> <li>useCallback: A hook that memoizes a function so that it doesn\u2019t get recreated on every render, preventing unnecessary re-renders of child components that depend on it.</li> </ul>"},{"location":"react/optimization/topic/#6-react-fragments-and-portals","title":"6. React Fragments and Portals","text":"<ul> <li>React Fragments: Allow you to return multiple elements from a component without adding extra nodes to the DOM. This is useful for grouping children elements without introducing unnecessary wrapper divs.</li> <li>React Portals: Allow you to render children into a DOM node that exists outside the hierarchy of the parent component, typically used for modals, tooltips, and popups.</li> </ul>"},{"location":"react/optimization/topic/#7-error-boundaries","title":"7. Error Boundaries","text":"<ul> <li>Error Boundaries: A component that catches JavaScript errors anywhere in the component tree and logs those errors, while also displaying a fallback UI instead of crashing the entire app. This is useful for building resilient applications.   You can create your own error boundaries using the <code>componentDidCatch</code> lifecycle method or the <code>ErrorBoundary</code> hook (experimental).</li> </ul>"},{"location":"react/optimization/topic/#8-react-devtools-and-performance-profiling","title":"8. React DevTools and Performance Profiling","text":"<ul> <li>React DevTools: Use the React DevTools extension for debugging and performance profiling. The Profiler tab helps track component render performance and diagnose performance bottlenecks.   You can visualize render times and analyze the performance of individual components to optimize rendering behavior.</li> </ul>"},{"location":"react/optimization/topic/#9-higher-order-components-hocs","title":"9. Higher Order Components (HOCs)","text":"<ul> <li>Higher Order Components: A pattern that allows you to reuse component logic by wrapping a component with a function that injects new functionality. For example, an HOC can be used to handle authentication, logging, or error handling.   Although HOCs have fallen out of favor with the introduction of hooks, they are still useful in certain cases.</li> </ul>"},{"location":"react/optimization/topic/#10-lazy-loading-and-code-splitting","title":"10. Lazy Loading and Code Splitting","text":"<ul> <li>Lazy Loading: Lazy loading allows you to load parts of your application only when needed. This reduces the initial load time of your app. Use <code>React.lazy</code> to dynamically import components and wrap them in <code>&lt;Suspense&gt;</code> to show a fallback UI while the component is loading.   Code Splitting: Split your app into smaller bundles to improve loading performance. Tools like Webpack and React.lazy can help with this.</li> </ul>"},{"location":"react/optimization/topic/#11-typescript-with-react","title":"11. TypeScript with React","text":"<ul> <li>TypeScript: Adding TypeScript to your React projects can help prevent bugs by enforcing static types. TypeScript works seamlessly with React, and the integration allows for better tooling (e.g., code completion, error checking).</li> <li>TypeScript + React Hooks: Learn how to type custom hooks, context providers, and event handlers. With TypeScript, you can also enforce stricter types for props and state.</li> </ul>"},{"location":"react/optimization/topic/#12-react-hooks-with-observables-rxjs","title":"12. React Hooks with Observables (RxJS)","text":"<ul> <li>RxJS: If you're dealing with complex asynchronous data flows (such as websockets, or multiple streams of data), integrating RxJS with React can help manage these streams using hooks.</li> <li>This can be especially useful when building apps that need to handle real-time data or other complex async behavior.</li> </ul>"},{"location":"react/optimization/topic/#13-react-and-graphql","title":"13. React and GraphQL","text":"<ul> <li>GraphQL Integration: Learn how to fetch data using GraphQL and libraries like Apollo Client or Relay. These libraries integrate well with React and allow for more flexible and efficient data fetching compared to REST APIs.</li> <li>GraphQL allows you to request exactly the data you need, reducing over-fetching and under-fetching issues, and supports features like pagination, caching, and subscriptions for real-time data.</li> </ul>"},{"location":"react/optimization/topic/#14-styled-components-and-css-in-js","title":"14. Styled Components and CSS-in-JS","text":"<ul> <li>Styled Components: A popular CSS-in-JS library for React that allows you to write actual CSS code inside JavaScript files, scoped to the component. This pattern helps you avoid global styles, and you can easily theme your components dynamically.</li> <li>There are other libraries for CSS-in-JS like Emotion and Stitches, each with its own set of optimizations.</li> </ul>"},{"location":"react/optimization/topic/#15-service-workers-and-progressive-web-apps-pwas","title":"15. Service Workers and Progressive Web Apps (PWAs)","text":"<ul> <li>Service Workers: Service workers are background scripts that allow you to cache assets and data for offline usage, creating more resilient web applications.</li> <li>Building a PWA (Progressive Web App) with React lets you build fast, reliable, and engaging apps that work offline or in low-network conditions.</li> </ul>"},{"location":"react/optimization/topic/#16-unit-testing-with-react-testing-library-and-jest","title":"16. Unit Testing with React Testing Library and Jest","text":"<ul> <li>React Testing Library: Encourages testing from the user's perspective by focusing on how the components behave, rather than testing their internal implementation.</li> <li>Jest: Jest is a popular testing framework that works well with React. It supports features like mocking, assertions, and snapshot testing.</li> </ul> <p>These topics can take your React applications to the next level, making them more efficient, maintainable, and scalable. You don\u2019t necessarily need to learn all of them at once, but exploring them progressively as your project\u2019s complexity grows will help you create better React apps.</p>"},{"location":"react/testing/cypress/","title":"Cypress","text":""},{"location":"react/testing/cypress/#theory","title":"Theory","text":"<p>Cypress is an end-to-end testing framework that provides a fast, reliable, and easy-to-use way to test your web applications.</p>"},{"location":"react/testing/cypress/#key-features-of-cypress","title":"Key Features of Cypress:","text":"<ol> <li>Real Browser Testing: Cypress runs tests directly in the browser, giving you a realistic testing environment.</li> <li>Automatic Waiting: Cypress automatically waits for commands and assertions to pass, making your tests more reliable without adding manual waits.</li> <li>Time Travel: Cypress captures snapshots as your tests run, allowing you to hover over commands in the Command Log to see what happened at each step.</li> <li>Debuggability: With detailed error messages and stack traces, Cypress makes debugging failed tests straightforward.</li> <li>Network Traffic Control: Cypress lets you stub and spy on network requests, giving you control over your application's API interactions during tests.</li> <li>Integration with CI/CD: Cypress integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines.</li> </ol>"},{"location":"react/testing/cypress/#when-to-use-cypress","title":"When to Use Cypress","text":"<ul> <li>End-to-End Testing: Cypress is perfect for testing the complete user journey, from loading the application to interacting with various elements and verifying outcomes.</li> <li>Integration Testing: When you need to test how different parts of your application work together, Cypress's realistic browser environment is beneficial.</li> <li>Real Browser Interactions: If you need to test how your application behaves in a real browser, including handling of network requests, cookies, and local storage, Cypress is the right tool.</li> <li>User Interface Testing: Cypress excels at simulating real user interactions and verifying the application's response.</li> </ul>"},{"location":"react/testing/cypress/#example-use-cases","title":"Example Use Cases","text":"<p>Cypress Example (End-to-End Testing a Login Flow)</p> <ol> <li> <p>Install Cypress:</p> <pre><code>npm install --save-dev cypress\n</code></pre> </li> <li> <p>Example Test File (login.spec.js):</p> <pre><code>describe('Login Flow', () =&gt; {\n    it('should log in successfully', () =&gt; {\n        cy.visit('http://localhost:3000/login');\n        cy.get('input[name=username]').type('user');\n        cy.get('input[name=password]').type('password');\n        cy.get('button[type=submit]').click();\n        cy.url().should('include', '/dashboard');\n        cy.contains('Welcome, user!');\n    });\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npx cypress open\n</code></pre> </li> </ol>"},{"location":"react/testing/cypress/#summary","title":"Summary","text":"<p>Use Cypress for end-to-end testing, integration testing, and when you need to simulate real user interactions in a browser.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"react/testing/intro/","title":"Intro","text":"<p>Mastering React testing in a large codebase can be challenging but is crucial for maintaining a robust and reliable application. Here\u2019s a comprehensive approach to get you started:</p>"},{"location":"react/testing/intro/#1-understand-the-fundamentals","title":"1.  Understand the Fundamentals","text":"<p>Before diving into complex scenarios, ensure you\u2019re comfortable with the basics:</p> <ul> <li>React Testing Library: Focus on testing components in a way that resembles how users interact with them. It encourages testing components from the user's perspective rather than the implementation details.</li> <li>Jest: A popular testing framework for React applications, providing utilities for assertions, mocking, and more.</li> </ul>"},{"location":"react/testing/intro/#2-set-up-a-testing-strategy","title":"2.  Set Up a Testing Strategy","text":"<p>Define Objectives:</p> <ul> <li>Unit Tests: Test individual components or functions in isolation.</li> <li>Integration Tests: Ensure that different parts of your application work together as expected.</li> <li>End-to-End Tests: Test the full application flow to simulate real user interactions.</li> </ul> <p>Testing Pyramid:</p> <ul> <li>Unit Tests: Most numerous, quick to run.</li> <li>Integration Tests: Fewer than unit tests, validate interactions.</li> <li>End-to-End Tests: Least frequent but cover the entire workflow.</li> </ul>"},{"location":"react/testing/intro/#3-establish-a-testing-framework","title":"3.  Establish a Testing Framework","text":"<p>Tools and Libraries:</p> <ul> <li>React Testing Library: For rendering components and querying the DOM.</li> <li>Jest: For assertions, mocking, and test utilities.</li> <li>Cypress or Playwright: For end-to-end testing.</li> <li>Storybook: For visual component testing and development.</li> </ul> <p>Configuration:</p> <ul> <li>Set up Jest and React Testing Library with a consistent configuration. Ensure that Jest is configured for handling imports and processing files correctly.</li> </ul>"},{"location":"react/testing/intro/#4-write-effective-tests","title":"4. Write Effective Tests","text":"<p>Component Testing:</p> <ul> <li>Render the Component: Use render from React Testing Library to render your component.</li> <li>Query Elements: Use queries like getByText, getByRole, etc., to select elements.</li> <li>Assertions: Use expect to assert conditions about your component.</li> </ul> <pre><code>import { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders the correct text', () =&gt; {\n  render(&lt;MyComponent /&gt;);\n  expect(screen.getByText(/expected text/i)).toBeInTheDocument();\n});\n</code></pre> <p>Integration Testing:</p> <ul> <li>Mock Dependencies: Use tools like jest.mock to mock out dependencies or services.</li> <li>Test User Interactions: Simulate user interactions and verify the outcomes.</li> </ul> <pre><code>import { render, screen, fireEvent } from '@testing-library/react';\nimport MyForm from './MyForm';\n\ntest('submits form data correctly', () =&gt; {\n  render(&lt;MyForm /&gt;);\n  fireEvent.change(screen.getByLabelText(/name/i), { target: { value: 'John Doe' } });\n  fireEvent.click(screen.getByRole('button', { name: /submit/i }));\n  expect(screen.getByText(/form submitted/i)).toBeInTheDocument();\n});\n</code></pre>"},{"location":"react/testing/intro/#5-maintain-and-scale-tests","title":"5.  Maintain and Scale Tests","text":"<p>Refactor Tests:</p> <ul> <li>Regularly refactor tests to keep them clean and maintainable.</li> <li>Use helper functions or custom hooks for repetitive testing logic.</li> </ul> <p>Test Coverage:</p> <ul> <li>Aim for high test coverage but focus on critical paths and user interactions rather than striving for 100% coverage.</li> </ul> <p>Continuous Integration (CI):</p> <ul> <li>Integrate your tests into a CI pipeline to automatically run tests on code changes and pull requests.</li> </ul>"},{"location":"react/testing/intro/#6-address-common-challenges","title":"6.  Address Common Challenges","text":"<p>Large Codebase Specifics:</p> <ul> <li>Test Isolation: Ensure tests do not depend on each other. Use mocks and stubs effectively.</li> <li>Performance: Optimize tests to run quickly by avoiding excessive rendering or complex setups.</li> <li>Debugging: Leverage Jest\u2019s debugging tools and React Testing Library\u2019s debugging utilities to troubleshoot failing tests.</li> </ul> <p>Documentation and Best Practices:</p> <ul> <li>Document your testing strategy and best practices for consistency.</li> <li>Conduct regular reviews and updates of your testing approach as the codebase evolves.</li> </ul> <p>By focusing on these areas, you can effectively master React testing and ensure your large codebase remains reliable and maintainable.</p> <p>Testing API calls and optimizing graphs, especially in the context of React applications, involves different strategies for each task. Let\u2019s break down the approaches for both:</p>"},{"location":"react/testing/intro/#testing-api-calls-in-react","title":"Testing API Calls in React","text":"<ol> <li> <p>Testing API Calls</p> <p>When testing API calls in React components, you'll generally want to isolate the component from the network request to ensure your tests are reliable and fast.</p> <p>Mocking API Calls</p> <ul> <li> <p>Use <code>jest.mock()</code>: You can mock the module that performs the API request (e.g., <code>axios</code>, <code>fetch</code>) to avoid actual network calls during testing.</p> myComponent.jsmyComponent.test.js <pre><code>// myComponent.js\nimport React, { useEffect, useState } from 'react';\nimport axios from 'axios';\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        axios.get('/api/data')\n        .then(response =&gt; setData(response.data))\n        .catch(error =&gt; console.error(error));\n    }, []);\n\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{data.message}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> <pre><code>// myComponent.test.js\nimport { render, screen, waitFor } from '@testing-library/react';\nimport axios from 'axios';\nimport MyComponent from './myComponent';\n\n// Mocking axios\njest.mock('axios');\n\ntest('fetches and displays data', async () =&gt; {\n    // Mock implementation\n    axios.get.mockResolvedValue({ data: { message: 'Hello World' } });\n\n    render(&lt;MyComponent /&gt;);\n\n    // Assertion\n    await waitFor(() =&gt; screen.getByText(/hello world/i));\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Handling Asynchronous Code</p> <p>When dealing with asynchronous operations:</p> <ul> <li>Use <code>waitFor</code>: To wait for changes in the DOM.</li> <li>Use <code>findBy</code> queries: For assertions involving async updates.</li> </ul> <pre><code>await waitFor(() =&gt; {\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ol>"},{"location":"react/testing/intro/#optimizing-graphs","title":"Optimizing Graphs","text":"<p>Optimizing graphs usually refers to improving the performance of data visualizations. Here\u2019s how to approach this:</p>"},{"location":"react/testing/intro/#1-before-optimization","title":"1.  Before Optimization","text":"Identify Performance Issues <ul> <li>Large Data Sets: Rendering large amounts of data can be slow.</li> <li>Re-renders: Unnecessary re-renders can impact performance.</li> <li>Complex Calculations: Expensive operations can affect responsiveness.</li> </ul>"},{"location":"react/testing/intro/#2-optimization-techniques","title":"2.  Optimization Techniques","text":"Optimize Data Handling <ul> <li>Data Aggregation: Aggregate data on the server side to reduce the amount of data sent to the client.</li> <li>Pagination/Infinite Scroll: Load data in chunks rather than all at once.</li> </ul> Optimize Rendering <ul> <li>Virtualization: Use libraries like <code>react-virtualized</code> or <code>react-window</code> to render only visible parts of the graph.</li> <li>Memoization: Use <code>React.memo</code> or <code>useMemo</code> to prevent unnecessary re-renders.</li> <li>Debouncing: For user interactions that trigger updates, use debouncing to limit the frequency of updates.</li> </ul> <pre><code>import React, { memo } from 'react';\nimport { FixedSizeList as List } from 'react-window';\n\nconst Row = memo(({ index, style }) =&gt; (\n&lt;div style={style}&gt;\n    {/* Row content */}\n&lt;/div&gt;\n));\n\nconst MyGraph = ({ data }) =&gt; (\n&lt;List\n    height={600}\n    itemCount={data.length}\n    itemSize={35}\n    width={1000}\n&gt;\n    {Row}\n&lt;/List&gt;\n);\n</code></pre>"},{"location":"react/testing/intro/#optimize-graph-calculations","title":"Optimize Graph Calculations","text":"<ul> <li>Web Workers: Offload intensive calculations to web workers.</li> <li>Canvas/SVG: Choose the right technology for rendering. For complex graphs, <code>canvas</code> may be more performant than <code>SVG</code>.</li> </ul> <pre><code>const MyGraph = ({ data }) =&gt; {\n  // Drawing logic using canvas API\n\n  return &lt;canvas id=\"graphCanvas\"&gt;&lt;/canvas&gt;;\n};\n</code></pre>"},{"location":"react/testing/intro/#profile-and-measure-performance","title":"Profile and Measure Performance","text":"<ul> <li>React DevTools: Use the Profiler tab to identify performance bottlenecks in React components.</li> <li>Browser DevTools: Use performance profiling tools to analyze rendering times and identify slow operations.</li> </ul>"},{"location":"react/testing/intro/#3-after-optimization","title":"3. After Optimization","text":""},{"location":"react/testing/intro/#test-and-validate","title":"Test and Validate","text":"<ul> <li>Benchmarking: Measure performance improvements before and after optimization.</li> <li>User Testing: Validate that the optimizations improve user experience and do not introduce new issues.</li> </ul>"},{"location":"react/testing/intro/#continuous-monitoring","title":"Continuous Monitoring","text":"<ul> <li>Performance Monitoring: Continuously monitor performance in production using tools like Google Lighthouse, New Relic, or custom performance metrics.</li> <li>By focusing on these strategies for both testing API calls and optimizing graphs, you can improve the performance and reliability of your React application.</li> </ul>"},{"location":"react/testing/jest/","title":"Jest","text":""},{"location":"react/testing/jest/#theory","title":"Theory","text":"<p>Jest is a delightful JavaScript testing framework developed by Facebook, designed to ensure correctness of any JavaScript codebase. It is widely used for testing React applications, but it can be used with any JavaScript project.</p>"},{"location":"react/testing/jest/#key-features-of-jest","title":"Key Features of Jest:","text":"<ol> <li>Zero Configuration: Jest works out of the box for most JavaScript projects, especially those using React.</li> <li>Snapshots: Jest can capture the output of your components and compare it to a reference snapshot file to ensure UI consistency.</li> <li>Isolated Tests: Each test runs in its own sandbox environment to avoid global state pollution.</li> <li>Coverage Reporting: Jest can generate code coverage reports, helping you understand how much of your code is tested.</li> <li>Mocking: Jest provides powerful mocking capabilities to simulate different scenarios and behaviors for your code dependencies. Parallel Execution: Tests run in parallel, speeding up the testing process.</li> </ol>"},{"location":"react/testing/jest/#when-to-use-jest","title":"When to Use Jest","text":"<ul> <li>Unit Testing: Jest is ideal for testing individual functions, modules, or components in isolation.</li> <li>Snapshot Testing: If you want to ensure that your UI components render consistently, snapshot testing with Jest is very effective.</li> <li>Mocking Dependencies: When you need to mock dependencies or simulate different scenarios, Jest's mocking capabilities are highly useful.</li> <li>Fast Feedback Loop: Jest's parallel execution and watch mode provide quick feedback during development.</li> </ul>"},{"location":"react/testing/jest/#example-use-cases","title":"Example Use Cases","text":"<p>Jest Example (Unit Testing a React Component)</p> <ol> <li> <p>Install Jest:</p> <pre><code>npm install --save-dev jest @testing-library/react @testing-library/jest-dom\n</code></pre> </li> <li> <p>Example Test File (<code>MyComponent.test.js</code>):</p> <pre><code>import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders a message', () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    const messageElement = screen.getByText(/hello, world!/i);\n    expect(messageElement).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npm test\n</code></pre> </li> </ol>"},{"location":"react/testing/jest/#summary","title":"Summary","text":"<p>Use Jest for unit testing, snapshot testing, and when you need fast feedback during development.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"react/testing/measuring-optimization-tools/","title":"Measuring Tools","text":"<p>Measuring the impact of optimizations, particularly in client-side applications like React, involves evaluating several performance metrics before and after making changes. Here\u2019s a structured approach to assess the effectiveness of your optimizations:</p>"},{"location":"react/testing/measuring-optimization-tools/#1-define-performance-metrics","title":"1.  Define Performance Metrics","text":"<p>Before you can measure changes, you need to define what metrics you\u2019ll be tracking. Common performance metrics include:</p> <ul> <li>Page Load Time: Time taken from initiating a page load to complete rendering.</li> <li>Time to Interactive (TTI): Time until the page is fully interactive.</li> <li>First Contentful Paint (FCP): Time taken for the first piece of content to be painted on the screen.</li> <li>Largest Contentful Paint (LCP): Time taken for the largest piece of content to be painted.</li> <li>Total Blocking Time (TBT): Time during which the page is blocked from user input.</li> <li>FPS (Frames Per Second): Smoothness of animations and interactions.</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#2-use-performance-measurement-tools","title":"2.  Use Performance Measurement Tools","text":"<p>1. Google Lighthouse:</p> <ul> <li>How to Use: Run Lighthouse audits in Chrome DevTools (Lighthouse tab), from the command line, or within CI/CD pipelines.</li> <li>What to Measure: Provides scores for performance, accessibility, SEO, and more. Use the performance score and individual metrics (FCP, LCP, TTI) to assess changes.</li> </ul> <p>2. Web Vitals:</p> <ul> <li>How to Use: Integrate the web-vitals library into your application to collect metrics like FCP, LCP, and CLS (Cumulative Layout Shift).</li> <li>What to Measure: Provides real-world performance data from actual user interactions.</li> </ul> <p>3. Chrome DevTools:</p> <ul> <li>How to Use: Use the Performance tab to record and analyze runtime performance, including rendering and scripting times.</li> <li>What to Measure: Look for metrics like scripting time, rendering time, and network requests.</li> </ul> <p>4. Performance APIs:</p> <ul> <li>How to Use: Use the Performance API in your code to manually measure specific timings and events.</li> <li>What to Measure: Custom timings for specific actions or events in your application.</li> </ul> <p>5. Real User Monitoring (RUM):</p> <ul> <li>How to Use: Tools like Google Analytics, New Relic, or Sentry can provide real-user performance metrics.</li> <li>What to Measure: Collect data from actual users to get insights into performance under real-world conditions.</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#3-establish-baseline-metrics","title":"3. Establish Baseline Metrics","text":"Before Optimization: <ul> <li>Run Performance Tests: Use the tools mentioned to capture performance metrics before implementing optimizations.</li> <li>Document Baseline Data: Record the metrics as a reference point for comparison.</li> </ul> <pre><code>import { getCLS, getFCP, getLCP, getFID } from 'web-vitals';\n\ngetCLS(console.log); // Report Cumulative Layout Shift\ngetFCP(console.log); // Report First Contentful Paint\ngetLCP(console.log); // Report Largest Contentful Paint\ngetFID(console.log); // Report First Input Delay\n</code></pre>"},{"location":"react/testing/measuring-optimization-tools/#4-apply-optimizations","title":"4. Apply Optimizations","text":"<p>Implement the changes you believe will improve performance, such as code splitting, lazy loading, optimizing data fetching, or using virtualized lists.</p>"},{"location":"react/testing/measuring-optimization-tools/#5-re-measure-performance","title":"5. Re-Measure Performance","text":"After Optimization: <ul> <li>Re-run Tests: Use the same tools and methods to measure performance after optimizations are applied.</li> <li>Compare Metrics: Compare the new data against your baseline to assess the impact of the optimizations.</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#6-analyze-results","title":"6. Analyze Results","text":"<p>Compare and Interpret:</p> <ul> <li>Improvement: Determine if metrics have improved, such as faster load times, reduced time to interactive, or smoother animations.</li> <li>Regression: Identify if any metrics have worsened or if new issues have been introduced.</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#7-continuous-monitoring","title":"7. Continuous Monitoring","text":"<p>Regular Checks:</p> <ul> <li>Ongoing Monitoring: Integrate performance monitoring into your CI/CD pipeline and regularly review performance metrics.</li> <li>User Feedback: Collect feedback from users to ensure that optimizations align with user experience improvements.</li> </ul> <p>Performance Dashboards:</p> <ul> <li>Create Dashboards: Use tools like Google Data Studio, Grafana, or custom dashboards to visualize performance metrics over time.</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#example-process","title":"Example Process","text":"<ol> <li> <p>Baseline Measurement:</p> <ul> <li>Before: Run Lighthouse audit and note down FCP, LCP, TTI.</li> </ul> </li> <li> <p>Optimization:</p> <ul> <li>Implement code splitting and lazy loading.</li> </ul> </li> <li> <p>Re-measure:</p> <ul> <li>After: Run Lighthouse audit again and compare the updated metrics.</li> </ul> </li> <li> <p>Analyze:</p> <ul> <li>Results: If FCP improved from 2s to 1s, LCP improved from 3s to 1.5s, this indicates a successful optimization.</li> </ul> </li> </ol> <p>By following these steps, you can effectively measure the impact of your optimizations and ensure that your changes lead to real performance improvements for your users.</p>"},{"location":"react/testing/measuring-optimization-tools/#react-tools-for-optimization","title":"React Tools for Optimization","text":"<p>For optimizing and measuring performance in a React web application, you have a variety of tools at your disposal. Here\u2019s a comprehensive list of tools categorized by their primary functions:</p>"},{"location":"react/testing/measuring-optimization-tools/#1-performance-testing-and-optimization","title":"1. Performance Testing and Optimization","text":"<p>1.1 Google Lighthouse</p> <ul> <li>Purpose: Provides performance audits, accessibility, SEO, and best practices.</li> <li>How to Use: Available in Chrome DevTools (Lighthouse tab), as a CLI tool, or as a GitHub Action.</li> <li>Website: Lighthouse</li> </ul> <p>1.2 Web Vitals</p> <ul> <li>Purpose: Measures key user-centric metrics like First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS).</li> <li>How to Use: Integrate the web-vitals library into your application to collect and report metrics.</li> <li>Website: Web Vitals</li> </ul> <p>1.3 Chrome DevTools</p> <ul> <li>Purpose: Provides real-time performance insights, profiling, and debugging.</li> <li>How to Use: Access the Performance tab in Chrome DevTools to record and analyze performance.</li> <li>Website: Chrome DevTools</li> </ul> <p>1.4 React DevTools</p> <ul> <li>Purpose: Helps inspect React component hierarchies, measure component render times, and track state and props.</li> <li>How to Use: Available as a browser extension or standalone app.</li> <li>Website: React DevTools</li> </ul> <p>1.5 Webpack Bundle Analyzer</p> <ul> <li>Purpose: Visualizes the size of webpack output files to help optimize bundling.</li> <li>How to Use: Integrate with your webpack configuration to generate interactive bundle reports.</li> <li>Website: Webpack Bundle Analyzer</li> </ul> <p>1.6 Source Map Explorer</p> <ul> <li>Purpose: Analyzes the size of the bundled code and its dependencies.</li> <li>How to Use: Run as a CLI tool to visualize and understand the size of your code.</li> <li>Website: Source Map Explorer</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#2-testing-tools","title":"2. Testing Tools","text":"<p>2.1 Jest</p> <ul> <li>Purpose: A testing framework for unit and integration tests with built-in test runners and assertions.</li> <li>How to Use: Write and run tests for JavaScript and React components.</li> <li>Website: Jest</li> </ul> <p>2.2 React Testing Library</p> <ul> <li>Purpose: Provides utilities for testing React components by interacting with the DOM in a user-centric way.</li> <li>How to Use: Write tests that focus on user interactions rather than implementation details.</li> <li>Website: React Testing Library</li> </ul> <p>2.3 Cypress</p> <ul> <li>Purpose: End-to-end testing framework that allows for writing and running integration and UI tests.</li> <li>How to Use: Write tests that simulate user interactions and validate application behavior.</li> <li>Website: Cypress</li> </ul> <p>2.4 Playwright</p> <ul> <li>Purpose: End-to-end testing framework with cross-browser support and automation capabilities.</li> <li>How to Use: Write tests to verify interactions across different browsers.</li> <li>Website: Playwright</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#3-monitoring-and-analytics","title":"3. Monitoring and Analytics","text":"<p>3.1 Google Analytics</p> <ul> <li>Purpose: Tracks user interactions and performance metrics for web applications.</li> <li>How to Use: Integrate with your React app to gather and analyze usage data.</li> <li>Website: Google Analytics</li> </ul> <p>3.2 Sentry</p> <ul> <li>Purpose: Provides error tracking and performance monitoring for web applications.</li> <li>How to Use: Integrate with React to track errors, performance issues, and monitor user interactions.</li> <li>Website: Sentry</li> </ul> <p>3.3 New Relic</p> <ul> <li>Purpose: Application performance monitoring (APM) tool with real-time performance metrics and insights.</li> <li>How to Use: Integrate with your app to monitor performance, errors, and user experience.</li> <li>Website: New Relic</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#4-code-quality-and-best-practices","title":"4. Code Quality and Best Practices","text":"<p>4.1 ESLint</p> <ul> <li>Purpose: A linting tool for identifying and fixing problems in your JavaScript code.</li> <li>How to Use: Integrate with your development workflow to enforce coding standards and catch errors.</li> <li>Website: ESLint</li> </ul> <p>4.2 Prettier</p> <ul> <li>Purpose: Code formatter that ensures consistent styling across your codebase.</li> <li>How to Use: Integrate with your code editor to format code automatically.</li> <li>Website: Prettier</li> </ul>"},{"location":"react/testing/measuring-optimization-tools/#5-documentation-and-development","title":"5. Documentation and Development","text":"<p>5.1 Storybook</p> <ul> <li>Purpose: Develop and test UI components in isolation with interactive documentation.</li> <li>How to Use: Set up Storybook to create a component library and visualize components in various states.</li> <li>Website: Storybook</li> </ul> <p>By leveraging these tools, you can effectively measure, optimize, test, and maintain your React web application, ensuring both performance improvements and code quality.</p>"},{"location":"react/testing/codereport/bugs/cleanup-function/","title":"Cleanup Function","text":"<p>Cleanup functions in React are essential for managing resources and avoiding memory leaks, especially when dealing with asynchronous operations, side effects, or subscriptions. Here\u2019s a breakdown of when and how to use cleanup functions, including patterns and common practices:</p>"},{"location":"react/testing/codereport/bugs/cleanup-function/#when-to-use-cleanup-functions","title":"When to Use Cleanup Functions","text":"<ol> <li> <p>Asynchronous Operations:</p> <ul> <li>Scenario: You make API calls or other asynchronous tasks in <code>useEffect</code> that might still be running when the component unmounts.</li> <li>Solution: Use a flag or an <code>AbortController</code> to cancel the request if the component unmounts.</li> </ul> </li> <li> <p>Subscriptions:</p> <ul> <li>Scenario: You subscribe to external data sources, like WebSocket connections, event listeners, or other subscriptions.</li> <li>Solution: Unsubscribe or clean up listeners when the component unmounts to prevent memory leaks.</li> </ul> </li> <li> <p>Timers:</p> <ul> <li>Scenario: You set up timers or intervals using <code>setTimeout</code> or <code>setInterval</code>.</li> <li>Solution: Clear the timers when the component unmounts to prevent unexpected behavior.</li> </ul> </li> <li> <p>Event Listeners:</p> <ul> <li>Scenario: You add event listeners to the <code>window</code>, <code>document</code>, or other elements.</li> <li>Solution: Remove these event listeners when the component unmounts to avoid memory leaks.</li> </ul> </li> </ol>"},{"location":"react/testing/codereport/bugs/cleanup-function/#popular-cleanup-patterns","title":"Popular Cleanup Patterns","text":"<ol> <li> <p>Using a Mounted Flag:</p> <ul> <li> <p>Pattern: Maintain a flag that tracks whether the component is mounted and use it to conditionally perform state updates.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        if (isMounted) {\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>AbortController for Fetch Requests:</p> <ul> <li> <p>Pattern: Use AbortController to cancel ongoing fetch requests when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('/data', { signal: controller.signal });\n            const data = await response.json();\n            setData(data);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            }\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        controller.abort();\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Cleanup for Event Listeners:</p> <ul> <li> <p>Pattern: Remove event listeners added to global objects or elements.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const handleResize = () =&gt; {\n        console.log('Resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () =&gt; {\n        window.removeEventListener('resize', handleResize);\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Clearing Timers:</p> <ul> <li> <p>Pattern: Clear any intervals or timeouts when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n        console.log('Timer triggered');\n    }, 1000);\n\n    return () =&gt; {\n        clearTimeout(timer);\n    };\n}, []);\n</code></pre> </li> </ul> </li> </ol>"},{"location":"react/testing/codereport/bugs/cleanup-function/#summary","title":"Summary","text":"<ul> <li>Asynchronous Operations: Use a mounted flag or <code>AbortController</code> to cancel ongoing tasks.</li> <li>Subscriptions: Clean up by unsubscribing or removing listeners.</li> <li>Timers: Clear <code>setTimeout</code> or <code>setInterval</code> when the component unmounts.</li> <li>Event Listeners: Remove listeners added to global objects or specific elements.</li> </ul> <p>Using these cleanup techniques helps ensure that your components are efficient and free from memory leaks, providing a better user experience and more reliable performance.</p>"},{"location":"react/testing/codereport/bugs/cleanup-function/#mail-module","title":"Mail Module","text":""},{"location":"react/testing/codereport/bugs/cleanup-function/#memory-leak-in-your-application","title":"memory leak in your application","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</p> TheoryExample <p>\"Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\"</p> <p>occurs when your React component is unmounted (removed from the UI), but an asynchronous operation (like an API call, event listener, or timeout) tries to update the component\u2019s state after it\u2019s already unmounted. This can lead to a memory leak because the state update is unnecessary and React doesn\u2019t know how to handle it anymore.</p> <p>Why This Happens:</p> <p>When a component is unmounted, it no longer exists in the React tree. However, if asynchronous tasks like API requests, <code>setTimeout</code>, or event listeners are still running, they might try to update the state of the unmounted component, which React warns against.</p> <p>How to Fix It:</p> <p>The solution is to clean up any asynchronous tasks when the component unmounts using the <code>cleanup</code> function in the <code>useEffect</code> hook. This ensures that any pending operations like API calls, subscriptions, or timeouts are canceled before the component unmounts, preventing state updates on unmounted components.</p> <p>Fixing a Memory Leak in <code>useEffect</code></p> Before (Potential Problem)After (With Cleanup) <pre><code>useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        setData(result);  // This may cause a state update on an unmounted component\n    };\n\n    fetchData();\n}, []);  // No cleanup, could cause memory leaks\n</code></pre> <p>To prevent the memory leak, you should clean up the asynchronous task when the component unmounts:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;  // This flag will track if the component is still mounted\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n\n        if (isMounted) {  // Only update the state if the component is still mounted\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;  // Clean up when the component unmounts\n    };\n}, []);  // Cleanup ensures that no updates occur if the component is unmounted\n</code></pre> How to Identify the Issue <ul> <li> <p>Look at <code>ReplyChatBox.js</code>, line 292 (based on the error message). There may be an asynchronous operation, such as an API request, event listener, or timeout, that's trying to update the component's state after it has been unmounted.</p> </li> <li> <p>Check all <code>useEffect</code> hooks in that component to ensure you're properly cleaning up any asynchronous tasks, such as:</p> <ul> <li>API calls (e.g., <code>fetch</code>)</li> <li>WebSocket connections</li> <li><code>setTimeout</code> or <code>setInterval</code></li> <li>Event listeners (<code>addEventListener</code>)</li> </ul> </li> </ul> General Steps to Fix <ul> <li>Identify the asynchronous task that is trying to update state after the component has unmounted.</li> <li>Use <code>useEffect</code> cleanup by returning a function that cancels or cleans up any ongoing async operations or event listeners.</li> <li>Use a mounted flag or <code>AbortController</code> for fetch requests to ensure that state is only updated while the component is still mounted.</li> </ul> <p>Example for Fetch Requests with AbortController:</p> <p>If you are using <code>fetch</code>, you can cancel the request using an <code>AbortController</code>:</p> <pre><code>useEffect(() =&gt; {\n  const controller = new AbortController();\n  const signal = controller.signal;\n\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchSomeData({ signal });\n      setData(result);  // Only update if fetch is successful\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        console.log(\"Fetch aborted\");\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    controller.abort();  // Clean up the fetch request when the component unmounts\n  };\n}, []);\n</code></pre> Summary <ul> <li>The warning indicates that some asynchronous task is trying to update state after the component has unmounted.</li> <li>To prevent this, clean up those tasks using <code>useEffect</code> cleanup functions.</li> <li>Be sure to use techniques like the <code>isMounted</code> flag or <code>AbortController</code> to ensure that no state updates occur on unmounted components.</li> </ul>"},{"location":"react/testing/codereport/bugs/cleanup-function/#improved-code-with-cleanup","title":"Improved Code with Cleanup","text":"Bug CodeImporved CodeKey Improvements <pre><code>useEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> <p>Yes, there\u2019s a potential issue with the code related to asynchronous operations and component unmounting. Specifically, if <code>fetchAllParticipants</code> completes after the component has unmounted, it could attempt to call <code>setUsers</code>, which would lead to the warning you saw: \"Can't perform a React state update on an unmounted component.\"</p> <pre><code>import { useEffect, useState } from 'react';\nimport { message } from 'antd'; // Assuming you're using Ant Design for messages\nimport storage from 'some-storage-module'; // Adjust import based on your setup\nimport { getAllUsers } from 'some-api-module'; // Adjust import based on your setup\n\nconst MyComponent = () =&gt; {\n    const [users, setUsers] = useState([]);\n\n    useEffect(() =&gt; {\n        let isMounted = true; // Flag to track component mount status\n\n        const fetchAllParticipants = async () =&gt; {\n            try {\n                const resp = await getAllUsers();\n                if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                    let participantFrom = storage.getItem(\"userId\");\n                    let allUsers = resp.data.filter(\n                        (obj) =&gt; obj.appUserId == participantFrom\n                    );\n                    setUsers(allUsers);\n                }\n            } catch (err) {\n                message.error(\"Failure\");\n            }\n        };\n\n        fetchAllParticipants();\n\n        return () =&gt; {\n            isMounted = false; // Cleanup function to update the flag on unmount\n        };\n    }, []);\n\n\n    return (\n        &lt;div&gt;\n            {/* Render your users or other components here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Mounted Flag: Added <code>let isMounted = true;</code> and updated it in the cleanup function to <code>isMounted = false;</code>. This ensures that state updates only occur if the component is still mounted.</p> </li> <li> <p>Error Handling: Moved the <code>catch</code> block into the <code>try...catch</code> statement to handle any potential errors and show a message if something goes wrong with <code>getAllUsers()</code>.</p> </li> <li> <p>Cleanup Function: Ensured that <code>isMounted</code> is set to <code>false</code> when the component unmounts, which prevents <code>setUsers</code> from being called if the component is no longer present.</p> </li> </ol> <p>Summary:</p> <p>By implementing the mounted flag, you prevent the warning about state updates on an unmounted component. This approach ensures that asynchronous operations don't attempt to update state after the component has unmounted, thereby avoiding potential memory leaks and other issues.</p>"},{"location":"react/testing/codereport/bugs/debouncing/","title":"debouncing","text":""},{"location":"react/testing/codereport/bugs/debouncing/#overview","title":"Overview","text":"<p>Debouncing is a technique used in programming to improve performance and efficiency, particularly in scenarios where certain actions are triggered repeatedly in a short period. Here\u2019s a breakdown of what debouncing is, why it\u2019s needed, and when to use it:</p>"},{"location":"react/testing/codereport/bugs/debouncing/#what-is-debouncing","title":"What is Debouncing?","text":"<p>Debouncing is a method used to ensure that a function is only executed after a certain amount of time has passed since the last time it was invoked. In other words, it limits the rate at which a function can fire by postponing the execution until a period of inactivity has been observed.</p>"},{"location":"react/testing/codereport/bugs/debouncing/#why-do-we-need-debouncing","title":"Why Do We Need Debouncing?","text":"<ol> <li> <p>Performance Improvement: Frequent triggering of functions can cause performance issues, especially if the function involves heavy computations or makes network requests. Debouncing helps to minimize these issues by consolidating multiple triggers into a single execution.</p> </li> <li> <p>User Experience: In web applications, debouncing is often used to improve user experience. For instance, it prevents a search query from being sent to the server on every keystroke, which can be annoying and inefficient.</p> </li> <li> <p>Resource Management: It helps to manage resources better by avoiding unnecessary function calls, reducing the load on both the client and server sides.</p> </li> </ol>"},{"location":"react/testing/codereport/bugs/debouncing/#when-to-use-debouncing","title":"When to Use Debouncing?","text":"<ol> <li> <p>Search Inputs: When implementing search functionality with real-time suggestions, debouncing can prevent excessive querying of a backend server as users type.</p> </li> <li> <p>Window Resizing: If you have functionality that adjusts based on the window size, debouncing can help avoid multiple calls to resize handlers while the user is actively resizing the window.</p> </li> <li> <p>Scroll Events: Debouncing is useful for handling scroll events, especially if you have features that trigger actions based on scrolling.</p> </li> <li> <p>Form Validation: In forms where validation occurs as the user types, debouncing can prevent constant validation checks on every keystroke.</p> </li> </ol>"},{"location":"react/testing/codereport/bugs/debouncing/#example","title":"Example","text":"<p>How to Implement Debouncing</p> <p>Here\u2019s a basic example of how to implement debouncing in JavaScript:</p> <pre><code>function debounce(func, delay) {\n    let timeoutId;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n}\n\n// Usage example:\nfunction search(query) {\n    console.log('Searching for:', query);\n}\n\nconst debouncedSearch = debounce(search, 300);\n\n// Attach debouncedSearch to an input event\ndocument.getElementById('searchInput').addEventListener('input', (event) =&gt; {\n    debouncedSearch(event.target.value);\n});\n</code></pre> <p>In this example:</p> <ul> <li><code>debounce</code> is a higher-order function that takes a function <code>func</code> and a delay in milliseconds.</li> <li>It returns a new function that, when invoked, clears the previous timeout and sets a new one. If the function is invoked again within the delay period, the previous timeout is cleared and a new one is set.</li> <li><code>debouncedSearch</code> is a debounced version of the <code>search</code> function, which will only be called 300 milliseconds after the user stops typing.</li> </ul> <p>By using debouncing, you ensure that <code>search</code> is not called too frequently and is executed only after the user has paused their input.</p>"},{"location":"react/testing/codereport/bugs/debouncing/#react","title":"React","text":"<p>What is Debouncing?</p> <p>Debouncing is a technique to limit how often a function is called. It makes sure that the function is only executed after a certain amount of time has passed since the last call. This is useful in scenarios where a function might be called repeatedly in a short period of time.</p> <p>When to Use Debounce in React</p> Use Debounce WhenDon\u2019t Use Debounce When <ol> <li> <p>User Input: If you have a search input field that triggers an API call or filtering every time the user types.</p> <ul> <li>Why? To avoid making an API call for every keystroke, which could overwhelm the server and slow down the app.</li> </ul> </li> <li> <p>Window Resize: If you have functionality that reacts to window resizing, like adjusting layout or reloading data.</p> <ul> <li>Why? To prevent excessive calls while the user is actively resizing the window.</li> </ul> </li> <li> <p>Scroll Events: If you\u2019re implementing infinite scrolling or tracking scroll position.</p> <ul> <li>Why? To limit how often you perform actions based on the scroll position, improving performance.</li> </ul> </li> </ol> <ol> <li> <p>Instant Feedback: If the action needs to happen immediately without delay, such as a submit button.</p> <ul> <li>Why? Debouncing would introduce a delay, which might not be suitable for actions requiring immediate response.</li> </ul> </li> <li> <p>Non-Frequent Actions: If the function is not triggered frequently or doesn\u2019t affect performance significantly.</p> <ul> <li>Why? Debouncing is unnecessary for actions that don\u2019t occur often or are already well-managed.</li> </ul> </li> </ol> <p>Simple Example with lodash</p> InstallImplementationExplanation <pre><code>npm install lodash\n</code></pre> <p>Here\u2019s a basic React component with a debounced search input:</p> <pre><code>import React, { useState, useCallback } from 'react';\nimport debounce from 'lodash/debounce';\n\nconst SearchComponent = () =&gt; {\n    const [query, setQuery] = useState('');\n    const [results, setResults] = useState([]);\n\n    // Create a debounced function for searching\n    const debouncedSearch = useCallback(\n        debounce(async (searchTerm) =&gt; {\n            if (searchTerm) {\n                try {\n                    const response = await fetch(`https://api.example.com/search?q=${searchTerm}`);\n                    const data = await response.json();\n                    setResults(data);\n                } catch (error) {\n                    console.error('Error fetching data:', error);\n                }\n            } else {\n                setResults([]);\n            }\n        }, 300), // Debounce with a 300ms delay\n        []\n    );\n\n    // Call the debounced search function whenever the query changes\n    const handleChange = (event) =&gt; {\n        const newQuery = event.target.value;\n        setQuery(newQuery);\n        debouncedSearch(newQuery);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                type=\"text\"\n                value={query}\n                onChange={handleChange}\n                placeholder=\"Search...\"\n            /&gt;\n            &lt;ul&gt;\n                {results.map((result, index) =&gt; (\n                    &lt;li key={index}&gt;{result.name}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default SearchComponent;\n</code></pre> <ul> <li> <p>State Variables: <code>query</code> holds the current search input, and <code>results</code> holds the search results.</p> </li> <li> <p>Debounce Function: <code>debouncedSearch</code> is created using <code>lodash</code>'s <code>debounce</code>. It\u2019s called with a 300ms delay, meaning it waits 300ms after the last change before making an API request.</p> </li> <li> <p>Handle Input Change: When the input changes, <code>handleChange</code> updates <code>query</code> and calls the debounced function. The debounced function will only trigger the API call 300ms after the user stops typing.</p> </li> <li> <p>Display Results: The results from the API call are displayed in a list.</p> </li> </ul> Summary <ul> <li>Use Debounce: When you want to limit the frequency of function calls, especially with user input or events that can fire rapidly.</li> <li>Don\u2019t Use Debounce: When immediate action is required or the function is not called frequently enough to benefit from debouncing.</li> </ul> <p>Using lodash for debouncing simplifies this process and ensures efficient performance.</p> COdeExplanation <pre><code>import React, { useCallback, useState } from 'react';\nimport debounce from 'lodash/debounce';\nimport { useDispatch } from 'react-redux'; // or wherever your dispatch is from\n\n// Example of the component\nconst MyComponent = () =&gt; {\n    const [selectedAttendees, setSelectedAttendees] = useState([]);\n    const [hasSelectedAttentionTos, setHasSelectedAttentionTos] = useState(false);\n    const dispatch = useDispatch(); // Assuming you are using Redux for state management\n\n    // Define the debounced version of your dispatch function\n    const debouncedDispatch = useCallback(\n        debounce((selectedPersonIds, selectedCompanyId) =&gt; {\n            dispatch(getCompanyorPersonEmailAddess(selectedPersonIds, selectedCompanyId));\n        }, 300), // Adjust the debounce delay as needed (300ms here)\n        [dispatch]\n    );\n\n    // The handleSelectChange function\n    const handleSelectChange = (values, options) =&gt; {\n        const selectedData = options.map((option) =&gt; ({\n            AttentionTo: option.props.children,\n            AttentionId: option.key,\n        }));\n\n        let selectedPersonIds = selectedData.map((item) =&gt; ({\n            contactPersonIds: item.AttentionId,\n        }));\n\n        setSelectedAttendees(selectedData);\n        setHasSelectedAttentionTos(!isEmpty(values));\n\n        // Call the debounced dispatch function\n        debouncedDispatch(selectedPersonIds, selectedCompanyId);\n    };\n\n    // Your component render logic here\n    return (\n        &lt;div&gt;\n            {/* Render your component here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Install and Import <code>debounce</code>: Import <code>debounce</code> from <code>lodash</code>.</p> </li> <li> <p>Create a Debounced Dispatch Function:</p> <ul> <li>Use <code>useCallback</code> to memoize the debounced function so that it doesn't get recreated on every render.</li> <li>The <code>debouncedDispatch</code> function is created using <code>debounce</code>. It wraps the dispatch call and delays its execution until after 300 milliseconds have passed since the last call. You can adjust this delay as needed.</li> </ul> </li> <li> <p>Update <code>handleSelectChange</code>:</p> <ul> <li>Inside <code>handleSelectChange</code>, instead of calling <code>dispatch</code> directly, call debouncedDispatch with the necessary parameters.</li> <li><code>debouncedDispatch</code> will now ensure that the <code>dispatch</code> function is only called after the specified delay, which prevents it from being called too frequently if <code>handleSelectChange</code> is triggered multiple times in quick succession.</li> </ul> </li> <li> <p>Include Dependencies:</p> <p>Make sure to include <code>dispatch</code> as a dependency in <code>useCallback</code> so that the debounced function is recreated if <code>dispatch</code> changes.</p> </li> </ol> <p>This approach will help you manage performance and reduce the number of times <code>dispatch</code> is called, especially if <code>handleSelectChange</code> is triggered frequently.</p>"},{"location":"react/testing/codereport/bugs/intro/","title":"Intro","text":""},{"location":"react/testing/codereport/bugs/intro/#dashboard-module","title":"Dashboard Module:","text":"Warning: Invalid DOM property <code>class</code>. Did you mean <code>className</code>? Solution <p>search gloal with <code>class=\"</code> and replace with className.</p> Warning: Each child in a list should have a unique \"key\" prop. IssueSolution <p>`PublicEvents.js:183``</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> <p>use unique <code>id</code> instead of <code>index</code>.</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> Warning: Each child in a list should have a unique \"key\" prop. <pre><code>children HonorRollPagiantion.js:153\nHonorRollPagination HonorRollPagiantion.js:139\n</code></pre> IssueSolved <pre><code>HonorRollPagiantion.js\n\n&lt;div\n    className=\"honor__card--circle\"\n\n    // ISSUE HERE\n    key={i}\n&gt;\n</code></pre> <pre><code>&lt;Carousel autoplay={true} dots={false}&gt;\n    {list?.honorRollCandidateDtos?.map(\n    (picture, i) =&gt; {\n        let name = picture?.candidateName;\n        let profilePicNameFL = name\n        ?.match(/\\b(\\w)/g)\n        .join(\"\");\n\n        return (\n        &lt;&gt;\n            &lt;div\n            className=\"honor__card--circle\"\n            key={i}\n            &gt;\n            {!isEmpty(\n                picture.candiateProfilePictureURL\n            ) ? (\n                &lt;img\n                src={\n                    cqBaseUrl +\n                    \"/\" +\n                    picture.candiateProfilePictureURL +\n                    token\n                }\n                alt=\"profile\"\n                /&gt;\n            ) : (\n                &lt;div\n                className=\"default-profile-name\"\n                style={{\n                    width: \"52px\",\n                    height: \"52px\",\n                }}\n                key={i}\n                &gt;\n                {profilePicNameFL}\n                &lt;/div&gt;\n            )}\n            &lt;/div&gt;\n        &lt;/&gt;\n        )\n    })\n    }\n&lt;/Carousel&gt;\n</code></pre> <p>updated the <code>key={i}</code> to <code>key={picture?.id}</code></p> <pre><code>&lt;&gt;\n    &lt;div\n    className=\"honor__card--circle\"\n    key={picture?.id}\n    &gt;\n    {!isEmpty(\n        picture.candiateProfilePictureURL\n    ) ? (\n        &lt;img\n        src={\n            cqBaseUrl +\n            \"/\" +\n            picture.candiateProfilePictureURL +\n            token\n        }\n        alt=\"profile\"\n        /&gt;\n    ) : (\n        &lt;div\n        className=\"default-profile-name\"\n        style={{\n            width: \"52px\",\n            height: \"52px\",\n        }}\n        key={picture?.id}\n        &gt;\n        {profilePicNameFL}\n        &lt;/div&gt;\n    )}\n    &lt;/div&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"react/testing/codereport/bugs/intro/#mail-module","title":"Mail Module","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.</p> BugSolution ReplyChatBox.js<pre><code>// pg: 192\nuseEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n// pg: 281\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> ReplyChatBox.js<pre><code>useEffect(() =&gt; {\n    // fetchAllParticipants();\n    let isMounted = true; // Flag to track component mount status\n\n    const fetchAllParticipants = async () =&gt; {\n        try {\n            const resp = await getAllUsers();\n\n            if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                let participantFrom = storage.getItem(\"userId\");\n                let allUsers = resp.data.filter(\n                    (obj) =&gt; obj.appUserId == participantFrom\n                );\n                setUsers(allUsers);\n            }\n        } catch (err) {\n            message.error(\"Failure\");\n        }\n    };\n\n    fetchAllParticipants();\n\n    return () =&gt; {\n        isMounted = false; // Cleanup function to update the flag on unmount\n    };\n}, []);\n</code></pre>"},{"location":"react/testing/codereport/bugs/master-topic/","title":"master topic","text":"<p>To fully master React and build robust, maintainable applications, you'll want to familiarize yourself with a variety of techniques, patterns, and libraries. Here\u2019s a comprehensive guide to what you should know:</p>"},{"location":"react/testing/codereport/bugs/master-topic/#techniques","title":"Techniques","text":"<ol> <li> <p>Component-Based Architecture:</p> <ul> <li>Understand: How to build reusable and composable components.</li> <li>Key Concepts: Props, state, lifecycle methods, hooks.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Local State: Use <code>useState</code> and <code>useReducer</code>.</li> <li>Global State: Understand Context API and third-party libraries like Redux or Zustand.</li> </ul> </li> <li> <p>Effect Management:</p> <ul> <li>Understand: Side effects in components using <code>useEffect</code>.</li> <li>Best Practices: Cleanup functions, dependencies.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Techniques: Memoization with <code>useMemo</code> and <code>useCallback</code>, code splitting, lazy loading components with <code>React.lazy</code> and <code>Suspense</code>.</li> <li>Tools: React Profiler, performance monitoring tools.</li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Understand: Controlled vs. uncontrolled components.</li> <li>Libraries: React Hook Form, Formik.</li> </ul> </li> <li> <p>Routing:</p> <ul> <li>Library: React Router.</li> <li>Concepts: Dynamic routing, nested routes, route guards.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Technique: Error boundaries to catch JavaScript errors anywhere in the component tree.</li> <li>Best Practices: Display user-friendly error messages.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Tools: Jest for unit testing, React Testing Library for component testing.</li> <li>Concepts: Mocking, snapshot testing.</li> </ul> </li> <li> <p>Styling:</p> <ul> <li>Options: CSS-in-JS libraries (styled-components, Emotion), CSS modules, and traditional CSS/Sass.</li> </ul> </li> <li> <p>Server-Side Rendering (SSR) and Static Site Generation (SSG):</p> <ul> <li>Frameworks: Next.js for SSR and SSG.</li> <li>Concepts: Benefits of SSR, SSG vs. CSR (Client-Side Rendering).</li> </ul> </li> <li> <p>Internationalization (i18n):</p> <ul> <li>Library: react-i18next for localization.</li> </ul> </li> <li> <p>Accessibility:</p> <ul> <li>Best Practices: Use semantic HTML, ARIA attributes, and tools like Lighthouse.</li> </ul> </li> </ol>"},{"location":"react/testing/codereport/bugs/master-topic/#patterns","title":"Patterns","text":"<ol> <li> <p>Functional vs. Class Components:</p> <ul> <li>Understand: Differences and when to use each.</li> </ul> </li> <li> <p>Higher-Order Components (HOCs):</p> <ul> <li>Concept: A pattern for reusing component logic.</li> </ul> </li> <li> <p>Render Props:</p> <ul> <li>Concept: A pattern for sharing code between components using a function that returns a React element.</li> </ul> </li> <li> <p>Custom Hooks:</p> <ul> <li>Concept: Encapsulate reusable logic into custom hooks.</li> </ul> </li> <li> <p>Context API for Dependency Injection:</p> <ul> <li>Concept: Provide and consume context to avoid prop drilling.</li> </ul> </li> <li> <p>Controlled and Uncontrolled Components:</p> <ul> <li>Concept: Managing form inputs and state.</li> </ul> </li> <li> <p>Compound Components:</p> <ul> <li>Concept: Design components that work together and share implicit state.</li> </ul> </li> <li> <p>Function-as-Child (Render Props):</p> <ul> <li>Concept: Sharing component logic with a function that provides children.</li> </ul> </li> </ol>"},{"location":"react/testing/codereport/bugs/master-topic/#libraries-and-tools","title":"Libraries and Tools","text":"<ol> <li> <p>State Management Libraries:</p> <ul> <li>Redux: For complex state management.</li> <li>Zustand: Lightweight state management.</li> <li>Recoil: For managing state with atoms and selectors.</li> </ul> </li> <li> <p>Data Fetching Libraries:</p> <ul> <li>Axios: For HTTP requests.</li> <li>React Query: For server-state management and data fetching.</li> </ul> </li> <li> <p>Routing Libraries:</p> <ul> <li>React Router: For client-side routing.</li> </ul> </li> <li> <p>Styling Libraries:</p> <ul> <li>styled-components: For CSS-in-JS styling.</li> <li>Emotion: Another CSS-in-JS library.</li> </ul> </li> <li> <p>Form Handling Libraries:</p> <ul> <li>React Hook Form: Simplifies form handling and validation.</li> <li>Formik: Another popular form management library.</li> </ul> </li> <li> <p>Testing Libraries:</p> <ul> <li>Jest: For unit testing.</li> <li>React Testing Library: For testing React components.</li> </ul> </li> <li> <p>Development Tools:</p> <ul> <li>ESLint: For code quality and consistency.</li> <li>Prettier: For code formatting.</li> </ul> </li> <li> <p>Build Tools:</p> <ul> <li>Webpack: For module bundling.</li> <li>Vite: A modern build tool that provides fast development server and optimized builds.</li> </ul> </li> <li> <p>Server-Side Frameworks:</p> <ul> <li>Next.js: For SSR and static site generation.</li> </ul> </li> <li> <p>Internationalization Libraries:</p> <ul> <li>react-i18next: For managing translations.</li> </ul> </li> <li> <p>Accessibility Tools:</p> <ul> <li>React Axe: For accessibility auditing.</li> </ul> </li> <li> <p>GraphQL Libraries:</p> <ul> <li>Apollo Client: For managing GraphQL data.</li> </ul> </li> </ol>"},{"location":"react/testing/codereport/bugs/master-topic/#summary","title":"Summary","text":"<ul> <li>Master React Basics: Components, state, props, hooks.</li> <li>Adopt Advanced Patterns: HOCs, render props, custom hooks.</li> <li>Optimize Performance: Memoization, code splitting, lazy loading.</li> <li>Use Libraries Wisely: State management (Redux, Zustand), data fetching (React Query), styling (styled-components), routing (React Router).</li> <li>Test Your Code: With Jest and React Testing Library.</li> <li>Handle Forms and Internationalization: With React Hook Form or Formik, and react-i18next.</li> <li>Stay Updated: With new React features and best practices.</li> </ul> <p>By understanding and applying these techniques, patterns, and libraries, you'll be well-equipped to build robust, efficient, and maintainable React applications.</p>"},{"location":"react/testing/codereport/bugs/solution/","title":"Solution","text":""},{"location":"react/testing/codereport/bugs/solution/#dashboard-module","title":"Dashboard Module","text":""},{"location":"react/testing/codereport/bugs/solution/#each-child-in-a-list-should-have-a-unique-key-prop","title":"Each child in a list should have a unique \"key\" prop","text":"Warning: Each child in a list should have a unique \"key\" prop. <p>Check the render method of <code>PublicEvents</code>. See https://reactjs.org/link/warning-keys for more information. PublicEvents@http://localhost:3000/static/js/main.chunk.js:218280:7</p> <p><code>PublicEvents.js:183</code></p> SourceSolutionTheory <pre><code># PublicEvents.js\n# page number : 189\n</code></pre> PublicEvents.js<pre><code>    &lt;&gt;\n        {data?.length &gt; 0 ? (\n          data?.map((list, i) =&gt; (\n            &lt;&gt;\n              {list.event !== \"day\" ? (\n                &lt;li\n                  key={i}\n                  className=\"dashboards__events--list\"\n                  style={{ padding: \"0px\" }}\n                &gt;\n                  &lt;div\n                    className={`dashboards__events--listTitle ${list?.event} `}\n                    style={{ flex: 6 }}\n                  &gt;\n                    &lt;span\n                      style={{ width: \"20px\", display: \"inline-block\" }}\n                    &gt;\n                      {i + 1}.\n                    &lt;/span&gt;\n\n                    {/* COMMENT */}\n                )})))}\n</code></pre> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n    ))\n) : null}\n</code></pre> <p>Key changes:</p> <ul> <li>Used <code>list.id</code> as the key prop: React expects each item in a list to have a unique key for efficient rendering. Using list.id ensures that React can uniquely identify each item.</li> <li>Avoided using i (the index) as the key: Using the index as a key can lead to issues when items in the list are reordered or when items are added/removed, causing incorrect re-rendering.</li> </ul> <p>If list.id is guaranteed to be unique, this should fix the warning you're seeing.</p>"},{"location":"react/testing/codereport/bugs/solution/#problem-title","title":"Problem Title","text":"<p>Problem Title: React List Rendering Warning: \"Each child in a list should have a unique 'key' prop\"</p> Problem Explanation <p>In React, when rendering a list of elements using the <code>.map()</code> method, each element must have a unique <code>key</code> prop. This key helps React efficiently identify and manage each item in the list, especially when items are added, removed, or reordered.</p> <p>If you don\u2019t provide a unique key for each list item, or if you use an unstable key (like an index <code>i</code>), React will display a warning: \"Each child in a list should have a unique 'key' prop\".</p> Why It Happens <p>When React renders a list, it needs to know which items are which. If items change order or some are removed/added, React uses the <code>key</code> prop to track these changes. If the key isn\u2019t unique or stable, React might:</p> <ol> <li>Re-render items unnecessarily.</li> <li>Confuse one item with another, leading to incorrect behavior (e.g., losing input values in a form).</li> </ol> <p>To avoid this issue, always provide a unique identifier (such as <code>id</code> from the list object) as the <code>key</code> prop instead of using something that might change, like an array index.</p>"},{"location":"react/testing/codereport/bugs/solution/#few-strategies","title":"Few strategies","text":"<p>If you don't receive a unique ID from the API, there are a few strategies you can use to provide a stable <code>key</code> for each list item in React. Here are some common solutions:</p> <ol> <li> <p>Generate a Unique ID Locally (Using a Library)</p> <p>You can use libraries like <code>uuid</code> or <code>nanoid</code> to generate unique IDs for each item when you don't have one from the API. This is a good approach if the list doesn't change frequently or you're fine with generating new IDs on each render.</p> <p>Using <code>uuid</code>:</p> <pre><code>npm install uuid\n</code></pre> <pre><code>import { v4 as uuidv4 } from \"uuid\";\n\n{\n  data?.length &gt; 0\n    ? data.map((list) =&gt; (\n        &lt;li key={uuidv4()}&gt;{list.name}&lt;/li&gt; // Generate a unique key for each item\n      ))\n    : null;\n}\n</code></pre> <p>This ensures each item has a stable, unique key.</p> </li> <li> <p>Combine Multiple Properties to Form a Unique Key</p> <p>If the items have other properties that are relatively unique, you can combine those properties to create a unique key.</p> <p>For example, if you have a list of users but no unique <code>id</code>, you can combine <code>name</code> and <code>email</code> or other available fields:</p> <pre><code>{\n  data?.length &gt; 0\n    ? data.map((list) =&gt; (\n        &lt;li key={`${list.name}-${list.email}`}&gt;{list.name}&lt;/li&gt; // Combine properties\n      ))\n    : null;\n}\n</code></pre> <p>This method works as long as the combination of properties guarantees uniqueness.</p> </li> <li> <p>Use the Index with Caution</p> <p>If none of the above options are available and the list is static (i.e., the order of the items doesn't change, and items are never added/removed), you can use the index as the key temporarily:</p> <pre><code>{\n  data?.length &gt; 0\n    ? data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n      ))\n    : null;\n}\n</code></pre> <p>However, using the index as a key is not ideal for dynamic lists, because:</p> <ul> <li>If the list changes (items are reordered, added, or removed), React can misidentify the items.</li> <li>Component states could get mixed up when using the index.</li> </ul> </li> </ol> Summary <ul> <li>Best Practice: Use a unique <code>id</code> if available.</li> <li>Fallback Options: Generate unique IDs locally, combine fields to create a unique key, or cautiously use the index if the list doesn't change frequently.</li> </ul>"},{"location":"react/testing/codereport/bugs/solution/#best-choice","title":"Best choice","text":"<p>The best choice depends on the specific use case, but generally speaking:</p> <ol> <li> <p>Use a Unique ID from the Data (Best Option)</p> <p>If the API provides a unique <code>id</code> (like a database <code>id</code>, <code>uuid</code>, etc.), this is always the best option. It ensures stability and guarantees uniqueness even when the list changes (items added, removed, or reordered).</p> </li> <li> <p>Generate a Unique ID Locally (Good Alternative)</p> <p>If the API doesn\u2019t provide a unique <code>id</code>, generating a unique ID using a library like <code>uuid</code> or <code>nanoid</code> is the next best option. This approach creates a stable unique key for each item.</p> <ul> <li>Why it's good: Each key is truly unique and doesn\u2019t depend on changing data.</li> <li>When to use: When the list items are dynamic, and you need stable keys even after re-renders.</li> </ul> </li> <li> <p>Combine Properties to Form a Key (Depends on Uniqueness)</p> <p>If there are certain properties that can be combined to create a unique value (like combining <code>name</code> and <code>email</code>), this is a valid approach. However, this method only works if the combination is guaranteed to be unique across all items.</p> <ul> <li>Why it's good: It avoids adding external dependencies.</li> <li>When to use: If the list contains objects with multiple consistent properties, but no single unique identifier.</li> </ul> </li> <li> <p>Use the Index (Last Resort)</p> <p>Using the array index (<code>i</code>) as the key should be the last resort and only in very specific cases where:</p> <ul> <li>The list won\u2019t change (no new items added, no reordering).</li> <li> <p>It\u2019s acceptable to lose performance and stability benefits.</p> </li> <li> <p>Why it's risky: Keys based on the index can lead to incorrect updates when items are added, removed, or reordered.</p> </li> </ul> </li> </ol> Best Choice Recommendation <ol> <li>Unique ID from API (best).</li> <li>Generated unique ID using libraries like <code>uuid</code>.</li> <li>Combine properties (if you can guarantee uniqueness).</li> <li>Index as key (last resort, use with caution).</li> </ol> <p>In general, using a unique identifier from the data or generating a unique key locally is the most stable and reliable approach for React's list rendering.</p>"},{"location":"react/topic/abort-controller-solved/","title":"Abort Controller Solved","text":""},{"location":"react/topic/abort-controller-solved/#solution","title":"Solution","text":"<p>how to solve the fetching data in the react 18 inside useEffect</p> <p>Fetching data inside a <code>useEffect</code> hook in React 18 is similar to how it\u2019s done in previous versions, but you need to handle some additional considerations due to changes and improvements in React 18, particularly with Strict Mode.</p> <p>Here\u2019s a step-by-step guide to handling data fetching inside <code>useEffect</code> effectively:</p> <ol> <li> <p>Basic Data Fetching with <code>useEffect</code></p> <p>Here\u2019s a simple example of how to fetch data in useEffect:</p> CodeFull Code <pre><code>useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data');\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (error) {\n            setError(error.message);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        // Optional: You can clean up here if needed\n    };\n}, []); \n</code></pre> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data');\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const result = await response.json();\n                setData(result);\n            } catch (error) {\n                setError(error.message);\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to run when the component unmounts\n        return () =&gt; {\n            // Optional: You can clean up here if needed\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    // Render the component UI based on the state\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n    if (!data) return &lt;div&gt;No data found&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data:&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> <li> <p>Handling Component Unmounts</p> <p>React\u2019s Strict Mode might cause components to mount and unmount multiple times during development to help identify potential issues. To handle this, you should ensure that your data fetching logic can gracefully handle unmounting:</p> <ul> <li><code>AbortController</code>: This is a good way to cancel ongoing network requests if the component unmounts.</li> </ul> CodeExample <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController(); // Create a new AbortController\n    const { signal } = controller;\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data', { signal });\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (error) {\n            if (error.name !== 'AbortError') { // Ignore AbortError errors\n                setError(error.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when component unmounts\n    };\n}, []);\n</code></pre> <p>Here\u2019s how you can use <code>AbortController</code>:</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const controller = new AbortController(); // Create a new AbortController\n        const { signal } = controller;\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data', { signal });\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const result = await response.json();\n                setData(result);\n            } catch (error) {\n                if (error.name !== 'AbortError') { // Ignore AbortError errors\n                    setError(error.message);\n                }\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function\n        return () =&gt; {\n            controller.abort(); // Abort the fetch request when component unmounts\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    // Render the component UI based on the state\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n    if (!data) return &lt;div&gt;No data found&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data:&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> <li> <p>Understanding Strict Mode Behavior</p> <p>React 18 Strict Mode is designed to help you find problems in your components by intentionally running certain lifecycle methods twice. Here\u2019s what you should know:</p> <ul> <li> <p>Development Only: Strict Mode\u2019s double-mount behavior happens only in development mode and not in production.</p> </li> <li> <p>Focus on Cleanup: Ensure that any side effects (like data fetching) are properly cleaned up in the cleanup function of <code>useEffect</code>.</p> </li> </ul> </li> </ol> Summary <ul> <li>Data Fetching: Use an async function inside <code>useEffect</code> to handle data fetching.</li> <li>Abort Requests: Use <code>AbortController</code> to cancel requests if the component unmounts.</li> <li>Strict Mode: React\u2019s Strict Mode may cause double mounting in development, so handle cleanup properly to avoid issues.</li> </ul> <p>By following these practices, you can ensure that your data fetching logic works correctly and efficiently in React 18, even with Strict Mode\u2019s additional checks.</p>"},{"location":"react/topic/abort-controller-solved/#updated-example","title":"Updated Example","text":"<p>In React's Strict Mode, components can be intentionally rendered twice to help identify potential side effects and ensure that your components are resilient to such situations. This double-rendering happens in development mode only, not in production.</p> <p>In your <code>fetchData</code> function, you've used an <code>AbortController</code> to manage the fetch request and handle the cancellation of the request if the component unmounts or if the <code>useEffect</code> cleanup function is called. This is an effective way to prevent updates to unmounted components and avoid potential memory leaks.</p> ExplanationUpdatedUseEffect and Cleanup <p>Here's a breakdown of why your <code>catch</code> block works correctly in Strict Mode:</p> <ol> <li> <p>AbortController and Cleanup:</p> <ul> <li><code>AbortController</code> is used to cancel the fetch request if the component unmounts or if the <code>useEffect</code> cleanup function is triggered.</li> <li>When <code>controller.abort()</code> is called, the fetch request is aborted, and an <code>AbortError</code> is thrown. 0   The <code>catch</code> block in your <code>fetchData</code> function handles this <code>AbortError</code> and ignores it, so it doesn't interfere with the component's state updates.</li> </ul> </li> <li> <p>Strict Mode Behavior:</p> <ul> <li>Strict Mode causes your component to render twice in development mode to help identify side effects. This means that <code>fetchData</code> may be called twice, and both calls would receive the same <code>signal</code> from the <code>AbortController</code>.</li> <li>When the component is unmounted or cleaned up, <code>controller.abort()</code> will be called, leading to an <code>AbortError</code>. The <code>catch</code> block will then handle this error by checking its name.</li> </ul> </li> <li> <p>Handling <code>AbortError</code>:</p> <ul> <li>You correctly handle <code>AbortError</code> by checking <code>error.name !== 'AbortError'</code>. This ensures that the <code>AbortError</code> is ignored and does not set the error state (<code>setError</code>).</li> <li>For other types of errors (e.g., network errors), you set the error state (<code>setError(error.message)</code>), which allows you to handle and display those errors appropriately.</li> </ul> </li> </ol> <p>Here\u2019s your <code>fetchData</code> function with comments explaining each part:</p> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`, // Include the API key if needed\n            },\n            signal, // Pass the signal to abort the request if needed\n        });\n\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        setData(data); // Update state with fetched data\n    } catch (error) {\n        // Handle errors except for AbortError\n        if (error.name !== 'AbortError') {\n            setError(error.message); // Update state with the error message\n        }\n    } finally {\n        setLoading(false); // Ensure loading state is updated\n    }\n};\n</code></pre> <p>The <code>useEffect</code> ensures that the fetch operation is properly cleaned up when the component unmounts:</p> <pre><code>useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when the component unmounts\n    };\n}, []); // Empty dependency array ensures this effect runs only once\n</code></pre> <p>In summary, your approach is correct. The <code>AbortError</code> is handled gracefully, ensuring that it doesn\u2019t interfere with other potential errors and allows for clean-up and proper handling in Strict Mode.</p>"},{"location":"react/topic/abort-controller-solved/#improvement","title":"Improvement","text":"<p>Yes, the approach you've taken is generally good for production, but there are a few considerations to ensure that it remains robust and optimized:</p> Production ReadinessEnhanced <code>fetchData</code>Example of <code>useEffect</code> <p>Key Points for Production Readiness</p> <ol> <li> <p>AbortController:</p> <p>Using <code>AbortController</code> is a good practice to avoid potential memory leaks and update attempts on unmounted components. It ensures that the fetch request is properly canceled if the component is unmounted or if the request is no longer needed.</p> </li> <li> <p>Error Handling:</p> <p>Handling <code>AbortError</code> gracefully is important. Ignoring <code>AbortError</code> ensures that your error handling only focuses on actual issues with the network request, rather than interruptions you expect and handle.</p> </li> <li> <p>Environment Variables:</p> <p>Make sure your environment variables (<code>REACT_APP_API_URL</code> and <code>REACT_APP_API_KEY</code>) are correctly set in your production environment and are secure. Avoid exposing sensitive information directly in your client-side code.</p> </li> <li> <p>Performance:</p> <p>While the double rendering in React's Strict Mode is only in development, you should ensure that your <code>useEffect</code> and state management are efficient. Avoid unnecessary state updates and ensure that your fetch logic is optimized.</p> </li> <li> <p>Error Reporting:</p> <p>For production, consider implementing a more robust error logging and reporting mechanism. Libraries like Sentry or LogRocket can help track and report errors that occur in your production environment.</p> </li> <li> <p>API Key Management:</p> <p>If you\u2019re using an API key, consider using environment variables or a secure method to manage it. Exposing API keys in the client code is generally not recommended, as it can lead to security vulnerabilities. Instead, consider server-side handling of sensitive information where possible.</p> </li> <li> <p>Loading State:</p> <p>Ensure that the loading state (<code>setLoading(false)</code>) is managed correctly to provide feedback to users while data is being fetched. This helps improve user experience.</p> </li> </ol> <p>Example of an Enhanced <code>fetchData</code></p> <p>Here\u2019s an enhanced version of your <code>fetchData</code> function with additional comments and considerations:</p> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n        // Prepare the request headers\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${apiKey}`, // Include the API key if needed\n        };\n\n        // Perform the fetch request\n        const response = await fetch(url, { method: 'GET', headers, signal });\n\n        // Check if the response was successful\n        if (!response.ok) {\n            throw new Error(`Network response was not ok: ${response.statusText}`);\n        }\n\n        // Parse the JSON data from the response\n        const data = await response.json();\n        setData(data); // Update state with fetched data\n\n    } catch (error) {\n        // Handle errors except for AbortError\n        if (error.name !== 'AbortError') {\n            setError(error.message); // Update state with the error message\n            console.error('Fetch error:', error); // Log the error for debugging\n        }\n    } finally {\n        setLoading(false); // Ensure loading state is updated\n    }\n};\n</code></pre> <p>Here\u2019s a more complete example of how you might use <code>fetchData</code> in a <code>useEffect</code>:</p> <pre><code>useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    // Ensure API_URL and API_KEY are defined\n    if (!API_URL || !API_KEY) {\n        console.error('API_URL or API_KEY is not defined');\n        return;\n    }\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when the component unmounts\n    };\n}, []); // Empty dependency array ensures this effect runs only once\n</code></pre> <p>Conclusion</p> <p>Your approach is solid for production with the current implementation. Ensure to follow best practices for error handling, performance optimization, and secure management of sensitive data. With these considerations, your data fetching and component management should be effective and reliable in a production environment.</p>"},{"location":"react/topic/cleanup/","title":"Cleanup","text":""},{"location":"react/topic/cleanup/#what-is-cleanup","title":"What is Cleanup?","text":"<p>Cleanup is a way of making sure that when a component is removed from the screen (unmounted), any ongoing operations or resources it was using are properly cleaned up to avoid problems like memory leaks or unexpected behavior.</p>"},{"location":"react/topic/cleanup/#when-do-you-need-cleanup","title":"When Do You Need Cleanup?","text":"<p>Here are some broad categories and everyday examples to help illustrate:</p>"},{"location":"react/topic/cleanup/#1-ongoing-operations","title":"1.  Ongoing Operations","text":"<ul> <li>Example: You have a timer that does something every few seconds (like a clock or a poller).</li> <li>Why Cleanup: If the component using the timer gets removed, you don\u2019t want that timer still running in the background. It could keep trying to update a component that no longer exists, which could lead to errors or waste resources.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const intervalId = setInterval(() =&gt; {\n        console.log('Tick');\n    }, 1000);\n\n    // Cleanup\n    return () =&gt; clearInterval(intervalId);\n}, []);\n</code></pre>"},{"location":"react/topic/cleanup/#2-asynchronous-requests","title":"2. Asynchronous Requests","text":"<ul> <li>Example: You\u2019re making a network request to fetch data from a server.</li> <li>Why Cleanup: If the request takes time and the component gets removed before it finishes, you might try to update a component that no longer exists, which can cause errors. Cleanup ensures you stop the request if it\u2019s no longer needed.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    // Cleanup\n    return () =&gt; controller.abort();\n}, []);\n</code></pre>"},{"location":"react/topic/cleanup/#3-subscriptions","title":"3. Subscriptions","text":"<ul> <li>Example: You\u2019re listening to a data stream or a real-time event (like a WebSocket connection).</li> <li>Why Cleanup: If you\u2019re listening to events and the component is removed, you should stop listening to avoid unnecessary network usage or errors.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const socket = new WebSocket('ws://example.com');\n    socket.onmessage = (event) =&gt; {\n        console.log('Message:', event.data);\n    };\n\n    // Cleanup\n    return () =&gt; socket.close();\n}, []);\n</code></pre>"},{"location":"react/topic/cleanup/#4-event-listeners","title":"4. Event Listeners","text":"<ul> <li>Example: You\u2019re adding a listener to the <code>window</code> to detect when the user resizes the browser.</li> <li>Why Cleanup: If the component is removed, the event listener should be removed to avoid potential memory leaks or errors.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const handleResize = () =&gt; {\n        console.log('Window resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup\n    return () =&gt; window.removeEventListener('resize', handleResize);\n}, []);\n</code></pre>"},{"location":"react/topic/cleanup/#general-rule-for-cleanup","title":"General Rule for Cleanup","text":"<p>If your component does something that might continue after it\u2019s removed from the screen (like running timers, making network requests, listening to events), you should provide a cleanup function to stop or undo that activity.</p>"},{"location":"react/topic/cleanup/#why-cleanup-is-important","title":"Why Cleanup is Important","text":"<ul> <li>Prevents Memory Leaks: If you don\u2019t clean up resources, they might keep using memory even after the component is gone.</li> <li>Avoids Errors: Ensures that your app doesn\u2019t try to update or interact with components that no longer exist.</li> <li>Improves Performance: Frees up resources when they\u2019re no longer needed, leading to better performance.</li> </ul> <p>In summary, cleanup in React is about making sure your components are good neighbors\u2014tidying up after themselves so they don\u2019t leave messes behind when they\u2019re done.</p>"},{"location":"react/topic/cleanup/#block-or-concise-body-in-return","title":"Block or Concise Body in <code>return</code>","text":"<p>Both of these syntax options for cleanup functions in React's <code>useEffect</code> hook are functionally equivalent, but they have subtle differences in style and readability. Let\u2019s break down each option and discuss when to use each:</p>"},{"location":"react/topic/cleanup/#1-using-a-block-body","title":"1. Using a Block Body:","text":"Basic ExampleCharacteristicsWhen to Use <pre><code>return () =&gt; {\n    controller.abort();\n};\n</code></pre> <ul> <li>Block Body: The <code>return</code> statement uses a block body <code>{}</code> which allows for multiple statements inside the cleanup function.</li> <li>Readability: This syntax can be more readable and flexible when the cleanup function needs to perform multiple actions or when additional logic is needed.</li> </ul> <ul> <li>Multiple Statements: Use this syntax if your cleanup function involves multiple operations. For example, you might need to abort a fetch request and also remove event listeners or perform other cleanup tasks.</li> </ul> <pre><code>return () =&gt; {\n    controller.abort();\n    console.log('Cleanup complete');\n    // Additional cleanup tasks\n};\n</code></pre> <ul> <li>Complex Logic: When you need to include more complex logic or conditions within the cleanup function, a block body is preferable for clarity.</li> </ul>"},{"location":"react/topic/cleanup/#2-using-a-concise-body","title":"2. Using a Concise Body:","text":"Basic ExampleCharacteristicsWhen to Use <pre><code>return () =&gt; controller.abort();\n</code></pre> <ul> <li>Concise Body: The <code>return</code> statement uses a single expression without a block body. It\u2019s often more compact and concise.</li> <li>Readability: This syntax is clear and succinct when the cleanup function only needs to execute a single line of code.</li> </ul> <ul> <li>Single Statement: Use this syntax when the cleanup function consists of a single operation. It\u2019s a more streamlined approach for simple cleanup tasks.</li> </ul>"},{"location":"react/topic/cleanup/#example-usage","title":"Example Usage","text":"<p>Single Statement Cleanup: If you only need to abort a fetch request, the concise body is sufficient and keeps your code clean.</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    return () =&gt; controller.abort();\n}, []);\n</code></pre> <p>Multiple Statements Cleanup: If you need to perform several cleanup actions, the block body is more appropriate.</p> BasicAdvanced <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    return () =&gt; {\n        controller.abort();\n        console.log('Fetch aborted and cleanup complete');\n        // Additional cleanup tasks if needed\n    };\n}, []);\n</code></pre> <pre><code>useEffect(() =&gt; {\n    // Establishing a WebSocket connection\n    const socket = new WebSocket('ws://example.com/chat');\n\n    // Function to handle incoming messages\n    const handleMessage = (event) =&gt; {\n        console.log('Message received:', event.data);\n    };\n\n    // Function to handle window resize events\n    const handleResize = () =&gt; {\n        console.log('Window resized');\n    };\n\n    // Adding event listeners\n    window.addEventListener('resize', handleResize);\n    socket.addEventListener('message', handleMessage);\n\n    // Cleanup function\n    return () =&gt; {\n        // Close WebSocket connection\n        socket.close();\n        console.log('WebSocket connection closed');\n\n        // Remove event listeners\n        window.removeEventListener('resize', handleResize);\n        socket.removeEventListener('message', handleMessage);\n        console.log('Event listeners removed');\n    };\n}, []);\n</code></pre>"},{"location":"react/topic/cleanup/#summary","title":"Summary","text":"<ul> <li> <p>Use a Block Body when you need to perform multiple cleanup actions or when including additional logic is necessary. It\u2019s more versatile and readable for complex cleanup scenarios.</p> </li> <li> <p>Use a Concise Body for simple cleanup tasks that involve only a single action. It\u2019s more succinct and keeps your code neat for straightforward scenarios.</p> </li> </ul> <p>Both approaches are valid and serve different needs based on the complexity of your cleanup logic. Choose the one that best fits the task at hand and improves code readability and maintainability.</p>"},{"location":"react/topic/code-for-change/","title":"Code For Change","text":""},{"location":"react/topic/code-for-change/#question","title":"Question","text":"How to: api, reducer, action <pre><code>src\n    services\n        redux\n            groupchat\n                action.js\n                reducer.js\n                api.js\n            contact\n                action.js\n                reducer.js\n                api.js\n        store\n            middlewares\n                app.js\n            index.js\n            StoreProvider.js\n    common.js\n    commonService.js\n    remanentCalls.js\n    types.js\n</code></pre> APIAction api<pre><code>import queryString from \"query-string\";\nimport { appBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class FingerPrintService {\n    addFingerPrint(q) {\n        let query = queryString.stringify(q);\n        let url = `${appBaseUrl}/attendance/allFingerPrintDataByDateRangeAdd?${query}`;\n        // local\n        // let url = `http://localhost:7143/FingerPrintData/GetRevisedFingerPrintDataByDateRange?${query}`;\n        let data = postService(url);\n        return data;\n    }\n}\n</code></pre> action.js<pre><code>import  { FINGER_PRINT_TYPES } from '../../types';\nimport { init, success, finish, error } from 'services/common';\nimport { message } from 'antd';\nimport { FingerPrintService } from \"./api\"\n\nconst fingerPrintService = new FingerPrintService();\n\nexport const fingerPrintAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        const resp = await fingerPrintService.addFingerPrint(body);\n        dispatch(finish(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        if(resp.isSuccess) {\n            dispatch(success(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT, resp.data))\n            message.success(\"Data pull successfully\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n\n    }\n} \n</code></pre> Redux Folder Structure Example 1. Basic Structure2. Intermediate Structure3. Advanced Structure <p>For a small to medium-sized application, you might keep things straightforward:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- actions/\n|   |   |-- exampleActions.js\n|   |-- reducers/\n|   |   |-- exampleReducer.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>actions/: Contains action creators.</li> <li>reducers/: Contains reducer functions.</li> <li>store.js: Configures and exports the Redux store.</li> </ul> store.js<pre><code>import { createStore, combineReducers } from 'redux';\nimport exampleReducer from './reducers/exampleReducer';\n\nconst rootReducer = combineReducers({\n    example: exampleReducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>As your application grows, you might want to organize things a bit more and introduce concepts like feature modules:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- feature1/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- feature2/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>feature1/ and feature2/: Feature-specific folders that include actions, reducers, and types (action type constants).</li> <li>types.js: Contains action type constants to avoid typos and make actions easier to manage.</li> </ul> feature1/actions.jsfeature1/reducer.jsstore.js actions.js<pre><code>import { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> reducer.js<pre><code>import { FEATURE1_ACTION } from './types';\nconst initialState = {};\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n        return { ...state, ...action.payload };\n        default:\n        return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <pre><code>import { createStore, combineReducers } from 'redux';\nimport feature1Reducer from './feature1/reducer';\nimport feature2Reducer from './feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>For larger applications, a more scalable and maintainable structure is often needed. This includes organizing by feature and separating concerns:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- features/\n|   |   |-- feature1/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |   |-- feature2/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |-- rootReducer.js\n|   |-- store.js\n|   |-- thunks/\n|   |   |-- feature1Thunks.js\n|   |   |-- feature2Thunks.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>features/: Organizes Redux code by feature or domain.</li> <li>selectors.js: Contains selector functions to derive data from the state.</li> <li>rootReducer.js: Combines all reducers into a single root reducer.</li> <li>thunks/: Contains asynchronous action creators (thunks) if using Redux Thunk for async operations.</li> </ul> selectors.jsactions.jsreducer.js javascript<pre><code>// features/feature1/selectors.js\n\nexport const getFeature1Data = (state) =&gt; state.feature1.data;\n</code></pre> javascript<pre><code>// features/feature1/actions.js\n\nimport { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> javascript<pre><code>// features/feature1/reducer.js\n\nimport { FEATURE1_ACTION } from './types';\n\nconst initialState = { data: [] };\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n            return { ...state, data: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <p>Types</p> <pre><code>// feature1/types.js\nexport const FEATURE1_ACTION = 'FEATURE1_ACTION';\nexport const FEATURE1_LOAD_REQUEST = 'FEATURE1_LOAD_REQUEST';\nexport const FEATURE1_LOAD_SUCCESS = 'FEATURE1_LOAD_SUCCESS';\nexport const FEATURE1_LOAD_FAILURE = 'FEATURE1_LOAD_FAILURE';\n</code></pre> <p>Reducer</p> rootReducer.jsstore.js <pre><code>import { combineReducers } from 'redux';\nimport feature1Reducer from './features/feature1/reducer';\nimport feature2Reducer from './features/feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nexport default rootReducer;\n</code></pre> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport rootReducer from './rootReducer';\nimport thunk from 'redux-thunk';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <p>This advanced structure helps in managing larger codebases by organizing Redux logic more effectively and separating concerns for better maintainability and scalability.</p> To determine if a React application is using Redux Thunk or Redux Saga middleware <p>To determine if a React application is using Redux Thunk or Redux Saga middleware, you can follow these steps:</p> <p>1. Check the Redux Store Configuration</p> <p>The most direct way to find out which middleware is being used is to examine the store configuration. The store is usually set up in a file like <code>store.js</code> or <code>configureStore.js</code>. For Redux Thunk:</p> <p>In the store configuration, look for <code>applyMiddleware</code> and see if <code>thunk</code> is being used:</p> <p>For Redux Thunk:</p> <p>In the store configuration, look for applyMiddleware and see if thunk is being used:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk'; // Import thunk middleware\nimport rootReducer from './rootReducer';\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(thunk) // Apply thunk middleware\n);\n\nexport default store;\n</code></pre> <p>If you see <code>thunk</code> being imported and used with <code>applyMiddleware</code>, then Redux Thunk is being used.</p> <p>For Redux Saga:</p> <p>If Redux Saga is being used, the store configuration will include <code>redux-saga</code> and <code>sagaMiddleware</code>:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga'; // Import saga middleware\nimport rootReducer from './rootReducer';\nimport rootSaga from './sagas'; // Import root saga\n\nconst sagaMiddleware = createSagaMiddleware(); // Create saga middleware\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(sagaMiddleware) // Apply saga middleware\n);\n\nsagaMiddleware.run(rootSaga); // Run the root saga\n\nexport default store;\n</code></pre> <p>In this case, you\u2019ll find <code>createSagaMiddleware</code> and <code>sagaMiddleware.run(rootSaga)</code> in the store configuration.</p> <p>2. Check Dependencies in package.json</p> <p>Look at the <code>dependencies</code> or <code>devDependencies</code> in your <code>package.json</code> file.</p> <p>For Redux Thunk:</p> <p>You will see <code>redux-thunk</code> listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-thunk\": \"^2.3.0\"\n}\n</code></pre> <p>For Redux Saga:</p> <p>You will see redux-saga listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-saga\": \"^1.1.3\"\n}\n</code></pre> <p>3. Search the Codebase</p> <p>You can perform a search in your codebase to see if any <code>thunk</code> or <code>saga</code> related code is present:</p> <ul> <li>Search for <code>thunk</code>: Look for <code>import thunk from 'redux-thunk' or applyMiddleware(thunk)</code>.</li> <li>Search for <code>saga</code>: Look for <code>import createSagaMiddleware from 'redux-saga', sagaMiddleware.run</code>, or <code>import { call, put } from 'redux-saga/effects'</code>.</li> </ul> <p>4. Inspect Middleware in DevTools</p> <p>If you are using Redux DevTools, you can inspect the middleware in your application:</p> <ol> <li>Open Redux DevTools in your browser.</li> <li>Look at the middleware section or check the logs to see which middleware is being applied.</li> </ol> <p>Summary</p> <ol> <li>Check Store Configuration: Look at the <code>applyMiddleware</code> in the store setup.</li> <li>Check package.json: See which middleware libraries are listed in dependencies.</li> <li>Search Codebase: Look for imports and usage related to <code>redux-thunk</code> or <code>redux-saga</code>.</li> <li>Inspect DevTools: Use Redux DevTools to examine applied middleware.</li> </ol> <p>By using these methods, you can determine whether your React application is utilizing Redux Thunk or Redux Saga middleware.</p>"},{"location":"react/topic/code-for-change/#code-for-change-cfc","title":"Code For Change (CFC)","text":""},{"location":"react/topic/code-for-change/#redux","title":"REDUX","text":"Improved Error Handling and Asynchronous Code Management in Redux-Thunk with React Component Integration Old CodeNew CodeKey Differences Explained Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n        if(resp.isSuccess) {\n            dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data))\n            message.success(\"Newly added Group Chat\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n        dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n    }\n}\n</code></pre> Component:<pre><code>const onFinish = (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    // dispatch(actionForGroupChatTitleAdd(values));\n    dispatch(actionForGroupChatTitleAdd(errorReq))\n        .then(() =&gt; {\n            console.log(\"Successfully added group chat title\");\n            onClose();\n        })\n        .catch((error) =&gt; {\n            console.log(\"error: \", error);\n            // Do not close the drawer in case of an error\n        });\n};\n</code></pre> <p>Updated Action Creator</p> <p>Your current action creator looks good, but for better error handling, we can ensure it throws an error when the response is not successful:</p> Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        try {\n            const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n            if(resp.isSuccess) {\n                dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data));\n                message.success(\"Newly added Group Chat\");\n                return resp.data; // Return data for success\n            } else {\n                dispatch(error(resp.errorMessage));\n                throw new Error(resp.errorMessage); // Throw error to be caught in the component\n            }\n        } catch (err) {\n            dispatch(error(err.message || 'Unknown error occurred'));\n            throw err; // Re-throw error to be caught in the component\n        } finally {\n            dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        }\n    }\n};\n</code></pre> <p>Component Handling the API Call</p> <p>In your component, handle the promise returned by the dispatch function to conditionally call <code>onClose</code>:</p> Component:<pre><code>const onFinish = async (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    try {\n        await dispatch(actionForGroupChatTitleAdd(errorReq));\n        console.log(\"Successfully added group chat title\");\n        onClose();\n    } catch (error) {\n        console.log(\"error: \", error);\n        message.error(\"Failed to add group chat title\");\n        // Drawer remains open\n    }\n};\n</code></pre> Explanation <p>Action Creator:</p> <ul> <li>If the API response is successful, it dispatches the <code>success</code> action and returns the response data.</li> <li>If the API response is not successful, it dispatches the <code>error</code> action and throws an error to be caught by the calling component.</li> <li>Errors caught within the <code>try</code> block are dispatched as errors and re-thrown to be handled by the component.</li> </ul> <p>Component:</p> <ul> <li>The <code>onFinish</code> function is modified to use <code>async/await</code> for handling the dispatch.</li> <li>On success (<code>await dispatch(actionForGroupChatTitleAdd(errorReq));</code>), it logs the success message and calls onClose() to close the drawer.</li> <li>On error (<code>catch</code> block), it logs the error and displays an error message using <code>message.error</code>. The drawer remains open.</li> </ul> <ol> <li> <p>Error Handling in Action Creator:</p> <p>Original Code:</p> <ul> <li>The action creator does not throw an error when the response is unsuccessful. It only dispatches the error message.</li> <li>This means the component cannot directly catch errors thrown by the action creator.</li> </ul> <p>Updated Code:</p> <ul> <li>The action creator explicitly throws an error when the response is unsuccessful. This allows the component to catch and handle the error.</li> <li>It uses a try-catch block to handle both the API call and any unexpected errors, re-throwing them to be caught in the component.</li> </ul> </li> <li> <p>Promise Handling in Component:</p> <p>Original Code:</p> <ul> <li>Uses <code>.then()</code> and <code>.catch()</code> to handle the promise returned by the action creator.</li> <li>If an error occurs, it is logged, but the drawer remains open because <code>onClose()</code> is not called in the <code>catch</code> block.</li> </ul> <p>Updated Code:</p> <ul> <li>Uses <code>async/await</code> syntax for better readability and error handling.</li> <li>The <code>try-catch</code> block allows for more straightforward handling of success and error cases.</li> <li>On success, it logs a message and calls <code>onClose()</code> to close the drawer.</li> <li>On error, it logs the error, displays an error message using <code>message.error</code>, and ensures the drawer remains open.</li> </ul> </li> </ol> <p>Summary</p> <p>The updated code improves error handling and readability:</p> <p>Action Creator:</p> <ul> <li>Handles both success and error cases explicitly.</li> <li>Throws errors to be caught by the component, ensuring better error propagation.</li> </ul> <p>Component:</p> <ul> <li>Uses <code>async/await</code> for cleaner, more readable asynchronous code.</li> <li>Handles success and error cases more clearly with a <code>try-catch</code> block.</li> <li>Ensures the drawer only closes on a successful API call, keeping it open on error.</li> </ul> <p>By documenting these changes, you can ensure a clear understanding of the improvements made and the rationale behind them.</p>"},{"location":"react/topic/code-for-change/#redux-middleware","title":"Redux Middleware","text":"which redux middleware is more advance thunk or saga? <p>Both Redux Thunk and Redux Saga are popular middleware options for managing side effects in a Redux application, but they have different approaches and capabilities. Here\u2019s a comparison to help you determine which might be more advanced or suitable for your needs:</p> Redux ThunkRedux Saga <p>Advantages:</p> <ul> <li>Simplicity: Thunks are functions that can be dispatched like normal actions, making them simple to understand and implement.</li> <li>Familiarity: It feels similar to regular JavaScript, especially for handling asynchronous logic using promises or async/await.</li> <li>Learning Curve: It has a lower learning curve compared to Redux Saga.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: As applications grow, complex async flows can become harder to manage and read.</li> <li>Error Handling: Handling complex error scenarios can be cumbersome.</li> </ul> <p>Advantages:</p> <ul> <li>Advanced Control: Provides more powerful control over complex async flows using generators, making it easier to manage and test.</li> <li>Concurrency: Better at handling concurrent actions and coordinating complex async processes.</li> <li>Testability: Sagas are more straightforward to test due to their generator-based nature.</li> <li>Composability: Easier to compose multiple sagas to work together and handle more advanced patterns like race conditions or parallel execution.</li> </ul> <p>Disadvantages:</p> <ul> <li>Complexity: Has a steeper learning curve due to the use of ES6 generators and more advanced patterns.</li> <li>Boilerplate: Can introduce more boilerplate code compared to Thunk.</li> </ul> <p>Conclusion</p> <p>When to Use Redux Thunk:</p> <ul> <li>For simpler applications or those just starting with Redux.</li> <li>When you need straightforward async logic handling.</li> <li>If you want a lower learning curve and less boilerplate.</li> </ul> <p>When to Use Redux Saga:</p> <ul> <li>For larger applications with complex async needs.</li> <li>When you need advanced control over side effects and better testability.</li> <li>If you are comfortable with generators and more complex patterns.</li> </ul> <p>Overall, Redux Saga is generally considered more advanced due to its powerful capabilities and fine-grained control over side effects. However, it also comes with more complexity, so the choice between Thunk and Saga should be based on your specific application needs and your team's familiarity with these tools.</p>"},{"location":"react/topic/code-for-change/#which-one-to-use","title":"Which one to use","text":"Which One to Master First: Thunk or Saga? <p>Start with Redux Thunk:</p> <ul> <li>Simplicity: Thunk is simpler and easier to grasp, making it a good starting point for understanding how to manage side effects in Redux.</li> <li>Foundational Knowledge: Learning Thunk first provides a solid foundation in handling asynchronous actions, which is beneficial before tackling the more advanced concepts in Redux Saga.</li> </ul> How to Master Redux ThunkHow to Master Redux Saga <ol> <li> <p>Understand the Basics:</p> <ul> <li>Learn how to create and dispatch actions in Redux.</li> <li>Understand synchronous vs. asynchronous actions.</li> </ul> </li> <li> <p>Set Up Redux Thunk:</p> <ul> <li>Integrate Redux Thunk into your Redux store configuration.</li> </ul> </li> <li> <p>Create Thunk Actions:</p> <ul> <li>Write action creators that return functions instead of plain objects.</li> <li>Use <code>dispatch</code> and <code>getState</code> inside these functions to manage async operations.</li> </ul> </li> <li> <p>Handle Asynchronous Logic:</p> <ul> <li>Use promises or async/await within Thunk actions to perform API calls or other async tasks.</li> <li>Manage loading states and error handling within Thunk actions.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Thunk documentation.</li> <li>Explore tutorials and examples on managing async actions with Thunk.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply your knowledge in real projects to gain practical experience.</li> <li>Refactor existing Redux code to use Thunk for async actions.</li> </ul> </li> </ol> <ol> <li> <p>Understand ES6 Generators:</p> <ul> <li>Familiarize yourself with ES6 generator functions, as they are fundamental to Redux Saga.</li> <li>Practice using <code>yield</code>, <code>next()</code>, and generator control flow.</li> </ul> </li> <li> <p>Learn Redux Saga Basics:</p> <ul> <li>Understand the core concepts of Redux Saga, including sagas, effects, watchers, and workers.</li> </ul> </li> <li> <p>Set Up Redux Saga:</p> <ul> <li>Integrate Redux Saga into your Redux store configuration.</li> </ul> </li> <li> <p>Create Simple Sagas:</p> <ul> <li>Write sagas to handle asynchronous actions using <code>takeEvery</code>, <code>takeLatest</code>, and <code>call</code>.</li> <li>Learn to manage side effects like API calls, delays, and parallel execution.</li> </ul> </li> <li> <p>Handle Complex Scenarios:</p> <ul> <li>Use advanced patterns like <code>race</code>, <code>all</code>, and <code>cancellation</code> to manage complex async flows.</li> <li>Handle concurrency and manage multiple sagas.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Saga documentation.</li> <li>Explore tutorials and examples to understand advanced use cases.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply Redux Saga in real projects to tackle more complex async logic.</li> <li>Refactor existing Thunk code to use Redux Saga for better control and testability.</li> </ul> </li> </ol> <p>Additional Tips for Mastery</p> <ul> <li>Practice Regularly: Consistent practice and application in real projects are key to mastering both Thunk and Saga.</li> <li>Join Communities: Participate in online forums, communities, and discussions to learn from others and share your experiences.</li> <li>Keep Updated: Both Thunk and Saga are actively maintained, so keep an eye on updates and best practices by following their repositories and release notes.</li> <li>Experiment: Don't be afraid to experiment with different patterns and techniques to find what works best for your use case.</li> </ul> <p>Starting with Redux Thunk provides a solid foundation, and mastering Redux Saga will give you advanced tools for handling complex asynchronous logic in your Redux applications.</p>"},{"location":"react/topic/code-for-change/#jest","title":"Jest","text":"<p>In the context of package management, like with <code>npm</code> (Node Package Manager) for JavaScript projects, <code>--save</code> and <code>--save-dev</code> are options used during the installation of packages. Here's a simple explanation of the difference:</p> <ul> <li> <p>--save: When you install a package using --save, it means the package will be listed as a dependency in your project's <code>package.json</code> file. This indicates that your project needs this package to run properly. These dependencies are typically packages required for the application to function correctly in production.</p> </li> <li> <p>--save-dev: On the other hand, when you install a package using --save-dev, it means the package will be listed as a development dependency in your project's <code>package.json</code> file. This indicates that your project only needs this package during development, such as for testing, building, or other development-related tasks. These dependencies are typically tools or libraries used during the development process, but not necessary for the application to run in production.</p> </li> </ul> <p>So, in summary:</p> <ul> <li>Use --save for packages your project needs to run.</li> <li>Use --save-dev for packages your project needs during development but not for running the final application.</li> </ul> <ul> <li>--save <code>vs</code> --save-dev</li> <li>jest testing</li> <li>How To Structure React Projects From Beginner To Advanced</li> <li>useEffect by Example</li> </ul>"},{"location":"react/topic/code-for-change/#easy-thumbnail","title":"Easy Thumbnail","text":"<ul> <li>easy-thumbnails 2.8.5: pypi</li> <li>easy thumbnail: readthedocs</li> <li>easy thumbnail: github</li> </ul> <pre><code>from easy_thumbnails.fields import ThumbnailerImageField\n\nclass Profile(models.Model):\n    user = models.OneToOneField('auth.User')\n    photo = ThumbnailerImageField(upload_to='photos', blank=True)\n</code></pre>"},{"location":"react/topic/code-for-change/#step-1","title":"Step 1:","text":"<pre><code>Run pip install easy-thumbnails.\n</code></pre>"},{"location":"react/topic/code-for-change/#step-2","title":"Step 2:","text":"<pre><code>Add `easy_thumbnails` to your INSTALLED_APPS setting:\n\n```python\nINSTALLED_APPS = (\n    ...\n    'easy_thumbnails',\n)\n```\n</code></pre>"},{"location":"react/topic/code-for-change/#step-3","title":"Step 3:","text":"<pre><code>Run `manage.py` migrate `easy_thumbnails`\n</code></pre>"},{"location":"react/topic/react-strict-mode/","title":"Strict Mode","text":"<p>React\u2019s Strict Mode is a development tool designed to help identify potential problems in an application by intentionally invoking certain lifecycle methods and hooks more than once. It is meant to help developers catch issues early, but it does not affect production builds. Here\u2019s an explanation of what Strict Mode is, why it might cause behavior like double API calls, and when you should use it.</p>"},{"location":"react/topic/react-strict-mode/#what-is-react-strict-mode","title":"What is React Strict Mode?","text":"<p>React Strict Mode is a tool provided by React to help developers identify and fix potential problems in their applications. It does the following:</p> <ol> <li> <p>Double Invokes Certain Lifecycle Methods: In development mode, Strict Mode will intentionally invoke lifecycle methods and hooks like <code>useEffect</code> twice. This helps identify side effects that are not correctly handled, such as improper cleanup or unintended behaviors.</p> </li> <li> <p>Warns About Deprecated Features: It helps find usage of deprecated lifecycle methods and legacy APIs that might lead to bugs.</p> </li> <li> <p>Detects Unsafe Lifecycle Methods: It identifies unsafe lifecycle methods that may lead to issues in future React versions.</p> </li> </ol>"},{"location":"react/topic/react-strict-mode/#why-does-strict-mode-cause-double-api-calls","title":"Why Does Strict Mode Cause Double API Calls?","text":"<p>In development mode, React Strict Mode invokes <code>useEffect</code> twice to ensure that effects are properly <code>cleaned up</code> and that the application is resilient to unexpected behavior. This behavior is intended to catch issues related to side effects and is not present in production builds.</p> <ul> <li>Development Mode Only: The double invocation occurs only in development mode to help identify issues. It does not happen in production builds.</li> <li>Strict Mode\u2019s Purpose: This behavior helps ensure that side effects, cleanup, and other lifecycle aspects are handled correctly and can be safely cleaned up.</li> </ul>"},{"location":"react/topic/react-strict-mode/#when-and-why-to-use-strict-mode","title":"When and Why to Use Strict Mode","text":"<p>Strict Mode is used during development for several reasons:</p> <ol> <li> <p>Identify Potential Issues: It helps catch issues related to side effects, deprecated methods, and other unsafe patterns early in the development process.</p> </li> <li> <p>Improve Code Quality: It encourages developers to write code that adheres to best practices and is more robust against potential issues.</p> </li> <li> <p>Prepare for Future Versions: It helps identify code that might not be compatible with future React versions, allowing developers to update their code proactively.</p> </li> </ol>"},{"location":"react/topic/react-strict-mode/#when-to-remove-strict-mode","title":"When to Remove Strict Mode","text":"<p>Strict Mode should generally be used during development to help catch issues early. Here\u2019s when you might consider removing it:</p> <ol> <li> <p>Testing Production Behavior: To test your application\u2019s behavior as it would be in production, where Strict Mode\u2019s additional checks and double invocations are not present.</p> </li> <li> <p>Debugging Specific Issues: If you are experiencing issues like double API calls and have confirmed that they are due to Strict Mode, you might temporarily remove Strict Mode to isolate and debug the problem. However, this is only for debugging purposes; you should re-enable Strict Mode during development to benefit from its checks.</p> </li> </ol>"},{"location":"react/topic/react-strict-mode/#summary","title":"Summary","text":"<ul> <li>React Strict Mode is a development-only feature that helps identify potential issues by double-invoking certain lifecycle methods and hooks.</li> <li>In Production: Strict Mode's behavior does not affect production builds; the double invocation and additional checks are only present during development.</li> <li>Use During Development: Strict Mode is valuable during development to ensure your code adheres to best practices and to catch potential issues early.</li> <li>Remove Temporarily for Testing: If you\u2019re encountering specific issues related to Strict Mode, you can temporarily remove it to debug. However, ensure it\u2019s used during development to catch potential problems.</li> </ul> <p>In conclusion, React Strict Mode is a useful tool for improving code quality and ensuring robustness, but its effects should be understood and managed during the development phase.</p>"},{"location":"react/topic/react-strict-mode/#reference","title":"Reference","text":""},{"location":"react/topic/slides/","title":"Slides","text":""},{"location":"react/topic/slides/#presentation","title":"Presentation","text":""},{"location":"react/topic/mastering/batching-react/","title":"Batching","text":""},{"location":"react/topic/mastering/batching-react/#overview","title":"Overview","text":"<p>Understanding batching in React is important because it directly affects performance and the behavior of state updates. Here's a breakdown of what you need to understand about batching:</p>"},{"location":"react/topic/mastering/batching-react/#1-what-is-batching-in-react","title":"1. What is Batching in React?","text":"<p>Batching in React refers to the grouping of multiple state updates together so that React can process them all at once and trigger a single re-render of the component. Without batching, React would re-render after each state update, which could be inefficient, especially if many updates happen in a short period.</p>"},{"location":"react/topic/mastering/batching-react/#2-why-is-batching-important","title":"2. Why is Batching Important?","text":"<ul> <li>Performance: By grouping state updates, React avoids unnecessary re-renders, which improves performance, especially in complex components or large applications.</li> <li>Consistency: Batching ensures that all state updates happen before React re-renders the component. This ensures that the UI is updated consistently, reflecting all the changes made to the state in one go.</li> </ul>"},{"location":"react/topic/mastering/batching-react/#3-how-does-batching-work","title":"3. How Does Batching Work?","text":"<ul> <li>Synchronous Updates: In React, state updates are batched when triggered from synchronous event handlers (like <code>onClick</code>, <code>onChange</code>, etc.). This means if you call <code>setState</code> multiple times in a single function, React will batch those updates and <code>re-render only once</code>.</li> </ul> <pre><code>const handleClick = () =&gt; {\n  setCounter(counter + 1); // 1st update\n  setText(\"Hello\"); // 2nd update\n  setVisible(true); // 3rd update\n  // React batches these 3 updates and re-renders only once\n};\n</code></pre> <ul> <li> <p>Asynchronous Updates (React 18+): Starting with <code>React 18</code>, React also batches updates that occur in asynchronous operations, such as:</p> </li> <li> <p>Promises</p> </li> <li><code>setTimeout</code></li> <li><code>async</code> functions</li> </ul> <p>Before React 18, batching only worked in synchronous events. React 18 extends this feature to include async code, so multiple updates in async code also result in just one re-render.</p> Example (React 18+)<pre><code>const handleAsyncUpdate = async () =&gt; {\n  setCounter(counter + 1); // 1st update\n  await fetchData(); // Async operation\n  setText(\"Updated\"); // 2nd update after async operation\n  // React batches both updates and re-renders once\n};\n</code></pre>"},{"location":"react/topic/mastering/batching-react/#4-when-does-batching-not-happen","title":"4. When Does Batching Not Happen?","text":"<p>There are some cases where React does not batch updates:</p> <ul> <li>Outside React event handlers: If you trigger a state update outside of a React event handler (e.g., in a <code>callback</code> function from a third-party library or non-React event), React doesn't batch updates by default.</li> </ul> <pre><code>setTimeout(() =&gt; {\n  setCounter(counter + 1); // React will NOT batch this update\n  setText(\"Hello\");\n}, 1000);\n</code></pre> <p>However, starting with React 18, asynchronous updates inside <code>setTimeout</code>, <code>Promise</code>, and <code>async</code> functions are batched.</p> <ul> <li>State updates inside a loop: While React will batch state updates inside loops if those updates are in a single event handler or function, if you make asynchronous or out-of-scope updates within loops, batching may not work as expected.</li> </ul> <pre><code>for (let i = 0; i &lt; 10; i++) {\n  setState(newValue); // React batches all state updates in this loop\n}\n</code></pre>"},{"location":"react/topic/mastering/batching-react/#5-why-is-batching-important-for-performance","title":"5. Why is Batching Important for Performance?","text":"<p>Batching helps minimize the number of re-renders in your React components:</p> <ul> <li>Reducing reflows and repaints in the DOM: Every time React re-renders a component, it may cause the browser to recalculate styles, layout, and re-render parts of the page. Reducing the number of re-renders improves the app\u2019s overall speed and responsiveness.</li> <li>Fewer computational resources: By reducing unnecessary renders, you also reduce the computational resources required to update the UI.</li> </ul>"},{"location":"react/topic/mastering/batching-react/#6-how-react-18-improved-batching","title":"6. How React 18 Improved Batching:","text":"<p>Before React 18, batching was limited to synchronous code. With React 18, batching now works even in asynchronous code (such as in <code>async</code> functions, <code>promises</code>, or <code>setTimeout</code>).</p> For example, with React 18:<pre><code>const handleClick = async () =&gt; {\n  setCounter(counter + 1);\n  await someAsyncOperation(); // Async operation\n  setText(\"Updated\");\n  // React batches both updates and triggers only one re-render\n};\n</code></pre> <p>In React 18, even though <code>setCounter</code> is called before <code>await</code>, and <code>setText</code> is called <code>after</code> the async operation completes, both state updates are batched together and result in only one re-render.</p>"},{"location":"react/topic/mastering/batching-react/#7-when-should-you-worry-about-batching","title":"7. When Should You Worry About Batching?","text":"<p>In most cases, React's built-in batching will take care of performance optimizations automatically. However, if you notice performance issues, such as frequent re-renders in large applications, or if you're managing complex state updates, you might need to:</p> <ul> <li>Optimize how you structure state updates.</li> <li>Avoid unnecessary state updates inside loops or async operations that might prevent batching from working properly.</li> <li>Use <code>useCallback</code> or <code>useMemo</code> to prevent unnecessary re-renders caused by props or state changes in child components.</li> </ul>"},{"location":"react/topic/mastering/batching-react/#8-potential-pitfalls","title":"8. Potential Pitfalls:","text":"<ul> <li>Stale state in batch updates: When using batching, if you rely on the current state to compute the next state, ensure you are correctly using the functional form of <code>setState</code> to avoid stale state.</li> </ul> <pre><code>setCounter((prev) =&gt; prev + 1); // Correct: Using functional form\nsetCounter(counter + 1); // Potential issue: may use stale state\n</code></pre> <p>Summary:</p> <ul> <li>Batching is React's way of grouping multiple state updates to minimize re-renders and improve performance.</li> <li>React batches updates during synchronous event handlers and async operations (from React 18 onwards).</li> <li>Understanding when batching occurs and when it doesn't is important to ensure you're writing efficient, performant React components.</li> <li>React 18 extends batching capabilities, including asynchronous state updates, for better performance optimization in modern React apps.</li> </ul> <p>By understanding these concepts, you'll be able to write more optimized React code and handle state updates efficiently.</p>"},{"location":"react/topic/mastering/batching-stale-state/","title":"Batching Stale State","text":""},{"location":"react/topic/mastering/batching-stale-state/#overview","title":"Overview","text":"<p>The issue you're encountering, where you get <code>World World World World</code> instead of the expected string like <code>Hello World</code>, is a classic case of stale state in React when using asynchronous state updates.</p>"},{"location":"react/topic/mastering/batching-stale-state/#the-problem","title":"The Problem:","text":"<pre><code>const appendText = () =&gt; {\n  setMessage(message + \" Hello\"); // First setMessage call\n  setMessage(message + \" World\"); // Second setMessage call\n};\n</code></pre> <ul> <li>React batches the updates, meaning that both <code>setMessage</code> calls are scheduled in the same event cycle (or click event).</li> <li>Since React state updates are asynchronous and do not immediately update the state, both calls to <code>setMessage</code> use the same stale value of <code>message</code>. This happens because at the time React schedules the updates, <code>message</code> is still the initial value (e.g., an empty string <code>''</code> or the previous value from the last render).</li> </ul>"},{"location":"react/topic/mastering/batching-stale-state/#the-solution","title":"The Solution:","text":"<p>To fix this issue and ensure that each update depends on the latest value of <code>message</code>, you should use the functional form of <code>setState</code>, which takes the previous state value and ensures that each update is applied correctly in sequence.</p> Updated Code with the Functional Form:<pre><code>const appendText = () =&gt; {\n  setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Uses the most recent `prevMessage`\n  setMessage((prevMessage) =&gt; prevMessage + \" World\"); // Also uses the most recent `prevMessage`\n};\n</code></pre>"},{"location":"react/topic/mastering/batching-stale-state/#why-this-works","title":"Why This Works:","text":"<p>By using the functional form of <code>setState</code>, each update will be based on the most recent state. React will take care of processing the updates sequentially, so each setMessage will work with the latest value of message.</p>"},{"location":"react/topic/mastering/batching-stale-state/#recap","title":"Recap:","text":"<ol> <li>Without functional form (<code>setMessage(message + ' Hello')</code>), React batches updates and uses the same stale state for all updates in quick succession.</li> <li>With functional form (<code>setMessage((prevMessage) =&gt; prevMessage + ' Hello')</code>), React ensures each update gets the latest state, avoiding the stale state issue.</li> </ol> <p>In conclusion, when updating the state based on its previous value (like appending text to a string), you should always use the functional form of <code>setState</code> to ensure you get the latest value and avoid stale state issues.</p>"},{"location":"react/topic/mastering/batching-stale-state/#why-is-the-functional-form-important-in-some-cases","title":"Why Is the Functional Form Important in Some Cases?","text":"<p>When state updates depend on the previous state, React batches updates and processes them asynchronously. If you call <code>setState</code> multiple times in quick succession without using the functional form, each update could be using the same initial state, leading to incorrect results.</p> <p>The functional form <code>(setState((prev) =&gt; prev + 1))</code> ensures that each update is based on the most recent state value, preventing stale state issues.</p> <p>Summary:</p> <ul> <li>Stale state occurs when multiple state updates happen in quick succession, and React uses the initial state for each update, rather than the most recent value.</li> <li>Always use the functional form of <code>setState</code> (e.g., <code>setCounter((prev) =&gt; prev + 1)</code>) when your state update depends on the previous state value.</li> <li>For independent state updates (when the new value doesn\u2019t depend on the previous state), you don\u2019t need the functional form.</li> </ul>"},{"location":"react/topic/mastering/batching-stale-state/#summary-of-when-to-use-the-functional-form","title":"Summary of When to Use the Functional Form","text":"<ul> <li>Arrays: Use the functional form when you're updating an array based on its previous value (e.g., adding/removing items).</li> <li>Objects: Use the functional form when you're updating an object based on its previous value (e.g., updating one property of the object).</li> <li>Strings: Use the functional form when you're updating a string based on its previous value (e.g., appending or modifying parts of the string).</li> </ul>"},{"location":"react/topic/mastering/batching-stale-state/#general-rule-of-thumb","title":"General Rule of Thumb:","text":"<ul> <li>Use the functional form of <code>setState</code> (or <code>setX</code>) whenever the new state depends on the previous state. This ensures that you always get the most up-to-date value for state.</li> <li>If you're not depending on the previous state (e.g., setting a static value), you can use the regular <code>setState</code> approach.</li> </ul> Final Example Using All Three (Array, Object, String)<pre><code>import React, { useState } from \"react\";\n\nconst StateUpdateExample = () =&gt; {\n  const [counter, setCounter] = useState(0);\n  const [items, setItems] = useState([]);\n  const [user, setUser] = useState({ name: \"John\", age: 25 });\n  const [message, setMessage] = useState(\"\");\n\n  const handleCounterIncrement = () =&gt; {\n    setCounter((prev) =&gt; prev + 1); // Correct for counter\n  };\n\n  const handleAddItem = () =&gt; {\n    setItems((prevItems) =&gt; [...prevItems, \"New Item\"]); // Correct for array\n  };\n\n  const handleUpdateUser = () =&gt; {\n    setUser((prevUser) =&gt; ({ ...prevUser, age: prevUser.age + 1 })); // Correct for object\n  };\n\n  const handleAppendMessage = () =&gt; {\n    setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Correct for string\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Counter: {counter}&lt;/p&gt;\n      &lt;p&gt;Items: {items.join(\", \")}&lt;/p&gt;\n      &lt;p&gt;\n        Name: {user.name}, Age: {user.age}\n      &lt;/p&gt;\n      &lt;p&gt;Message: {message}&lt;/p&gt;\n      &lt;button onClick={handleCounterIncrement}&gt;Increment Counter&lt;/button&gt;\n      &lt;button onClick={handleAddItem}&gt;Add Item&lt;/button&gt;\n      &lt;button onClick={handleUpdateUser}&gt;Update User&lt;/button&gt;\n      &lt;button onClick={handleAppendMessage}&gt;Append Message&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default StateUpdateExample;\n</code></pre>"},{"location":"react/topic/mastering/batching-stale-state/#why-it-might-be-working","title":"Why It Might Be Working:","text":"<p>React 18 introduced a feature called concurrent rendering, which allows React to batch updates more intelligently and make updates feel smoother. In particular, React 18 can batch multiple state updates and render them together, avoiding unnecessary re-renders. However, concurrent rendering doesn't automatically solve the stale state issue caused by asynchronous state updates when you're using the same state variable (like <code>message</code>) in quick succession.</p> <p>Here\u2019s why it may seem to work in your case:</p> <ol> <li> <p>React 18's Automatic Batching: React 18 batches state updates automatically. This means React can delay updates to state until after the current event handler (like the click event) finishes. This doesn't eliminate stale state, but the fact that you're seeing smooth rendering could be due to React batching the updates together efficiently and handling the DOM re-renders in a way that doesn't cause noticeable lag.</p> </li> <li> <p>The Case of Single <code>setState</code> Call: If you\u2019re clicking the \"Append Text\" button only a few times, and you don't have multiple state updates in quick succession (or too many re-renders), the update to <code>message</code> will often look smooth. React might be able to re-render quickly even without the functional form in such scenarios. This is especially true when you aren't triggering multiple updates simultaneously or relying on the most recent state value (in this case, the <code>\"Hello\"</code> string you're appending).</p> </li> <li> <p>Minimal Delay: React's internal implementation, particularly with concurrent rendering, ensures that updates are processed efficiently. So, even though you are using the stale state <code>(message + ' Hello')</code>, React 18 might be handling your simple state updates efficiently enough that you don't notice a lag or stale state, especially with a relatively simple example like this.</p> </li> <li> <p>User Interaction and Timing: The problem with stale state generally arises when multiple <code>setState</code> calls happen rapidly, like in a loop or with fast user interactions. If you're only appending text to the message once per click (and not rapidly), React may successfully update the message without noticeable issues.</p> </li> </ol>"},{"location":"react/topic/mastering/batching-stale-state/#why-stale-state-can-still-be-a-concern","title":"Why Stale State Can Still Be a Concern:","text":"<ul> <li>Multiple Rapid Updates: If you clicked the button many times quickly, you might run into the stale state issue. React schedules updates asynchronously and batches them together, which can cause it to not use the latest value of <code>message</code> for each click.</li> </ul> <pre><code>const appendText = () =&gt; {\n  setMessage(message + \" Hello\"); // Multiple quick clicks might cause stale updates\n  setMessage(message + \" World\");\n};\n</code></pre> <p>In this case, even though both <code>setMessage</code> calls are triggered quickly, React may batch them together and use the stale value of <code>message</code> for both updates. So, the final value might be <code>\"HelloWorld\"</code>, even though you wanted <code>\"Hello World\"</code>.</p>"},{"location":"react/topic/mastering/batching-stale-state/#how-react-18-handles-it","title":"How React 18 Handles It:","text":"<p>React 18 introduced Concurrent Mode and the Automatic Batching of Updates (even across multiple event handlers), so React intelligently groups these updates together. This can prevent the UI from \"flickering\" or lagging, making it feel like state updates are happening faster.</p> <p>However, it does not automatically solve the stale state issue when you're relying on the previous state for an update (like <code>message + ' Hello'</code>). React still schedules updates asynchronously, and if you try to update the same state in multiple functions without the functional form, the updates could still use outdated values of the state.</p> <p>So, Why Is It Working for You Now?</p> <ol> <li>Single State Update: You're appending text once per click, and there's no rapid succession of multiple updates that might trigger the stale state issue.</li> <li>Batching and Concurrent Rendering: React 18's concurrent rendering makes updates smoother, even if the state is technically being updated asynchronously.</li> <li>No Immediate Consecutive Updates: You're not calling setMessage multiple times rapidly in a way that would highlight the stale state issue.</li> </ol>"},{"location":"react/topic/mastering/batching-stale-state/#the-best-practice-to-ensure-correctness","title":"The Best Practice to Ensure Correctness:","text":"<p>Even though your example might be working well right now, it's still best practice to use the functional form of <code>setState</code> when you're updating based on the previous state to avoid stale state issues. This will ensure that your updates work correctly in all cases (especially if state updates become more complex or rapid).</p> <pre><code>const appendText = () =&gt; {\n  setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Always use the latest state\n};\n</code></pre> <p>Conclusion:</p> <ul> <li>React 18\u2019s concurrent rendering and automatic batching help smooth out performance and avoid visible lag, but they don\u2019t automatically resolve stale state issues in every case.</li> <li>The example seems to work fine because you\u2019re not rapidly updating the state and there's no immediate need for the latest state in the next update.</li> <li>Use the functional form of <code>setState</code> when the new state depends on the previous state to ensure correctness in all scenarios, especially when updates happen quickly or frequently.</li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/","title":"Component Re-rendering Deep","text":""},{"location":"react/topic/mastering/component-re-rendering/#overview","title":"Overview","text":"<p>A deep understanding of React's rendering mechanics is crucial for optimizing performance and avoiding common pitfalls when building React applications. Here's an overview of the key concepts involved:</p>"},{"location":"react/topic/mastering/component-re-rendering/#1-virtual-dom-and-reconciliation","title":"1. Virtual DOM and Reconciliation","text":"<ul> <li> <p>Virtual DOM: React uses a Virtual DOM to optimize the process of updating the real DOM. When the state or props of a component change, React doesn\u2019t immediately change the actual DOM. Instead, it creates a virtual representation (a \"diff\") of the updated DOM, compares it with the previous one, and then updates only the parts that have changed.</p> </li> <li> <p>Reconciliation: This is the process by which React updates the DOM based on the differences between the old and new Virtual DOM. React uses an efficient algorithm called \"diffing\" to minimize the number of DOM updates.</p> </li> </ul> <p>The diffing algorithm has certain assumptions:</p> <ul> <li>It assumes components with the same type will generate the same subtree.</li> <li>It compares the component trees efficiently, only updating what is necessary, using keys in lists to optimize the process.</li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#2-component-re-renders","title":"2. Component Re-renders","text":"When Does React Re-render Components? <ul> <li>State Changes: When a component\u2019s state (<code>useState</code>) changes, React re-renders that component and its children.</li> <li>Props Changes: If a component\u2019s props change (i.e., the parent component passes new values), React will re-render that child component.</li> <li>Context Changes: If the value passed through a React Context provider changes, any components consuming that context will re-render.</li> </ul> <p>This re-rendering behavior is designed for correctness, but it can lead to performance issues if not managed properly, particularly in large applications with complex component trees.</p>"},{"location":"react/topic/mastering/component-re-rendering/#3-memoization-and-preventing-unnecessary-re-renders","title":"3. Memoization and Preventing Unnecessary Re-renders","text":"<ul> <li>Pure Components: A pure component is one that only re-renders when its props or state change. React provides <code>React.memo</code> (for functional components) and <code>PureComponent</code> (for class components) to automatically implement shallow comparison of props and prevent unnecessary re-renders.</li> </ul> <p>useMemo and useCallback Hooks:</p> <ul> <li> <p><code>useMemo</code>: Used to memoize expensive calculations and avoid recalculating them on every render.</p> </li> <li> <p><code>useCallback</code>: Used to memoize functions to ensure that functions aren't recreated on every render unless their dependencies change.</p> </li> <li> <p>Shallow Comparison: React performs a shallow comparison of props and state. If the object references remain the same, React assumes the component\u2019s data hasn\u2019t changed, and therefore, no re-render is necessary. However, this can cause issues when working with mutable objects like arrays and objects, as React might not detect changes if the reference hasn\u2019t changed.</p> </li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#4-key-prop-in-lists","title":"4. Key Prop in Lists","text":"<ul> <li>The <code>key</code> prop is essential when rendering lists in React. React uses keys to identify which items have changed, been added, or removed, which helps optimize the reconciliation process. Without proper keys, React may fail to efficiently update the list, leading to performance issues and unexpected behaviors.</li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#5-state-and-prop-updates-are-batched","title":"5. State and Prop Updates Are Batched","text":"<ul> <li> <p>Batching: React batches multiple state updates together for performance optimization. This means that when you call multiple <code>setState</code> or state-updating functions, React groups these updates and processes them in a single re-render cycle.</p> </li> <li> <p>However, state updates may still cause multiple renders if they happen in different event handlers (or in different life cycle methods for class components). React batches updates in event handlers, but not in asynchronous callbacks (e.g., <code>setTimeout</code>, <code>Promises</code>).</p> </li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#6-re-rendering-with-hooks","title":"6. Re-rendering with Hooks","text":"<ul> <li> <p>Hooks like <code>useState</code>, <code>useEffect</code>, <code>useReducer</code>, and <code>useContext</code> can cause components to re-render when state or context values change. However, React doesn\u2019t automatically re-render a component for every hook call, and this can sometimes be confusing:</p> </li> <li> <p><code>useEffect</code>: The <code>useEffect</code> hook runs after a render, and its behavior can be controlled by its dependency array. This allows for fine-grained control over when side effects are executed and can help avoid unnecessary re-renders.</p> </li> <li> <p><code>useReducer</code>: This hook can be used to manage complex state logic and helps avoid excessive re-renders by keeping state updates in a single dispatch cycle.</p> </li> </ul> <p>Understanding how each hook causes re-renders (and under what conditions) is crucial for efficient performance.</p>"},{"location":"react/topic/mastering/component-re-rendering/#7-concurrent-mode-and-suspense","title":"7. Concurrent Mode and Suspense","text":"<ul> <li> <p>Concurrent Mode is an experimental feature in React designed to make rendering more responsive by allowing React to pause work and come back to it later. This feature is particularly helpful in large applications with complex UIs, as it prevents the UI from becoming unresponsive during heavy computations.</p> </li> <li> <p>Suspense: Suspense allows React to delay rendering a part of the UI until some condition is met (e.g., waiting for data to load). It is often used with React.lazy for code-splitting, where large components are loaded only when necessary.</p> </li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#8-fiber-architecture","title":"8. Fiber Architecture","text":"<ul> <li> <p>React Fiber is the reimplementation of React's core algorithm. It enables asynchronous rendering, which allows React to pause work and come back to it later, improving the performance of complex applications.</p> </li> <li> <p>Fiber allows React to prioritize updates based on their importance. For instance, a user interaction might take priority over less critical updates (like an animation).</p> </li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#9-updating-state-in-functional-components","title":"9. Updating State in Functional Components","text":"<ul> <li>When you call <code>setState</code> (in class components) or the <code>useState</code> hook (in functional components), React schedules a re-render. However, due to batching, the state update might not be applied immediately. This can lead to unexpected results if you try to use the updated state value immediately after calling <code>setState</code>. Instead, React applies the new state in the next render cycle.</li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#10-event-handling-and-re-renders","title":"10. Event Handling and Re-renders","text":"<ul> <li>React\u2019s synthetic event system can impact re-render behavior. When an event handler is triggered, React may update the component state or props, which causes the component to re-render. It\u2019s important to understand how events work in React, and how to manage event listeners to avoid unnecessary re-renders.</li> </ul>"},{"location":"react/topic/mastering/component-re-rendering/#conclusion","title":"Conclusion","text":"<p>A deep understanding of React\u2019s rendering mechanics revolves around efficiently managing state, minimizing unnecessary re-renders, optimizing performance, and leveraging hooks and memoization techniques. By mastering these concepts, React developers can ensure their applications remain performant, even as they grow in complexity.</p>"},{"location":"react/topic/mastering/explainingothers/","title":"Explain to 5 Year","text":""},{"location":"react/topic/mastering/explainingothers/#hooks","title":"Hooks","text":""},{"location":"react/topic/mastering/explainingothers/#when-to-use-hooks","title":"When to Use Hooks","text":"<p>Hooks are a powerful feature in React that allow you to use state and other React features without writing a class. Here\u2019s when and why you should use them:</p> <ol> <li> <p>Functional Components</p> <ul> <li>When to Use: When you\u2019re building a component using a function rather than a class.</li> <li>Why: Hooks are designed to work with functional components, making them simpler and easier to manage compared to class components.</li> </ul> <pre><code>function MyComponent() {\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;You clicked {count} times&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> </li> <li> <p>State Management</p> <ul> <li>When to Use: When you need to manage state in a functional component.</li> <li>Why: The <code>useState</code> hook lets you add state to functional components, which was previously only possible with class components.</li> </ul> <pre><code>function Counter() {\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> </li> <li> <p>Side Effects</p> <ul> <li>When to Use: When you need to perform side effects (like data fetching, subscriptions, or manually changing the DOM) in a functional component.</li> <li>Why: The <code>useEffect</code> hook helps you handle side effects in a way that\u2019s clean and integrated with the React lifecycle.</li> </ul> <pre><code>function DataFetcher() {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; setData(data));\n    }, []); // Empty array means this runs once when the component mounts\n\n    return &lt;div&gt;{data ? &lt;p&gt;Data: {data}&lt;/p&gt; : &lt;p&gt;Loading...&lt;/p&gt;}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Context</p> <ul> <li>When to Use: When you want to share state or functions across multiple components.</li> <li>Why: The <code>useContext</code> hook allows you to access values from a context provider without having to pass props down through every level of your component tree.</li> </ul> <pre><code>const ThemeContext = React.createContext('light');\n\nfunction ThemedButton() {\n    const theme = useContext(ThemeContext);\n\n    return &lt;button style={{ background: theme === 'dark' ? '#333' : '#FFF' }}&gt;Click me&lt;/button&gt;;\n}\n</code></pre> </li> </ol>"},{"location":"react/topic/mastering/explainingothers/#when-not-to-use-hooks","title":"When Not to Use Hooks","text":"<p>Hooks are powerful, but there are cases where they might not be the best fit:</p> <ol> <li> <p>Class Components</p> <ul> <li>When Not to Use: When you are working with class components that already use lifecycle methods and state management.</li> <li>Why: Hooks are meant to simplify functional components. If you are comfortable with class components and their lifecycle methods, you might not need to switch.</li> </ul> </li> <li> <p>Complex State Logic</p> <ul> <li>When Not to Use: When you have very complex state logic that might be better managed with a class component or external state management library (like <code>Redux</code>).</li> <li>Why: While hooks can manage complex state, there are scenarios where state management libraries might offer better solutions for very complex state interactions.</li> </ul> </li> <li> <p>Performance Considerations</p> <ul> <li> <p>When Not to Use: When using hooks in a way that causes unnecessary re-renders or performance issues.</p> </li> <li> <p>Why: Some hooks like <code>useEffect</code> can lead to performance issues if not used carefully. For example, a <code>useEffect</code> that runs on every render can cause excessive updates. Always optimize hooks and consider memoization or <code>useCallback</code> to prevent performance issues.</p> </li> </ul> <pre><code>function ExpensiveComponent({ data }) {\n    const [filteredData, setFilteredData] = useState([]);\n\n    // This useEffect will run every time `data` changes\n    useEffect(() =&gt; {\n        const newFilteredData = filterData(data);\n        setFilteredData(newFilteredData);\n    }, [data]); // Dependencies array controls when this runs\n\n    return &lt;div&gt;{filteredData}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> Summary <p>Use Hooks:</p> <ul> <li>In functional components.</li> <li>For managing state with <code>useState</code>.</li> <li>For handling side effects with <code>useEffect</code>.</li> <li>To access and share values with <code>useContext</code>.</li> </ul> <p>Avoid Using Hooks:</p> <ul> <li>In class components that already handle lifecycle methods and state.</li> <li>When dealing with very complex state that might need external libraries.</li> <li>In ways that could lead to performance problems, such as unnecessary re-renders.</li> </ul> <p>By understanding when and how to use hooks, you can take full advantage of their power to make your React applications more efficient and easier to maintain.</p>"},{"location":"react/topic/mastering/explainingothers/#hooks-in-functional-components-cheatsheet","title":"Hooks in Functional Components Cheatsheet","text":"<ul> <li><code>useState</code>: For managing local state.</li> <li><code>useEffect</code>: For performing side effects like data fetching or subscribing to events.</li> <li><code>useContext</code>: For accessing context values.</li> <li><code>useMemo</code> and <code>useCallback</code>: For performance optimizations</li> </ul>"},{"location":"react/topic/mastering/explainingothers/#overview-of-react-hooks","title":"Overview of React Hooks","text":"<p>From Initial Release to Latest Versions</p> React 16.8React 18 <ul> <li><code>useState</code>: For managing local state within a functional component.</li> <li><code>useEffect</code>: For performing side effects like data fetching, subscriptions, or manually changing the DOM.</li> <li><code>useContext</code>: For accessing context values directly without needing to pass props down the component tree.</li> <li><code>useReducer</code>: For managing more complex state logic with a reducer function, an alternative to useState.</li> <li><code>useLayoutEffect</code>: For performing effects that need to happen synchronously after DOM mutations but before the browser repaints.</li> <li><code>useImperativeHandle</code>: For customizing the instance value exposed by ref when using forwardRef.</li> <li><code>useMemo</code>: For memoizing the result of a computation to avoid recalculating on every render, improving performance.</li> <li><code>useCallback</code>: For memoizing callback functions to prevent unnecessary re-renders of components.</li> </ul> <ul> <li><code>useTransition</code>: For managing state updates that are less critical and can be deferred to maintain a responsive UI.</li> <li><code>useDeferredValue</code>: For deferring the rendering of less critical updates, allowing the browser to paint more smoothly.</li> <li><code>useId</code>: For generating unique IDs that persist across server and client renders, aiding in accessibility and form handling.</li> <li><code>useSyncExternalStore</code>: For subscribing to external stores and ensuring your component is synchronized with changes to the store.</li> </ul>"},{"location":"react/topic/mastering/explainingothers/#react-major-version","title":"React Major Version","text":"<ul> <li>React 0.x: Initial release with core concepts like components and Virtual DOM.</li> <li>React 15.x: Performance improvements and new API updates.</li> <li>React 16.x: Fiber architecture, error boundaries, and the introduction of Hooks.</li> <li>React 17.x: Focused on stability and upgrade ease.</li> <li>React 18.x: Concurrent features, new hooks, and performance enhancements.</li> </ul>"},{"location":"react/topic/mastering/function-declaration-and-expression/","title":"Function Declaration & Expression","text":""},{"location":"react/topic/mastering/function-declaration-and-expression/#1-function-declarations","title":"1. Function Declarations","text":"When to UseWhen to Use <ul> <li> <p>Utility Functions:</p> <p>When you have utility functions <code>or</code> helper functions that are used across multiple components or files, function declarations are a good choice due to their hoisting behavior. This allows you to reference them before they are defined in your code.</p> <pre><code>// Utility function declared at the top\nfunction calculateSomething(x) {\n    return x * 2;\n}\n\nfunction MyComponent() {\n    const result = calculateSomething(5);\n    return &lt;div&gt;{result}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Top-Level Scope:</p> <p>When defining functions at the top level of a module that should be available throughout the file or across various parts of your code, function declarations can be more intuitive.</p> </li> </ul> <ul> <li> <p>Hoisting:</p> <p>Function declarations are hoisted, meaning they are available throughout the scope they are defined in, which can be useful for organizing code.</p> </li> </ul>"},{"location":"react/topic/mastering/function-declaration-and-expression/#2-function-expressions","title":"2. Function Expressions","text":"When to UseWhy <ul> <li> <p>Component Definitions:</p> <p>When defining React functional components, function expressions (often with arrow functions) are commonly used. This is because they offer a concise syntax and align well with React\u2019s functional programming paradigm.</p> <pre><code>const MyComponent = () =&gt; {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers and Callbacks:</p> <p>For inline event handlers or callbacks, arrow functions provide a more succinct syntax and handle <code>this</code> context automatically.</p> <pre><code>const handleClick = () =&gt; {\n    console.log('Clicked!');\n};\n\nfunction MyComponent() {\n    return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;\n}\n</code></pre> </li> <li> <p>Inline Functions:</p> <p>When passing functions as props or defining functions inside render methods or functional components, function expressions (especially arrow functions) help keep the code concise and readable.</p> <pre><code>const MyComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n            {[1, 2, 3].map(number =&gt; (\n                &lt;div key={number}&gt;{number}&lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n</code></pre> </li> </ul> <ul> <li>Conciseness: Function expressions and arrow functions provide a more compact syntax, which is particularly useful in modern React codebases.</li> <li>Lexical <code>this</code>: Arrow functions inherit <code>this</code> from their surrounding context, avoiding common pitfalls with <code>this</code> binding in event handlers or methods.</li> </ul>"},{"location":"react/topic/mastering/function-declaration-and-expression/#summary","title":"Summary","text":"<ul> <li> <p>Function Declarations: Use them for utility functions, and top-level functions that benefit from hoisting or need to be referenced before their definition. They are more traditional and offer clear readability.</p> </li> <li> <p>Function Expressions and Arrow Functions: Use them for defining React components, inline functions, event handlers, and callbacks due to their concise syntax and lexical scoping of <code>this</code>.</p> </li> </ul> <p>Ultimately, the choice between function declarations and function expressions often comes down to the specific needs of your code and your team\u2019s coding style preferences. In modern React development, function expressions, especially with arrow functions, are prevalent due to their ease of use and alignment with functional programming principles.</p>"},{"location":"react/topic/mastering/function-declaration-and-expression/#utility-functions","title":"Utility functions","text":"<p>Utility functions are helper functions designed to perform common tasks or calculations that are not specific to a particular component but are used across various parts of your application. They help keep your code DRY (Don't Repeat Yourself) by encapsulating reusable logic that can be shared and maintained independently.</p>"},{"location":"react/topic/mastering/function-declaration-and-expression/#overview","title":"Overview","text":"Characteristics of Utility Functions <ul> <li>Reusable: Utility functions are generic and can be used in multiple places throughout your application.</li> <li>Single Responsibility: They generally do one thing well, making them easy to test and maintain.</li> <li>Stateless: They do not maintain or modify internal state; they operate based on the inputs provided and return a result.</li> </ul>"},{"location":"react/topic/mastering/function-declaration-and-expression/#example","title":"Example","text":"<p>Examples of Utility Functions in React</p> <ol> <li> <p>Simple Calculation Utility</p> <p>Suppose you have a function that formats numbers as currency. This function is not tied to a specific component but is used across your application wherever you need currency formatting.</p> JSUsage in a Component utils/formatCurrency.js<pre><code>// Utility function for formatting numbers as currency\nexport function formatCurrency(amount) {\n    return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n    }).format(amount);\n}\n</code></pre> <pre><code>import React from 'react';\nimport { formatCurrency } from './utils/formatCurrency';\n\nconst ProductPrice = ({ price }) =&gt; {\n    return &lt;div&gt;Price: {formatCurrency(price)}&lt;/div&gt;;\n};\n\nexport default ProductPrice;\n</code></pre> </li> <li> <p>Data Transformation Utility</p> <p>Imagine you need a utility to filter out users who are active from a list of users.</p> JSUsage in a Component utils/filterActiveUsers.js<pre><code>// Utility function for filtering active users\nexport function filterActiveUsers(users) {\n    return users.filter(user =&gt; user.isActive);\n}\n</code></pre> <pre><code>import React from 'react';\nimport { filterActiveUsers } from './utils/filterActiveUsers';\n\nconst UserList = ({ users }) =&gt; {\n    const activeUsers = filterActiveUsers(users);\n\n    return (\n        &lt;ul&gt;\n            {activeUsers.map(user =&gt; (\n                &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default UserList;\n</code></pre> </li> <li> <p>Date Formatting Utility</p> <p>If you need to format dates in various parts of your app, you might use a date formatting utility.</p> JSUsage in a Component utils/formatDate.js<pre><code>// Utility function for formatting dates\nexport function formatDate(date) {\n    return new Intl.DateTimeFormat('en-US').format(new Date(date));\n}\n</code></pre> <pre><code>import React from 'react';\nimport { formatDate } from './utils/formatDate';\n\nconst EventDate = ({ date }) =&gt; {\n    return &lt;div&gt;Event Date: {formatDate(date)}&lt;/div&gt;;\n};\n\nexport default EventDate;\n</code></pre> </li> </ol> Summary <p>Utility functions are designed to be reusable and to perform common operations that can be used across various components or modules in your application. By isolating these functions into separate files or modules, you make your codebase cleaner, more modular, and easier to maintain.</p> <p>In a React application, you would typically place utility functions in a dedicated <code>utils</code> directory or similar structure, and then import them into your components or other parts of your application as needed.</p>"},{"location":"react/topic/mastering/hooks-mastering-topic/","title":"Hooks Mastering","text":""},{"location":"react/topic/mastering/hooks-mastering-topic/#topic","title":"Topic","text":"<p>Mastering React functional hooks involves understanding their fundamentals, exploring advanced use cases, and practicing their application in real-world scenarios. Here\u2019s a structured approach to deepening your knowledge of React hooks:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li> <p>React Hooks Overview: Learn about the basic hooks such as <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, <code>useReducer</code>, and <code>useCallback</code>. Understand their signatures, use cases, and lifecycle implications.</p> <ul> <li><code>useState</code>: Manages local component state.</li> <li><code>useEffect</code>: Handles side effects (e.g., data fetching, subscriptions).</li> <li><code>useContext</code>: Accesses context values.</li> <li><code>useReducer</code>: Manages state using a reducer function.</li> <li><code>useCallback</code>: Memoizes callback functions.</li> <li><code>useMemo</code>: Memoizes expensive computations.</li> </ul> </li> <li> <p>Component Lifecycle: Understand how hooks map to lifecycle methods in class components (e.g., <code>useEffect</code> is similar to <code>componentDidMount</code> and <code>componentDidUpdate</code>).</p> </li> </ul> </li> <li> <p>Dive Deeper into Each Hook</p> <ul> <li> <p><code>useState</code>:</p> <ul> <li>Multiple state variables.</li> <li>State initialization and lazy initialization.</li> <li>Handling complex state.</li> </ul> </li> <li> <p><code>useEffect</code>:</p> <ul> <li>Cleanup functions.</li> <li>Dependency arrays and how they affect the execution.</li> <li>Managing asynchronous operations.</li> </ul> </li> <li> <p><code>useReducer</code>:</p> <ul> <li>Comparing with <code>useState</code>.</li> <li>When to use <code>useReducer</code> over <code>useState</code>.</li> <li>Handling complex state logic and actions.</li> </ul> </li> <li> <p><code>useContext</code>:</p> <ul> <li>Creating and providing context.</li> <li>Consuming context efficiently.</li> </ul> </li> <li> <p><code>useCallback</code> and <code>useMemo</code>:</p> <ul> <li>When to use them to optimize performance.</li> <li>Understanding dependencies and their impact.</li> </ul> </li> </ul> </li> <li> <p>Explore Advanced Hooks and Patterns</p> <ul> <li> <p>Custom Hooks: Learn to create reusable hooks to encapsulate logic. Practice building custom hooks for common patterns in your applications.</p> </li> <li> <p>Performance Optimization:</p> <ul> <li>Learn how hooks like <code>useMemo</code> and <code>useCallback</code> help prevent unnecessary re-renders.</li> <li>Understand the <code>React.memo</code> for memoizing components.</li> </ul> </li> <li> <p>Error Boundaries: Implement error handling using <code>Error Boundaries</code> in combination with hooks for better user experience.</p> </li> <li> <p>Custom Hook Patterns:</p> <ul> <li>Data fetching and synchronization (e.g., <code>useFetch</code>).</li> <li>Form handling and validation.</li> <li>Animation and timing effects.</li> </ul> </li> </ul> </li> <li> <p>Practice and Apply</p> <ul> <li> <p>Build Projects: Apply hooks in real-world projects. Build components that use various hooks and integrate them with APIs or complex state management.</p> </li> <li> <p>Refactor Class Components: Convert class components to functional components with hooks to understand their practical use.</p> </li> <li> <p>Code Reviews and Community: Participate in code reviews and seek feedback. Engage with the React community to learn from others\u2019 experiences and practices.</p> </li> </ul> </li> <li> <p>Stay Updated and Experiment</p> <ul> <li> <p>React Documentation: Regularly check the official React documentation for updates and new features.</p> </li> <li> <p>Blogs and Tutorials: Follow reputable blogs and tutorials to keep up with advanced techniques and best practices.</p> </li> <li> <p>Experiment: Try implementing new patterns and experimenting with different hook combinations to understand their behavior better.</p> </li> </ul> </li> <li> <p>Deep Dive into Related Libraries</p> <ul> <li> <p>React Query or SWR: Explore libraries like React Query for data fetching and caching. They often use hooks internally and provide a lot of utilities that complement your understanding of hooks.</p> </li> <li> <p>Form Libraries: Libraries like Formik or React Hook Form offer hooks for managing form state and validation, which can deepen your understanding of hooks in different contexts.</p> </li> </ul> </li> </ol> <p>By systematically studying these aspects, you\u2019ll be well on your way to mastering React functional hooks and applying them effectively in your projects.</p>"},{"location":"react/topic/mastering/hooks-mastering-topic/#god-tier","title":"God Tier","text":"<p>To reach a \"god level\" mastery of React functional hooks, you'll need to progress from foundational knowledge to complex and nuanced applications. Here's a structured and comprehensive approach to achieving this:</p> <ol> <li> <p>Master the Fundamentals</p> <ul> <li> <p>Core Hooks:</p> <ul> <li><code>useState</code>: Practice managing simple and complex state, using state initialization, and handling asynchronous updates.</li> <li><code>useEffect</code>: Understand different ways to use effects, including cleanup, dependency management, and handling async operations.</li> <li><code>useContext</code>: Implement and consume context, understand context performance implications, and create context providers.</li> <li><code>useReducer</code>: Implement complex state logic and actions, understand when to use useReducer versus useState.</li> <li><code>useCallback</code>: Learn when and how to memoize callbacks to avoid unnecessary re-renders.</li> <li><code>useMemo</code>: Memoize values to avoid expensive recalculations, and understand how to use dependencies properly.</li> </ul> </li> <li> <p>Component Lifecycle Mapping:</p> <ul> <li>Map hooks to lifecycle methods in class components (e.g., <code>useEffect</code> to <code>componentDidMount</code>/<code>componentDidUpdate</code>).</li> </ul> </li> </ul> </li> <li> <p>Build Strong Intermediate Skills</p> <ul> <li> <p>Custom Hooks:</p> <ul> <li>Create Reusable Logic: Develop custom hooks to encapsulate logic that is used across multiple components (e.g., form handling, data fetching).</li> <li>Combine Hooks: Create custom hooks that use other hooks to manage complex state or effects.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Avoid Re-renders: Use <code>React.memo</code> and <code>useCallback</code> to prevent unnecessary re-renders of components.</li> <li>Optimize Effects: Use the dependency array correctly in <code>useEffect</code> to avoid running effects unnecessarily.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Implement error boundaries in functional components, and combine them with hooks to manage and handle errors effectively.</li> </ul> </li> </ul> </li> <li> <p>Achieve Advanced Mastery</p> <ul> <li> <p>Complex Custom Hooks:</p> <ul> <li>Abstract Logic: Build custom hooks that abstract complex logic such as pagination, authentication, or offline storage.</li> <li>Complex Interactions: Develop hooks that manage complex interactions between components, such as synchronized state across different parts of an app.</li> </ul> </li> <li> <p>Advanced Patterns:</p> <ul> <li>Render Props and Higher-Order Components (HOCs): Compare and contrast hooks with these patterns, and understand when and why to use hooks over them.</li> <li>Compound Components: Use hooks to create compound component patterns that share state and behavior seamlessly.</li> </ul> </li> <li> <p>Performance Tuning:</p> <ul> <li>Code Splitting and Lazy Loading: Utilize React\u2019s lazy loading and code splitting features to optimize performance.</li> <li>Memoization Strategies: Dive deep into memoization techniques and understand their impact on performance.</li> </ul> </li> </ul> </li> <li> <p>Deep Dive into Ecosystem and Libraries</p> <ul> <li> <p>React Query/SWR:</p> <ul> <li>Master libraries that manage server state with hooks, such as React Query or SWR. Learn their advanced features like caching, pagination, and optimistic updates.</li> </ul> </li> <li> <p>Form Libraries:</p> <ul> <li>Formik/React Hook Form: Deep dive into form handling libraries and their hooks. Understand how they simplify complex form logic and validation.</li> </ul> </li> <li> <p>Animation Libraries:</p> <ul> <li>React Spring/Framer Motion: Explore animation libraries that use hooks to manage animations and transitions.</li> </ul> </li> </ul> </li> <li> <p>Practice and Real-World Application</p> <ul> <li> <p>Build and Refactor Projects:</p> <ul> <li>Refactor Existing Code: Take existing class-based components and refactor them to functional components using hooks.</li> <li>Build New Projects: Create projects from scratch using hooks to reinforce your understanding.</li> </ul> </li> <li> <p>Code Reviews and Collaboration:</p> <ul> <li>Participate in Code Reviews: Review code written by others and provide feedback on hook usage and best practices.</li> <li>Collaborate on Open Source: Contribute to open source projects to see how experienced developers use hooks in various contexts.</li> </ul> </li> </ul> </li> <li> <p>Stay Updated and Continue Learning</p> <ul> <li> <p>React Documentation and Releases:</p> <ul> <li>Follow Official Docs: Regularly check the official React documentation for updates on hooks and new features.</li> <li>Stay Current: Keep up with the latest React releases and changes to hooks.</li> </ul> </li> <li> <p>Community and Thought Leaders:</p> <ul> <li>Read Blogs and Watch Talks: Follow influential React developers and stay updated with the latest techniques and best practices.</li> <li>Engage with the Community: Participate in forums, attend meetups, and join discussions to learn from peers and experts.</li> </ul> </li> </ul> </li> </ol> <p>By following this structured approach and continuously challenging yourself with new projects and concepts, you\u2019ll develop a profound and comprehensive mastery of React functional hooks.</p>"},{"location":"react/topic/mastering/one-most-important-in-react/","title":"One Most IMP","text":""},{"location":"react/topic/mastering/one-most-important-in-react/#overview","title":"Overview","text":"<p>What is the most challenging about react</p> <p>One of the most challenging aspects of React development is state management, especially as an application grows in complexity. While React itself provides a straightforward way to manage component state locally, scaling this across larger applications can quickly become difficult. Here's why:</p> <ol> <li> <p>Complex State Management: As an application grows, managing state at the component level becomes cumbersome. Passing state down through many layers of components (often referred to as \"prop drilling\") can lead to messy code and performance issues. Managing global state can also become tricky, especially when components rely on shared data or need to react to changes in real-time.</p> </li> <li> <p>Choosing the Right State Management Solution: React offers various options for state management, ranging from React\u2019s built-in <code>useState</code> and <code>useReducer</code> hooks to more advanced libraries like Redux, Context API, or third-party solutions like Recoil or Zustand. Deciding which tool to use, or how to organize state efficiently, can be overwhelming, especially for beginners or in large-scale applications.</p> </li> <li> <p>Component Re-rendering: React\u2019s re-rendering behavior can sometimes be hard to control. While React uses a virtual DOM for performance optimization, unnecessary re-renders can still occur if state updates or props change unintentionally. Optimizing renders using techniques like memoization (e.g., <code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>) requires a deep understanding of React\u2019s rendering mechanics.</p> </li> <li> <p>Asynchronous Data Handling: Working with asynchronous data (e.g., fetching data from APIs) can create challenges, such as managing loading states, error handling, and ensuring that UI is updated correctly when data arrives. React hooks like <code>useEffect</code> or libraries like React Query can help, but handling side effects and asynchronous behavior still requires careful attention to avoid race conditions or inconsistent state.</p> </li> <li> <p>Understanding Hooks: React hooks, like <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, and custom hooks, are powerful but can be tricky to master, especially for developers coming from a class-based component background. Understanding the rules of hooks (e.g., they must be called in the same order in every render) and dealing with hooks' dependency arrays in useEffect can be confusing.</p> </li> <li> <p>Context API Performance Issues: While React's Context API is a simple way to manage global state, using it incorrectly or excessively can cause performance problems because any update to the context triggers a re-render of all components that consume that context. Managing context efficiently is essential for preventing unnecessary re-renders.</p> </li> <li> <p>TypeScript Integration: As React applications grow, incorporating TypeScript for type safety is increasingly common. While TypeScript brings many benefits, it can be challenging to integrate correctly, especially when working with complex component props, states, and third-party libraries that may not have proper type definitions.</p> </li> <li> <p>Testing: React applications often require careful testing of components, hooks, and integration. Tools like Jest and React Testing Library are commonly used, but writing tests that accurately simulate real user interactions and ensure proper state management can be time-consuming and complex.</p> </li> </ol> <p>React offers a lot of flexibility and power, but these challenges require a solid understanding of its core concepts and best practices to build maintainable, performant, and scalable applications.</p>"},{"location":"react/topic/mastering/one-most-important-in-react/#additional","title":"Additional","text":"<p>what is the one of the most important to understand in react to master in depth</p> <p>One of the most important concepts to understand in React to master it in depth is State Management. This concept is crucial because it drives how data flows and is managed in your application. Here's why state management is central to React development:</p> <ol> <li> <p>State and Re-rendering:</p> <ul> <li>In React, state is used to hold data that affects the rendering of a component. Understanding how state works and triggers re-renders is key to ensuring that your application behaves as expected.</li> <li>React's reconciliation algorithm (the process of updating the DOM) relies on detecting changes in state, so understanding this process helps you write more efficient applications and optimize performance.</li> </ul> </li> <li> <p>Component Lifecycle:</p> <ul> <li>React components go through a lifecycle, and understanding this lifecycle helps you manage state at various stages of a component\u2019s existence (e.g., mounting, updating, unmounting).</li> <li>Managing state properly in different lifecycle methods (in class components) or hooks (in functional components) like useEffect or useState is essential for building dynamic, responsive applications.</li> </ul> </li> <li> <p>State Management Libraries:</p> <ul> <li> <p>As applications grow in complexity, managing state across multiple components can become challenging. This is where state management libraries come into play. The most commonly used ones in React are:</p> <ul> <li>Redux: For global state management across the entire application.</li> <li>Context API: React\u2019s built-in solution for sharing state between components without prop drilling.</li> <li>Recoil or Zustand: Modern alternatives to Redux that offer simpler, more flexible state management.</li> </ul> </li> <li> <p>Mastering these tools (and understanding when and why to use them) is essential for managing complex state in large-scale applications.</p> </li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>React\u2019s re-rendering can sometimes lead to performance issues, especially in large applications. Understanding how to optimize state management to reduce unnecessary re-renders (using techniques like memoization, <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code>) is vital.</li> <li>Proper state management allows you to ensure that only necessary parts of the application are re-rendered when state changes.</li> </ul> </li> <li> <p>State Immutability:</p> <ul> <li>React relies on the concept of immutability (i.e., not directly modifying the state). Instead, state should be updated in an immutable way (e.g., using spread operators, <code>Object.assign</code>, or libraries like <code>Immer</code>).</li> <li>Understanding immutability is key to preventing bugs and ensuring React's efficient re-rendering process works properly.</li> </ul> </li> <li> <p>Asynchronous State Management:</p> <ul> <li>Many times, state needs to be updated asynchronously, especially when working with APIs or handling user inputs. React\u2019s hooks (such as <code>useState</code> with asynchronous updates, and <code>useEffect</code> for side effects) are important tools in dealing with this complexity.</li> <li>Learning how to manage state updates effectively in an asynchronous environment is essential for building smooth, user-friendly applications.</li> </ul> </li> </ol> <p>Conclusion:</p> <p>Mastering state management in React involves understanding how state drives the UI, how to optimize re-renders, how to manage state across components, and how to handle it efficiently in large-scale applications. This knowledge is fundamental to becoming proficient in React, as it underpins almost every aspect of building React applications.</p>"},{"location":"react/topic/mastering/shallow-comparison/","title":"Shallow Comparison","text":"<p>Understanding Immutability and State Change Detection in React</p>"},{"location":"react/topic/mastering/shallow-comparison/#overview","title":"Overview","text":"<p>In React, state and props are fundamental to how the component behaves. When working with state, it is important to understand whether the data has changed or not to optimize re-renders and ensure that React is efficiently managing updates. Here's how you can determine whether an object or array (or any data structure) has changed its original value in React:</p>"},{"location":"react/topic/mastering/shallow-comparison/#1-using-object-references-to-detect-changes","title":"1. Using Object References to Detect Changes","text":"<p>In JavaScript, objects and arrays are reference types. This means when you assign an object or array to a variable, that variable doesn't hold the actual data but instead holds a reference (or pointer) to the original object or array in memory.</p> <p>In React, the most efficient way to detect whether a value has changed is by comparing the reference of the value, not the value itself (for non-primitive types like arrays and objects).</p> Key Concept: <ul> <li>Primitive types: (e.g., <code>number</code>, <code>string</code>, <code>boolean</code>) are compared by value.</li> <li>Reference types: (e.g., <code>array</code>, <code>object</code>) are compared by reference.</li> </ul> <p>In React, you can use shallow comparison (comparing the references) to check if something has changed, and React will re-render when the reference changes.</p>"},{"location":"react/topic/mastering/shallow-comparison/#2-how-to-compare-changes-in-react","title":"2. How to Compare Changes in React","text":"<p>To compare if a value has changed, you can look at whether the reference of the object or array has changed. If the reference has changed, the object/array is considered \"new\" and React will update the component accordingly.</p> <p>Here are a few ways to check if a value has changed:</p> <p>For Primitive Types (numbers, strings, booleans):</p> <p>You can simply compare the previous and current values.</p> <pre><code>let prevValue = 5;\nlet currentValue = 6;\n\nif (prevValue !== currentValue) {\n  console.log(\"The value has changed!\");\n}\n</code></pre> <p>For Objects and Arrays (reference types):</p> <p>You cannot compare objects and arrays directly by value in JavaScript. Instead, you compare their references. If the reference changes, it means the data has changed.</p> <pre><code>const prevArray = [1, 2, 3];\nconst newArray = [...prevArray, 4]; // Creating a new array\n\nif (prevArray !== newArray) {\n  console.log(\"The array has changed!\"); // This will log\n}\n\nconst prevObject = { name: \"Alice\" };\nconst newObject = { ...prevObject, age: 25 }; // Creating a new object\n\nif (prevObject !== newObject) {\n  console.log(\"The object has changed!\"); // This will log\n}\n</code></pre>"},{"location":"react/topic/mastering/shallow-comparison/#3-how-react-detects-changes-using-usestate-and-useeffect","title":"3. How React Detects Changes (Using <code>useState</code> and <code>useEffect</code>)","text":"<p>In React, the core way to update the UI is by using state. When state changes, React checks if the state reference has changed (using shallow comparison). If the reference has changed, it triggers a re-render.</p> <p>Here's how you might typically check for changes in React components:</p> Example using useState and useEffect:<pre><code>import React, { useState, useEffect } from \"react\";\n\nfunction ExampleComponent() {\n  const [state, setState] = useState({ count: 0 });\n\n  // Using useEffect to watch for changes in state\n  useEffect(() =&gt; {\n    console.log(\"State has changed:\", state);\n  }, [state]); // Only triggers when `state` changes\n\n  const handleClick = () =&gt; {\n    // Updating state by creating a new object (immutable update)\n    setState((prevState) =&gt; ({ ...prevState, count: prevState.count + 1 }));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {state.count}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default ExampleComponent;\n</code></pre> Key Points: <ul> <li><code>useState</code>: React checks the state reference to see if it has changed. If the new state reference is different from the previous state reference, React re-renders the component.</li> <li><code>useEffect</code>: You can use <code>useEffect</code> with a dependency array to run side effects only when a value (state or props) changes. The dependency array is compared shallowly for changes.</li> <li>Immutable updates: You should always update state immutably by creating a new object or array (using spread syntax or methods like <code>concat()</code> for arrays). Direct mutation of state can cause unpredictable behavior in React.</li> </ul>"},{"location":"react/topic/mastering/shallow-comparison/#4-shallow-vs-deep-comparison","title":"4. Shallow vs Deep Comparison","text":"<ul> <li> <p>Shallow Comparison: Compares only the references for objects and arrays. This is how React determines whether a state change has occurred, by comparing the <code>reference</code> of the previous and new state.</p> </li> <li> <p>Deep Comparison: Compares the actual contents of objects or arrays, which is more expensive computationally and generally not needed in React.</p> </li> </ul> <p>For React, shallow comparison is used by default. When you update state by creating a new reference (new object or array), React will re-render the component.</p>"},{"location":"react/topic/mastering/shallow-comparison/#5-example-of-detecting-change-in-react-state","title":"5. Example of Detecting Change in React State","text":"<p>Here\u2019s an example of detecting changes using <code>useState</code> and <code>useEffect</code>:</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nfunction App() {\n  const [state, setState] = useState({ name: \"Alice\", age: 25 });\n\n  // Log when state changes\n  useEffect(() =&gt; {\n    console.log(\"State has changed:\", state);\n  }, [state]); // Only triggers when `state` reference changes\n\n  const changeState = () =&gt; {\n    // Immutable update (creates a new object)\n    setState((prevState) =&gt; ({ ...prevState, age: prevState.age + 1 }));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Name: {state.name}&lt;/p&gt;\n      &lt;p&gt;Age: {state.age}&lt;/p&gt;\n      &lt;button onClick={changeState}&gt;Increment Age&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>In this example:</p> <ul> <li>We use the spread operator (<code>{ ...prevState, age: prevState.age + 1 }</code>) to create a new state object.</li> <li>React detects the change by comparing the new <code>state</code> reference with the old one.</li> </ul>"},{"location":"react/topic/mastering/shallow-comparison/#6-reacts-performance-optimization-with-shouldcomponentupdate-or-reactmemo","title":"6. React's Performance Optimization with <code>shouldComponentUpdate</code> or <code>React.memo()</code>","text":"<p>React provides ways to optimize how and when components re-render. For functional components, you can use <code>React.memo()</code> to prevent unnecessary re-renders based on state or props changes:</p> <pre><code>const MyComponent = React.memo(function MyComponent({ data }) {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n});\n</code></pre> <p>React will shallowly compare the props, and only re-render the component if the props have changed.</p>"},{"location":"react/topic/mastering/shallow-comparison/#conclusion-how-to-compare-changes-in-react","title":"Conclusion: How to Compare Changes in React","text":"<ul> <li>Reference comparison is the most important concept. When state or props change, React compares their references, not their contents.</li> <li>To trigger a re-render, always create new references (by using immutable patterns like <code>spread</code> or array methods like <code>concat()</code>).</li> <li>Use <code>useEffect</code> with a dependency array to react to changes in state.</li> <li>Avoid mutating state directly\u2014always make an immutable update.</li> <li>React does shallow comparisons by default, which compares references for objects and arrays, so always ensure that you are updating state immutably.</li> </ul> <p>By following these principles, React can efficiently manage state changes and optimize re-renders, ensuring your app runs smoothly.</p>"},{"location":"react/topic/mastering/state-immutability/","title":"State Immutability","text":"<p>State Immutability: explain me in depth what is is in js and react and how does it effect in react</p>"},{"location":"react/topic/mastering/state-immutability/#state-immutability-in-javascript-and-react","title":"State Immutability in JavaScript and React","text":"<p>Immutability refers to the concept that once an object or data structure is created, it cannot be changed. Instead of directly modifying the original object, a new copy of the object is created with the updated values. This principle is critical in both JavaScript and React for ensuring that your code works predictably and efficiently, especially when it comes to state management.</p>"},{"location":"react/topic/mastering/state-immutability/#immutability-in-javascript","title":"Immutability in JavaScript","text":"<p>In JavaScript, objects and arrays are mutable by default, meaning that you can modify them directly (e.g., change a property of an object or append to an array). However, immutability means you should avoid direct modifications. For example:</p> <ul> <li> <p>Mutable Operation (Not Immutable):</p> <pre><code>let obj = { name: \"John\" };\nobj.name = \"Jane\"; // Direct modification\n</code></pre> </li> <li> <p>Immutable Operation (Using Immutability):</p> <pre><code>let obj = { name: \"John\" };\nobj = { ...obj, name: \"Jane\" }; // Create a new object with updated values\n</code></pre> </li> </ul> <p>Instead of directly modifying <code>obj</code>, you create a new object with the updated properties. This ensures that the original object remains unchanged.</p>"},{"location":"react/topic/mastering/state-immutability/#immutability-in-react","title":"Immutability in React","text":"<p>Immutability plays a critical role in React because it directly affects re-rendering and state updates.</p> <p>In React, the UI is a function of state. React tracks the changes in state to decide when and how to re-render components. If state is directly mutated, React can\u2019t easily detect changes, which can lead to unexpected behavior, such as:</p> <ul> <li>UI not updating properly</li> <li>State not being tracked correctly</li> <li>Unnecessary re-renders</li> </ul> <p>To understand why immutability matters, let\u2019s break down its effects in React:</p>"},{"location":"react/topic/mastering/state-immutability/#why-immutability-is-important-in-react","title":"Why Immutability is Important in React","text":"<ol> <li> <p>Efficient Re-rendering:</p> <ul> <li>React uses a reconciliation process to determine what has changed in the UI. If you mutate the state directly, React will not be able to detect that a change has occurred because the reference to the object or array remains the same.</li> <li>Immutability allows React to detect changes: When you create a new object or array with updated values, React can compare the new reference with the old one and quickly determine that something has changed, triggering a re-render.</li> </ul> </li> <li> <p>Predictability of State Updates:</p> <ul> <li>Immutability ensures that the state is predictable. When the state is directly modified, it becomes difficult to reason about how the state changes over time because one part of the app might change the state while another part might depend on the old state.</li> <li>With immutability, state changes are clear and explicit. The new state is distinct from the previous one, which makes debugging and understanding the flow of data easier.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>In React, especially with large applications, unnecessary re-renders can hurt performance. Direct mutation can lead to re-renders that might not be needed.</li> <li>Immutability helps in performance optimization: By comparing references (shallow comparison) instead of values, React can skip unnecessary updates to components, especially when the state or props haven\u2019t actually changed.</li> </ul> </li> <li> <p>Working with Pure Components:</p> <ul> <li> <p>React encourages the use of pure components, which are components that only depend on the props and state they receive. A pure component re-renders only if the props or state change.</p> </li> <li> <p>Mutating state directly prevents React from recognizing changes: If a component\u2019s state is mutated directly, React might not detect that the component\u2019s data has changed, leading to stale UI.</p> </li> </ul> </li> </ol>"},{"location":"react/topic/mastering/state-immutability/#examples-of-immutability-in-react","title":"Examples of Immutability in React","text":"<p>Let's explore how immutability works in React with a few examples.</p> <p>Example 1: Updating State in a React Component</p> <p>In React, state is often updated using the <code>useState</code> hook (or <code>this.setState</code> in class components). To update state in an immutable way, you must ensure that you create a new copy of the state rather than modifying it directly.</p> <ul> <li> <p>Mutable Approach (Incorrect):</p> <pre><code>const [state, setState] = useState({ count: 0 });\n\nconst increment = () =&gt; {\n  state.count += 1; // Mutating state directly (Incorrect)\n  setState(state); // Doesn't trigger re-render correctly\n};\n</code></pre> </li> <li> <p>Immutable Approach (Correct):</p> <pre><code>const [state, setState] = useState({ count: 0 });\n\nconst increment = () =&gt; {\n  setState((prevState) =&gt; ({ count: prevState.count + 1 })); // Create a new object\n};\n</code></pre> </li> </ul> <p>In the immutable approach, instead of modifying the <code>state.count</code> directly, we return a new object with an updated count. This ensures React will detect a change and trigger a re-render.</p> <p>Example 2: Updating Arrays or Objects</p> <p>When updating arrays or objects in React, you need to make sure you're not directly modifying them. Here\u2019s how you would do it immutably.</p> <ul> <li> <p>Updating an Array (Mutable Way)</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst addItem = () =&gt; {\n  items.push(4); // Mutating the array directly (Incorrect)\n  setItems(items);\n};\n</code></pre> </li> <li> <p>Updating an Array (Immutable Way)</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst addItem = () =&gt; {\n  setItems((prevItems) =&gt; [...prevItems, 4]); // Create a new array with added item\n};\n</code></pre> </li> </ul> <p>In the immutable approach, you use the spread operator (...) to create a new array with the updated item, rather than modifying the existing array.</p> <p>Example 3: Using <code>map()</code> or <code>filter()</code> to Update Arrays</p> <p>Let\u2019s say you need to update an item in an array or remove it.</p> <ul> <li> <p>Immutable Array Update (Correct):</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst updateItem = (id, newValue) =&gt; {\n  setItems((prevItems) =&gt;\n    prevItems.map((item) =&gt; (item === id ? newValue : item))\n  ); // Map to create a new array with updated value\n};\n</code></pre> </li> <li> <p>Immutable Array Removal (Correct):</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst removeItem = (id) =&gt; {\n  setItems((prevItems) =&gt; prevItems.filter((item) =&gt; item !== id)); // Create new array excluding item\n};\n</code></pre> </li> </ul> <p>In both examples, you are not modifying the original array (prevItems). Instead, you create a new array using map() or filter().</p>"},{"location":"react/topic/mastering/state-immutability/#why-mutating-state-can-cause-issues-in-react","title":"Why Mutating State Can Cause Issues in React","text":"<ol> <li> <p>Inconsistent Rendering: If you mutate the state, React won\u2019t be able to compare the new and old state properly, resulting in missed updates to the UI.</p> </li> <li> <p>Hard to Track Changes: When state is mutated directly, it\u2019s harder to know when and where changes happen. This leads to debugging difficulties.</p> </li> <li> <p>Unintended Side Effects: Mutating state directly can lead to unintended consequences, as other parts of the code might be expecting the original state.</p> </li> </ol>"},{"location":"react/topic/mastering/state-immutability/#summary","title":"Summary","text":"<ul> <li>Immutability is a core principle in React that ensures proper state updates and component re-renders.</li> <li>By creating new objects or arrays with updated values instead of directly modifying the original state, React can detect changes efficiently.</li> <li>This leads to better performance, easier debugging, and predictable state behavior in your application.</li> </ul> <p>Mastering immutability in React helps you write more efficient, maintainable, and bug-free applications.</p>"},{"location":"router/intro/","title":"Intro","text":"<p>router</p> <p></p>"},{"location":"router/permission-based-routing/","title":"Permission Based Routing","text":"<p>To implement permission-based routing in the <code>AppRoutes</code> component you've shared, you will need to incorporate checks that will verify if the user has the necessary permissions to access certain routes. Given that you're using Redux for authentication, the approach would involve both authentication and permission checks.</p> PrivateRoute.js<pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\n\n// Permission-based PrivateRoute component\nconst PrivateRoute = ({ children, requiredPermissions }) =&gt; {\n  const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n  const userPermissions = useSelector((state) =&gt; state.auth.permissions); // Assuming permissions are stored here\n\n  // If not authenticated, redirect to login page\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  // If user doesn't have the required permissions, redirect to \"no access\" page\n  if (\n    requiredPermissions &amp;&amp;\n    !requiredPermissions.every((permission) =&gt;\n      userPermissions.includes(permission)\n    )\n  ) {\n    return &lt;Navigate to=\"/no-access\" /&gt;;\n  }\n\n  return children;\n};\n\nexport default PrivateRoute;\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { APP_ROUTES } from \".\";\n\n// ROUTES\nimport PrivateRoute from \"./PrivateRoutes\";\nimport RedirectRoute from \"./RedirectRoutes\";\n\nimport Login from \"@features/auth/components/Login/Login\";\nimport Dashboard from \"@features/dashboard/components/Dashboard\";\nimport MainLayout from \"@shared/components/DashbordLayout/MainLayout\";\nimport Analysis from \"@features/dashboard/components/Analysis\";\nimport WorkSpace from \"@features/dashboard/components/Workspace\";\nimport NotFound from \"@shared/components/NotFoundPage\";\nimport BuyingSelling from \"@features/forex/components/BuyingSelling\";\nimport AllDeals from \"@features/forex/components/AllDeals\";\n// import Users from \"@features/settings/components/Users/components/Users\";\nimport Country from \"@features/settings/components/Country\";\nimport CounterParty from \"@features/settings/components/CounterParty\";\nimport Currency from \"@features/settings/components/Currency\";\nimport CounterPartyDealers from \"@features/settings/components/CounterPartyDealers\";\nimport RolePermissions from \"@features/settings/components/RolesAndPermissions\";\nimport DealBankAccounts from \"@features/settings/components/DealBankAccounts\";\nimport Users from \"@features/settings/components/Users\";\nimport Province from \"@features/settings/components/Province\";\nimport UpdatePassword from \"@features/profile/components/UpdatePassword\";\nimport UserProfile from \"@features/profile/components/UserProfile\";\nimport FiscalYear from \"@features/settings/components/FiscalYear\";\nimport Rates from \"@features/settings/components/Rates\";\n\nconst AppRoutes = () =&gt; {\n  const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n  const protectedRoutes = [\n    {\n      path: APP_ROUTES.DASHBOARD_ANALYSIS,\n      element: &lt;Analysis /&gt;,\n      requiredPermissions: [\n        \"Permissions.Application.CanViewDataDuringBusinessHours\",\n      ],\n    },\n    {\n      path: APP_ROUTES.DASHBOARD_WORKSPACE,\n      element: &lt;WorkSpace /&gt;,\n      requiredPermissions: [\"Permissions.Application.CanViewDataWeekendOnly\"],\n    },\n    {\n      path: APP_ROUTES.FOREX_DEALS,\n      element: &lt;AllDeals /&gt;,\n      requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n    },\n    {\n      path: APP_ROUTES.FOREX_TRADING,\n      element: &lt;BuyingSelling /&gt;,\n      requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_COUNTRY,\n      element: &lt;Country /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanView\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_PROVINCE,\n      element: &lt;Province /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanEdit\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_FISCALYEAR,\n      element: &lt;FiscalYear /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanView\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_RATES,\n      element: &lt;Rates /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanEdit\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_CURRENCY,\n      element: &lt;Currency /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanView\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_COUNTERPARTY,\n      element: &lt;CounterParty /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanEdit\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_COUNTERPARTYDEALERS,\n      element: &lt;CounterPartyDealers /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanEdit\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_DEALBANKACCOUNT,\n      element: &lt;DealBankAccounts /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanView\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_ROLESPERMISSIONS,\n      element: &lt;RolePermissions /&gt;,\n      requiredPermissions: [\"Permissions.PermissionMgmt.CanEdit\"],\n    },\n    {\n      path: APP_ROUTES.SETTING_USERS,\n      element: &lt;Users /&gt;,\n      requiredPermissions: [\"Permissions.User.CanView\"],\n    },\n    {\n      path: APP_ROUTES.PROFILE,\n      element: &lt;UserProfile /&gt;,\n      requiredPermissions: [\"Permissions.User.CanView\"],\n    },\n    {\n      path: APP_ROUTES.PROFILE_UPDATEPASSWORD,\n      element: &lt;UpdatePassword /&gt;,\n      requiredPermissions: [\"Permissions.User.CanView\"],\n    },\n    { path: \"*\", element: &lt;NotFound /&gt; },\n  ];\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route\n          path=\"/\"\n          element={\n            &lt;RedirectRoute&gt;\n              &lt;Login /&gt;\n            &lt;/RedirectRoute&gt;\n          }\n        &gt;&lt;/Route&gt;\n\n        {protectedRoutes.map(({ path, element, requiredPermissions }) =&gt; (\n          &lt;Route\n            key={path}\n            path={path}\n            element={\n              &lt;PrivateRoute requiredPermissions={requiredPermissions}&gt;\n                &lt;MainLayout&gt;{element}&lt;/MainLayout&gt;\n              &lt;/PrivateRoute&gt;\n            }\n          /&gt;\n        ))}\n\n        &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre> Key ChangesNotes <ol> <li><code>PrivateRoute</code> Component: Now checks for both authentication and permissions.</li> <li>requiredPermissions: Added a <code>requiredPermissions</code> field to each route in protectedRoutes, defining the necessary permissions for each route.</li> <li>Route Protection: Wrapped each route with the <code>PrivateRoute</code> component, passing the required permissions.</li> </ol> <ul> <li>You need to ensure that your Redux state holds both authentication status (<code>isAuthenticated</code>) and permissions (<code>permissions</code>).</li> <li>You can customize the <code>PrivateRoute</code> further to redirect to a custom page (e.g., a \"No Access\" page) when permissions are insufficient.</li> </ul>"},{"location":"router/permission-based-routing/#hide-the-menu","title":"Hide the Menu","text":"<p>To hide menu items in your <code>Sidebar</code> based on user permissions, you can follow these steps:</p> <ul> <li>Get the user's permissions from the Redux store (assuming the permissions are already part of the user\u2019s data).</li> <li>Filter the menu items by checking whether the user has the necessary permissions before rendering the item.</li> <li>Update the sidebar items dynamically to only show items that the user is authorized to view.</li> </ul> <p>Here's how you can modify your Sidebar component to achieve this:</p> <p>1. Get Permissions from Redux Store:</p> <p>You can use the <code>useSelector</code> hook to access the user's permissions from the Redux store. For this example, I'm assuming that the permissions are stored in <code>state.auth.permissions</code>.</p> <p>2. Filter the Menu Items:</p> <p>Before rendering the menu, check whether the user has the necessary permissions for each menu item. You can add a condition that checks if the user has the required permissions for each route.</p> <p>3. Update the <code>Sidebar</code> Component:</p> <pre><code>import React, { useState, useEffect } from \"react\";\nimport { Menu } from \"antd\";\nimport {\n  DashboardOutlined,\n  SettingOutlined,\n  UserOutlined,\n  AccountBookOutlined,\n  BankOutlined,\n  FundOutlined,\n  ProjectOutlined,\n  IssuesCloseOutlined,\n} from \"@ant-design/icons\";\nimport { useNavigate, useLocation } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { APP_ROUTES } from \"@shared/routes\";\nimport logger from \"@shared/utils/logger\";\n\nconst Sidebar = ({ collapsed, height, width }) =&gt; {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const permissions = useSelector((state) =&gt; state.auth.permissions); // Assuming permissions are stored here\n\n  // Define the menu items\n  const items = [\n    {\n      key: APP_ROUTES.DASHBOARD,\n      label: \"Dashboard\",\n      icon: &lt;DashboardOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.DASHBOARD_ANALYSIS,\n          label: \"Analysis\",\n          requiredPermissions: [\n            \"Permissions.Application.CanViewDataDuringBusinessHours\",\n          ],\n        },\n        {\n          key: APP_ROUTES.DASHBOARD_WORKSPACE,\n          label: \"Workplace\",\n          requiredPermissions: [\n            \"Permissions.Application.CanViewDataWeekendOnly\",\n          ],\n        },\n      ],\n    },\n    {\n      key: APP_ROUTES.FOREX,\n      label: \"Forex T Deal\",\n      icon: &lt;AccountBookOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.FOREX_DEALS,\n          label: \"All Deals\",\n          requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n        },\n        {\n          key: APP_ROUTES.FOREX_TRADING,\n          label: \"Buying / Selling\",\n          requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n        },\n      ],\n    },\n    {\n      key: \"/lcy\",\n      label: \"M.M.D. - Lcy\",\n      icon: &lt;BankOutlined /&gt;,\n      children: [\n        {\n          key: \"/lcy/option1\",\n          label: \"Option 7\",\n        },\n      ],\n    },\n    // ... other menu items (similarly)\n  ];\n\n  // Function to filter items based on permissions\n  const filterItemsByPermissions = (items) =&gt; {\n    return items.filter((item) =&gt; {\n      // If item has children, filter the children recursively\n      if (item.children) {\n        item.children = filterItemsByPermissions(item.children);\n      }\n\n      // Only include the item if it has no required permissions or the user has them\n      return (\n        !item.requiredPermissions ||\n        item.requiredPermissions.some((perm) =&gt; permissions.includes(perm))\n      );\n    });\n  };\n\n  // Filter menu items based on permissions\n  const filteredItems = filterItemsByPermissions(items);\n\n  // Function to get parent key for open submenu\n  const getParentKey = (path) =&gt; {\n    const parent = filteredItems.find((item) =&gt; path.startsWith(item.key));\n    return parent ? parent.key : null;\n  };\n\n  const [openKeys, setOpenKeys] = useState([getParentKey(location.pathname)]);\n\n  useEffect(() =&gt; {\n    setOpenKeys([getParentKey(location.pathname)]);\n  }, [location.pathname]);\n\n  const handleClick = ({ key }) =&gt; {\n    navigate(key);\n  };\n\n  return (\n    &lt;Menu\n      className=\"sidebar-layout\"\n      style={{\n        height: height,\n        width: width,\n        textAlign: \"left\",\n      }}\n      mode=\"inline\"\n      selectedKeys={[location.pathname]}\n      inlineCollapsed={collapsed}\n      openKeys={openKeys}\n      onOpenChange={setOpenKeys}\n      onClick={handleClick}\n      items={filteredItems} // Use the filtered items\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre> Key Changes <ol> <li> <p>Permissions Check:</p> <ul> <li>Each item now has an optional <code>requiredPermissions</code> field. If it has this field, it will be an array of permissions required for that item to be visible.</li> <li>The <code>filterItemsByPermissions</code> function filters out items that the user doesn't have permissions for.</li> </ul> </li> <li> <p>Recursive Filtering:</p> <ul> <li>Since some items have <code>children</code>, the <code>filterItemsByPermissions</code> function filters both parent and child items recursively.</li> <li>If an item or its children don't match the permissions, they will be excluded from the menu.</li> </ul> </li> <li> <p>Dynamic Menu Rendering:</p> <ul> <li>The <code>filteredItems</code> array is used to render the menu, ensuring that only items the user is authorized to see are included.</li> </ul> </li> </ol> <p>4. Permissions Configuration:</p> <p>Make sure that you have permissions set up properly in your Redux store and that each route/component has its necessary permission defined (like <code>Permissions.Application.CanViewDashboard</code>, etc.).</p> <p>5. Example:</p> <ul> <li>If a user doesn't have the <code>Permissions.Application.CanViewDataDuringBusinessHours</code>, the \"Analysis\" link will not be displayed in the sidebar.</li> <li>Similarly, any other menu item that requires specific permissions will be hidden from the sidebar if the user doesn't have the necessary permissions.</li> </ul> <p>By following this approach, you ensure that menu items are not just hidden but also prevented from rendering based on the user's permissions, making the app's navigation more secure and dynamic.</p>"},{"location":"router/permission-based-routing/#hiding-the-parent-as-well-is-not-children","title":"Hiding the Parent as Well is not children","text":"<p>Great question! In the scenario where both the \"All Deals\" and \"Buying / Selling\" menu items under \"Forex T Deal\" do not have the <code>canView</code> permission, the \"Forex T Deal\" text (parent label) would still be shown unless you explicitly filter out the parent item as well.</p> <p>Currently, in the provided code, the filtering logic only checks the <code>requiredPermissions</code> on the children. If none of the children have permission, the parent (in this case, \"Forex T Deal\") will still be visible, even if all the child items are hidden.</p> <p>To address this, you can modify the filtering logic to also check if the parent item itself should be shown based on the visibility of its children. If none of the child items are allowed to be shown due to missing permissions, you can hide the entire parent as well.</p> <p>Here\u2019s how to fix this:</p> <p>You need to update the filtering function so that it also hides the parent item if none of its children are visible (based on permissions).</p> <pre><code>import React, { useState, useEffect } from \"react\";\nimport { Menu } from \"antd\";\nimport {\n  DashboardOutlined,\n  SettingOutlined,\n  AccountBookOutlined,\n  BankOutlined,\n  FundOutlined,\n  ProjectOutlined,\n  IssuesCloseOutlined,\n} from \"@ant-design/icons\";\nimport { useNavigate, useLocation } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { APP_ROUTES } from \"@shared/routes\";\nimport logger from \"@shared/utils/logger\";\n\nconst Sidebar = ({ collapsed, height, width }) =&gt; {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const permissions = useSelector((state) =&gt; state.auth.permissions); // Assuming permissions are stored here\n\n  // Define the menu items\n  const items = [\n    {\n      key: APP_ROUTES.DASHBOARD,\n      label: \"Dashboard\",\n      icon: &lt;DashboardOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.DASHBOARD_ANALYSIS,\n          label: \"Analysis\",\n          requiredPermissions: [\n            \"Permissions.Application.CanViewDataDuringBusinessHours\",\n          ],\n        },\n        {\n          key: APP_ROUTES.DASHBOARD_WORKSPACE,\n          label: \"Workplace\",\n          requiredPermissions: [\n            \"Permissions.Application.CanViewDataWeekendOnly\",\n          ],\n        },\n      ],\n    },\n    {\n      key: APP_ROUTES.FOREX,\n      label: \"Forex T Deal\",\n      icon: &lt;AccountBookOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.FOREX_DEALS,\n          label: \"All Deals\",\n          requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n        },\n        {\n          key: APP_ROUTES.FOREX_TRADING,\n          label: \"Buying / Selling\",\n          requiredPermissions: [\"Permissions.Application.CanViewDashboard\"],\n        },\n      ],\n    },\n    // Other items...\n  ];\n\n  // Function to filter items based on permissions\n  const filterItemsByPermissions = (items) =&gt; {\n    return items.filter((item) =&gt; {\n      // If item has children, filter the children recursively\n      if (item.children) {\n        item.children = filterItemsByPermissions(item.children);\n\n        // If no child is visible, exclude the parent item as well\n        if (item.children.length === 0) {\n          return false;\n        }\n      }\n\n      // Only include the item if it has no required permissions or the user has them\n      return (\n        !item.requiredPermissions ||\n        item.requiredPermissions.some((perm) =&gt; permissions.includes(perm)) ||\n        (item.children &amp;&amp; item.children.length &gt; 0) // Keep parent if it has visible children\n      );\n    });\n  };\n\n  // Filter menu items based on permissions\n  const filteredItems = filterItemsByPermissions(items);\n\n  // Function to get parent key for open submenu\n  const getParentKey = (path) =&gt; {\n    const parent = filteredItems.find((item) =&gt; path.startsWith(item.key));\n    return parent ? parent.key : null;\n  };\n\n  const [openKeys, setOpenKeys] = useState([getParentKey(location.pathname)]);\n\n  useEffect(() =&gt; {\n    setOpenKeys([getParentKey(location.pathname)]);\n  }, [location.pathname]);\n\n  const handleClick = ({ key }) =&gt; {\n    navigate(key);\n  };\n\n  return (\n    &lt;Menu\n      className=\"sidebar-layout\"\n      style={{\n        height: height,\n        width: width,\n        textAlign: \"left\",\n      }}\n      mode=\"inline\"\n      selectedKeys={[location.pathname]}\n      inlineCollapsed={collapsed}\n      openKeys={openKeys}\n      onOpenChange={setOpenKeys}\n      onClick={handleClick}\n      items={filteredItems} // Use the filtered items\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre> Key Changes <ol> <li> <p>Filtering Parents Based on Children Visibility:</p> <ul> <li>In the <code>filterItemsByPermissions</code> function, after filtering the child items, we check if any children are visible. If none of the children are visible, we return <code>false</code> to prevent the parent item from being included.</li> <li>The parent menu item is only included if it has visible children or if the parent itself is permitted.</li> </ul> </li> <li> <p>Excluding the Parent if No Child Has Permission:</p> <ul> <li>In the filtering logic, if none of the children for a parent item are visible due to permission constraints, the parent item (e.g., \"Forex T Deal\") will be excluded as well.</li> </ul> </li> </ol> Example <ul> <li>If neither \"All Deals\" nor \"Buying / Selling\" has the necessary permissions, the entire \"Forex T Deal\" section (parent item) will be hidden from the sidebar.</li> <li>If one of the child items under \"Forex T Deal\" has permissions, the parent item (\"Forex T Deal\") will be visible with the corresponding child item(s) displayed.</li> </ul> <p>By applying this logic, your sidebar dynamically adjusts to the user's permissions, ensuring that both parent and child menu items are conditionally rendered.</p>"},{"location":"router/permission-based-routing/#constants","title":"CONSTANTS","text":"<p>Yes, you can definitely store all the permissions in a constants file and then reference them throughout your application. This approach makes your code more maintainable and avoids the repetition of hardcoded permission strings.</p> Steps <ol> <li>Create a Constants File for permissions.</li> <li>Use the Constants in your Sidebar and other components.</li> </ol> <p>1. Create a Permissions Constants File:</p> <p>Create a file, e.g., <code>permissions.js</code> inside a <code>constants</code> or <code>config</code> folder. This will hold all your permission keys.</p> <pre><code>// src/constants/permissions.js\n\nexport const Permissions = {\n  // Application Permissions\n  CAN_VIEW_DATA_WEEKEND_ONLY: \"Permissions.Application.CanViewDataWeekendOnly\",\n  CAN_VIEW_DASHBOARD: \"Permissions.Application.CanViewDashboard\",\n  CAN_VIEW_DATA_DURING_BUSINESS_HOURS:\n    \"Permissions.Application.CanViewDataDuringBusinessHours\",\n\n  // Forex Permissions\n  CAN_VIEW_FOREX_DEALS: \"Permissions.Forex.CanViewDeals\",\n  CAN_VIEW_FOREX_TRADING: \"Permissions.Forex.CanViewTrading\",\n\n  // Settings Permissions\n  CAN_VIEW_COUNTRY: \"Permissions.Setting.CanViewCountry\",\n  CAN_VIEW_PROVINCE: \"Permissions.Setting.CanViewProvince\",\n  CAN_VIEW_FISCAL_YEAR: \"Permissions.Setting.CanViewFiscalYear\",\n  CAN_VIEW_RATES: \"Permissions.Setting.CanViewRates\",\n  CAN_VIEW_CURRENCY: \"Permissions.Setting.CanViewCurrency\",\n  CAN_VIEW_COUNTER_PARTY: \"Permissions.Setting.CanViewCounterParty\",\n  CAN_VIEW_DEAL_BANK_ACCOUNT: \"Permissions.Setting.CanViewDealBankAccount\",\n  CAN_VIEW_COUNTER_PARTY_DEALERS:\n    \"Permissions.Setting.CanViewCounterPartyDealers\",\n  CAN_VIEW_ROLES_AND_PERMISSIONS:\n    \"Permissions.Setting.CanViewRolesAndPermissions\",\n  CAN_VIEW_USERS: \"Permissions.Setting.CanViewUsers\",\n\n  // Profile Permissions\n  CAN_VIEW_PROFILE: \"Permissions.Profile.CanViewProfile\",\n  CAN_UPDATE_PASSWORD: \"Permissions.Profile.CanUpdatePassword\",\n};\n</code></pre> <p>2. Update Your Sidebar to Use These Constants:</p> <p>Now, in your <code>Sidebar</code> component, you can reference the permissions from the <code>permissions.js</code> file.</p> Sidebar.js<pre><code>import React, { useState, useEffect } from \"react\";\nimport { Menu } from \"antd\";\nimport {\n  DashboardOutlined,\n  SettingOutlined,\n  AccountBookOutlined,\n  BankOutlined,\n  FundOutlined,\n  ProjectOutlined,\n  IssuesCloseOutlined,\n} from \"@ant-design/icons\";\nimport { useNavigate, useLocation } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { APP_ROUTES } from \"@shared/routes\";\nimport { Permissions } from \"@constants/permissions\"; // Import permissions constants\n\nconst Sidebar = ({ collapsed, height, width }) =&gt; {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const permissions = useSelector((state) =&gt; state.auth.permissions); // Assuming permissions are stored here\n\n  // Define the menu items\n  const items = [\n    {\n      key: APP_ROUTES.DASHBOARD,\n      label: \"Dashboard\",\n      icon: &lt;DashboardOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.DASHBOARD_ANALYSIS,\n          label: \"Analysis\",\n          requiredPermissions: [\n            Permissions.CAN_VIEW_DATA_DURING_BUSINESS_HOURS,\n          ],\n        },\n        {\n          key: APP_ROUTES.DASHBOARD_WORKSPACE,\n          label: \"Workplace\",\n          requiredPermissions: [Permissions.CAN_VIEW_DATA_WEEKEND_ONLY],\n        },\n      ],\n    },\n    {\n      key: APP_ROUTES.FOREX,\n      label: \"Forex T Deal\",\n      icon: &lt;AccountBookOutlined /&gt;,\n      children: [\n        {\n          key: APP_ROUTES.FOREX_DEALS,\n          label: \"All Deals\",\n          requiredPermissions: [Permissions.CAN_VIEW_FOREX_DEALS],\n        },\n        {\n          key: APP_ROUTES.FOREX_TRADING,\n          label: \"Buying / Selling\",\n          requiredPermissions: [Permissions.CAN_VIEW_FOREX_TRADING],\n        },\n      ],\n    },\n    // Other items...\n  ];\n\n  // Function to filter items based on permissions\n  const filterItemsByPermissions = (items) =&gt; {\n    return items.filter((item) =&gt; {\n      // If item has children, filter the children recursively\n      if (item.children) {\n        item.children = filterItemsByPermissions(item.children);\n\n        // If no child is visible, exclude the parent item as well\n        if (item.children.length === 0) {\n          return false;\n        }\n      }\n\n      // Only include the item if it has no required permissions or the user has them\n      return (\n        !item.requiredPermissions ||\n        item.requiredPermissions.some((perm) =&gt; permissions.includes(perm)) ||\n        (item.children &amp;&amp; item.children.length &gt; 0) // Keep parent if it has visible children\n      );\n    });\n  };\n\n  // Filter menu items based on permissions\n  const filteredItems = filterItemsByPermissions(items);\n\n  // Function to get parent key for open submenu\n  const getParentKey = (path) =&gt; {\n    const parent = filteredItems.find((item) =&gt; path.startsWith(item.key));\n    return parent ? parent.key : null;\n  };\n\n  const [openKeys, setOpenKeys] = useState([getParentKey(location.pathname)]);\n\n  useEffect(() =&gt; {\n    setOpenKeys([getParentKey(location.pathname)]);\n  }, [location.pathname]);\n\n  const handleClick = ({ key }) =&gt; {\n    navigate(key);\n  };\n\n  return (\n    &lt;Menu\n      className=\"sidebar-layout\"\n      style={{\n        height: height,\n        width: width,\n        textAlign: \"left\",\n      }}\n      mode=\"inline\"\n      selectedKeys={[location.pathname]}\n      inlineCollapsed={collapsed}\n      openKeys={openKeys}\n      onOpenChange={setOpenKeys}\n      onClick={handleClick}\n      items={filteredItems} // Use the filtered items\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre> Key ChangesBenefits <ol> <li> <p>Permissions Constants:</p> <ul> <li>I imported the <code>Permissions</code> constants from <code>@constants/permissions.js</code>.</li> <li>The permissions used in each item are now referenced from the <code>Permissions</code> constants, e.g., <code>Permissions.CAN_VIEW_DATA_DURING_BUSINESS_HOURS</code>, <code>Permissions.CAN_VIEW_FOREX_DEALS</code>, etc.</li> </ul> </li> <li> <p>Easier Maintenance:</p> <ul> <li>By centralizing your permissions in a constants file, you reduce the risk of hardcoding strings multiple times, and you make it easier to update permissions in the future. If a permission key changes, you only need to update it in one place (the <code>permissions.js</code> file).</li> </ul> </li> </ol> <ul> <li>Centralized Management: All permission keys are now in one place, making it easier to update and manage.</li> <li>Cleaner Code: Instead of repeating long permission strings, you use meaningful constants.</li> <li>Consistency: Reduces the chances of typos or errors in permission strings.</li> </ul> <p>3. Optional: Use Permissions in Other Components</p> <p>You can similarly import the <code>Permissions</code> constants in other parts of your application where you need to check permissions, making your code consistent and modular.</p> <pre><code>import { Permissions } from \"@constants/permissions\"; // Import permissions constants\n\n// Example of how you could use them\nif (userPermissions.includes(Permissions.CAN_VIEW_DASHBOARD)) {\n  // Grant access to the dashboard\n}\n</code></pre> <p>This pattern keeps your permission checks clean and easy to manage across the app.</p>"},{"location":"router/permission-based-routing/#role-based-or-permission-based-routing","title":"Role-based or Permission-based Routing","text":"<p>Role-based or permission-based routing is an extension of protected routing where routes are conditionally rendered based on the user\u2019s permissions or roles. Permissions can be fetched from the server, or you can store them in global state (e.g., Redux, Context API) after a successful login.</p> <p>This is the type of routing you've asked about: if a user doesn\u2019t have the required permissions, the route won\u2019t be shown or accessed.</p> Example of Permission-based Routing<pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Route, Redirect } from \"react-router-dom\";\n\n// Mock permission data\nconst permissions = [\"CAN_VIEW_DASHBOARD\"];\n\nconst hasPermission = (permission) =&gt; permissions.includes(permission);\n\nconst Dashboard = () =&gt; &lt;div&gt;Dashboard&lt;/div&gt;;\nconst Settings = () =&gt; &lt;div&gt;Settings&lt;/div&gt;;\n\nconst ProtectedRoute = ({\n  component: Component,\n  requiredPermission,\n  ...rest\n}) =&gt; {\n  return (\n    &lt;Route\n      {...rest}\n      render={(props) =&gt;\n        hasPermission(requiredPermission) ? (\n          &lt;Component {...props} /&gt;\n        ) : (\n          &lt;Redirect to=\"/no-permission\" /&gt;\n        )\n      }\n    /&gt;\n  );\n};\n\nconst NoPermission = () =&gt; (\n  &lt;div&gt;You do not have permission to view this page.&lt;/div&gt;\n);\n\nconst App = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/no-permission\" component={NoPermission} /&gt;\n        &lt;ProtectedRoute\n          path=\"/dashboard\"\n          component={Dashboard}\n          requiredPermission=\"CAN_VIEW_DASHBOARD\"\n        /&gt;\n        &lt;ProtectedRoute\n          path=\"/settings\"\n          component={Settings}\n          requiredPermission=\"CAN_VIEW_SETTINGS\"\n        /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>ProtectedRoute</code> component checks whether the user has the necessary permission to access a route. If the user doesn\u2019t have the required permission, they\u2019re redirected to a \"No Permission\" page.</p>"},{"location":"router/permission-based-routing/#no-access-page","title":"NO Access Page","text":"<p>To define the <code>/no-access</code> route in your app, you can add a <code>Route</code> for the \"No Access\" page within your <code>AppRoutes</code> component, similar to how you define other routes. This page will be shown if the user doesn\u2019t have the required permissions to access certain routes.</p> Steps <ol> <li>Create a NoAccess Page Component: First, create a simple component that will display the \"No Access\" message.</li> <li>Add the NoAccess Route: Include the <code>/no-access</code> route in your routing setup (<code>AppRoutes</code>).</li> </ol> <p>1. Create the <code>NoAccess</code> Component</p> <p>Let\u2019s start by creating a simple <code>NoAccess</code> component.</p> <p><code>NoAccess.js</code> (e.g., <code>src/components/NoAccess.js</code>):</p> <pre><code>import React from \"react\";\n\nconst NoAccess = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;No Access&lt;/h1&gt;\n      &lt;p&gt;You do not have permission to view this page.&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default NoAccess;\n</code></pre> <p>2. Add the <code>NoAccess</code> Route to Your <code>AppRoutes</code></p> <p>Now, in your <code>AppRoutes</code> component, you need to define a Route that points to the <code>NoAccess</code> page when the user is redirected to <code>/no-access</code>.</p> AppRoutes.js<pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\nimport { APP_ROUTES } from \"@shared/routes\";\n\n// Import components\nimport PrivateRoute from \"./PrivateRoutes\";\nimport RedirectRoute from \"./RedirectRoutes\";\n\nimport Login from \"@features/auth/components/Login/Login\";\nimport Dashboard from \"@features/dashboard/components/Dashboard\";\nimport MainLayout from \"@shared/components/DashbordLayout/MainLayout\";\nimport Analysis from \"@features/dashboard/components/Analysis\";\nimport WorkSpace from \"@features/dashboard/components/Workspace\";\nimport NotFound from \"@shared/components/NotFoundPage\";\nimport BuyingSelling from \"@features/forex/components/BuyingSelling\";\nimport AllDeals from \"@features/forex/components/AllDeals\";\nimport Users from \"@features/settings/components/Users\";\nimport Country from \"@features/settings/components/Country\";\nimport NoAccess from \"@shared/components/NoAccess\"; // Import the NoAccess component\n\nconst AppRoutes = () =&gt; {\n  const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n  const protectedRoutes = [\n    { path: APP_ROUTES.DASHBOARD_ANALYSIS, element: &lt;Analysis /&gt; },\n    { path: APP_ROUTES.DASHBOARD_WORKSPACE, element: &lt;WorkSpace /&gt; },\n    { path: APP_ROUTES.FOREX_DEALS, element: &lt;AllDeals /&gt; },\n    { path: APP_ROUTES.FOREX_TRADING, element: &lt;BuyingSelling /&gt; },\n    { path: APP_ROUTES.SETTING_COUNTRY, element: &lt;Country /&gt; },\n    { path: APP_ROUTES.SETTING_USERS, element: &lt;Users /&gt; },\n    { path: \"*\", element: &lt;NotFound /&gt; },\n  ];\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route\n          path=\"/\"\n          element={\n            &lt;RedirectRoute&gt;\n              &lt;Login /&gt;\n            &lt;/RedirectRoute&gt;\n          }\n        &gt;&lt;/Route&gt;\n\n        {protectedRoutes.map(({ path, element }) =&gt; (\n          &lt;Route\n            key={path}\n            path={path}\n            element={\n              &lt;PrivateRoute requiredPermissions={[\"CAN_VIEW_DASHBOARD\"]}&gt;\n                &lt;MainLayout&gt;{element}&lt;/MainLayout&gt;\n              &lt;/PrivateRoute&gt;\n            }\n          /&gt;\n        ))}\n\n        {/* No Access Route */}\n        &lt;Route path=\"/no-access\" element={&lt;NoAccess /&gt;} /&gt;\n\n        &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"router/docs/auth-techniques/","title":"Technique","text":"<p>Techniques for Managing Authentication in React</p> <p>Here's a comprehensive overview of various techniques for managing authentication and state in React applications, presented in a structured format for easy reference.</p>"},{"location":"router/docs/auth-techniques/#categorized","title":"Categorized","text":"<p>Here\u2019s a categorized overview of various techniques for managing authentication in React applications, grouped by their complexity and use cases. This should help with memorization!</p>"},{"location":"router/docs/auth-techniques/#1-simple-state-management-techniques","title":"1. Simple State Management Techniques","text":"<ul> <li> <p>Context API</p> <ul> <li>Best For: Small to medium-sized applications.</li> <li>Use Case: Sharing authentication state across multiple components without prop drilling.</li> </ul> </li> <li> <p>Zustand</p> <ul> <li>Best For: Lightweight state management.</li> <li>Use Case: Applications needing a simple and fast solution for state management.</li> </ul> </li> </ul>"},{"location":"router/docs/auth-techniques/#2-intermediate-state-management-techniques","title":"2. Intermediate State Management Techniques","text":"<ul> <li> <p>Recoil</p> <ul> <li>Best For: Medium to large applications.</li> <li>Use Case: Efficient local and global state management with an intuitive API.</li> </ul> </li> <li> <p>MobX</p> <ul> <li>Best For: Reactive programming needs.</li> <li>Use Case: Applications requiring automatic UI updates with minimal boilerplate.</li> </ul> </li> </ul>"},{"location":"router/docs/auth-techniques/#3-advanced-state-management-techniques","title":"3. Advanced State Management Techniques","text":"<ul> <li> <p>Redux</p> <ul> <li>Best For: Large applications with complex state management.</li> <li>Use Case: Centralized state management, especially when using middleware for async actions.</li> </ul> </li> </ul>"},{"location":"router/docs/auth-techniques/#4-server-dependent-techniques","title":"4. Server-Dependent Techniques","text":"<ul> <li> <p>React Query</p> <ul> <li>Best For: Data-heavy applications.</li> <li>Use Case: Efficient data fetching, caching, and synchronizing server data alongside authentication.</li> </ul> </li> <li> <p>Firebase Authentication</p> <ul> <li>Best For: Easy and secure user authentication.</li> <li>Use Case: Applications needing quick integration of various authentication methods (Google, email/password).</li> </ul> </li> </ul>"},{"location":"router/docs/auth-techniques/#summary-table","title":"Summary Table","text":"Category Technique Best For Use Case Simple State Management Context API Small to medium apps State sharing without prop drilling Zustand Lightweight apps Simple and fast state management Intermediate State Management Recoil Medium to large apps Local and global state management MobX Reactive programming Automatic UI updates with minimal boilerplate Advanced State Management Redux Large apps with complex state Centralized state management Server-Dependent Techniques React Query Data-heavy apps Efficient data fetching and caching Firebase Authentication Easy and secure user auth Quick integration of authentication methods"},{"location":"router/docs/auth-techniques/#conclusion","title":"Conclusion","text":"<p>By categorizing these techniques, you can better recall which method to use based on your project's size, complexity, and specific requirements. This structure makes it easier to remember the right tools for different scenarios in React applications!</p>"},{"location":"router/docs/best-method-for-auth/","title":"Best Method","text":"<p>The \"best\" method for implementing login and logout functionality in a React application depends on several factors, including the project's complexity, your team's familiarity with the technologies, and the specific requirements of the application. Here's a breakdown to help you choose the most suitable approach:</p>"},{"location":"router/docs/best-method-for-auth/#1-simple-applications","title":"1. Simple Applications","text":"<ul> <li>Best Method: Context API with Custom Hooks</li> <li>Why: For smaller apps, using the Context API with custom hooks is straightforward, requires minimal setup, and keeps the code clean. It's easy to understand and maintain.</li> </ul>"},{"location":"router/docs/best-method-for-auth/#2-medium-to-large-applications","title":"2. Medium to Large Applications","text":"<ul> <li>Best Method: Redux with Middleware (e.g., Redux Thunk)</li> <li>Why: If your application has multiple interconnected states and requires complex state management, Redux is a robust solution. It provides a clear structure for managing authentication alongside other global states, with middleware allowing for handling asynchronous actions like API calls.</li> </ul>"},{"location":"router/docs/best-method-for-auth/#3-reactive-applications","title":"3. Reactive Applications","text":"<ul> <li>Best Method: MobX</li> <li>Why: If you prefer a more reactive and less boilerplate-heavy approach, MobX is excellent for managing authentication state in a simpler manner. It's particularly beneficial for applications that require frequent state updates.</li> </ul>"},{"location":"router/docs/best-method-for-auth/#4-data-driven-applications","title":"4. Data-Driven Applications","text":"<ul> <li>Best Method: React Query</li> <li>Why: If your app heavily relies on data fetching, using React Query can simplify authentication as part of your data management strategy. It automatically handles caching, loading, and error states, making it efficient for managing authentication requests.</li> </ul>"},{"location":"router/docs/best-method-for-auth/#5-full-featured-authentication-solutions","title":"5. Full-Featured Authentication Solutions","text":"<ul> <li>Best Method: Firebase Authentication or Auth0</li> <li>Why: If you need a robust, secure, and scalable solution with built-in user management, using Firebase or Auth0 is ideal. They provide a wide range of authentication methods and handle security concerns, allowing you to focus on the frontend.</li> </ul>"},{"location":"router/docs/best-method-for-auth/#summary","title":"Summary","text":"<ul> <li>For Simplicity: Context API is great for small projects.</li> <li>For Complexity: Redux is best for larger, more complex applications.</li> <li>For Reactivity: MobX is good for applications needing frequent state updates.</li> <li>For Data Focus: React Query excels in data-driven contexts.</li> <li>For Full Solutions: Firebase and Auth0 are excellent for ready-made authentication systems.</li> </ul> <p>Ultimately, the choice should align with your team's skills, project needs, and how you foresee the application scaling in the future. If unsure, starting with the Context API for smaller projects and transitioning to Redux or a third-party service as complexity grows is a sound strategy.</p>"},{"location":"router/docs/not-found-component/","title":"Not Found","text":"<p>Here\u2019s an example of how you might implement a simple <code>NotFound</code> component to be used with a catch-all route in React Router v6.</p>"},{"location":"router/docs/not-found-component/#example","title":"Example","text":"NotFound ComponentUsage in Your RoutesExplanation <pre><code>import React from 'react';\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: 'center', marginTop: '50px' }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>You can then use this <code>NotFound</code> component in your routing setup like this:</p> <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport About from './About'; // Your About component\nimport Home from './Home';   // Your Home component\nimport NotFound from './NotFound'; // Your NotFound component\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ul> <li>NotFound Component: This component simply displays a message and provides a link to return to the homepage.</li> <li>Catch-All Route: The <code>path=\"*\"</code> route captures any undefined paths and renders the <code>NotFound</code> component, ensuring users have feedback when they navigate to a nonexistent route.</li> </ul> <p>This setup provides a user-friendly experience by guiding users back to valid pages!</p>"},{"location":"router/docs/not-found-component/#folder-struture","title":"Folder Struture","text":"<p>Here\u2019s a suggested folder structure for a React application that includes a NotFound component. This structure promotes organization and scalability:</p> Suggested Folder StructureExplanation of Structure <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u2514\u2500\u2500 NotFound.jsx   // Store your NotFound component here\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages             // Optional: for more complex structures\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles            // Optional: for CSS or styled components\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>/public</code>: Contains static assets and the main HTML file.</li> <li><code>/src</code>: Main source folder for your application.<ul> <li><code>/components</code>: This folder holds your React components, including the <code>NotFound</code> component.</li> <li><code>/pages</code>: (Optional) Useful if you want to separate different pages of your app into their own components, enhancing organization.</li> <li><code>/styles</code>: (Optional) Store your CSS or styled components here.</li> <li><code>App.jsx</code>: The main application file where you can set up your routes.</li> <li><code>index.js</code>: The entry point of your React application.</li> </ul> </li> </ul> <p>By organizing your components this way, you can easily manage and locate your files as your application grows!</p>"},{"location":"router/docs/not-found-component/#advanced","title":"Advanced","text":"<p>Here\u2019s a more advanced example of a React application that uses the <code>NotFound</code> component along with several routes, including nested routes, dynamic routing, and a simple layout.</p> <p>Folder Structure</p> <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u251c\u2500\u2500 NotFound.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Navbar.jsx\n\u2502   \u2502   \u2514\u2500\u2500 UserProfile.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Example</p> index.jsApp.jsxNavbar.jsxHomePage.jsxAboutPage.jsxUserProfile.jsxNotFound.jsx <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./styles/App.css\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport HomePage from \"./pages/HomePage\";\nimport AboutPage from \"./pages/AboutPage\";\nimport NotFound from \"./components/NotFound\";\nimport Navbar from \"./components/Navbar\";\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n                &lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1 Profile&lt;/Link&gt;\n            &lt;Link to=\"/user/2\"&gt;User 2 Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>import React from \"react\";\n\nconst HomePage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default HomePage;\n</code></pre> <pre><code>import React from \"react\";\n\nconst AboutPage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;About Us&lt;/h1&gt;\n            &lt;p&gt;This is the about page.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default AboutPage;\n</code></pre> <pre><code>import React from \"react\";\nimport { useParams } from \"react-router-dom\";\n\nconst UserProfile = () =&gt; {\n    const { id } = useParams();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Displaying profile for user ID: {id}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserProfile;\n</code></pre> <pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: \"center\", marginTop: \"50px\" }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>Explanation</p> <ol> <li>Routing Setup: The <code>App</code> component uses <code>BrowserRouter</code> to wrap the application and Routes to define paths.</li> <li>Dynamic Routing: The <code>UserProfile</code> component uses <code>useParams</code> to extract the user ID from the URL.</li> <li>Catch-All Route: The route <code>path=\"*\"</code> ensures that any undefined paths render the <code>NotFound</code> component.</li> <li>Navigation: The <code>Navbar</code> component provides links to navigate between the home page, about page, and user profiles.</li> </ol> <p>This setup showcases a more advanced application structure with routing, making it easier to manage and expand as your application grows!</p>"},{"location":"router/docs/react-router/","title":"React Router","text":"<p>React Router is a library that enables routing in React applications. It allows you to create single-page applications with navigation and different views without reloading the page. With React Router, you can define routes in your app, manage navigation, and render specific components based on the current URL.</p> <p>Since you've created a React app using npx create-react-app, you'll need to install React Router separately, as it's not included by default. You can install it using npm:</p> <pre><code>npm install react-router-dom\n</code></pre>"},{"location":"router/docs/react-router/#what-react-router-does","title":"What React Router Does:","text":"<ul> <li>Routing: Maps URLs to components, allowing different components to render based on the current path.</li> <li>Navigation: Provides components like <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> for navigation without full page reloads.</li> <li>Dynamic Routing: Supports parameters in routes, enabling you to create dynamic routes based on data.</li> <li>Nested Routes: Allows you to nest routes for better organization of your components.</li> <li>Programmatic Navigation: Offers functionality to navigate programmatically using hooks like <code>useNavigate</code>.</li> </ul> Basic Example <p>Here\u2019s a simple example to illustrate how to use React Router:</p> <ol> <li>Install it (as mentioned above).</li> <li> <p>Create some basic components:</p> <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n</code></pre> </li> <li> <p>Set up routing in your main component (e.g., <code>App.js</code>):</p> <pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\nimport Home from './Home';\nimport About from './About';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/nav&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>This example sets up a basic navigation between a home page and an about page. When you click the links, React Router will render the corresponding component without reloading the page.</p> </li> </ol>"},{"location":"router/docs/router-version/","title":"Version","text":"<ul> <li>React Router v4 - October 2017</li> <li>React Router v5 - February 2019</li> <li>React Router v6 - November 2021</li> <li>React Router v6.4 - June 2022</li> <li>React Router v6.8 - August 2023</li> </ul>"},{"location":"router/docs/router-version/#major-updates","title":"Major Updates","text":"<p>Here are the major updates from the key React Router versions that you should remember:</p> React Router v4React Router v5React Router v6React Router v6.4React Router v6.8 <ul> <li>Component-based API: Introduced a declarative way to define routes using components.</li> <li>Nested Routes: Allowed for easier management of nested routing.</li> <li> <p>Key Update: Component-based API and Nested Routes</p> Example<pre><code>import { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Hooks: Introduced <code>useParams</code>, <code>useLocation</code>, and other hooks for better access to routing data.</li> <li>Improved Redirects: Added more control over route rendering with props on <code>&lt;Route&gt;</code>.</li> <li> <p>Key Update: Hooks (<code>useParams</code>, <code>useLocation</code>)</p> Example<pre><code>import { BrowserRouter as Router, Route, Link, useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams();\n    return &lt;h2&gt;User ID: {id}&lt;/h2&gt;;\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/user/:id\" component={User} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li><code>Routes</code> Component: Replaced <code>Switch</code> for improved route matching.</li> <li>Route Ranking: Enhanced routing logic for better performance.</li> <li>Nested Routes: Simplified nested route definitions.</li> <li> <p>Key Update: <code>Routes</code> Component and Route Ranking</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Data APIs: Introduced loaders and actions for handling data fetching directly in routes.</li> <li>Layout Routes: Enhanced support for layouts in nested routes.</li> <li> <p>Key Update: Data APIs (Loaders and Actions)</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst loader = async () =&gt; {\n    const data = await fetch('/api/data'); // Fetch data\n    return data.json();\n};\n\nconst DataComponent = () =&gt; {\n    // Use data in your component\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Refinements: Continued improvements based on user feedback, focusing on data handling and route management.</li> <li> <p>Key Update: Refinements for improved data handling</p> <p><code>(Similar to v6.4 but with more refined API usage)</code></p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul>"},{"location":"router/docs/router-version/#additional","title":"Additional","text":"<p>In React Router v6, the <code>Routes</code> component replaced the <code>Switch</code> component from previous versions, and this change brought several improvements in how route matching works. Here\u2019s what it means:</p> <ol> <li> <p>Improved Route Matching</p> <ul> <li>Order of Matching:</li> </ul> <p>With <code>Switch</code>, the first route that matched was rendered, which could lead to issues if more specific routes were placed after more general ones. The new <code>Routes</code> component performs better by automatically ranking routes, meaning it will always match the most specific route first.</p> <ul> <li>Simplified Syntax:</li> </ul> <p><code>Routes</code> allows you to define routes using the <code>element</code> prop directly, making the syntax cleaner and easier to read.</p> Using <code>Switch</code> (v5)Using Routes (v6) <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this example, if you navigate to <code>/</code>, the <code>Home</code> component will render because it's matched first. However, if you had a more specific route, such as <code>/about</code>, it could potentially lead to unexpected behavior if not ordered correctly.</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this version with <code>Routes</code>, it handles matching more efficiently. It automatically prioritizes more specific paths, so you can be confident that the correct component will render based on the current URL.</p> </li> <li> <p>No Need for <code>exact</code></p> <p>In <code>v5</code>, you often had to use the <code>exact</code> prop to ensure that a route only matched when the path was exactly as specified. With <code>Routes</code>, the matching logic is more intuitive, and <code>exact</code> is no longer necessary.</p> </li> </ol> <p>Conclusion</p> <p>Overall, the shift from Switch to Routes in React Router v6 enhances route handling by making it more efficient, reducing potential errors, and simplifying the syntax for developers.</p>"},{"location":"router/docs/router-version/#route-ordering","title":"Route Ordering","text":""},{"location":"router/docs/router-version/#before-v6","title":"Before v6","text":"<p>Before React Router v6, specifically in versions 4 and 5, the order of matching was important when using the <code>Switch</code> component. Here's how it worked:</p> Key Points on Order of Matching with Switch <ol> <li> <p>First Match Wins:</p> <ul> <li>The <code>Switch</code> component rendered the first <code>&lt;Route&gt;</code> that matched the current location. This meant that if you had more specific routes after less specific ones, those specific routes would never be reached because the first matching route would take precedence.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>To prevent more general routes from matching, you often had to use the <code>exact</code> prop. This ensured that a route only matched if the path was exactly as specified.</li> </ul> </li> </ol> <p>Example</p> <p>Here's a demonstration of the matching behavior with <code>Switch</code>:</p> Incorrect Order Without <code>exact</code>Correct Order With <code>exact</code> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>If you navigate to <code>/</code>, this setup would render the <code>Home</code> component, and the <code>About</code> route would never be reached because it comes after the <code>/</code> route.</li> </ul> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>In this setup, using exact on the <code>/</code> route means it will only match when the path is exactly <code>/</code>. This allows the <code>/about</code> route to be matched correctly when you navigate to <code>/about</code>.</li> </ul> <p>Conclusion</p> <p>In summary, before v6, the order of routes and the use of the <code>exact</code> prop were crucial for ensuring the correct component rendered based on the URL. With the introduction of <code>Routes</code> in v6, these concerns have largely been alleviated, allowing for more intuitive and error-free routing!</p> <p>Sure! Here\u2019s an example of a React Router setup with multiple routes using Switch in versions 4 or 5. I'll illustrate how to properly order them to ensure the correct components render.</p> <p>Example with Multiple Routes</p> <p>Let\u2019s consider a scenario where we have the following components:</p> <ul> <li><code>Home</code></li> <li><code>About</code></li> <li><code>Contact</code></li> <li><code>AboutDetails</code></li> <li><code>UserProfile</code></li> </ul> ComponentsProper Ordering with <code>Switch</code>Explanation of Route OrderingConclusion <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n\n// Contact.js\nconst Contact = () =&gt; &lt;h2&gt;Contact&lt;/h2&gt;;\n\n// AboutDetails.js\nconst AboutDetails = () =&gt; &lt;h2&gt;About Details&lt;/h2&gt;;\n\n// UserProfile.js\nconst UserProfile = () =&gt; &lt;h2&gt;User Profile&lt;/h2&gt;;\n</code></pre> <pre><code>import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/contact\"&gt;Contact&lt;/Link&gt;\n            &lt;Link to=\"/about/details\"&gt;About Details&lt;/Link&gt;\n            &lt;Link to=\"/user/john\"&gt;User Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n\n        &lt;Switch&gt;\n            {/* Specific routes should come first */}\n            &lt;Route path=\"/about/details\" component={AboutDetails} /&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/contact\" component={Contact} /&gt;\n            &lt;Route path=\"/user/:username\" component={UserProfile} /&gt;\n\n            {/* This should be the last route to match the root path */}\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ol> <li> <p>Specific Routes First:</p> <ul> <li>The <code>/about/details</code> route is placed first because it is more specific than the <code>/about</code> route. If you placed <code>/about</code> first, navigating to <code>/about/details</code> would incorrectly render the About component.</li> </ul> </li> <li> <p>General Routes Last:</p> <ul> <li>The root path (<code>/</code>) is placed last. If it were placed earlier, it would match any path and render the <code>Home</code> component, preventing any of the more specific routes from rendering.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>The <code>exact</code> prop on the root path (<code>/</code>) ensures it only matches the exact URL <code>/</code>, allowing all other routes to be matched properly without interference.</li> </ul> </li> </ol> <p>This setup demonstrates how to structure and order your routes effectively using the <code>Switch</code> component before React Router v6. Proper ordering is crucial to ensure that the intended components render based on the URL, especially when dealing with multiple routes and nested paths!</p>"},{"location":"router/docs/router-version/#after-v6","title":"After v6","text":"<p>In React Router v6, you do not need to worry about the order of matching in the same way you did in previous versions with Switch. Here\u2019s why:</p> Automatic Route Ranking <ul> <li> <p>Specificity:</p> <p>React Router v6 automatically ranks routes based on their specificity. This means that it will match the most specific route first, regardless of the order you define them in your <code>Routes</code>.</p> </li> <li> <p>No Need for <code>exact</code>:</p> <p>Unlike in v5, where you often had to use the <code>exact</code> prop to avoid unintentional matches, v6 handles this internally. A route will only match if it corresponds precisely to the current URL.</p> </li> </ul> Example <p>Here\u2019s an example to illustrate this:</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about/details\" element={&lt;AboutDetails /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this case:</p> <ul> <li>If you navigate to <code>/about/details</code>, it will render the <code>AboutDetails</code> component.</li> <li>If you navigate to <code>/about</code>, it will render the <code>About</code> component.</li> <li>If you navigate to <code>/</code>, it will render the <code>Home</code> component.</li> </ul> <p>Conclusion</p> <p>You can define your routes in any order, and React Router v6 will ensure that the correct component is rendered based on the URL, making it easier to manage your routes without worrying about their sequence. This significantly simplifies routing logic and reduces the potential for errors!</p>"},{"location":"router/docs/routing/","title":"Routing","text":"<p>Routing logic in web applications defines how different URLs (or paths) correspond to various components or views in the application. In React, this is primarily handled by libraries like react-router-dom.</p> <pre><code>-   Basic Routing\n-   Dynamic Routing\n-   Nested Routes\n-   Redirects\n-   Protected Routes\n-   404 Handling\n-   Lazy Loading\n-   History Management\n-   Custom Hooks for Routing\n-   Route Guards\n</code></pre> Install React Router <p>First, ensure you have <code>react-router-dom</code> installed:</p> <pre><code>npm install react-router-dom\n</code></pre> <p>Here are some key concepts and techniques related to routing logic:</p>"},{"location":"router/docs/routing/#1-basic-routing","title":"1. Basic Routing","text":"<ul> <li> <p>Single Page Application (SPA): In SPAs, routing is done client-side. The browser loads a single HTML page and JavaScript takes care of changing views without reloading the page.</p> </li> <li> <p>Route Definition: Routes are defined to map URL paths to React components, usually using <code>&lt;Route&gt;</code> components. Each route specifies a <code>path</code> and the corresponding <code>element</code> to render.</p> </li> </ul> AppRoutes.js (Basic Example) <pre><code>import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from '../components/Home/Home';\nimport About from '../components/About/About';\nimport NotFound from '../components/NotFound/NotFound';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"router/docs/routing/#2-dynamic-routing","title":"2. Dynamic Routing","text":"<ul> <li>Route Parameters: You can create dynamic routes that accept parameters. For example, <code>/user/:id</code> can capture the <code>id</code> of a user, allowing you to render user-specific components based on the URL.</li> </ul> User.js (Dynamic Example) <pre><code>import React from 'react';\nimport { useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams(); // Fetching dynamic parameter\n    return &lt;h1&gt;User Profile: {id}&lt;/h1&gt;;\n};\n\nexport default User;\n</code></pre>"},{"location":"router/docs/routing/#3-nested-routes","title":"3. Nested Routes","text":"<ul> <li>Hierarchy: You can have routes within routes, enabling more complex structures. This is useful for layouts where certain components (like a sidebar or header) are always present.</li> </ul> AppRoutes.js (Advanced with Nested Routes) <pre><code>import User from '../components/User/User';\nimport UserProfile from '../components/User/UserProfile';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;}&gt;\n                &lt;Route path=\"profile\" element={&lt;UserProfile /&gt;} /&gt; {/* Nested route */}\n            &lt;/Route&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"router/docs/routing/#4-redirects","title":"4. Redirects","text":"<ul> <li>Redirecting Users: You can use redirect logic to send users to different paths based on certain conditions, like authentication status or specific URL patterns.</li> </ul> AppRoutes.js (Redirect Example) <p>You can use <code>&lt;Navigate /&gt;</code> for redirects:</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/old-path\" element={&lt;Navigate to=\"/new-path\" replace /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"router/docs/routing/#5-protected-routes","title":"5. Protected Routes","text":"<ul> <li>Authentication Checks: Certain routes can be protected, requiring users to be authenticated. You can create higher-order components (HOCs) or render logic that checks authentication before allowing access.</li> </ul> AuthContext.jsProtectedRoute.jsAdmin.jsAppRoutes.js <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const login = () =&gt; setIsAuthenticated(true);\n    const logout = () =&gt; setIsAuthenticated(false);\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\nexport const useAuth = () =&gt; useContext(AuthContext);\n</code></pre> <pre><code>import React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ element }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p><code>Admin.js</code> (Protected Route Example)</p> <pre><code>import React from 'react';\n\nconst Admin = () =&gt; {\n    return &lt;h1&gt;Admin Page - Access Restricted&lt;/h1&gt;;\n};\n</code></pre> <p><code>AppRoutes.js</code> (Including Protected Routes)</p> <pre><code>import ProtectedRoute from '../components/ProtectedRoute';\nimport Admin from '../components/Admin/Admin';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/admin\" element={&lt;ProtectedRoute element={&lt;Admin /&gt;} /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"router/docs/routing/#6-404-not-found-routes","title":"6. 404 Not Found Routes","text":"<ul> <li>Catch-All Route: A route can be defined to catch all unmatched paths, typically rendering a \"Not Found\" component. This helps in providing a better user experience for invalid URLs.</li> </ul> Example <p>This is already covered in the earlier examples, but the wildcard route (<code>path=\"*\"</code>) ensures that any unmatched route renders the <code>NotFound</code> component.</p>"},{"location":"router/docs/routing/#7-lazy-loading-routes","title":"7. Lazy Loading Routes","text":"<ul> <li>Code Splitting: Use React\u2019s <code>lazy</code> and <code>Suspense</code> to load components only when needed, improving initial load times. This is particularly useful for larger applications with many routes.</li> </ul> User.js (Lazy Loading Example) <p>You can use <code>React.lazy</code> to lazily load components.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nconst UserProfile = lazy(() =&gt; import('./UserProfile'));\n\nconst User = () =&gt; {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;UserProfile /&gt;\n        &lt;/Suspense&gt;\n    );\n};\n</code></pre>"},{"location":"router/docs/routing/#8-history-management","title":"8. History Management","text":"<ul> <li>Browser History: React Router uses the browser's history API to manage navigation. This allows for back and forward navigation without reloading the page.</li> </ul> <p>react-router-dom handles browser history automatically, allowing for back and forward navigation. You can also use <code>useNavigate</code> for programmatic navigation.</p> Example of <code>useNavigate</code> <pre><code>import { useNavigate } from 'react-router-dom';\n\nconst SomeComponent = () =&gt; {\n    const navigate = useNavigate();\n\n    const handleClick = () =&gt; {\n        navigate('/about'); // Programmatically navigate to about\n    };\n\n    return &lt;button onClick={handleClick}&gt;Go to About&lt;/button&gt;;\n};\n</code></pre>"},{"location":"router/docs/routing/#9-custom-route-logic","title":"9. Custom Route Logic","text":"<ul> <li>Custom Hooks: You can create custom hooks for complex routing logic, like checking user roles or fetching data before rendering a route.</li> </ul> useCurrentPath.js <p>You can create custom hooks to access the current path.</p> <pre><code>import { useLocation } from 'react-router-dom';\n\nconst useCurrentPath = () =&gt; {\n    const location = useLocation();\n    return location.pathname;\n};\n\nexport default useCurrentPath;\n</code></pre>"},{"location":"router/docs/routing/#10-using-route-guards","title":"10. Using Route Guards","text":"<ul> <li>Authorization Checks: Implement route guards to restrict access to certain components based on user roles or permissions, enhancing security in your application</li> </ul> Custom Guard Example <p>You can create more complex guards using custom logic.</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst RoleBasedRoute = ({ element, allowedRoles }) =&gt; {\n    const { userRole } = useAuth(); // Assume you have user roles in context\n    return allowedRoles.includes(userRole) ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n</code></pre> <p>Final Setup in <code>App.js</code></p> App.js<pre><code>import React from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport { AuthProvider } from \"./context/AuthContext\";\n\nfunction App() {\n  return (\n    &lt;AuthProvider&gt;\n      &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n          &lt;Navbar /&gt;\n          &lt;AppRoutes /&gt;\n        &lt;/div&gt;\n      &lt;/Router&gt;\n    &lt;/AuthProvider&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"router/docs/routing/#summary","title":"Summary","text":"<p>Routing logic can be simple or complex depending on the application's requirements. Understanding these techniques allows you to create more robust, maintainable, and user-friendly web applications. Here's a brief summary of techniques:</p>"},{"location":"router/docs/routing/#summary-of-concepts","title":"Summary of Concepts","text":"<ol> <li>Basic Routing: Defined straightforward paths to components.</li> <li>Dynamic Routing: Used URL parameters to dynamically render content.</li> <li>Nested Routes: Demonstrated child routes for complex layouts.</li> <li>Redirects: Redirected users based on certain conditions.</li> <li>Protected Routes: Restricted access based on authentication.</li> <li>404 Handling: Managed unmatched routes gracefully.</li> <li>Lazy Loading: Improved performance by loading components only when needed.</li> <li>History Management: Utilized the built-in browser history.</li> <li>Custom Hooks for Routing: Created reusable hooks for accessing routing data.</li> <li>Route Guards: Implemented role-based access control.</li> </ol>"},{"location":"router/docs/routing/#folder-structure","title":"Folder Structure","text":"<pre><code>/src\n  /components\n    /Navbar\n      Navbar.js\n      Navbar.css\n    /Home\n      Home.js\n    /About\n      About.js\n    /NotFound\n      NotFound.js\n    /User\n      User.js\n      UserProfile.js\n    /Admin\n      Admin.js\n  /routes\n    AppRoutes.js\n  /context\n    AuthContext.js\n  App.js\n  index.js\n</code></pre>"},{"location":"router/docs/why-react-router/","title":"Why React Router","text":"<p>React Router is beneficial for several reasons:</p> <ol> <li>Dynamic Routing: It allows you to create routes that can change based on user interaction or application state, enabling a more dynamic user experience.</li> <li>Nested Routing: You can set up nested routes, which helps maintain a clear structure in larger applications, making it easier to manage related components.</li> <li>Code Splitting: React Router supports lazy loading of routes, which improves performance by loading only the necessary code for the current view.</li> <li>Browser History Management: It simplifies managing browser history, allowing users to navigate back and forth seamlessly.</li> <li>URL Management: React Router enables clean and meaningful URLs, which is important for usability and SEO.</li> <li>Declarative Routing: You define routes in a declarative manner, which integrates well with the React component model.</li> <li>State Preservation: It allows you to maintain state across different routes, making it easier to build a consistent user experience.</li> </ol> <p>Overall, while you can build applications without it, React Router makes managing navigation and routing in React apps much easier and more efficient, especially as they grow in complexity.</p>"},{"location":"router/docs/why-react-router/#additional","title":"Additional","text":"<p>Here are some lesser-known aspects and potential pitfalls of React Router that you might want to be aware of:</p> <ol> <li> <p>Route Rendering: The way you render routes can affect your app\u2019s performance. Using <code>component</code> vs. <code>render</code> props can lead to unnecessary re-renders if not handled carefully.</p> </li> <li> <p>Data Fetching: While React Router itself doesn\u2019t handle data fetching, it\u2019s common to implement data loading in route components, which can lead to duplicated logic if not structured properly.</p> </li> <li> <p>Context Issues: If you\u2019re using multiple routers or nesting, managing context can become complex. Be cautious about how context providers interact with router components.</p> </li> <li> <p>Use of <code>Link</code>: Always use the <code>Link</code> component for navigation instead of anchor (<code>&lt;a&gt;</code>) tags. This prevents a full page reload and ensures that React Router can manage the app\u2019s history correctly.</p> </li> <li> <p>Nested Routes Complexity: While nested routes can be powerful, they can also add complexity to your routing logic. It\u2019s important to manage props and state effectively when dealing with deeply nested routes.</p> </li> <li> <p>404 Handling: Setting up a catch-all route for handling 404 pages can sometimes be overlooked, leading to a poor user experience when users navigate to nonexistent routes.</p> </li> <li> <p>Browser History Management: Understanding how React Router interacts with the browser\u2019s history stack is crucial. Mismanagement can lead to issues with the back and forward buttons.</p> </li> <li> <p>Version Changes: Keep an eye on version changes and breaking changes. React Router has gone through significant changes over versions, particularly from v5 to v6.</p> </li> <li> <p>Custom Route Matching: You can create custom route matching logic, but it can get tricky if not well-documented within your codebase.</p> </li> <li> <p>Accessibility: Ensure that your routing and navigation components are accessible, as React Router does not automatically handle ARIA roles and attributes.</p> </li> </ol> <p>Being aware of these nuances can help you use React Router more effectively and avoid common pitfalls!</p>"},{"location":"router/docs/why-react-router/#example","title":"Example","text":"<p>Sure! Here are some examples of good and bad practices with React Router:</p>"},{"location":"router/docs/why-react-router/#1-route-rendering","title":"1. Route Rendering","text":"Bad Example: Using <code>component</code> Prop <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This approach can lead to unnecessary re-renders if the About component's props change.</p> <p><code>Fine with v5</code></p> Good Example: Using <code>element</code> Prop (React Router v6) <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <p>Using the <code>element</code> prop helps maintain a clean render and optimizes performance.</p>"},{"location":"router/docs/why-react-router/#2-conditional-rendering","title":"2. Conditional Rendering","text":"Bad Example: Conditional Logic in Route Definition <pre><code>&lt;Route path=\"/profile\" render={() =&gt; user ? &lt;Profile /&gt; : &lt;Redirect to=\"/login\" /&gt;} /&gt;\n</code></pre> <p>This can be harder to read and maintain.</p> Good Example: Use a Wrapper Component <pre><code>const PrivateRoute = ({ children }) =&gt; {\n    return user ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\n// Usage\n&lt;Route path=\"/profile\" element={&lt;PrivateRoute&gt;&lt;Profile /&gt;&lt;/PrivateRoute&gt;} /&gt;\n</code></pre> <p>This keeps your routes cleaner and separates concerns.</p>"},{"location":"router/docs/why-react-router/#3-handling-404-pages","title":"3. Handling 404 Pages","text":"Bad Example: Not Defining a Catch-All Route <p>If you forget to handle undefined routes, users might just see a blank page.</p> Good Example: Defining a Catch-All Route <pre><code>&lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n</code></pre> <p>This way, users will always have feedback if they navigate to a nonexistent route.</p>"},{"location":"router/docs/why-react-router/#4-navigation-with-link","title":"4. Navigation with <code>Link</code>","text":"Bad Example: Using <code>&lt;a&gt;</code> Tag for Navigation <pre><code>&lt;a href=\"/about\"&gt;About&lt;/a&gt;\n</code></pre> <p>This causes a full page reload, losing the single-page app experience.</p> Good Example: Using <code>&lt;Link&gt;</code> <pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> <p>This enables React Router to manage navigation without reloading the page.</p>"},{"location":"router/docs/why-react-router/#5-nested-routes","title":"5. Nested Routes","text":"Bad Example: Deeply Nested Routes Without Organization <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n    // more deeply nested routes...\n&lt;/Route&gt;\n</code></pre> <p>This can get confusing and hard to manage.</p> Good Example: Clear Nested Structure <pre><code>&lt;Route path=\"/dashboard/*\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n&lt;/Route&gt;\n</code></pre> <p>Using <code>/*</code> makes it clear that more routes are nested under <code>/dashboard</code>.</p> <p>Summary</p> <p>Using React Router effectively involves keeping your code organized, making good use of props, and handling navigation and state management thoughtfully. Following these good practices will lead to a cleaner, more maintainable, and more user-friendly application!</p>"},{"location":"router/docs/why-react-router/#changes-v5-vs-v6","title":"Changes <code>v5</code> vs <code>v6</code>","text":"<p>Exactly! Here\u2019s a breakdown:</p> In React Router v5In React Router v6Why the Change? <p>Using this syntax is perfectly acceptable:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This correctly renders the <code>About</code> component when the path matches. It\u2019s a standard practice for v5.</p> <p>This syntax becomes outdated and not recommended:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>In v6, you should use:</p> <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <ul> <li>Simpler API: The v6 <code>element</code> prop allows you to directly pass a React element, which can help avoid issues with re-renders and make the code cleaner.</li> <li>Consistency: It aligns better with how React works, encouraging the use of JSX for rendering.</li> </ul> <p>So, in summary, while the original example is good practice in v5, it becomes a bad example in v6 due to the API changes. Always make sure to follow the guidelines specific to the version you\u2019re using!</p>"},{"location":"router/example/context-auth/","title":"Context API","text":""},{"location":"router/example/context-auth/#context","title":"context","text":"AuthContext.jsx <pre><code>import React, { createContext, useContext, useState, useEffect } from \"react\";\n\n// Create an Auth Context\nconst AuthContext = createContext();\n\n// AuthProvider component to wrap the app\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [token, setToken] = useState(null); // For storing JWT or session token\n\n    // Check local storage for the token on initial load\n    useEffect(() =&gt; {\n        const storedToken = localStorage.getItem(\"token\");\n        console.log(\"Stored Token:\", storedToken);\n\n        if (storedToken) {\n            setIsAuthenticated(true);\n            setToken(storedToken);\n        }\n    }, []);\n\n    // Login function to set authentication state\n    const login = (token) =&gt; {\n        setIsAuthenticated(true);\n        setToken(token);\n        // Optionally, store the token in localStorage\n        localStorage.setItem(\"token\", token);\n    };\n\n    // Logout function to clear authentication state\n    const logout = () =&gt; {\n        setIsAuthenticated(false);\n        setToken(null);\n        localStorage.removeItem(\"token\"); // Clear token from localStorage\n    };\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\n// Custom hook to use the AuthContext\nexport const useAuth = () =&gt; {\n    return useContext(AuthContext);\n};\n</code></pre>"},{"location":"router/example/context-auth/#routes","title":"routes","text":"AppRoutes.jsxProtectedRoute.jsx <pre><code>import { Routes, Route, Navigate } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport Login from \"../components/Login/login\";\nimport NotFound from \"../components/NotFound\";\nimport ProtectedRoute from \"./ProtectedRoute\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst AppRoutes = () =&gt; {\n    const { isAuthenticated } = useAuth();\n\n    return (\n        &lt;Routes&gt;\n            &lt;Route\n                path=\"/\"\n                element={isAuthenticated ? &lt;Navigate to=\"/home\" /&gt; : &lt;Login /&gt;}\n            /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                    &lt;ProtectedRoute&gt;\n                        &lt;Home /&gt;\n                    &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"\\*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? children : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre>"},{"location":"router/example/context-auth/#app-index","title":"App &amp; index","text":"App.jsindex.js <pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\";\nimport { AuthProvider } from \"./context/AuthContext\";\nimport \"./App.css\";\n\nfunction App() {\n    return (\n        &lt;AuthProvider&gt;\n            &lt;Router&gt;\n                &lt;div className=\"App\"&gt;\n                    &lt;Navbar /&gt;\n                    {/* {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} */}\n                    &lt;AppRoutes /&gt;\n                &lt;/div&gt;\n            &lt;/Router&gt;\n        &lt;/AuthProvider&gt;\n    );\n}\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n&lt;React.StrictMode&gt;\n    &lt;App /&gt;\n&lt;/React.StrictMode&gt;\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n</code></pre>"},{"location":"router/example/context-auth/#component","title":"Component","text":"login.jsxNavbar/index.js <pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\nimport { login } from \"../../api/auth\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst Login = () =&gt; {\n    const { login: authenticate } = useAuth();\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate();\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            const response = await login(values.username, values.password);\n            console.log(\"API Response:\", response); // Log the response\n            authenticate(response.access); // Call login method from context\n            message.success(\"login successfull\");\n            navigate(\"/home\"); // Navigate to home after successful login\n        } catch (error) {\n            message.error(error.message || \"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" initialValues={{ remember: true }} onFinish={onFinish}&gt;\n                &lt;Form.Item\n                    name=\"username\"\n                    rules={[{ required: true, message: \"Please input your username!\" }]}\n                &gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item\n                    name=\"password\"\n                    rules={[{ required: true, message: \"Please input your password!\" }]}\n                &gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <pre><code>import { Link } from \"react-router-dom\";\nimport { Layout, Menu } from \"antd\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst { Header } = Layout;\n\nconst Navbar = () =&gt; {\n    const { isAuthenticated, logout } = useAuth();\n\n    return (\n        &lt;Layout&gt;\n            &lt;Header&gt;\n                &lt;Menu theme=\"dark\" mode=\"horizontal\"&gt;\n                    {isAuthenticated ? (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"home\"&gt;\n                            &lt;Link to=\"/home\"&gt;Dashboard&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;Menu.Item key=\"logout\"&gt;\n                            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    ) : (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"login\"&gt;\n                            &lt;Link to=\"/\"&gt;Login&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    )}\n                &lt;/Menu&gt;\n            &lt;/Header&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre>"},{"location":"router/example/simple-login/","title":"Simple login","text":""},{"location":"router/example/simple-login/#full-code-example","title":"Full Code Example","text":"<ol> <li> <p>Create Your Project Structure</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Home.js\n\u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2514\u2500\u2500 NotFound.js\n\u251c\u2500\u2500 routes/\n\u2502   \u251c\u2500\u2500 AppRoutes.js\n\u2502   \u2514\u2500\u2500 ProtectedRoute.js\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> </li> <li> <p>Install Required Packages Make sure you have React Router and Ant Design installed:</p> <pre><code>npm install react-router-dom antd\n</code></pre> </li> <li> <p>Code for Each Component</p> index &amp; AppRoutesComponent index.js<pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"antd/dist/antd.css\"; // Import Ant Design styles\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> App.js<pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\"; // Import your Navbar component\n\nconst App = () =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const handleLogin = (status) =&gt; {\n        setIsAuthenticated(status);\n    };\n\n    return (\n        &lt;Router&gt;\n            {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} {/* Show Navbar only if authenticated */}\n            &lt;AppRoutes isAuthenticated={isAuthenticated} onLogin={handleLogin} /&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> AppRoutes.js<pre><code>import { Routes, Route } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport NotFound from \"../components/NotFound\";\nimport Login from \"../components/Login\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = ({ isAuthenticated, onLogin }) =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login onLogin={onLogin} /&gt;} /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                &lt;ProtectedRoute isAuthenticated={isAuthenticated}&gt;\n                    &lt;Home /&gt;\n                &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> ProtectedRoute.js<pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\n\nconst ProtectedRoute = ({ isAuthenticated, children }) =&gt; {\n    return isAuthenticated ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> Home.js<pre><code>import React from \"react\";\n\nconst Home = () =&gt; {\n    return &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;;\n};\n\nexport default Home;\n</code></pre> NotFound.js<pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;;\n};\n\nexport default NotFound;\n</code></pre> Login.js<pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = ({ onLogin }) =&gt; {\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate(); // Initialize useNavigate\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            // Simulate an API call\n            const response = await fakeLoginAPI(values);\n            if (response.success) {\n                onLogin(true); // Update the authentication state\n                navigate(\"/home\"); // Navigate to the home (dashboard) route\n            } else {\n                message.error(response.message);\n            }\n        } catch (error) {\n            message.error(\"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const fakeLoginAPI = async ({ username, password }) =&gt; {\n        // Simulating an API call\n        return new Promise((resolve) =&gt; {\n            setTimeout(() =&gt; {\n                if (username === \"user\" &amp;&amp; password === \"pass\") {\n                    resolve({ success: true });\n                } else {\n                    resolve({ success: false, message: \"Invalid credentials\" });\n                }\n            }, 1000);\n        });\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" onFinish={onFinish}&gt;\n                &lt;Form.Item name=\"username\" rules={[{ required: true, message: 'Please input your username!' }]}&gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item name=\"password\" rules={[{ required: true, message: 'Please input your password!' }]}&gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> </ol>"},{"location":"router/example/simple-login/#summary","title":"Summary","text":"<ul> <li>Login Component: Handles user authentication and simulates an API call.</li> <li>Protected Route: Redirects to the login page if the user is not authenticated.</li> <li>App Component: Manages the authentication state and routes.</li> </ul>"},{"location":"router/example/simple-login/#running-the-application","title":"Running the Application","text":"<ol> <li> <p>Start your React application:</p> <pre><code>npm start\n</code></pre> </li> <li> <p>Navigate to <code>http://localhost:3000/login</code> to access the login page. Use <code>username: user and password: pass</code> to log in and access the home page.</p> <p>This setup provides a complete example of a React application with protected routing and a login flow using Ant Design and React Router. If you have any further questions or need additional features, feel free to ask!</p> </li> </ol>"},{"location":"router/example/antd/active-link/","title":"Active link","text":""},{"location":"router/example/antd/active-link/#best-approach-to-active-state","title":"Best Approach to active state","text":"<p>The best way to handle the active state of a <code>Menu</code> in Ant Design, especially when using routing (like with <code>react-router-dom</code>), is to dynamically highlight the active menu item based on the current route. There are a few approaches to achieving this, but the most efficient and maintainable one involves using React Router's <code>useLocation</code> hook and leveraging the <code>selectedKeys</code> prop of the Ant Design <code>Menu</code> component.</p> <pre><code>const findSelectedKey = (items) =&gt; {\n  for (const item of items) {\n    if (item.children) {\n      const selectedChild = findSelectedKey(item.children);\n      if (selectedChild) return selectedChild;\n    }\n    if (\n      React.isValidElement(item.label) &amp;&amp;\n      item.label.props.to === location.pathname\n    ) {\n      return item.key;\n    }\n  }\n  return null;\n};\n\nconst selectedKey = findSelectedKey(items);\n\n\n// Menu\n&lt;Menu\n    selectedKeys={[selectedKey]}\n&gt;\n</code></pre>"},{"location":"router/example/antd/active-link/#best-approach-to-implement","title":"Best Approach to Implement:","text":"<ol> <li> <p>Using <code>selectedKeys</code> and <code>useLocation</code>:</p> <p>We'll use selectedKeys to highlight the active menu item and Link components in the menu items to properly associate routes with menu items.</p> <pre><code>import React from \"react\";\nimport { Link, useLocation } from \"react-router-dom\"; // Import useLocation\nimport {\n  AppstoreOutlined,\n  ContainerOutlined,\n  DesktopOutlined,\n  MailOutlined,\n  PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const location = useLocation(); // Get the current location (path)\n\n  // Define the items for the sidebar\n  const items = [\n    {\n      key: \"1\", // The unique key for the menu item\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"2\",\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"3\",\n      icon: &lt;ContainerOutlined /&gt;,\n      label: &lt;Link to=\"/spending\"&gt;Spending&lt;/Link&gt;,\n    },\n    {\n      key: \"sub1\",\n      label: \"Reports\",\n      icon: &lt;MailOutlined /&gt;,\n      children: [\n        {\n          key: \"5\",\n          label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;,\n        },\n        {\n          key: \"6\",\n          label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;,\n        },\n      ],\n    },\n    {\n      key: \"sub2\",\n      label: \"Profile\",\n      icon: &lt;AppstoreOutlined /&gt;,\n      children: [\n        {\n          key: \"9\",\n          label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;,\n        },\n        {\n          key: \"10\",\n          label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;,\n        },\n      ],\n    },\n  ];\n\n  // Find the key of the menu item that corresponds to the current path\n  const findSelectedKey = (items) =&gt; {\n    for (const item of items) {\n      if (item.children) {\n        // Check in children if the current path matches\n        const selectedChild = findSelectedKey(item.children);\n        if (selectedChild) return selectedChild;\n      }\n      if (\n        React.isValidElement(item.label) &amp;&amp;\n        item.label.props.to === location.pathname\n      ) {\n        return item.key; // Return the key if the path matches\n      }\n    }\n    return null; // Return null if no match is found\n  };\n\n  const selectedKey = findSelectedKey(items); // Get the selected key based on the current path\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      selectedKeys={[selectedKey]} // Set the selected key to highlight the active menu item\n      items={items}\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre> </li> </ol>"},{"location":"router/example/antd/active-link/#key-parts-of-this-approach","title":"Key Parts of This Approach:","text":"<ol> <li> <p><code>useLocation</code>:</p> <ul> <li>The <code>useLocation</code> hook from <code>react-router-dom</code> is used to get the current route path (<code>location.pathname</code>).</li> </ul> </li> <li> <p><code>findSelectedKey</code>:</p> <ul> <li>We recursively check each menu item and its children to see if their Link's to prop matches the current <code>location.pathname</code>. This ensures we highlight the correct item, even if it's inside a submenu.</li> </ul> </li> <li> <p><code>selectedKeys</code>:</p> <ul> <li>The <code>selectedKeys</code> prop in the <code>Menu</code> is dynamically set to the key of the currently active route. This will highlight the correct menu item automatically.</li> </ul> </li> </ol>"},{"location":"router/example/antd/active-link/#advantages-of-this-approach","title":"Advantages of This Approach:","text":"<ol> <li> <p>Automatic Sync:</p> <ul> <li>When you navigate through different routes, the active menu item will automatically update. This avoids any manual state management to track which item is active.</li> </ul> </li> <li> <p>Works for Nested Routes:</p> <ul> <li>This solution supports both top-level items and nested routes (submenus). It checks all submenus recursively and highlights the correct menu item, even if the user is deep within a nested route.</li> </ul> </li> <li> <p>No Additional State Management:</p> <ul> <li>Unlike some other approaches that require additional state to track active menu items, this approach directly ties the active menu item to the route, making the code simpler and easier to maintain.</li> </ul> </li> <li> <p>Minimal Code:</p> <ul> <li>The code is concise and easy to understand. We don't need to maintain custom active states or manage complex UI logic outside of what <code>react-router-dom</code> and Ant Design offer out of the box.</li> </ul> </li> </ol>"},{"location":"router/example/antd/active-link/#alternative-approaches-and-why-this-one-is-better","title":"Alternative Approaches and Why This One is Better:","text":"<ol> <li> <p>Using Custom Active State in <code>Menu.Item</code>:</p> <ul> <li>You could manually track which menu item is active using a custom state (<code>useState</code> or <code>Redux</code>). While this works, it introduces unnecessary complexity. React Router is built for this purpose, so it's better to rely on it to manage the routing logic.</li> </ul> </li> <li> <p>Using Ant Design <code>Menu.Item</code>'s <code>active</code> Prop:</p> <ul> <li>Ant Design's <code>Menu.Item</code> doesn't have an <code>active</code> prop. The active state is determined using <code>selectedKeys</code> or <code>defaultSelectedKeys</code>, making our approach using <code>selectedKeys</code> the most natural and correct way.</li> </ul> </li> </ol>"},{"location":"router/example/antd/active-link/#summary","title":"Summary:","text":"<ul> <li> <p>Best Practice: The best practice is to use <code>useLocation</code> from <code>react-router-dom</code> in combination with the <code>selectedKeys</code> prop of Ant Design's <code>Menu</code>. This ties the active state directly to the current route and ensures the correct item is highlighted even after page refreshes or when navigating to different routes.</p> </li> <li> <p>This approach is <code>clean</code>, <code>efficient</code>, and <code>maintainable</code>, and it leverages the power of React Router and Ant Design's built-in features for navigation and UI state management.</p> </li> </ul>"},{"location":"router/example/antd/intro/","title":"Sidebar Menu Route","text":"<p>To add links in the <code>Sidebar</code> component using Ant Design's <code>Menu</code>, you can utilize the <code>Link</code> component from react-router-dom to create navigational links for each menu item. Specifically, you'll need to modify the <code>label</code> property of each menu item to wrap it with the <code>Link</code> component. This allows the menu items to trigger navigation when clicked.</p> Steps to Add Links <ol> <li>Import <code>Link</code> from <code>react-router-dom</code>: This will allow you to navigate between different routes when a user clicks on a menu item.</li> <li>Wrap the <code>label</code> of each menu item with the <code>Link</code> component, and provide the to prop <code>to</code> specify the path for each route.</li> <li>Handle submenu items similarly by wrapping their <code>label</code> in a <code>Link</code>.</li> </ol> ExampleExplanation <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\"; // Import Link\nimport {\n    AppstoreOutlined,\n    ContainerOutlined,\n    DesktopOutlined,\n    MailOutlined,\n    PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n    const items = [\n        {\n            key: \"1\",\n            icon: &lt;PieChartOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n        },\n        {\n            key: \"2\",\n            icon: &lt;DesktopOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n        },\n        {\n            key: \"3\",\n            icon: &lt;ContainerOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/spending\"&gt;Spending&lt;/Link&gt;,\n        },\n        {\n            key: \"sub1\",\n            label: \"Reports\",\n            icon: &lt;MailOutlined /&gt;,\n            children: [\n                {\n                    key: \"5\",\n                    // Add Link here\n                    label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;,\n                },\n                {\n                    key: \"6\",\n                    // Add Link here\n                    label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;,\n                },\n            ],\n        },\n        {\n            key: \"sub2\",\n            label: \"Profile\",\n            icon: &lt;AppstoreOutlined /&gt;,\n            children: [\n                {\n                    key: \"9\",\n                    // Add Link here\n                    label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;,\n                },\n                {\n                    key: \"10\",\n                    // Add Link here\n                    label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;,\n                },\n            ],\n        },\n    ];\n\n    return (\n        &lt;Menu\n            mode=\"inline\"\n            inlineCollapsed={collapsed}\n            items={items}\n            style={{ width: `${width}px` }}\n        /&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <ol> <li> <p><code>Link</code> Wrapping: Each <code>label</code> property in the <code>items</code> array is now wrapped in a <code>Link</code> component. The <code>to</code> prop on the <code>Link</code> specifies the path to navigate to when the menu item is clicked.</p> <pre><code>label: (\n    &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; // Add the route path here\n),\n</code></pre> </li> <li> <p>Submenus: For the <code>sub1</code> and <code>sub2</code> keys (the submenus), each child item\u2019s <code>label</code> is also wrapped with a <code>Link</code> to allow navigation inside the submenu.</p> <pre><code>{\n    key: \"5\",\n    label: (\n        &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt; // Add the route path here\n    ),\n},\n</code></pre> </li> </ol> Note <ul> <li> <p>Paths: Ensure the paths in the <code>to</code> prop (e.g., <code>/dashboard</code>, <code>/balance</code>, <code>/profile/edit</code>) correspond to the routes defined in your AppRoutes component (or wherever you're managing routing).</p> </li> <li> <p>Ant Design Menu with Links: Ant Design\u2019s <code>Menu</code> component supports <code>Link</code> components directly in the <code>label</code>. By doing this, you integrate routing functionality while still using Ant Design\u2019s styled menu.</p> </li> </ul>"},{"location":"router/example/antd/intro/#example-routes-in-approutes-for-reference","title":"Example Routes in <code>AppRoutes</code> (for reference):","text":"<p>Make sure that these routes are defined in your <code>AppRoutes</code> (or wherever the routing is configured):</p> <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n&lt;Route path=\"/balance\" element={&lt;Balance /&gt;} /&gt;\n&lt;Route path=\"/spending\" element={&lt;Spending /&gt;} /&gt;\n&lt;Route path=\"/reports/monthly\" element={&lt;MonthlyReport /&gt;} /&gt;\n&lt;Route path=\"/reports/yearly\" element={&lt;YearlyReport /&gt;} /&gt;\n&lt;Route path=\"/profile/edit\" element={&lt;EditProfile /&gt;} /&gt;\n&lt;Route path=\"/profile/change-password\" element={&lt;ChangePassword /&gt;} /&gt;\n</code></pre>"},{"location":"router/example/antd/key-and-label/","title":"key & label Link","text":"<p>Avoiding Common Pitfalls: Proper Usage of <code>key</code> in Ant Design Menus</p> <p>Correct, you should not use route paths like <code>/profile</code>, <code>/dashboard</code>, etc., in the <code>key</code> prop of Ant Design <code>Menu</code> items. The <code>key</code> prop is intended to be a unique identifier for each menu item, and it should not directly represent the route path.</p>"},{"location":"router/example/antd/key-and-label/#overview","title":"Overview","text":"<p>Using <code>/lcy/</code> (or any path-like string) in key for Ant Design Menu items is not a good practice and not recommended for several reasons:</p>"},{"location":"router/example/antd/key-and-label/#1-ant-designs-key-should-be-unique","title":"1. Ant Design's <code>key</code> Should Be Unique:","text":"<p>The <code>key</code> prop in Ant Design's <code>Menu</code> component is designed to be a unique identifier for each <code>Menu.Item</code> (and <code>SubMenu</code>). It's not meant to represent the path of the route or any URL structure. Instead, it should be a simple string or number that uniquely identifies each item in the menu.</p> Why it's not good <ul> <li><code>key</code> is primarily used to determine the selected item and for efficient re-rendering of menu components. If you use path-like strings (e.g., <code>/dashboard/</code>, <code>/profile/</code>), it can conflict with how keys are expected to behave, especially in nested submenus.</li> <li>It's also not guaranteed that the paths will be unique in all cases, especially if you have dynamic routes or nested routes.</li> </ul>"},{"location":"router/example/antd/key-and-label/#2-path-matching-is-handled-by-react-router","title":"2. Path Matching is Handled by React Router:","text":"<p>The route path matching (like <code>/dashboard</code>, <code>/profile/edit</code>, etc.) should be handled separately via React Router and not mixed with the <code>key</code> prop of the menu. The <code>key</code> should be used solely for internal identification, and you should rely on the current <code>location.pathname</code> (from <code>useLocation</code> hook) to determine which route is active.</p> Best Practice <ul> <li>Menu <code>key</code> should be a unique identifier for the item itself, not a route path.</li> <li>Use <code>to</code> prop of the <code>Link</code> inside <code>Menu.Item</code> to handle routing, and use <code>location.pathname</code> to match the current active route.</li> </ul>"},{"location":"router/example/antd/key-and-label/#3-maintainability-and-clarity","title":"3. Maintainability and Clarity:","text":"<p>Using a path string as the <code>key</code> might make the code less maintainable and harder to debug, especially if routes change or get restructured. A simple <code>key</code> (like <code>\"1\"</code>, <code>\"sub1\"</code>, etc.) keeps things clear and decouples the UI logic (menu structure) from the routing logic.</p>"},{"location":"router/example/antd/key-and-label/#what-to-use-instead","title":"What to Use Instead:","text":"<p>1. Use Unique Identifiers for <code>key</code>:</p> <p>Instead of using the path or URL, use a simple, unique string or number to identify each menu item. This could be something like <code>\"1\"</code>, <code>\"sub1\"</code>, <code>\"profile\",</code> etc.</p> <pre><code>const items = [\n  {\n    key: \"dashboard\", // A unique, descriptive key for this menu item\n    icon: &lt;PieChartOutlined /&gt;,\n    label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n  },\n  {\n    key: \"balance\", // A unique key\n    icon: &lt;DesktopOutlined /&gt;,\n    label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n  },\n  {\n    key: \"profile\", // A unique key for the profile menu\n    icon: &lt;AppstoreOutlined /&gt;,\n    label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n  },\n];\n</code></pre> <p>2. Use <code>Link</code> for Navigation:</p> <p>The <code>Link</code> component from <code>react-router-dom</code> should be used to navigate between routes. The <code>to</code> prop of <code>Link</code> will automatically match the route for you.</p> <p>3. Use <code>selectedKeys</code> with Simple Matching:</p> <p>Use <code>selectedKeys</code> in combination with the <code>useLocation</code> hook from React Router to highlight the active menu item based on the current path.</p> <pre><code>import { Link, useLocation } from \"react-router-dom\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const location = useLocation();\n\n  // Define menu items with unique keys\n  const items = [\n    {\n      key: \"1\",\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"2\",\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"3\",\n      icon: &lt;AppstoreOutlined /&gt;,\n      label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n    },\n  ];\n\n  // Get the selected key based on the current route\n  const selectedKey = items.find(\n    (item) =&gt;\n      React.isValidElement(item.label) &amp;&amp;\n      item.label.props.to === location.pathname\n  )?.key;\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      selectedKeys={[selectedKey]} // Set the selected key to highlight the active menu item\n      items={items}\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n</code></pre>"},{"location":"router/example/antd/key-and-label/#summary-of-best-practices","title":"Summary of Best Practices:","text":"<ol> <li> <p>Avoid using route paths as keys:</p> <ul> <li>Use simple, unique identifiers for <code>key</code> (e.g., <code>\"dashboard\"</code>, <code>\"profile\"</code>, etc.).</li> </ul> </li> <li> <p>Use <code>Link</code> for route navigation:</p> <ul> <li>The <code>Link</code> component should handle the route path (via the <code>to</code> prop) and not be confused with the <code>key</code> prop of the <code>Menu</code>.</li> </ul> </li> <li> <p>Use <code>location.pathname</code> for active route matching:</p> <ul> <li>Use React Router's <code>useLocation</code> hook to determine which route is active, and then match it to the corresponding menu item to highlight it with selectedKeys.</li> </ul> </li> <li> <p>Keep UI and routing concerns separate:</p> <ul> <li>Your <code>Menu</code> component's <code>key</code> prop should be used for UI-specific identification, not for routing or paths.</li> </ul> </li> </ol> <p>By following these best practices, you ensure your menu system is both efficient and maintainable, and you avoid potential conflicts or issues with Ant Design's <code>Menu</code> component.</p>"},{"location":"router/example/antd/key-and-label/#additional","title":"Additional","text":"<pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n  AppstoreOutlined,\n  ContainerOutlined,\n  DesktopOutlined,\n  MailOutlined,\n  PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const items = [\n    {\n      key: \"dashboard\", // Unique key for top-level item\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"balance\", // Unique key for top-level item\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"profile\", // Unique key for top-level item\n      icon: &lt;AppstoreOutlined /&gt;,\n      label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n    },\n    {\n      key: \"sub1\", // Unique key for submenu \"Reports\"\n      icon: &lt;MailOutlined /&gt;,\n      label: \"Reports\", // No Link here, as it's a parent item\n      children: [\n        {\n          key: \"monthly\",\n          label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;, // Submenu item\n        },\n        {\n          key: \"yearly\",\n          label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;, // Submenu item\n        },\n      ],\n    },\n    {\n      key: \"sub2\", // Unique key for submenu \"Settings\"\n      icon: &lt;ContainerOutlined /&gt;,\n      label: \"Settings\", // No Link here, as it's a parent item\n      children: [\n        {\n          key: \"editProfile\",\n          label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;, // Submenu item\n        },\n        {\n          key: \"changePassword\",\n          label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;, // Submenu item\n        },\n      ],\n    },\n  ];\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      items={items} // Pass the menu items (including submenus) here\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre>"},{"location":"router/example/antd/key-and-label/#tips","title":"Tips","text":"<p>Correct Approach: Use Descriptive and Unique Keys for Menu Items</p> <p>Instead of using the route path in the <code>key</code>, you should use a unique identifier for each menu item. The <code>key</code> can be a string (like <code>\"dashboard\"</code>, <code>\"profile\"</code>, etc.) that describes the menu item. You will still use the <code>Link</code> component to navigate to the appropriate path, but the <code>key</code> will be a simpler and more appropriate value.</p> ExampleKey Points to Remember <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n    AppstoreOutlined,\n    ContainerOutlined,\n    DesktopOutlined,\n    MailOutlined,\n    PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n    const items = [\n        {\n            key: \"dashboard\", // A unique, descriptive key for this menu item\n            icon: &lt;PieChartOutlined /&gt;,\n            label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;, // Link for routing\n        },\n        {\n            key: \"balance\", // A unique key for this menu item\n            icon: &lt;DesktopOutlined /&gt;,\n            label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n        },\n        {\n            key: \"profile\", // A unique key for this menu item\n            icon: &lt;AppstoreOutlined /&gt;,\n            label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n        },\n        {\n            key: \"sub1\", // Unique key for submenu \"Reports\"\n            icon: &lt;MailOutlined /&gt;,\n            label: \"Reports\", // No Link here, as it's a parent item\n            children: [\n                {\n                    key: \"monthly\", // Unique key for \"Monthly\" report\n                    label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;, // Submenu item\n                },\n                {\n                    key: \"yearly\", // Unique key for \"Yearly\" report\n                    label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;, // Submenu item\n                },\n            ],\n        },\n        {\n            key: \"sub2\", // Unique key for submenu \"Settings\"\n            icon: &lt;ContainerOutlined /&gt;,\n            label: \"Settings\", // No Link here, as it's a parent item\n            children: [\n                {\n                    key: \"editProfile\", // Unique key for \"Edit Profile\"\n                    label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;, // Submenu item\n                },\n                {\n                    key: \"changePassword\", // Unique key for \"Change Password\"\n                    label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;, // Submenu item\n                },\n            ],\n        },\n    ];\n\n    return (\n        &lt;Menu\n            mode=\"inline\"\n            inlineCollapsed={collapsed}\n            items={items} // Pass the menu items (including submenus) here\n            style={{ width: `${width}px` }}\n        /&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <ol> <li> <p><code>key</code> is for identification: Use simple strings like <code>\"dashboard\"</code>, <code>\"balance\"</code>, <code>\"profile\"</code>, etc., as unique identifiers for menu items and submenus.</p> </li> <li> <p>Use <code>Link</code> for Routing: The <code>Link</code> component from React Router should be used to handle navigation to the actual route path (<code>to=\"/dashboard\"</code>, <code>to=\"/profile\"</code>, etc.).</p> </li> <li> <p>Match Active Menu Item with <code>location.pathname</code>: To highlight the active menu item, use <code>useLocation</code> from React Router to get the current path and match it to the correct key.</p> </li> <li> <p>Submenus: Use the <code>children</code> property inside the <code>Menu</code> item to define submenus. The <code>key</code> for each submenu item should also be unique and descriptive.</p> </li> </ol> <p>By following this approach, you maintain clear separation between UI behavior (the <code>key</code> for menu item identification) and routing behavior (the <code>Link</code> component for navigation). This makes your code easier to understand, maintain, and scale as your application grows.</p>"},{"location":"router/question/pervent-layout-flashing-v6/","title":"Privent Flashing Layout","text":"<p>How to Prevent Layout Flashing on Protected Routes in React Router v6</p>"},{"location":"router/question/pervent-layout-flashing-v6/#overview","title":"Overview","text":"Old Code AppRoutes.jsxProtectedRoute.jsx <pre><code>import {\n    BrowserRouter as Router,\n    Routes,\n    Route,\n    Navigate,\n} from \"react-router-dom\";\nimport Login from \"../pages/Login\";\nimport Signup from \"../pages/Signup\";\nimport Dashboard from \"../pages/Dashboard\";\nimport BalanceManagement from \"../pages/BalanceManagement\";\nimport Spending from \"../pages/Spending\";\nimport Profile from \"../pages/Profile\";\nimport Reports from \"../pages/Reports\";\n\nimport MyLayout from \"../components/layouts/MyLayout\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;Route path=\"/signup\" element={&lt;Signup /&gt;} /&gt;\n\n                &lt;Route\n                    path=\"/*\"\n                    element={\n                        &lt;MyLayout&gt;\n                            &lt;Routes&gt;\n                                &lt;Route\n                                    path=\"/dashboard\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Dashboard /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/balance\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;BalanceManagement /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/spending\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Spending /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/reports\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Reports /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/profile\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Profile /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                            &lt;/Routes&gt;\n                        &lt;/MyLayout&gt;\n                    }\n                /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <pre><code>import { Navigate } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n    if (!isAuthenticated) {\n        return &lt;Navigate to=\"/login\" replace /&gt;;\n    }\n    return children;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p>The issue you're experiencing with a split-second display of the layout UI when directly navigating to <code>/dashboard</code> can be due to several reasons related to how React Router handles route matching and conditional rendering in your <code>ProtectedRoute</code>.</p>"},{"location":"router/question/pervent-layout-flashing-v6/#the-issue","title":"The Issue:","text":"<p>When you navigate directly to /dashboard, React Router first tries to load the route associated with /dashboard, and only after this does it evaluate whether the user is authenticated or not through your ProtectedRoute wrapper. If the user is not authenticated, the redirect to /login happens, but this could cause a flicker (split-second UI) as the layout and other components might briefly render before the redirect occurs.</p>"},{"location":"router/question/pervent-layout-flashing-v6/#why-it-happens","title":"Why It Happens:","text":"<ol> <li> <p>Initial Layout Rendering:</p> <ul> <li>The <code>MyLayout</code> component is rendered immediately because you're using a nested <code>Routes</code> structure. The layout is rendered before the <code>ProtectedRoute</code> has a chance to check the user's authentication status, causing the layout to appear briefly even before the redirect happens.</li> </ul> </li> <li> <p>Redirection Delay:</p> <ul> <li>The <code>Navigate</code> component works asynchronously, and while it performs the redirection, React Router might still render the <code>MyLayout</code> and the inner components (<code>Dashboard</code>, <code>BalanceManagement</code>, etc.) briefly before redirecting, causing that split-second UI flicker.</li> </ul> </li> </ol>"},{"location":"router/question/pervent-layout-flashing-v6/#solution","title":"Solution:","text":"<p>To prevent the flicker and ensure that the layout is only rendered after authentication is checked, you can refactor your approach slightly to prevent rendering the layout prematurely. One common strategy is to conditionally render the layout or the protected route itself based on the user's authentication status.</p> <p>Refactor to Use Protected Routes Properly:</p> <p>Here\u2019s an updated approach where we conditionally render <code>MyLayout</code> and the protected routes only after checking authentication:</p> AppRoutes.jsx (Refactored):Explanation of Changes: <pre><code>import {\n    BrowserRouter as Router,\n    Routes,\n    Route,\n    Navigate,\n} from \"react-router-dom\";\nimport Login from \"../pages/Login\";\nimport Signup from \"../pages/Signup\";\nimport Dashboard from \"../pages/Dashboard\";\nimport BalanceManagement from \"../pages/BalanceManagement\";\nimport Spending from \"../pages/Spending\";\nimport Profile from \"../pages/Profile\";\nimport Reports from \"../pages/Reports\";\n\nimport MyLayout from \"../components/layouts/MyLayout\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                {/* Public Routes */}\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;Route path=\"/signup\" element={&lt;Signup /&gt;} /&gt;\n\n                {/* Protected Routes with Layout */}\n                &lt;Route\n                    path=\"/*\"\n                    element={\n                        &lt;ProtectedRoute&gt;\n                        &lt;MyLayout&gt;\n                            &lt;Routes&gt;\n                            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n                            &lt;Route path=\"/balance\" element={&lt;BalanceManagement /&gt;} /&gt;\n                            &lt;Route path=\"/spending\" element={&lt;Spending /&gt;} /&gt;\n                            &lt;Route path=\"/reports\" element={&lt;Reports /&gt;} /&gt;\n                            &lt;Route path=\"/profile\" element={&lt;Profile /&gt;} /&gt;\n                            &lt;/Routes&gt;\n                        &lt;/MyLayout&gt;\n                        &lt;/ProtectedRoute&gt;\n                    }\n                /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <ol> <li> <p>ProtectedRoute Wraps Layout:</p> <ul> <li>The <code>ProtectedRoute</code> now wraps the entire <code>MyLayout</code> and the nested routes.</li> <li>This ensures that the layout and any protected routes are not rendered until the authentication status is checked.</li> <li>If the user is not authenticated, the <code>Navigate</code> component inside <code>ProtectedRoute</code> will redirect them to <code>/login</code> before the layout and routes are rendered.</li> </ul> </li> <li> <p>No Nested Routes in ProtectedRoute:</p> <ul> <li>Instead of nesting the <code>Routes</code> inside <code>MyLayout</code> and wrapping each route with <code>ProtectedRoute</code>, the <code>ProtectedRoute</code> now controls whether the MyLayout (and all nested routes) should be rendered at all. This eliminates the need to check authentication for each route individually.</li> </ul> </li> <li> <p>Flicker-Free UI:</p> <ul> <li>By moving the authentication check to wrap the layout (and routes inside it), we avoid the brief flicker where the layout renders before the user is redirected.</li> </ul> </li> </ol> ProtectedRoute.jsx (Refactor) <p>Your <code>ProtectedRoute</code> component is mostly fine but needs a slight improvement. Make sure you're using the <code>useSelector</code> hook correctly and check authentication before rendering any children.</p> <pre><code>// src/routes/ProtectedRoute.jsx\nimport { useSelector } from \"react-redux\";\nimport { Navigate } from \"react-router-dom\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n    if (!isAuthenticated) {\n        return &lt;Navigate to=\"/login\" replace /&gt;;\n    }\n\n    return children;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>ProtectedRoute</code> will only render its <code>children</code> (the <code>MyLayout</code> and its child routes) if the user is authenticated. Otherwise, it redirects to <code>/login</code>.</li> </ul>"},{"location":"router/question/pervent-layout-flashing-v6/#why-this-works","title":"Why This Works:","text":"<ul> <li>By wrapping the entire layout and its children inside <code>ProtectedRoute</code>, the authentication check happens before the layout is rendered. This ensures that nothing is displayed (no UI flicker) until the authentication check is complete.</li> <li>With this change, users who are not authenticated will be redirected to the login page immediately, and no layout or protected routes will be rendered.</li> </ul>"},{"location":"router/question/pervent-layout-flashing-v6/#alternative-option-use-suspense-or-loading-indicator","title":"Alternative Option: Use Suspense or Loading Indicator","text":"<p>If you still experience a slight delay (maybe due to fetching authentication state from a server or external source), you could consider using React's <code>Suspense</code> or a loading indicator to avoid showing blank pages.</p>"},{"location":"router/types/private-vs-protected/","title":"Privated vs Protected","text":""},{"location":"router/types/private-vs-protected/#overview","title":"Overview","text":"<p>In React Router, \"ProtectedRoute\" and \"PrivateRoute\" are not built-in components but commonly used names for similar concepts. Both terms generally refer to a route that restricts access based on some authentication condition.</p>"},{"location":"router/types/private-vs-protected/#heres-a-quick-breakdown","title":"Here's a quick breakdown:","text":"<ul> <li> <p>PrivateRoute: This term is often used to describe a route that is only accessible to authenticated users. If a user is not authenticated, they are typically redirected to a login page.</p> </li> <li> <p>ProtectedRoute: This term is also used similarly and often implies that certain conditions (like user roles or permissions) must be met for access, not just authentication.</p> </li> </ul> <p>In practice, you might find libraries or examples using either term, but they usually serve the same purpose. You can implement them with custom logic to check user authentication and redirect as needed.</p>"},{"location":"router/types/private-vs-protected/#in-depth","title":"IN DEPTH","text":"<p>In React, particularly when using React Router, \"ProtectedRoute\" and \"PrivateRoute\" are commonly used terms to describe components that restrict access to certain routes based on user authentication status. While they serve a similar purpose, the terminology can vary depending on the implementation or library used.</p>"},{"location":"router/types/private-vs-protected/#privateroute","title":"PrivateRoute","text":"<ul> <li>Purpose: Typically restricts access to a route unless the user is authenticated.</li> <li>Usage: If a user tries to access a route and they are not logged in, they are redirected to a login page or another specified route.</li> <li>Implementation: Often involves checking a user authentication state (like a token or user object in context or Redux).</li> </ul> PrivateRoute.js<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n  const isAuthenticated = // logic to check if user is authenticated\n  return (\n    &lt;Route\n      {...rest}\n      render={props =&gt;\n        isAuthenticated ? (\n          &lt;Component {...props} /&gt;\n        ) : (\n          &lt;Redirect to=\"/login\" /&gt;\n        )\n      }\n    /&gt;\n  );\n};\n</code></pre>"},{"location":"router/types/private-vs-protected/#protectedroute","title":"ProtectedRoute","text":"<ul> <li>Purpose: Similar to PrivateRoute, it generally protects routes from being accessed by unauthorized users. The terminology might imply a broader use case, like protecting routes that are only accessible to certain user roles or permissions.</li> <li>Usage: Can also include additional checks, such as user roles or specific conditions beyond just being logged in.</li> <li>Implementation: May involve more complex logic depending on application needs.</li> </ul> ProtectedRoute.js<pre><code>const ProtectedRoute = ({ component: Component, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = // logic to get auth and role\n  return (\n    &lt;Route\n      {...rest}\n      render={props =&gt;\n        isAuthenticated &amp;&amp; userRole === requiredRole ? (\n          &lt;Component {...props} /&gt;\n        ) : (\n          &lt;Redirect to=\"/unauthorized\" /&gt;\n        )\n      }\n    /&gt;\n  );\n};\n</code></pre> Summary <ul> <li><code>PrivateRoute.js</code> for the authentication check.</li> <li><code>ProtectedRoute.js</code> for role-based or permission checks.</li> </ul>"},{"location":"router/types/private-vs-protected/#major-differences","title":"Major Differences","text":"<ol> <li> <p>Scope of Protection:</p> <ul> <li>PrivateRoute: Typically focuses solely on authentication (whether the user is logged in).</li> <li>ProtectedRoute: May include role-based access control or other conditions beyond just authentication.</li> </ul> </li> <li> <p>Terminology and Usage:</p> <ul> <li>The naming and specific implementation can vary by project or team conventions. \"ProtectedRoute\" might be used in some projects to indicate more complex restrictions.</li> </ul> </li> </ol> <p>In essence, while both concepts are about controlling access to routes based on authentication, \"ProtectedRoute\" often implies additional layers of security or role checks compared to a more straightforward \"PrivateRoute.\"</p>"},{"location":"router/types/private-vs-protected/#full-example-using-both","title":"Full Example Using Both","text":"<p>Create the Route Components</p> PrivateRoute.jsProtectedRoute.js <pre><code>// PrivateRoute.js\nimport React from 'react';\nimport { Route, Navigate } from 'react-router-dom';\n\nconst PrivateRoute = ({ component: Component, isAuthenticated, ...rest }) =&gt; (\n    &lt;Route\n        {...rest}\n        element={isAuthenticated ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n    /&gt;\n);\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// ProtectedRoute.js\nimport React from 'react';\nimport { Route, Navigate } from 'react-router-dom';\n\nconst ProtectedRoute = ({ component: Component, isAuthenticated, userRole, requiredRole, ...rest }) =&gt; (\n    &lt;Route\n        {...rest}\n        element={\n            isAuthenticated &amp;&amp; userRole === requiredRole ? (\n                &lt;Component /&gt;\n            ) : (\n                &lt;Navigate to=\"/unauthorized\" /&gt;\n            )\n        }\n    /&gt;\n);\n\nexport default ProtectedRoute;\n</code></pre> <p>Set Up Your Main Application</p> <pre><code>// App.js\nimport React, { useState } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport PrivateRoute from \"./PrivateRoute\";\nimport ProtectedRoute from \"./ProtectedRoute\";\nimport Home from \"./Home\";\nimport Login from \"./Login\";\nimport Admin from \"./Admin\";\nimport Unauthorized from \"./Unauthorized\";\n\nconst App = () =&gt; {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userRole, setUserRole] = useState(null); // e.g., 'admin', 'user'\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n        &lt;PrivateRoute\n          path=\"/home\"\n          element={Home}\n          isAuthenticated={isAuthenticated}\n        /&gt;\n        &lt;ProtectedRoute\n          path=\"/admin\"\n          element={Admin}\n          isAuthenticated={isAuthenticated}\n          userRole={userRole}\n          requiredRole=\"admin\"\n        /&gt;\n        &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>Example Components</p> Home.jsLogin.jsAdmin.jsUnauthorized.js <pre><code>// Home.js\nimport React from 'react';\n\nconst Home = () =&gt; &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;;\n\nexport default Home;\n</code></pre> <pre><code>// Login.js\nimport React from 'react';\n\nconst Login = () =&gt; {\nreturn &lt;h1&gt;Please log in&lt;/h1&gt;;\n};\n\nexport default Login;\n</code></pre> <pre><code>// Admin.js\nimport React from 'react';\n\nconst Admin = () =&gt; &lt;h1&gt;Welcome to the Admin Page!&lt;/h1&gt;;\n\nexport default Admin;\n</code></pre> <pre><code>// Unauthorized.js\nimport React from 'react';\n\nconst Unauthorized = () =&gt; &lt;h1&gt;You do not have permission to view this page.&lt;/h1&gt;;\n\nexport default Unauthorized;\n</code></pre> <p>Conclusion</p> <p>With this setup:</p> <ul> <li>Users can navigate to the <code>/home</code> route if they are authenticated.</li> <li>The <code>/admin</code> route is protected and requires the user to be authenticated and have the role of \"admin.\"</li> <li>If access is denied, users are redirected to the <code>/unauthorized</code> page.</li> </ul> <p>You can enhance the logic for authentication and role management based on your specific needs!</p>"},{"location":"router/types/private-vs-protected/#alternative-methods","title":"Alternative Methods","text":"<p>These methods offer different approaches to structuring your routes, each with its own benefits. You can choose the one that best fits your application\u2019s needs and complexity:</p> <ul> <li>Separate Route Component: Keeps the main routing file clean.</li> <li>Dynamic Route Rendering: Makes it easy to add/remove routes from a configuration.</li> <li>Nested Routes: Organizes routes hierarchically, improving readability.</li> <li>Higher-Order Component: Streamlines route protection logic.</li> </ul>"},{"location":"router/types/private-vs-protected/#best-methods","title":"Best Methods","text":"<p>The Route Composition method is the best choice for managing private and protected routes in your application, especially given your needs for role-based and authentication-based access control. Here\u2019s why it stands out:</p> BenefitsExample Use Case <p>Benefits of Route Composition for Private and Protected Routes</p> <ol> <li> <p>Modularity and Reusability:</p> <ul> <li>By encapsulating access logic in separate <code>PrivateRoute</code> and <code>ProtectedRoute</code> components, you create reusable, isolated pieces of code. This modularity allows each route type to have its own logic, which you can consistently apply across your app.</li> </ul> </li> <li> <p>Separation of Concerns:</p> <ul> <li>Each route component (<code>PrivateRoute</code>, <code>ProtectedRoute</code>) handles specific concerns: <code>PrivateRoute</code> focuses on authentication, while <code>ProtectedRoute</code> can add role-based or conditional access. This separation makes it easy to understand and modify each route\u2019s behavior independently without affecting other routes.</li> </ul> </li> <li> <p>Flexibility with Access Rules:</p> <ul> <li>Route Composition is highly adaptable. For example, you can easily add role-based access control by extending <code>ProtectedRoute</code> without altering other routes. This approach supports more complex access logic (e.g., requiring certain permissions) while keeping your routing logic clean.</li> </ul> </li> <li> <p>Easier Maintenance and Scalability:</p> <ul> <li>As your app grows and you add more protected routes, maintaining a single access check within <code>ProtectedRoute</code> and <code>PrivateRoute</code> becomes far simpler than updating access checks across scattered route definitions or HOCs. If authentication logic changes, you only need to update these components rather than every individual route.</li> </ul> </li> <li> <p>Enhanced Readability:</p> <ul> <li>By using <code>PrivateRoute</code> and <code>ProtectedRoute</code>, you can easily see which routes are protected and the type of access required without digging into nested logic. This readability makes onboarding new developers or reviewing route logic straightforward.</li> </ul> </li> </ol> <p>Example Use Case for Route Composition</p> <p>Suppose your application requires:</p> <ul> <li>Basic authentication for access to certain areas (e.g., a user dashboard).</li> <li>Role-based access to restricted routes (e.g., a \u201cFinancial\u201d route only accessible to premium users).</li> </ul> <p>The Route Composition approach lets you define <code>PrivateRoute</code> for general authenticated access and <code>ProtectedRoute</code> for role-based access. This setup will be flexible and scalable for other future roles or access requirements without significant restructuring.</p> Example Code Implementation for Route Composition<pre><code>// PrivateRoute.js - For routes that only need authentication\nimport React from 'react';\nimport { Navigate } from 'react-router-dom';\n\nconst PrivateRoute = ({ element, isAuthenticated }) =&gt; {\n  return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default PrivateRoute;\n\n// ProtectedRoute.js - For routes that need both authentication and role-checks\nconst ProtectedRoute = ({ element, isAuthenticated, requiredRole, userRole }) =&gt; {\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/\" /&gt;;\n  } else if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/not-authorized\" /&gt;;\n  }\n  return element;\n};\n\nexport default ProtectedRoute;\n\n// AppRoutes.js - Main route configuration with route composition\nimport PrivateRoute from './PrivateRoute';\nimport ProtectedRoute from './ProtectedRoute';\n\nfunction AppRoutes() {\n  const isAuthenticated = // your authentication logic\n  const userRole = // your role logic (e.g., \"standard\" or \"premium\")\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n        &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute isAuthenticated={isAuthenticated} element={&lt;Dashboard /&gt;} /&gt;} /&gt;\n        &lt;Route path=\"/financial\" element={&lt;ProtectedRoute isAuthenticated={isAuthenticated} userRole={userRole} requiredRole=\"premium\" element={&lt;Financial /&gt;} /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre> <p>Why Route Composition is the Best Choice</p> <p>This method balances flexibility, scalability, and simplicity, making it ideal for any application with evolving access requirements. With Route Composition, you get clear, maintainable code that keeps both security and readability in mind\u2014key factors for developing robust, scalable applications.</p>"},{"location":"router/types/types-of-access-control-routes/","title":"Route Protection","text":""},{"location":"router/types/types-of-access-control-routes/#types-of-access-control-routes-in-react","title":"Types of access control routes in React","text":"<p>Understanding Route Protection in React: PrivateRoute, ProtectedRoute, and More</p> Types of Access Control Routes in React: <ol> <li> <p>Public Routes</p> <ul> <li>Accessible to everyone (no authentication or authorization required).</li> </ul> </li> <li> <p>Private Routes (Authenticated Routes)</p> <ul> <li>Only accessible to authenticated users (checks if the user is logged in).</li> </ul> </li> <li> <p>Protected Routes (Authorization Based on Roles)</p> <ul> <li>Accessible only to authenticated users with specific roles or permissions (e.g., admins, managers).</li> </ul> </li> <li> <p>Role-Based Access Control (RBAC) Routes</p> <ul> <li>Routes that are restricted based on a user\u2019s assigned roles or permissions, allowing fine-grained access control.</li> </ul> </li> <li> <p>Unauthorized Access Handling (Redirection)</p> <ul> <li>Involves redirecting users who are not authorized to access certain routes to login or an \"unauthorized\" page.</li> </ul> </li> <li> <p>Global State Management (<code>React Context</code> for Authentication)</p> <ul> <li>Using a global context (like React Context) to manage authentication state, roles, and permissions, which can be checked throughout the application.</li> </ul> </li> </ol> <p>These are the different access control patterns in React that you can apply to your routing logic based on whether users need to be authenticated or authorized (or both) to access certain resources or pages in your app.</p> <p>Different types of access control routes in React</p>"},{"location":"router/types/types-of-access-control-routes/#access-control","title":"Access Control","text":"<p>Ah, I see! You're referring to the types of routes in terms of access control\u2014like public, protected, and private routes. This is a common pattern when you need to restrict access to certain routes based on the user's authentication or authorization status.</p> <p>Here's how you can classify these types of routes and implement them in a React app (often using React Router and some form of authentication, like JWT or session-based authentication).</p>"},{"location":"router/types/types-of-access-control-routes/#1-public-routes","title":"1. Public Routes","text":"<ul> <li>Definition: These are routes that are accessible to anyone, regardless of whether they are logged in or not.</li> <li>Examples: A home page, about page, login page, sign-up page, etc.</li> <li>Use Case: Public routes are typically for general information that all users (authenticated or not) can view.</li> </ul> Implementation<pre><code>&lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n&lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n</code></pre> <p>In this case, anyone can visit the <code>/</code> or<code>/about</code> routes, regardless of their authentication status.</p>"},{"location":"router/types/types-of-access-control-routes/#2-private-routes-authenticated-routes","title":"2. Private Routes (Authenticated Routes)","text":"<ul> <li>Definition: These are routes that require the user to be authenticated before they can access them. If a user is not authenticated, they are usually redirected to a login page or shown an error message.</li> <li>Use Case: Private routes are typically for pages that require the user to be logged in, like their profile, dashboard, or account settings.</li> </ul> <p>Implementation: To create a private route, you typically create a wrapper component that checks the user's authentication status and either renders the route's component or redirects them to the login page.</p> Example of a PrivateRoute component<pre><code>const PrivateRoute = ({ element, ...rest }) =&gt; {\n  const isAuthenticated = useAuth(); // Custom hook to check auth status\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage in your routing configuration<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;PrivateRoute path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>Here, the <code>/dashboard</code> route is only accessible if the user is authenticated. Otherwise, they are redirected to the login page.</p>"},{"location":"router/types/types-of-access-control-routes/#3-protected-routes-authorization-based-on-roles","title":"3. Protected Routes (Authorization Based on Roles)","text":"<ul> <li>Definition: Protected routes can be thought of as a mix of private routes and role-based access control (RBAC). These routes not only require the user to be authenticated, but also to have certain permissions or roles to access them. For example, a user may need to be an \"admin\" to access certain pages like an admin panel.</li> <li>Use Case: Protected routes are for scenarios where access to certain routes depends not just on being logged in, but on the user's role or permissions (e.g., admin dashboard, settings for premium users, etc.).</li> </ul> <p>Implementation: You can extend the logic of private routes by checking the user's role in addition to their authentication status.</p> Example of a ProtectedRoute component<pre><code>const ProtectedRoute = ({ element, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = useAuth(); // Custom hook to check auth and role\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/unauthorized\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage in your routing configuration<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;ProtectedRoute path=\"/admin\" element={&lt;AdminPanel /&gt;} requiredRole=\"admin\" /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>In this case, only users who are authenticated and have the admin role can access the <code>/admin</code> route. If the user doesn't have the required role, they are redirected to an unauthorized page.</p>"},{"location":"router/types/types-of-access-control-routes/#4-adminrole-based-routes","title":"4. Admin/Role-Based Routes","text":"<ul> <li>Definition: A more specific form of protected routes where access depends on the user's role (admin, manager, user, etc.). This is often part of the protected route system, where roles are checked before rendering the component.</li> <li>Use Case: These routes are for applications where different types of users (admin, regular user, etc.) have different levels of access. For example, an admin might have access to an admin dashboard, but a regular user wouldn\u2019t.</li> </ul> <p>Implementation: Here's how you might create role-based access control in your route configuration:</p> <pre><code>const RoleBasedRoute = ({ element, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = useAuth(); // Check auth and role\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/unauthorized\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;RoleBasedRoute path=\"/admin\" element={&lt;Admin /&gt;} requiredRole=\"admin\" /&gt;\n  &lt;RoleBasedRoute\n    path=\"/user-settings\"\n    element={&lt;UserSettings /&gt;}\n    requiredRole=\"user\"\n  /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre>"},{"location":"router/types/types-of-access-control-routes/#example-flow-for-public-private-and-protected-routes","title":"Example Flow for Public, Private, and Protected Routes\"","text":"<p>Let\u2019s put it all together in an example where we have:</p> <ul> <li>Public Routes: Accessible to everyone (<code>Home</code>, <code>About</code>, <code>Login</code>)</li> <li>Private Routes: Only accessible to authenticated users (<code>Dashboard</code>)</li> <li>Protected Routes: Only accessible to authenticated users with a specific role (<code>Admin Panel</code>)</li> </ul> <pre><code>&lt;Routes&gt;\n  {/* Public Routes */}\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n\n  {/* Private Route */}\n  &lt;PrivateRoute path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n\n  {/* Protected Route (only accessible by admin) */}\n  &lt;ProtectedRoute path=\"/admin\" element={&lt;AdminPanel /&gt;} requiredRole=\"admin\" /&gt;\n\n  {/* Fallback for unauthorized access */}\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>Summary of Route Types:</p> <ul> <li>Public Routes: Routes that anyone can access, regardless of authentication status.</li> <li>Private Routes: Routes that require the user to be authenticated to access.</li> <li>Protected Routes: Routes that require the user to be authenticated and may require specific permissions or roles.</li> </ul>"},{"location":"router/types/types-of-access-control-routes/#question","title":"Question","text":"<p>Question</p> <p>The most commonly used types of access control routes in React applications are Private Routes (Authenticated Routes) and Role-Based Access Control (RBAC) Routes. The exact choice depends on the complexity and requirements of your application, but here\u2019s a breakdown of why these two are generally the most used:</p> <p>1. Private Routes (Authenticated Routes)</p> <ul> <li> <p>Why it\u2019s most used: In most web applications, especially those with user accounts (like social networks, dashboards, or e-commerce sites), you typically need to ensure that certain parts of your app are only accessible to users who are logged in.   Private Routes are simple to implement and cover a large portion of authentication requirements.</p> </li> <li> <p>How it's implemented: You protect routes by checking whether a user is authenticated (i.e., logged in). If they are not authenticated, they are redirected to a login page.</p> </li> <li> <p>Example use cases:</p> <ul> <li>Dashboard pages that show user-specific data (e.g., <code>/dashboard</code>).</li> <li>Profile pages where only logged-in users can access their personal details (e.g., <code>/profile</code>).</li> <li>Admin or other restricted sections (if roles are not required for access).</li> </ul> </li> <li> <p>Why it\u2019s widely used: Many applications require a basic authentication flow, so Private Routes are easy to implement and meet the needs of most use cases.</p> </li> </ul> <p>2. Role-Based Access Control (RBAC) Routes</p> <ul> <li> <p>Why it\u2019s most used: When your application has different user roles (e.g., <code>admin</code>, <code>user</code>, <code>manager</code>), you might want to restrict access to certain routes or features based on those roles. RBAC Routes are an extension of Private Routes that check both authentication and authorization (role).</p> </li> <li> <p>How it's implemented: Once a user is authenticated, you check the user's role before granting access to specific routes. For example, only users with the <code>admin</code> role can access the<code>/admin</code> page.</p> </li> <li> <p>Example use cases:</p> <ul> <li>Admin dashboards or settings (e.g., <code>/admin</code>).</li> <li>Role-based content management or moderation pages (e.g., <code>/moderator</code>).</li> <li>Custom user settings based on role (e.g., <code>/manager/settings</code>).</li> </ul> </li> <li> <p>Why it\u2019s widely used:</p> <ul> <li>Many modern applications are built with different levels of access for different users, especially in enterprise or business-focused applications.</li> <li>Role-based access control is a common and scalable way to manage permissions.</li> </ul> </li> </ul> <p>Comparison: Private Routes vs. RBAC Routes</p> <ul> <li> <p>Private Routes are used when you only need to ensure that users are logged in, without worrying about their role. This is typically enough for most simple apps where only authentication is necessary.</p> </li> <li> <p>RBAC Routes add another layer by checking not just if the user is logged in, but also whether they have the correct role for accessing certain routes. This is necessary for applications that have multiple types of users with varying levels of access.</p> </li> </ul> <p>Which One is Most Used?</p> <ul> <li> <p>Private Routes (Authenticated Routes) are the most common for simpler apps or apps where users simply need to be logged in to access protected areas. Examples of this type of access control include personal blogs, e-commerce sites with user accounts, or social networks.</p> </li> <li> <p>Role-Based Access Control (RBAC Routes) are widely used as well, especially in applications with more complex user management. As soon as you have multiple roles with different permissions (like admins, users, or moderators), you\u2019ll need to implement RBAC for more granular control over what each user can do.</p> </li> </ul> <p>Conclusion</p> <p>For a typical React app:</p> <ul> <li>Private Routes are the most commonly used when dealing with basic authentication needs (ensuring users are logged in).</li> <li>RBAC Routes become necessary as the app grows in complexity and needs more detailed user access management based on roles.</li> </ul> <p>In short: if your app involves just logging users in and letting them access certain sections, Private Routes will be sufficient. However, as your app grows in complexity and you need to differentiate between users (e.g., admins vs. regular users), Role-Based Access Control (RBAC) becomes the go-to solution.</p>"},{"location":"router/types/types-of-router/","title":"Types of Router","text":""},{"location":"router/types/types-of-router/#overview","title":"Overview","text":"<p>In React, routing is typically handled by a library called React Router. It allows developers to manage navigation within a React application by mapping URLs to different components, thus enabling single-page applications (SPAs).</p> <p>React Router provides several types of routers, each suited to different environments or use cases. Here's a breakdown of the main types of routers in React Router:</p>"},{"location":"router/types/types-of-router/#1-browserrouter","title":"1. BrowserRouter","text":"<ul> <li>Usage: This is the most common router used for web applications that run in the browser.</li> <li>Description: <code>BrowserRouter</code> uses the HTML5 history API to keep the UI in sync with the URL. It allows for cleaner URLs (e.g., <code>https://example.com/about</code>), without the hash (<code>#</code>) symbol. It is best suited for traditional web apps where the server supports client-side routing.</li> </ul> <pre><code>import { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"router/types/types-of-router/#2-hashrouter","title":"2. HashRouter","text":"<ul> <li>Usage: This router is often used for applications that are deployed on static file servers or environments that don't support HTML5 history API.</li> <li>Description: <code>HashRouter</code> uses the URL's hash (#) to manage routing. This is useful for scenarios where server-side configurations cannot handle direct URL routing or for environments where you don't have access to modify the server. It results in URLs like <code>http://example.com/#/about</code> rather than <code>http://example.com/about</code>.</li> </ul> <pre><code>import { HashRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"router/types/types-of-router/#3-memoryrouter","title":"3. MemoryRouter","text":"<ul> <li>Usage: This is often used in testing, React Native applications, or situations where you want to keep the navigation history in memory and don't need it to be reflected in the URL.</li> <li>Description: <code>MemoryRouter</code> keeps track of the history in memory (instead of the URL or the browser's history stack). It's suitable for use cases where the application doesn't need a real browser history, such as in non-browser environments (e.g., React Native, testing).</li> </ul> <pre><code>import { MemoryRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router initialEntries={[\"/\"]} initialIndex={0}&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"router/types/types-of-router/#summary-of-routers","title":"Summary of Routers:","text":"Router Type Usage Description BrowserRouter For client-side routing in web applications. Uses the browser's history API for clean URLs and full control over navigation. HashRouter For environments that cannot use the HTML5 history API. Uses the hash (<code>#</code>) in the URL to track routes (common in static file hosting). MemoryRouter For non-browser environments, such as React Native or tests. Keeps the history stack in memory rather than the URL bar, not reflected in the browser's address. StaticRouter For server-side rendering (SSR) in React apps. Used to render React components on the server, where the location is passed in as a prop."},{"location":"router/types/types-of-router/#choosing-the-right-router","title":"Choosing the Right Router:","text":"<ul> <li>BrowserRouter is generally the best option for standard web applications that run in modern browsers.</li> <li>HashRouter is useful if you're hosting the app on a static file server or need to work around server limitations.</li> <li>MemoryRouter is helpful for SSR or testing environments, where URL manipulation isn't required.</li> <li>StaticRouter is used specifically in SSR contexts, where you're rendering the app server-side.</li> </ul> <p>If you're building a standard web app, you\u2019ll most likely use BrowserRouter, but depending on your environment and needs, other routers might be more appropriate.</p>"},{"location":"router/types/types-of-router/#reference","title":"Reference","text":"<ul> <li>Types and Implementation Methods</li> <li>Relative Vs Dynamic Routing in React - Routing Method</li> <li>React JS Types of Routers</li> <li>Understanding the Three Types of Routers in React</li> <li>A complete guide to routing in React</li> <li>Offical doc</li> </ul>"},{"location":"router/version/v6/","title":"v6","text":""},{"location":"router/version/v6/#react-router","title":"React Router","text":"<ul> <li>React Router v6 Update: Updated PrivateRoute to use Navigate instead of Redirect.</li> <li>Component Validation: Ensured PrivateRoute validates its props with PropTypes.</li> <li>Router Configuration: Updated App component to use Routes and Route components from react-router-dom v6.</li> </ul> <p>By making these changes, your code will be compatible with react-router-dom version 6, and you should no longer encounter the issue with the Redirect component.</p> <p>React Router is a popular library used for routing in React applications. It allows you to handle navigation and rendering of different components based on the URL, enabling single-page application (SPA) behavior.</p>"},{"location":"router/version/v6/#versions-of-react-router","title":"Versions of React Router","text":"<p>React Router has undergone several major versions, each introducing significant changes and improvements:</p> <ol> <li>React Router v1 and v2: Early versions focused on basic routing capabilities.</li> <li>React Router v3: Provided a more stable API but started showing limitations in terms of flexibility and ease of use.</li> <li>React Router v4: Introduced a major overhaul with a declarative approach to routing, enabling more powerful and flexible routing capabilities.</li> <li>React Router v5: Built on v4's foundation, providing incremental improvements and more features while maintaining backward compatibility.</li> <li>React Router v6: Another major update with significant changes to the API, simplifying and modernizing routing in React applications.</li> </ol>"},{"location":"router/version/v6/#major-updates-and-changes","title":"Major Updates and Changes","text":""},{"location":"router/version/v6/#react-router-v4","title":"React Router v4","text":"<ul> <li>Declarative Routing: Introduced a new approach where routes are declared as components, making the routing logic more intuitive and easier to manage.</li> <li>Dynamic Routing: Allowed routes to be dynamic, enabling more flexibility.</li> <li>Nested Routes: Improved support for nested routes, making it easier to build complex routing structures.</li> <li>Removal of Route Configuration: Moved away from centralized route configuration to a component-based approach.</li> </ul>"},{"location":"router/version/v6/#react-router-v5","title":"React Router v5","text":"<ul> <li>Incremental Improvements: Built on v4, adding minor enhancements and optimizations while maintaining the same declarative approach.</li> <li>Hooks Support: Introduced hooks like <code>useHistory</code>, <code>useLocation</code>, <code>useParams</code>, and <code>useRouteMatch</code> for more flexible and powerful routing.</li> <li>Suspense Integration: Improved integration with React's Suspense for data fetching and code splitting.</li> </ul>"},{"location":"router/version/v6/#react-router-v6","title":"React Router v6","text":"<ul> <li>Simplified API: Major overhaul with a more straightforward and simplified API.</li> <li>Routes and Route Elements: Introduced the Routes and Route elements, replacing Switch and Route from previous versions.</li> <li>Nested Routes: Enhanced nested routing with a more intuitive approach.</li> <li>Data Loading: Integrated better support for data loading and fetching, aligning with modern React patterns.</li> <li>Improved TypeScript Support: Enhanced TypeScript support for better type checking and developer experience.</li> <li>URL-based State: Improved handling of state through URLs, making it easier to manage state with routing.</li> <li>Route Definitions: Allowed defining routes as objects or elements, providing more flexibility.</li> </ul>"},{"location":"router/version/v6/#example-comparison","title":"Example Comparison","text":"React Router v5 <pre><code>import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;Redirect from=\"/\" to=\"/dashboard\" /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> React Router v6 <pre><code>import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute component={Dashboard} /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;Navigate to=\"/dashboard\" /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre>"},{"location":"router/version/v6/#summary-of-major-changes-in-v6","title":"Summary of Major Changes in v6","text":"<ol> <li><code>Switch</code> replaced by <code>Routes</code>: <code>Switch</code> component is replaced by <code>Routes</code>.</li> <li><code>component</code> and <code>render</code> replaced by <code>element</code>: The <code>component</code> and <code>render</code> props are replaced by <code>element</code>.</li> <li><code>Redirect</code> replaced by <code>Navigate</code>: <code>Redirect</code> component is replaced by <code>Navigate</code>.</li> <li>Route Definitions: Routes can now be defined using nested <code>Route</code> elements.</li> <li>Hooks and Context API: Improved hooks and context for routing logic.</li> <li>Improved TypeScript Support: Better TypeScript support for static type checking.</li> </ol> <p>By understanding these changes, you can effectively use React Router in your projects and take advantage of the latest features and improvements.</p>"},{"location":"state-management/intro/","title":"Intro","text":"<p>Most developers use Redux, Recoil, Mobx, and other third-party libraries to manage the global state in large-scale applications.</p> <ul> <li> <p> Redux</p> <p>A JS library for predictable and maintainable global state management.</p> <p> Reference</p> </li> <li> <p> Mobx</p> <p>MobX is a signal based, battle-tested library that makes state management simple and scalable by transparently applying functional reactive programming. </p> <p> Reference</p> </li> <li> <p> Recoil</p> <p>A state management library for React.</p> <p> Reference</p> </li> <li> <p> Zustand</p> <p>A small, fast, and scalable bearbones state management solution.</p> <p> Reference</p> </li> </ul>"},{"location":"state-management/jwt-verification-clientside/","title":"JWT Client Side","text":""},{"location":"state-management/jwt-verification-clientside/#jwt-on-client-side","title":"JWT on Client Side","text":"<p>When handling JWT tokens on the client-side, the main focus should be usability rather than security, because the client doesn't have access to the secret or public keys needed to fully verify the signature of the JWT (which is the most critical part of the validation process). Instead, the client can perform certain checks that help improve the user experience and avoid relying on expired or malformed tokens.</p> <p>Here is the standard approach and what the client can verify:</p>"},{"location":"state-management/jwt-verification-clientside/#1-verify-jwt-structure-format-check","title":"1. Verify JWT Structure (Format Check)","text":"<p>The client can verify that the JWT is well-formed by checking if it has the correct structure. A valid JWT should consist of three parts (header, payload, and signature) separated by ..</p> <ul> <li>Header: Encoded JSON containing metadata (e.g., algorithm).</li> <li>Payload: Encoded JSON containing claims (e.g., user information, roles, and expiration).</li> <li>Signature: Ensures the integrity and authenticity of the token (though this cannot be verified client-side).</li> </ul> <p>Why: Checking the structure ensures the token isn't malformed. If it doesn\u2019t have three parts, it\u2019s not a valid JWT.</p> <pre><code>const isValidJWTStructure = (token) =&gt; {\n  if (!token) return false;\n\n  const parts = token.split(\".\");\n  if (parts.length !== 3) return false;\n\n  // Optionally, you could also check that each part matches base64 encoding\n  const [header, payload, signature] = parts;\n  return (\n    /^[A-Za-z0-9-_]+$/.test(header) &amp;&amp;\n    /^[A-Za-z0-9-_]+$/.test(payload) &amp;&amp;\n    /^[A-Za-z0-9-_]+$/.test(signature)\n  );\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#2-decode-the-jwt-and-check-expiration","title":"2. Decode the JWT and Check Expiration","text":"<p>One of the most common client-side checks is checking whether the token has expired. JWT tokens usually include an <code>exp</code> (expiration) claim in the payload, which you can decode and compare against the current time.</p> <p>Why: If the token is expired, it should not be used for further requests, and the client can prompt the user to re-authenticate.</p> <p>You can use libraries like jwt-decode to decode the token and read the expiration:</p> <pre><code>import jwtDecode from \"jwt-decode\";\n\nconst verifyTokenExpiration = (token) =&gt; {\n  try {\n    const decoded = jwtDecode(token);\n    const currentTime = Date.now() / 1000; // Current time in seconds\n\n    // Check if the token has expired\n    if (decoded.exp &amp;&amp; decoded.exp &lt; currentTime) {\n      return false; // Token is expired\n    }\n    return true; // Token is valid\n  } catch (error) {\n    console.error(\"Failed to decode token\", error);\n    return false; // Token is invalid or malformed\n  }\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#3-check-the-aud-audience-and-iss-issuer-claims-optional","title":"3. Check the <code>aud</code> (Audience) and <code>iss</code> (Issuer) Claims (Optional)","text":"<p>You can optionally check the <code>aud</code> (audience) and <code>iss</code> (issuer) claims to ensure the token was issued for the correct application (audience) and by a trusted issuer. This isn't typically done on the client side in many apps, but for additional security checks (especially for more complex applications), you can verify that these fields are correct.</p> <ul> <li>aud (Audience): This should be your application\u2019s identifier or a list of valid audiences.</li> <li>iss (Issuer): This should be the issuer of the token (e.g., your identity provider or backend server).</li> </ul> <p>Why: This ensures the token was issued for the intended audience and by a trusted party.</p> <pre><code>const verifyAudienceAndIssuer = (token) =&gt; {\n  try {\n    const decoded = jwtDecode(token);\n\n    const expectedAudience = \"myAppAudience\";\n    const expectedIssuer = \"myIssuer\";\n\n    if (decoded.aud !== expectedAudience || decoded.iss !== expectedIssuer) {\n      return false; // Token has an unexpected audience or issuer\n    }\n    return true; // Token is valid for this audience and issuer\n  } catch (error) {\n    return false; // Token is invalid or malformed\n  }\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#4-handle-token-expiration-gracefully","title":"4. Handle Token Expiration Gracefully","text":"<p>While the client can't fully validate the signature, it can check for expiration (as shown above) and manage the user session accordingly. You should implement a flow where expired tokens are detected and users are logged out or prompted to re-authenticate.</p> <ul> <li>If the token has expired, clear any user session information (like storing it in <code>localStorage</code> or <code>sessionStorage</code>) and redirect the user to the login page.</li> <li>Optionally, you can implement a refresh token flow (with a separate API endpoint) to silently refresh the session without requiring the user to log in again.</li> </ul>"},{"location":"state-management/jwt-verification-clientside/#5-gracefully-handle-invalid-tokens","title":"5. Gracefully Handle Invalid Tokens","text":"<p>If the JWT is malformed or invalid, it\u2019s important to catch errors gracefully so the app doesn\u2019t crash or behave unexpectedly. This is especially important if you are decoding the token on the client side.</p> <p>For instance, in the code snippet above where jwtDecode is used, you might want to ensure that any invalid token (one that can't be decoded) is ignored and the user is redirected to the login page.</p> <pre><code>try {\n  const decodedToken = jwtDecode(token);\n  if (decodedToken.exp &lt; Date.now() / 1000) {\n    // Handle expired token\n    alert(\"Session expired, please log in again.\");\n  }\n} catch (error) {\n  alert(\"Invalid token.\");\n  // Clear the session and redirect to login page\n  localStorage.removeItem(\"token\");\n  window.location.href = \"/login\";\n}\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#6-store-tokens-securely","title":"6. Store Tokens Securely","text":"<p>While not a \"validation\" per se, it\u2019s essential to store JWT tokens securely on the client side. Here are some security tips:</p> <ul> <li>Use <code>HttpOnly</code> cookies: This is the safest way to store JWT tokens, as it prevents JavaScript from accessing the token (mitigates XSS attacks).</li> <li>Avoid <code>localStorage</code> or <code>sessionStorage</code> for storing sensitive tokens because these are accessible via JavaScript and could be stolen via XSS attacks. If you must store them in <code>localStorage</code>, ensure you're using proper XSS defenses.</li> </ul>"},{"location":"state-management/jwt-verification-clientside/#standard-practice-overview","title":"Standard Practice Overview:","text":"<ul> <li>Verify JWT structure: Ensure the token has three parts (header, payload, signature).</li> <li>Decode and check expiration: Verify that the token has not expired (check the <code>exp</code> claim).</li> <li>Optionally verify <code>aud</code> and <code>iss</code> claims: Check if the token's audience and issuer are valid for your application.</li> <li>Gracefully handle invalid or expired tokens: Log out users or prompt them to log in again when the token is expired or malformed.</li> <li>Secure token storage: Use HttpOnly cookies or other secure methods to store JWT tokens.</li> </ul>"},{"location":"state-management/jwt-verification-clientside/#what-shouldnt-the-client-do","title":"What Shouldn't the Client Do?","text":"<ul> <li>Never verify the JWT signature: The client doesn't have the secret or public key required to verify the integrity of the JWT, so you should rely on the server for actual signature verification.</li> <li>Don\u2019t trust the JWT entirely on the client-side: Always assume that the client-side data can be tampered with. For example, if you rely on decoding a JWT to determine the user's role, make sure that your server performs its own authorization checks when handling sensitive requests.</li> </ul>"},{"location":"state-management/jwt-verification-clientside/#conclusion","title":"Conclusion:","text":"<p>In summary, the client-side checks you should perform for a JWT are:</p> <ol> <li>Verify the token structure.</li> <li>Decode and check expiration (if the token is expired, log the user out).</li> <li>Optionally verify claims like <code>aud</code> and <code>iss</code>.</li> <li>Ensure the token is securely stored.</li> </ol> <p>The server-side is where the real trust and security come from\u2014so always ensure that the server verifies the JWT's signature and performs authorization checks.</p>"},{"location":"state-management/jwt-verification-clientside/#summary-of-compulsory-vs-optional-client-side-checks","title":"Summary of Compulsory <code>vs.</code> Optional Client-Side Checks","text":"<p>When it comes to JWT verification on the client-side, there are some checks that are compulsory to ensure the token is at least usable and does not immediately violate basic expectations (like being expired or malformed), while others are optional, depending on your application's specific security and user experience requirements.</p> Compulsory Checks (Must Do on the Client-Side) <p>These are the checks that should always be done when handling JWT tokens on the client side to ensure the token is safe to use and doesn't immediately cause issues in the application.</p> <p>1.  Verify JWT Structure (Well-formed Token)</p> <p>A valid JWT token consists of three parts: the header, the payload, and the signature, separated by dots (<code>.</code>). You should always check the token format to ensure it's properly structured.</p> <ul> <li>Why: Ensures the token is a valid JWT format and isn't malformed.</li> <li>What to do: Check that the token is split into three parts and that each part is a valid Base64 URL string.</li> </ul> <pre><code>const isValidJWTStructure = (token) =&gt; {\n    if (!token) return false;\n    const parts = token.split('.');\n    if (parts.length !== 3) return false;\n    return /^[A-Za-z0-9-_]+$/.test(parts[0]) &amp;&amp; /^[A-Za-z0-9-_]+$/.test(parts[1]) &amp;&amp; /^[A-Za-z09-_]+$/.test(parts[2]);\n};\n</code></pre> <p>2.  Decode and Check Expiration (<code>exp</code> Claim)</p> <p>The expiration (<code>exp</code>) claim is a standard claim in JWT that indicates the token's expiry time. If the token has expired, it should not be used, and the user should be logged out or prompted to re-authenticate.</p> <ul> <li>Why: Ensures the token is still valid and hasn\u2019t expired, preventing issues with session management.</li> <li>What to do: Decode the JWT to check the <code>exp</code> claim and compare it to the current time.</li> </ul> <pre><code>import jwtDecode from 'jwt-decode';\n\nconst verifyTokenExpiration = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const currentTime = Date.now() / 1000; // Current time in seconds\n\n        // Check if the token has expired\n        if (decoded.exp &amp;&amp; decoded.exp &lt; currentTime) {\n            return false; // Token expired\n        }\n\n        return true; // Token still valid\n    } catch (error) {\n        return false; // Malformed token\n    }\n};\n</code></pre> Optional Checks (Useful, But Not Required) <p>These checks are not mandatory but can enhance your security posture and improve user experience, depending on your application's specific needs.</p> <p>3.  Verify Audience (<code>aud</code>) Claim</p> <p>The audience (<code>aud</code>) claim indicates for which system the token is intended. You can verify this claim to ensure that the token was issued for your specific application.</p> <ul> <li>Why: To prevent token misuse where the token might be intended for another audience.</li> <li>What to do: Decode the token and check if the <code>aud</code> claim matches your application's expected value.</li> </ul> <pre><code>const verifyAudience = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const expectedAudience = 'yourAppIdentifier'; // Example audience value\n        return decoded.aud === expectedAudience;\n    } catch (error) {\n        return false;\n    }\n};\n</code></pre> <p>4.  Verify Issuer (iss) Claim</p> <p>The issuer (<code>iss</code>) claim identifies who issued the token (usually your authentication service). You can check this claim to ensure the token comes from a trusted source.</p> <ul> <li>Why: To ensure the token is from a trusted issuer.</li> <li>What to do: Decode the token and verify the iss claim.</li> </ul> <pre><code>const verifyIssuer = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const expectedIssuer = 'yourTrustedIssuer'; // Example issuer value\n        return decoded.iss === expectedIssuer;\n    } catch (error) {\n        return false;\n    }\n};\n</code></pre> <p>5.  Verify Custom Claims</p> <p>Some applications might include custom claims in the JWT payload, like <code>role</code>, <code>permissions</code>, or specific user attributes (e.g., <code>is_admin</code>). You can decode the JWT and check if these claims are valid and match what the client needs.</p> <ul> <li>Why: To tailor the app's behavior based on the user's roles or permissions.</li> <li>What to do: Decode the token and check for custom claims like <code>role</code>, <code>permissions</code>, etc.</li> </ul> <pre><code>const verifyRoleClaim = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const requiredRole = 'admin'; // Example role\n        return decoded.role === requiredRole;\n    } catch (error) {\n        return false;\n    }\n};\n</code></pre> What Shouldn't the Client Do? (What is Not Safe or Recommended) <p>1. Never Verify the JWT Signature</p> <p>The client cannot verify the signature of a JWT because it does not have access to the secret key or the public key used to sign the token. Signature verification is the server\u2019s responsibility. If you were to attempt signature verification on the client, you'd expose the secret key (which defeats the purpose of using JWTs).</p> <ul> <li> <p>Why: The signature verification requires the secret or public key, which should never be exposed to the client.</p> </li> <li> <p>What to do: Always rely on the server to handle JWT signature verification.</p> </li> </ul> <p>2. Never Trust the JWT Claims Without Server Validation</p> <p>The client-side validation can help manage the user interface and session flow, but it should never be the sole decision-maker on whether a user is authorized or not. The server should always perform proper authorization checks for sensitive actions.</p> <ul> <li> <p>Why: The client could be compromised (e.g., via XSS), so it cannot be fully trusted for critical security decisions.</p> </li> <li> <p>What to do: Always ensure that authorization and access control checks happen server-side.</p> </li> </ul>"},{"location":"state-management/jwt-verification-clientside/#compulsory-client-side-checks-must-do","title":"Compulsory Client-Side Checks (Must Do):","text":"<ol> <li>Verify JWT structure (format): Ensure the token has 3 parts.</li> <li>Decode and check expiration (exp claim): Ensure the token has not expired.</li> </ol>"},{"location":"state-management/jwt-verification-clientside/#optional-client-side-checks-helpful-but-not-required","title":"Optional Client-Side Checks (Helpful but Not Required):","text":"<ol> <li>Verify aud (Audience) claim: Ensure the token is intended for your app.</li> <li>Verify iss (Issuer) claim: Ensure the token is issued by a trusted issuer.</li> <li>Verify custom claims (e.g., role, permissions): Check custom data (if needed) for UI behavior.</li> </ol>"},{"location":"state-management/jwt-verification-clientside/#what-the-client-should-never-do","title":"What the Client Should Never Do:","text":"<ol> <li>Never verify the JWT signature (this should be done server-side).</li> <li>Never trust client-side JWT claims for sensitive operations (authorization should be enforced server-side).</li> </ol> Conclusion <ul> <li>Compulsory: The client should always verify the token structure and check for expiration. This ensures that the token isn't malformed and hasn't expired, which could cause usability issues or security risks.</li> <li>Optional: Verifying the <code>aud</code> (audience) and <code>iss</code> (issuer) claims, as well as custom claims like role, can be useful for certain applications but are not strictly necessary for basic functionality.</li> <li>Never: The client should never verify the JWT signature or rely on the client-side for authorization decisions. Always trust the server to do proper validation.</li> </ul> <p>By following these guidelines, you can manage JWT tokens safely on the client-side while ensuring that security-sensitive actions (like signature verification and authorization) are handled on the server-side where they belong.</p>"},{"location":"state-management/jwt-verification-clientside/#usage","title":"USAGE","text":"Steps to Update Your Code: <ol> <li>Check the JWT Structure: We'll check if the JWT has 3 parts (header, payload, signature).</li> <li>Check Expiration (<code>exp</code> Claim): We'll decode the token and check if it has expired.</li> <li>If Token is Valid: Store the token in <code>Redux</code> and <code>localStorage</code>.</li> <li>If Token is Invalid/Expired: Show an error notification.</li> </ol> ExampleExplanation <pre><code>import React, { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Layout, Spin, Form, Input, Button, Alert, notification } from \"antd\";\nimport { useDispatch } from \"react-redux\";\nimport queryString from \"query-string\";\nimport jwtDecode from \"jwt-decode\"; // Correct import for jwt-decode\nimport { useLoginMutation } from \"@features/auth/services/authApi\";\nimport { setAuth } from \"@features/auth/services/authSlice\";\nimport { LoginHeader, LoginForm, LoginFooter } from \"./\";\nimport { notify } from \"@shared/utils/notificationUtils\";\nimport logger from \"@shared/utils/logger\";\n\nconst { Content } = Layout;\n\nconst Login = () =&gt; {\nconst [login, { isLoading, isError, data, error }] = useLoginMutation();\nconst [loading, setLoading] = useState(false);\nconst dispatch = useDispatch();\nconst navigate = useNavigate();\n\n// Helper function to check token expiration\nconst isTokenExpired = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const currentTime = Date.now() / 1000; // Current time in seconds\n        return decoded.exp &amp;&amp; decoded.exp &lt; currentTime;\n    } catch (error) {\n        return true; // In case the token is malformed\n    }\n};\n\n// Helper function to verify token structure (split into 3 parts)\nconst isValidJWTStructure = (token) =&gt; {\n    const parts = token.split(\".\");\n    return (\n        parts.length === 3 &amp;&amp; parts.every((part) =&gt; /^[A-Za-z0-9-_]+$/.test(part))\n    );\n};\n\nconst onFinish = async (values) =&gt; {\n    setLoading(true);\n    const { username, password } = values;\n\n    try {\n        // Prepare the form data to send\n        const normalData = { username, password, expiresInMins: 1 };\n        const user = await login(normalData).unwrap(); // Call the login mutation\n\n        const accessToken = user?.accessToken;\n\n        // 1. Validate the JWT Structure\n        if (!isValidJWTStructure(accessToken)) {\n            notify(\n                \"error\",\n                \"topRight\",\n                \"Invalid Token\",\n                \"The token structure is invalid.\",\n                2\n            );\n            setLoading(false);\n            return;\n        }\n\n        // 2. Check if the token is expired\n        if (isTokenExpired(accessToken)) {\n            notify(\n                \"error\",\n                \"topRight\",\n                \"Token Expired\",\n                \"The token has expired. Please login again.\",\n                2\n            );\n            setLoading(false);\n            return;\n        }\n\n        // 3. Decode the token\n        const decodedToken = jwtDecode(accessToken);\n        logger.info({ msg: \"Decoded Token\", decodedToken });\n\n        // 4. Dispatch the token and user info to Redux store\n        dispatch(\n            setAuth({\n                token: accessToken || null,\n                refresh: user?.refreshToken || null,\n                role: decodedToken?.role || null,\n                scope: decodedToken?.scope || null,\n            })\n        );\n\n        // 5. Store the token in localStorage for persistence\n        localStorage.setItem(\"authToken\", accessToken);\n\n        // 6. Redirect the user to the dashboard\n        navigate(\"/dashboard\");\n        setLoading(false);\n    } catch (err) {\n        setLoading(false);\n        logger.error({ msg: \"Login Error\", err });\n        notify(\n            \"error\",\n            \"topRight\",\n            err?.data?.error || \"Invalid Credentials\",\n            err?.data?.error_description ||\n            \"An unexpected error occurred during login.\",\n            2\n        );\n    }\n};\n\n    return (\n        &lt;Layout style={{ minHeight: \"100vh\", width: \"100%\" }}&gt;\n            &lt;LoginHeader /&gt;\n\n            &lt;Content\n                style={{\n                    padding: \"50px 0\",\n                    display: \"flex\",\n                    justifyContent: \"center\",\n                    width: \"100%\",\n                }}\n            &gt;\n                &lt;div\n                style={{\n                    width: \"100%\",\n                    maxWidth: 420,\n                    padding: \"20px\",\n                }}\n                &gt;\n                    &lt;LoginForm onFinish={onFinish} loading={loading} /&gt;\n                &lt;/div&gt;\n            &lt;/Content&gt;\n\n            &lt;LoginFooter /&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <p>1. <code>isValidJWTStructure</code> Function:</p> <p>This function checks that the JWT token is properly formatted. It splits the token into three parts (header, payload, and signature), and verifies that all parts are valid Base64 URL encoded strings.</p> <pre><code>const isValidJWTStructure = (token) =&gt; {\n    const parts = token.split('.');\n    return parts.length === 3 &amp;&amp; parts.every(part =&gt; /^[A-Za-z0-9-_]+$/.test(part));\n};\n</code></pre> <p>2. isTokenExpired Function:</p> <p>This function decodes the JWT and checks if the <code>exp</code> claim is less than the current time (in seconds). If expired, it returns <code>true</code>, otherwise <code>false</code>.</p> <pre><code>const isTokenExpired = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const currentTime = Date.now() / 1000; // Current time in seconds\n        return decoded.exp &amp;&amp; decoded.exp &lt; currentTime;\n    } catch (error) {\n        return true; // In case the token is malformed\n    }\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#utility-functions","title":"Utility Functions","text":"Creating the Utility Functions <ol> <li><code>validateJWTStructure</code>: Checks if the JWT has the correct structure (i.e., 3 parts: header, payload, signature).</li> <li><code>isTokenExpired</code>: Checks if the JWT is expired by comparing the <code>exp</code> claim to the current timestamp.</li> <li><code>decodeToken</code>: Decodes the JWT (if needed for extracting additional information such as <code>role</code>, <code>scope</code>, etc.).</li> </ol> <p>Let's implement these utility functions in a dedicated file, such as <code>jwtUtils.js</code>.</p> Step 1Step 2Explanation <p>Step 1: Create Utility Functions</p> <p>Create a new file, e.g., <code>src/shared/utils/jwtUtils.js</code>.</p> <pre><code>// src/shared/utils/jwtUtils.js\n\n// WRONG\n// import jwtDecode from \"jwt-decode\";\n// CORRECT\nimport { jwtDecode } from \"jwt-decode\";\n\n/**\n * Check if the JWT has the correct structure.\n * A valid JWT should consist of 3 parts: header, payload, signature.\n * @param {string} token - The JWT string.\n * @returns {boolean} - True if the structure is valid, otherwise false.\n */\nexport const validateJWTStructure = (token) =&gt; {\n    const parts = token.split(\".\");\n    return (\n        parts.length === 3 &amp;&amp; parts.every((part) =&gt; /^[A-Za-z0-9-_]+$/.test(part))\n    );\n};\n\n/**\n * Check if the JWT is expired.\n * @param {string} token - The JWT string.\n * @returns {boolean} - True if the token is expired, otherwise false.\n */\nexport const isTokenExpired = (token) =&gt; {\n    try {\n        const decoded = jwtDecode(token);\n        const currentTime = Date.now() / 1000; // Current time in seconds\n        return decoded.exp &amp;&amp; decoded.exp &lt; currentTime;\n    } catch (error) {\n        return true; // Return true if the token is malformed or invalid\n    }\n};\n\n/**\n * Decode the JWT and return its decoded payload.\n * @param {string} token - The JWT string.\n * @returns {object|null} - The decoded payload or null if invalid.\n */\nexport const decodeToken = (token) =&gt; {\n    try {\n        return jwtDecode(token);\n    } catch (error) {\n        return null; // Return null if the token is invalid or malformed\n    }\n};\n</code></pre> <p>Step 2: Using the Utility Functions in the Login Component</p> <p>Now, let's update your Login component to use these utility functions.</p> <pre><code>import React, { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { Layout, Spin, Form, Input, Button, Alert, notification } from \"antd\";\nimport { useDispatch } from \"react-redux\";\nimport queryString from \"query-string\";\nimport { useLoginMutation } from \"@features/auth/services/authApi\";\nimport { setAuth } from \"@features/auth/services/authSlice\";\nimport { LoginHeader, LoginForm, LoginFooter } from \"./\";\nimport { notify } from \"@shared/utils/notificationUtils\";\nimport logger from \"@shared/utils/logger\";\n\n// Import the JWT utilities\nimport {\n    validateJWTStructure,\n    isTokenExpired,\n    decodeToken,\n} from \"@shared/utils/jwtUtils\";\n\nconst { Content } = Layout;\n\nconst Login = () =&gt; {\n    const [login, { isLoading, isError, data, error }] = useLoginMutation();\n    const [loading, setLoading] = useState(false);\n    const dispatch = useDispatch();\n    const navigate = useNavigate();\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        const { username, password } = values;\n\n        try {\n            // Prepare the form data to send\n            const normalData = { username, password, expiresInMins: 1 };\n            const user = await login(normalData).unwrap(); // Call the login mutation\n\n            const accessToken = user?.accessToken;\n\n            // 1. Validate the JWT Structure\n            if (!validateJWTStructure(accessToken)) {\n                notify(\n                    \"error\",\n                    \"topRight\",\n                    \"Invalid Token\",\n                    \"The token structure is invalid.\",\n                    2\n                );\n                setLoading(false);\n                return;\n            }\n\n            // 2. Check if the token is expired\n            if (isTokenExpired(accessToken)) {\n                notify(\n                    \"error\",\n                    \"topRight\",\n                    \"Token Expired\",\n                    \"The token has expired. Please login again.\",\n                    2\n                );\n                setLoading(false);\n                return;\n            }\n\n            // 3. Decode the token\n            const decodedToken = decodeToken(accessToken);\n            logger.info({ msg: \"Decoded Token\", decodedToken });\n\n            // 4. Dispatch the token and user info to Redux store\n            dispatch(\n                setAuth({\n                    token: accessToken || null,\n                    refresh: user?.refreshToken || null,\n                    role: decodedToken?.role || null,\n                    scope: decodedToken?.scope || null,\n                })\n            );\n\n            // 5. Store the token in localStorage for persistence\n            localStorage.setItem(\"authToken\", accessToken);\n\n            // 6. Redirect the user to the dashboard\n            navigate(\"/dashboard\");\n            setLoading(false);\n        } catch (err) {\n            setLoading(false);\n            logger.error({ msg: \"Login Error\", err });\n            notify(\n                \"error\",\n                \"topRight\",\n                err?.data?.error || \"Invalid Credentials\",\n                err?.data?.error_description ||\n                \"An unexpected error occurred during login.\",\n                2\n            );\n        }\n    };\n\nreturn (\n    &lt;Layout style={{ minHeight: \"100vh\", width: \"100%\" }}&gt;\n        &lt;LoginHeader /&gt;\n\n        &lt;Content\n            style={{\n                padding: \"50px 0\",\n                display: \"flex\",\n                justifyContent: \"center\",\n                width: \"100%\",\n            }}\n        &gt;\n            &lt;div\n            style={{\n                width: \"100%\",\n                maxWidth: 420,\n                padding: \"20px\",\n            }}\n            &gt;\n            &lt;LoginForm onFinish={onFinish} loading={loading} /&gt;\n            &lt;/div&gt;\n        &lt;/Content&gt;\n\n        &lt;LoginFooter /&gt;\n    &lt;/Layout&gt;\n);\n};\n\nexport default Login;\n</code></pre> <p>1. Import Utility Functions:</p> <p>We import the utility functions we created (<code>validateJWTStructure</code>, <code>isTokenExpired</code>, and <code>decodeToken</code>) at the top of the <code>Login</code> component.</p> <pre><code>import { validateJWTStructure, isTokenExpired, decodeToken } from \"@shared/utils/jwtUtils\";\n</code></pre> <p>2. Import Utility Functions:</p> <ul> <li> <p>JWT Structure Validation:</p> <p>We use <code>validateJWTStructure(accessToken)</code> to check if the token is in the correct format.</p> </li> <li> <p>Token Expiry Check:</p> <p>We use <code>isTokenExpired(accessToken)</code> to ensure that the token has not expired.</p> </li> <li> <p>Decode the Token:</p> <p>We use <code>decodeToken(accessToken)</code> to decode the token and extract user data (e.g., <code>role</code>, <code>scope</code>).</p> </li> </ul> <p>3. Error Handling:</p> <p>If the JWT fails any of the checks (structure or expiration), we notify the user with an error message and prevent the further flow (i.e., user is not logged in).</p> <p>4. Storing Token:</p> <p>If the token is valid, we store it in Redux using <code>dispatch(setAuth(...))</code> and also persist it in <code>localStorage</code> so that the session is maintained across page reloads.</p>"},{"location":"state-management/jwt-verification-clientside/#refresh-token-verification","title":"Refresh Token Verification","text":"<p>Yes, it is a good practice to verify the refresh token's structure as well, even though the refresh token itself is typically simpler than the access token. Verifying the structure of the refresh token ensures that it conforms to the expected JWT format before you attempt to use it for a refresh operation.</p>"},{"location":"state-management/jwt-verification-clientside/#why-verify-the-refresh-token-structure","title":"Why Verify the Refresh Token Structure?","text":"<ul> <li>Security: Just like the access token, the refresh token can be tampered with or malformed. Ensuring that the refresh token follows the correct structure prevents attempts to use invalid or corrupted tokens.</li> <li>Prevention of Errors: Verifying the structure helps you avoid errors in the flow before you make the request to your backend to refresh the token. If the structure is incorrect, you can notify the user early without attempting to use the token in an API call.</li> </ul>"},{"location":"state-management/jwt-verification-clientside/#when-to-verify-the-refresh-token","title":"When to Verify the Refresh Token?","text":"<ul> <li>Before sending the refresh token to the server: If the token is invalid or malformed, you would want to stop the process immediately and avoid making an unnecessary request to your backend.</li> <li>In your frontend application: In some cases, you may want to validate the structure of the refresh token stored in <code>localStorage</code> or passed in requests to ensure that it is in the correct JWT format.</li> </ul> Example: Verifying the Refresh Token Structure <p>Let's update the <code>jwtUtils.js</code> to include this verification and use it in the refreshToken process.</p> Step 1Step 2 <p>Step 1: Update the validateJWTStructure function</p> <pre><code>// src/shared/utils/jwtUtils.js\n\n/**\n * Check if the JWT has the correct structure.\n * A valid JWT should consist of 3 parts: header, payload, signature.\n * @param {string} token - The JWT string.\n * @returns {boolean} - True if the structure is valid, otherwise false.\n */\nexport const validateJWTStructure = (token) =&gt; {\n    const parts = token.split('.');\n    return parts.length === 3 &amp;&amp; parts.every(part =&gt; /^[A-Za-z0-9-_]+$/.test(part));\n};\n</code></pre> <p>Step 2: Using the <code>validateJWTStructure</code> in the Refresh Token Flow</p> <p>Now let's update the <code>refreshToken</code> function to verify the structure of the refresh token before attempting the refresh process:</p> <pre><code>// src/shared/utils/jwtUtils.js\n\nimport axios from \"axios\";\nimport { notify } from \"@shared/utils/notificationUtils\";\n\n// The function to refresh the token\nexport const refreshToken = async (refreshToken) =&gt; {\n    try {\n        // First, check if the refresh token structure is valid\n        if (!validateJWTStructure(refreshToken)) {\n            notify(\"error\", \"topRight\", \"Invalid Refresh Token\", \"The refresh token structure is invalid.\", 2);\n            throw new Error(\"Invalid refresh token structure\");\n        }\n\n        // Make an API call to your backend to refresh the token\n        const response = await axios.post(\"/api/auth/refresh-token\", {\n            refresh_token: refreshToken,\n        });\n\n        // Check if the response contains a new access token\n        if (response.data?.accessToken) {\n            return response.data.accessToken; // Return the new access token\n        }\n\n        throw new Error(\"Failed to refresh the token.\");\n    } catch (error) {\n        console.error(\"Refresh token error\", error);\n        notify(\"error\", \"topRight\", \"Session Expired\", \"Please log in again.\", 3);\n        throw error; // Rethrow the error to be handled downstream\n    }\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#optimize-code","title":"Optimize Code","text":"<pre><code>import { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { useNavigate } from \"react-router-dom\";\nimport { useLoginMutation } from \"../api\"; // Replace with the actual path\nimport { setAuth } from \"../redux/slices/auth\"; // Replace with actual path\nimport logger from \"@shared/utils/logger\";\nimport { decode as jwtDecode } from \"jwt-decode\"; // If needed\nimport queryString from \"query-string\";\nimport { notify } from \"../utils/notifications\"; // Replace with actual path\nimport {\n  validateJWTStructure,\n  isTokenExpired,\n  decodeToken,\n} from \"../utils/jwtUtils\"; // Utility functions for JWT\n\nconst onFinish = async (values) =&gt; {\n  setLoading(true); // Set loading state to true\n\n  const { username, password } = values;\n\n  try {\n    // Prepare data for login\n    const normalData = { username, password, expiresInMins: 1 };\n\n    // Call login API\n    const user = await login(normalData).unwrap();\n    const accessToken = user?.accessToken;\n\n    // Early return if token structure is invalid or expired\n    if (!accessToken || !validateJWTStructure(accessToken)) {\n      setLoading(false);\n      return;\n    }\n\n    if (isTokenExpired(accessToken)) {\n      setLoading(false);\n      return;\n    }\n\n    // Decode the access token\n    const decodedToken = decodeToken(accessToken);\n\n    // Dispatch auth details to Redux store\n    dispatch(\n      setAuth({\n        token: accessToken,\n        refresh: user?.refreshToken || null,\n        role: decodedToken?.role || null,\n        scope: decodedToken?.scope || null,\n      })\n    );\n\n    // Navigate to dashboard\n    setLoading(false);\n    navigate(\"/dashboard\");\n  } catch (err) {\n    setLoading(false);\n    handleError(err);\n  }\n};\n\n// Separate error handling function\nconst handleError = (err) =&gt; {\n  logger.error({ msg: \"Login Error\", err });\n  notify(\n    \"error\",\n    \"topRight\",\n    err?.data?.error || \"Invalid Credentials\",\n    err?.data?.error_description ||\n      \"An unexpected error occurred during login.\",\n    2\n  );\n};\n</code></pre>"},{"location":"state-management/jwt-verification-clientside/#reference","title":"Reference","text":"<ul> <li>JWT Verify client-side?, stackoverflow.com</li> </ul>"},{"location":"state-management/redux-persist-local-or-session/","title":"Redux Persist Local and Session","text":""},{"location":"state-management/redux-persist-local-or-session/#local-or-session-storage","title":"Local or Session Storage","text":"<p>In the context of Redux Toolkit (RTK), the <code>persistConfig</code> you're referring to is likely used with the redux-persist library, which helps persist Redux state to either <code>localStorage</code> or <code>sessionStorage</code> (among other storage options).</p> ExampleExplanation <pre><code>const persistConfig = {\n    key: \"root\",  // the key used to store the Redux state in the storage\n    storage,      // determines the storage method (e.g., localStorage or sessionStorage)\n    whitelist: [\"auth\"],  // specifies which part of the state to persist (in this case, \"auth\")\n};\n</code></pre> <p>Here\u2019s the breakdown of how storage works:</p> <p>Storage Type: The <code>storage</code> variable can be configured to use different types of web storage, such as <code>localStorage</code> or <code>sessionStorage</code>. These are the two most common choices.</p> <ul> <li>If you use <code>localStorage</code>, the data will persist even after the browser window is closed. It's not cleared until you manually delete it or clear your browser data.</li> <li>If you use <code>sessionStorage</code>, the data is stored for the duration of the page session. It is cleared when the browser or tab is closed.</li> </ul> <p>You can define which storage you want to use by importing either:</p> <pre><code>import storage from \"redux-persist/lib/storage\";  // for localStorage\n</code></pre> <p>or</p> <pre><code>import storageSession from \"redux-persist/lib/storage/session\";  // for sessionStorage\n</code></pre> <p>By default, when you use redux-persist, it will save the persisted state in either <code>localStorage</code> or <code>sessionStorage</code> under the key specified in <code>persistConfig.key</code>. In this case, the state for the <code>auth</code> slice will be saved under the key <code>\"root\"</code> in the selected storage type (<code>localStorage</code> or <code>sessionStorage</code>).</p>"},{"location":"state-management/middleware/","title":"Intro","text":"<ul> <li> <p> redux-thunk </p> </li> <li> <p> redux-saga </p> </li> </ul>"},{"location":"state-management/middleware/#question","title":"Question","text":""},{"location":"state-management/middleware/#middleware-in-react","title":"Middleware in react","text":"<p>why do we need middleware in react. what do we need it. when do we need it. what is the problem. what exactly the problem does it solve. when do we do not need it. example me clearly and simply.</p> <p>Middleware in React is commonly associated with state management libraries like Redux. Middleware provides a way to extend the capabilities of Redux by adding custom functionality to the dispatching of actions. Here's a breakdown of why and when you might need middleware, what problems it solves, and when you might not need it.</p>"},{"location":"state-management/middleware/#why-do-we-need-middleware","title":"Why Do We Need Middleware?","text":"<ol> <li> <p>Enhance Dispatching:</p> <p>Middleware allows you to enhance the behavior of the dispatch function. This can include logging actions, handling asynchronous actions, or modifying actions before they reach the reducer.</p> </li> <li> <p>Asynchronous Actions:</p> <p>By default, Redux actions are synchronous. Middleware like redux-thunk or redux-saga allows you to handle asynchronous operations (e.g., API calls) within your action creators.</p> </li> <li> <p>Side Effects Management:</p> <p>Middleware helps manage side effects in a predictable manner, ensuring that the state changes in response to actions are manageable and traceable.</p> </li> </ol>"},{"location":"state-management/middleware/#what-problems-does-middleware-solve","title":"What Problems Does Middleware Solve?","text":"<ol> <li> <p>Handling Async Logic:</p> <p>Middleware allows you to write asynchronous logic that interacts with the Redux store. Without middleware, you'd have to handle async logic outside of Redux, which can lead to a less organized codebase.</p> </li> <li> <p>Action Logging:</p> <p>Middleware can log every action dispatched, along with the state before and after the action. This is helpful for debugging and understanding the flow of actions in your application.</p> </li> <li> <p>Centralized Error Handling:</p> <p>Middleware can be used to catch and handle errors that occur during the dispatching of actions, ensuring that your application remains stable.</p> </li> </ol>"},{"location":"state-management/middleware/#when-do-you-need-middleware","title":"When Do You Need Middleware?","text":"<ul> <li> <p>Asynchronous Data Fetching:</p> <p>If your application needs to fetch data from an API or handle other asynchronous operations, middleware like redux-thunk or redux-saga is necessary.</p> </li> <li> <p>Complex State Management:</p> <p>When your application has complex state transitions and side effects that need to be managed in a centralized way.</p> </li> <li> <p>Enhanced Debugging:</p> <p>To provide better debugging and logging capabilities, middleware can be very useful.</p> </li> </ul>"},{"location":"state-management/middleware/#when-do-you-not-need-middleware","title":"When Do You Not Need Middleware?","text":"<ul> <li> <p>Simple Applications:</p> <p>For simple applications with straightforward state management and no asynchronous operations, middleware might be overkill.</p> </li> <li> <p>Local State Management:</p> <p>If your state management needs are limited to a few components, using local component state and React's context API might be sufficient.</p> </li> </ul>"},{"location":"state-management/middleware/#example","title":"Example","text":"<p>Let's consider a simple example using redux-thunk to handle an asynchronous API call.</p>"},{"location":"state-management/middleware/#without-middleware-synchronous","title":"Without Middleware (Synchronous)","text":"<pre><code>// actions.js\nexport const increment = () =&gt; ({\n  type: 'INCREMENT'\n});\n\n// reducer.js\nconst counter = (state = 0, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    default:\n      return state;\n  }\n};\n</code></pre>"},{"location":"state-management/middleware/#with-middleware-asynchronous","title":"With Middleware (Asynchronous)","text":"<pre><code>// actions.js\nexport const fetchUserData = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_USER_REQUEST' });\n    try {\n      const response = await fetch('https://api.example.com/user');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_FAILURE', error });\n    }\n  };\n};\n\n// reducer.js\nconst user = (state = { data: null, loading: false, error: null }, action) =&gt; {\n  switch (action.type) {\n    case 'FETCH_USER_REQUEST':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_USER_SUCCESS':\n      return { ...state, loading: false, data: action.payload };\n    case 'FETCH_USER_FAILURE':\n      return { ...state, loading: false, error: action.error };\n    default:\n      return state;\n  }\n};\n</code></pre> <p>In this example, redux-thunk middleware allows us to handle the asynchronous API call within the action creators, making it easier to manage the state transitions related to fetching user data.</p>"},{"location":"state-management/middleware/#summary","title":"Summary","text":"<p>Middleware in React (typically used with Redux) is essential for managing complex state transitions, especially when dealing with asynchronous operations. It extends the capabilities of the Redux store, allowing for enhanced dispatching, centralized error handling, and better debugging. While it's invaluable for complex applications, simpler applications might not need middleware.</p>"},{"location":"state-management/mobx/intro/","title":"Intro","text":"<p>mobx</p>"},{"location":"state-management/recoil/intro/","title":"Intro","text":"<p>recoil</p>"},{"location":"state-management/redux/intro/","title":"Intro","text":"<ul> <li> <p> Standard Redux</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> RTK Redux</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> </ul>"},{"location":"state-management/redux/intro/#standard-redux-vs-redux-toolkit","title":"Standard Redux <code>vs</code> Redux Toolkit","text":"<p>what is the major difference between the standard redux and redux toolkit</p> <p>Redux Toolkit (RTK) is essentially an official, recommended way to write Redux logic. It simplifies many aspects of using Redux, making it easier to set up and use. Here are the major differences between standard Redux and Redux Toolkit:</p>"},{"location":"state-management/redux/intro/#1-boilerplate-code","title":"1. Boilerplate Code","text":"<ul> <li>Standard Redux: Requires a lot of boilerplate code for actions, reducers, and store configuration. You need to manually create action types, action creators, and handle state updates in reducers.</li> <li>Redux Toolkit: Reduces boilerplate significantly. It provides functions like <code>createSlice</code>, which automatically generates action creators and action types based on the reducer functions you define.</li> </ul>"},{"location":"state-management/redux/intro/#2-store-configuration","title":"2. Store Configuration","text":"<ul> <li>Standard Redux: Setting up the store requires a lot of manual configuration, especially if you need middleware or enhancers.</li> <li>Redux Toolkit: <code>configureStore</code> simplifies store setup, automatically applying useful middleware like Redux Thunk and enabling the Redux DevTools extension by default.</li> </ul>"},{"location":"state-management/redux/intro/#3-immutable-state-updates","title":"3. Immutable State Updates","text":"<ul> <li>Standard Redux: You have to manually ensure immutability in state updates, which can lead to bugs if not done correctly.</li> <li>Redux Toolkit: Uses the Immer library internally, allowing you to write \"mutative\" logic in reducers. You can directly modify the state without worrying about immutability, and Immer takes care of the necessary immutability under the hood.</li> </ul>"},{"location":"state-management/redux/intro/#4-built-in-middleware","title":"4. Built-in Middleware","text":"<ul> <li>Standard Redux: You need to set up middleware like Thunk or Saga manually for handling asynchronous logic.</li> <li>Redux Toolkit: Comes with built-in support for Thunk. You can easily add custom middleware as needed.</li> </ul>"},{"location":"state-management/redux/intro/#5-creating-selectors","title":"5. Creating Selectors","text":"<ul> <li>Standard Redux: You often have to write selectors manually and might create a separate file for them.</li> <li>Redux Toolkit: While you can still create selectors, RTK encourages using <code>createSlice</code> and <code>createAsyncThunk</code>, which can simplify the way you handle state and asynchronous operations.</li> </ul>"},{"location":"state-management/redux/intro/#6-asynchronous-logic-handling","title":"6. Asynchronous Logic Handling","text":"<ul> <li>Standard Redux: Managing side effects and asynchronous logic often involves writing additional code and using middleware like Redux Thunk or Redux Saga.</li> <li>Redux Toolkit: Provides <code>createAsyncThunk</code>, a utility that simplifies the process of handling asynchronous actions, automatically dispatching pending, fulfilled, and rejected action types.</li> </ul>"},{"location":"state-management/redux/intro/#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Standard Redux: While it\u2019s powerful, it requires a deeper understanding of Redux concepts and often leads to inconsistencies in how developers implement Redux in projects.</li> <li>Redux Toolkit: Encourages best practices and provides a consistent way to write Redux logic, making it easier for new developers to adopt.</li> </ul>"},{"location":"state-management/redux/intro/#summary","title":"Summary","text":"<p>In summary, Redux Toolkit streamlines the process of using Redux by reducing boilerplate, simplifying store configuration, and encouraging best practices. It makes it easier to manage state in applications, especially for new developers or those working on complex applications. If you're starting a new Redux project, using Redux Toolkit is highly recommended!</p>"},{"location":"state-management/redux/intro/#reference","title":"Reference","text":"<ul> <li>redux-thunk: github</li> <li>Redux docs: Writing Logic with Thunks</li> <li>Stack Overflow: Dispatching Redux Actions with a Timeout</li> <li>Stack Overflow: Why do we need middleware for async flow in Redux?</li> <li>What the heck is a \"thunk\"?</li> <li>Thunks in Redux: The Basics</li> </ul>"},{"location":"state-management/redux/react-redux/","title":"react-redux","text":"<p>React-Redux is a binding library that connects React with Redux.</p> <pre><code>npm install react-redux\n</code></pre> <p></p> What React-Redux DoesWhat Happens if You Don't Use React-Redux <ol> <li>Connects React with Redux: React-Redux provides the necessary bindings to enable React components to interact with the Redux store, allowing them to access the global state and dispatch actions.</li> <li>State Management: It allows components to subscribe to specific parts of the Redux state, enabling them to automatically update when that state changes.</li> <li>Dispatch Actions: React-Redux provides a way to dispatch actions directly from React components, helping to trigger state changes in the Redux store.</li> <li>Performance Optimization: It optimizes performance by ensuring that components only re-render when the specific state slices they use change, rather than re-rendering for every state change.</li> <li>Provides Hooks: It offers hooks like <code>useSelector</code> and <code>useDispatch</code>, which simplify state access and action dispatching in functional components, promoting a cleaner code structure.</li> </ol> <ol> <li>Manual State Management: Without React-Redux, you\u2019d have to manage global state manually, often by passing state and functions through props from parent to child components. This can lead to \"prop drilling,\" where props need to be passed through many layers of components.</li> <li>Complexity and Boilerplate: You might end up writing more boilerplate code to manage state and handle updates, making your application harder to maintain and read.</li> <li>Performance Issues: You may face performance issues, as every component might re-render for any state change if you don\u2019t implement a selective update strategy manually.</li> <li>Difficulty in Scaling: As your application grows, managing state without a centralized solution can become cumbersome and error-prone, making it challenging to keep track of where state is being modified.</li> <li>Limited Tooling: You miss out on the ecosystem of tools and middleware available with Redux (like Redux DevTools) that aid in debugging and state tracking.</li> </ol> <p>Summary</p> <p>Using React-Redux simplifies state management, enhances performance, and keeps your codebase organized, especially in larger applications. Not using it can lead to increased complexity, inefficiencies, and maintenance challenges.</p>"},{"location":"state-management/redux/react-redux/#example-with-react-redux","title":"Example with React-Redux","text":"Example InstallStoreSliceProviderComponent <ol> <li> <p>Install Dependencies: If you haven't already, install React-Redux and Redux Toolkit:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Redux Store:</p> <p>Create a file <code>src/app/store.js</code>:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> </li> </ol> <ol> <li> <p>Create a Slice:</p> <p>Create a file <code>src/features/counterSlice.js</code>:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n    },\n});\n\nexport const { increment, decrement } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Provider:</p> <p>Modify <code>src/index.js</code> to wrap your app with the Redux Provider:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport store from './app/store';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;\n);\n</code></pre> </li> </ol> <ol> <li> <p>Create a Counter Component:</p> <p>Modify <code>src/App.js</code>:</p> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement } from './features/counterSlice';\n\nfunction App() {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"state-management/redux/react-redux/#example-without-react-redux","title":"Example Without React-Redux","text":"Example 1. Set Up State in the Component: <p>Modify <code>src/App.js</code> to manage state without Redux:</p> <pre><code>import React, { useState } from \"react\";\n\nfunction App() {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; {\n        setCount((prevCount) =&gt; prevCount + 1);\n    };\n\n    const decrement = () =&gt; {\n        setCount((prevCount) =&gt; prevCount - 1);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>Summary</p> <ul> <li>With React-Redux: State is managed globally, allowing easy access and updates from any component. You use useSelector to read state and useDispatch to modify it.</li> <li>Without React-Redux: State is managed locally within the component, requiring you to handle state passing and updates through props when dealing with nested components.</li> </ul> <p>Using React-Redux simplifies state management, especially in larger applications, while managing state locally can quickly become cumbersome in more complex scenarios.</p>"},{"location":"state-management/redux/react-redux/#additional","title":"Additional","text":"<p>in the counterSlice.js there no counterReducer. how does it import import counterReducer from '../features/counterSlice'; i dont understand</p> <p>Great question! The <code>counterReducer</code> in <code>counterSlice.js</code> is actually the default export of the slice you create with <code>createSlice</code>. Let's clarify how this works.</p> <p>Breakdown of <code>counterSlice.js</code></p> <p>When you create a slice with <code>createSlice</code>, it automatically generates a reducer function for you, which you can export. Here\u2019s the key part of the code:</p> ExampleExplanation <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;  // This is counterReducer\n</code></pre> <ol> <li> <p>Creating the Slice: The <code>createSlice</code> function creates a slice object that contains:</p> <ul> <li>The slice name.</li> <li>The initial state.</li> <li>Reducers that handle state updates.</li> </ul> </li> <li> <p>Exporting the Reducer: The line <code>export default counterSlice.reducer;</code> exports the reducer function, which is the default export of this module. This exported function can be referred to as <code>counterReducer</code> in the <code>store.js</code> file.</p> </li> </ol> <p>In <code>store.js</code></p> <p>When you import it like this:</p> <pre><code>import counterReducer from \"../features/counterSlice\";\n</code></pre> <p>You are actually importing the default export from <code>counterSlice.js</code>, which is the reducer function generated by <code>createSlice</code>.</p> <p>Summary</p> <ul> <li>The <code>counterReducer</code> is the default export from the <code>counterSlice.js</code> file, which is the reducer created by <code>createSlice</code>.</li> <li>You can name it anything when you import it (like <code>counterReducer</code>), as long as you know it's the default export from that file.</li> </ul>"},{"location":"state-management/redux/redux-architecture/","title":"Redux Architecture","text":""},{"location":"state-management/redux/redux-architecture/#redux-architecture","title":"Redux Architecture","text":""},{"location":"state-management/redux/redux-architecture/#redux-architecture_1","title":"Redux Architecture","text":"<ul> <li> <p>Option 1: Set <code>keepUnusedDataFor: 0</code> to immediately discard data when it's no longer in use.</p> <p>This option works best when:</p> <ul> <li>Data is either very dynamic or user-specific, where you don\u2019t want the same data being reused.</li> <li>You have a lot of short-lived requests, and keeping the data in memory could lead to unnecessary overhead.</li> </ul> </li> <li> <p>Option 2: Use <code>providesTags</code> and <code>invalidatesTags</code> to have more control over when to invalidate cache and when to keep data.</p> <p>This is ideal when:</p> <ul> <li>You have more complex data relationships where invalidation or cache updates need to be handled manually.</li> <li>You need to share cached data between multiple components but also need to control when to refresh or invalidate that cache.</li> </ul> </li> </ul> <p>In general, use <code>keepUnusedDataFor: 0</code> for simple use cases where caching is unnecessary, and use <code>providesTags</code>/<code>invalidatesTags</code> when you need more control over cache updates, invalidation, and relationships between resources.</p> <p>Difference</p> <ul> <li><code>refetchOnMountOrArgChange</code> ensures that data is refetched when a component mounts or when the query arguments change.</li> <li><code>keepUserData: 0</code> is used for cache management to clear stale data after mutations or invalidations to avoid using outdated cache.</li> </ul> <p>These are both advanced features for managing data fetching and caching, but they serve different purposes in your application workflow.</p>"},{"location":"state-management/redux/redux-architecture/#reference","title":"Reference","text":"<ul> <li>Introduction to Redux (Action, Reducers and Store)</li> <li>Fetch Data with Redux-Thunk in React Native App</li> <li>React + Redux architecture</li> <li>React - Redux Saga</li> <li>Implementing Redux Architecture Using React Hooks R Reactjs</li> </ul>"},{"location":"state-management/redux/core/folder-structure/","title":"Folder Structure","text":"<p>Application Structure for React.js</p>"},{"location":"state-management/redux/core/folder-structure/#redux-thunk","title":"Redux Thunk","text":"<p>To use an API in a React application with Redux Thunk, you'll need to follow these steps:</p> <ol> <li> <p>Set up Redux Thunk: Ensure you have Redux and Redux Thunk installed and configured in your React application.</p> </li> <li> <p>Create an API Service: Create a file to manage your API calls, typically using a library like axios or fetch.</p> </li> <li> <p>Create Action Types: Define the action types for your API calls.</p> </li> <li> <p>Create Actions: Use Redux Thunk to create asynchronous actions that dispatch the appropriate actions based on the API response.</p> </li> <li> <p>Create Reducers: Create reducers to handle the actions and update the state accordingly.</p> </li> <li> <p>Connect Redux to React Components: Use <code>connect</code> or hooks (<code>useSelector</code> and <code>useDispatch</code>) to connect your React components to the Redux store.</p> </li> </ol>"},{"location":"state-management/redux/core/folder-structure/#set-up-redux-thunk","title":"Set up Redux Thunk","text":"<pre><code>npm install redux react-redux redux-thunk axios\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#basic","title":"Basic","text":"<pre><code>my-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 DataComponent.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 index.css\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#folder-structure-explanation","title":"Folder Structure Explanation","text":"<ul> <li> <p>actions/: Contains action types and action creators.</p> </li> <li> <p>actionTypes.js: Defines the action types.</p> </li> <li> <p>index.js: Contains action creators using Redux Thunk.</p> </li> <li> <p>api/: Contains API service functions.</p> </li> <li> <p>index.js: Defines the functions to make API calls (e.g., using axios).</p> </li> <li> <p>components/: Contains React components.</p> </li> <li> <p>DataComponent.js: Example component that uses Redux Thunk to fetch and display data.</p> </li> <li> <p>reducers/: Contains Redux reducers.</p> </li> <li> <p>index.js: Combines and exports all the reducers.</p> </li> <li> <p>store/: Contains the Redux store configuration.</p> </li> <li> <p>index.js: Sets up the Redux store with Thunk middleware.</p> </li> <li> <p>App.js: Main app component.</p> </li> <li> <p>index.js: Entry point of the application, where you set up React and Redux.</p> </li> <li> <p>index.css: Global CSS file for styling.</p> </li> </ul>"},{"location":"state-management/redux/core/folder-structure/#example-files","title":"Example Files","text":"Example actions/api/components/reducers/store/App.jsindex.js actionTypes.jsindex.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> index.js <pre><code>import axios from 'axios';\n\nconst API_URL = 'https://api.example.com';\n\nexport const fetchData = () =&gt; {\n    return axios.get(`${API_URL}/data`);\n};\n</code></pre> DataComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../actions';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const dataState = useSelector((state) =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {dataState.loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : dataState.error ? (\n                &lt;p&gt;Error: {dataState.error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {dataState.data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> index.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    data: dataReducer,\n});\n</code></pre> index.js <pre><code>import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport thunk from 'redux-thunk';\nimport dataReducer from '../reducers';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n\n// or\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps you organize your code in a modular and maintainable way. Each part of your application is separated by its responsibility, making it easier to manage and scale.</p>"},{"location":"state-management/redux/core/folder-structure/#intermediate-example","title":"Intermediate Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 DataComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 dataActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 dataReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 selectors/\n\u2502       \u2514\u2500\u2500 dataSelectors.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#folder-structure-explanation_1","title":"Folder Structure Explanation","text":"<ul> <li> <p>api/: Contains files related to API calls.</p> </li> <li> <p>index.js: Manages API requests.</p> </li> <li> <p>components/: Contains reusable React components.</p> </li> <li> <p>DataComponent.js: Example component.</p> </li> <li> <p>redux/: Contains all Redux-related logic.</p> </li> <li> <p>actions/: Contains action types and action creators.</p> <ul> <li>actionTypes.js: Defines action types.</li> <li>dataActions.js: Contains action creators related to data.</li> </ul> </li> <li>reducers/: Contains reducer functions.<ul> <li>dataReducer.js: Reducer for data-related actions.</li> <li>rootReducer.js: Combines all reducers.</li> </ul> </li> <li>store/: Contains the Redux store configuration.<ul> <li>index.js: Sets up the Redux store with middleware.</li> </ul> </li> <li> <p>selectors/: Contains selector functions.</p> <ul> <li>dataSelectors.js: Selectors for accessing data state.</li> </ul> </li> <li> <p>utils/: Contains utility functions and helpers.</p> </li> <li>apiHelpers.js: Helper functions for API calls.</li> </ul>"},{"location":"state-management/redux/core/folder-structure/#example-files_1","title":"Example Files","text":"redux/ /actions//reducers//store//selectors/ /actionTypes.js/dataActions.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> /dataReducer.js/rootReducer.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n</code></pre> <pre><code>import { combineReducers } from 'redux';\nimport dataReducer from './dataReducer';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nexport default rootReducer;\n</code></pre> /index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> /dataSelectors.js <pre><code>export const getDataState = (state) =&gt; state.data;\nexport const getData = (state) =&gt; getDataState(state).data;\nexport const getDataLoading = (state) =&gt; getDataState(state).loading;\nexport const getDataError = (state) =&gt; getDataState(state).error;\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#connecting-components","title":"Connecting Components","text":"Example components/App.jsindex.js DataComponent.js<pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../redux/actions/dataActions';\nimport { getData, getDataLoading, getDataError } from '../redux/selectors/dataSelectors';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const data = useSelector(getData);\n    const loading = useSelector(getDataLoading);\n    const error = useSelector(getDataError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> <pre><code>//App and index.js\nimport React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps maintain a clear separation of concerns, making the codebase easier to manage and scale as the application grows. It also adheres to best practices, making it easier for other developers to understand and contribute to the project.</p>"},{"location":"state-management/redux/core/folder-structure/#advanced-example","title":"Advanced Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 user.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 UserComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 userActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 entitiesReducer.js\n\u2502   \u2502   \u251c\u2500\u2500 usersReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 selectors/\n\u2502   \u2502   \u2514\u2500\u2500 userSelectors.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 normalize.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#action","title":"Action","text":"redux/actions/ actionTypes.jsuserActions.js <pre><code>export const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';\nexport const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';\nexport const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';\nexport const CREATE_USER_REQUEST = 'CREATE_USER_REQUEST';\nexport const CREATE_USER_SUCCESS = 'CREATE_USER_SUCCESS';\nexport const CREATE_USER_FAILURE = 'CREATE_USER_FAILURE';\n// Other action types...\n</code></pre> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n} from './actionTypes';\n\nimport {\n    getUserById,\n    createUser,\n    updateUser,\n    deleteUser,\n    searchUsers,\n} from '../../api/user';\n\nimport { normalizeUserData } from '../utils/normalize';\n\n// Fetch user by ID\nexport const fetchUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_USER_REQUEST });\n\n        try {\n            const response = await getUserById(id);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: FETCH_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: FETCH_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Create user\nexport const addUser = (userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: CREATE_USER_REQUEST });\n\n        try {\n            const response = await createUser(userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: CREATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: CREATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Update user\nexport const modifyUser = (id, userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: UPDATE_USER_REQUEST });\n\n        try {\n            const response = await updateUser(id, userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: UPDATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: UPDATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Delete user\nexport const removeUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: DELETE_USER_REQUEST });\n\n        try {\n            await deleteUser(id);\n            dispatch({ type: DELETE_USER_SUCCESS, payload: id });\n        } catch (error) {\n            dispatch({ type: DELETE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Search users\nexport const findUsers = (queryParams) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: SEARCH_USERS_REQUEST });\n\n        try {\n            const response = await searchUsers(queryParams);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: SEARCH_USERS_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: SEARCH_USERS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#reducers","title":"Reducers","text":"redux/reducers/ entitiesReducer.jsusersReducer.jsrootReducer.js <p>This reducer handles the normalization of entities, which helps in managing relationships between different entities.</p> <pre><code>import { combineReducers } from 'redux';\nimport {\n    FETCH_USER_SUCCESS,\n    CREATE_USER_SUCCESS,\n    UPDATE_USER_SUCCESS,\n    SEARCH_USERS_SUCCESS,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    users: {},\n};\n\nconst users = (state = initialState.users, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_SUCCESS:\n        case CREATE_USER_SUCCESS:\n        case UPDATE_USER_SUCCESS:\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                ...action.payload.entities.users,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    users,\n});\n</code></pre> <p>This reducer handles the specific logic related to users, such as loading states and errors.</p> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n    UPDATE_USER_REQUEST,\n    UPDATE_USER_SUCCESS,\n    UPDATE_USER_FAILURE,\n    DELETE_USER_REQUEST,\n    DELETE_USER_SUCCESS,\n    DELETE_USER_FAILURE,\n    SEARCH_USERS_REQUEST,\n    SEARCH_USERS_SUCCESS,\n    SEARCH_USERS_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    error: null,\n    allIds: [],\n    currentUser: null,\n};\n\nconst usersReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_REQUEST:\n        case CREATE_USER_REQUEST:\n        case UPDATE_USER_REQUEST:\n        case DELETE_USER_REQUEST:\n        case SEARCH_USERS_REQUEST:\n            return {\n                ...state,\n                loading: true,\n                error: null,\n            };\n        case FETCH_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                currentUser: action.payload.result,\n            };\n        case CREATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: [...state.allIds, action.payload.result],\n            };\n        case UPDATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n            };\n        case DELETE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: state.allIds.filter((id) =&gt; id !== action.payload),\n            };\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: action.payload.result,\n            };\n        case FETCH_USER_FAILURE:\n        case CREATE_USER_FAILURE:\n        case UPDATE_USER_FAILURE:\n        case DELETE_USER_FAILURE:\n        case SEARCH_USERS_FAILURE:\n            return {\n                ...state,\n                loading: false,\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default usersReducer;\n</code></pre> <p>Combine the entity and user-specific reducers to create the root reducer.</p> <pre><code>import { combineReducers } from 'redux';\nimport entitiesReducer from './entitiesReducer';\nimport usersReducer from './usersReducer';\n\nconst rootReducer = combineReducers({\n    entities: entitiesReducer,\n    users: usersReducer,\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#normalization","title":"Normalization","text":"<p>Normalize the data received from the API to ensure it is stored in a flat structure, making it easier to manage and update.</p> redux/utils/normalize.js <pre><code>import { normalize, schema } from 'normalizr';\n\n// Define a user schema\nconst user = new schema.Entity('users');\n\n// Define a function to normalize user data\nexport const normalizeUserData = (data) =&gt; {\n    return normalize(data, user);\n};\n</code></pre> <p>Selectors</p> <p>Use selectors to access and derive data from the state, keeping your components clean and focused on rendering.</p> redux/selectors/userSelectors.js <pre><code>import { createSelector } from 'reselect';\n\nexport const getUsersState = (state) =&gt; state.users;\nexport const getEntitiesState = (state) =&gt; state.entities;\n\nexport const getAllUserIds = createSelector(\n    [getUsersState],\n    (usersState) =&gt; usersState.allIds\n);\n\nexport const getUserById = (state, userId) =&gt;\ngetEntitiesState(state).users[userId];\n\nexport const getAllUsers = createSelector(\n    [getAllUserIds, getEntitiesState],\n    (allIds, entities) =&gt; allIds.map((id) =&gt; entities.users[id])\n);\n\nexport const getCurrentUser = createSelector(\n    [getUsersState, getEntitiesState],\n    (usersState, entities) =&gt; entities.users[usersState.currentUser]\n);\n</code></pre>"},{"location":"state-management/redux/core/folder-structure/#connecting-components_1","title":"Connecting Components","text":"components/UserComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUser, addUser, modifyUser, removeUser, findUsers } from '../redux/actions/userActions';\nimport { getAllUsers, getCurrentUser, getUserLoading, getUserError } from '../redux/selectors/userSelectors';\n\nconst UserComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const users = useSelector(getAllUsers);\n    const currentUser = useSelector(getCurrentUser);\n    const loading = useSelector(getUserLoading);\n    const error = useSelector(getUserError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchUser(1)); // Fetch user with ID 1\n    }, [dispatch]);\n\n    const handleAddUser = (userData) =&gt; {\n        dispatch(addUser(userData));\n    };\n\n    const handleUpdateUser = (id, userData) =&gt; {\n        dispatch(modifyUser(id, userData));\n    };\n\n    const handleDeleteUser = (id) =&gt; {\n        dispatch(removeUser(id));\n    };\n\n    const handleSearchUsers = (queryParams) =&gt; {\n        dispatch(findUsers(queryParams));\n    };\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;div&gt;\n                &lt;h1&gt;User Details&lt;/h1&gt;\n                {currentUser &amp;&amp; &lt;div&gt;{currentUser.name}&lt;/div&gt;}\n                &lt;h1&gt;All Users&lt;/h1&gt;\n                &lt;ul&gt;\n                    {users.map((u) =&gt; (\n                    &lt;li key={u.id}&gt;{u.name}&lt;/li&gt;\n                    ))}\n                &lt;/ul&gt;\n                &lt;/div&gt;\n            )}\n            &lt;button onClick={() =&gt; handleAddUser({ name: 'New User' })}&gt;Add User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleUpdateUser(1, { name: 'Updated User' })}&gt;Update User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleDeleteUser(1)}&gt;Delete User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleSearchUsers({ name: 'John' })}&gt;Search Users&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserComponent;\n</code></pre> <p>Store</p> redux/store/index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)));\n\nexport default store;\n</code></pre> <p>This structure allows for scalability, as each part of the state is managed independently and can be easily extended with new entities or additional logic. The use of selectors ensures that the component logic remains clean and focused on rendering, while the normalization of data helps manage relationships and avoid nested state.</p>"},{"location":"state-management/redux/core/redux-pattern/","title":"Redux Pattern","text":""},{"location":"state-management/redux/core/redux-pattern/#redux-pattern","title":"Redux Pattern","text":"<p>The Redux pattern is an architecture for managing and centralizing application state in JavaScript applications, particularly those with complex, shared states across multiple components. It follows a unidirectional data flow and is based on the principles of predictability, immutability, and state management.</p> <p>Here's a breakdown of the key concepts:</p>"},{"location":"state-management/redux/core/redux-pattern/#key-concepts-of-redux-pattern","title":"Key Concepts of Redux Pattern:","text":"<ol> <li> <p>Store:</p> <ul> <li>The store is a single, centralized object that holds the entire state of the application. In Redux, there is usually just one store for the whole app, which contains the global state.</li> </ul> </li> <li> <p>State:</p> <ul> <li>The state is the current state of the application, kept in the store. The state is read-only, meaning it can only be updated through specific actions.</li> </ul> </li> <li> <p>Action:</p> <ul> <li> <p>An action is a plain JavaScript object that describes an event or something that happened in the application. Actions have a <code>type</code> (describing the event) and an optional payload containing additional data.</p> </li> <li> <p>Example: <code>{ type: 'ADD_TODO', payload: { text: 'Learn Redux' } }</code></p> </li> </ul> </li> <li> <p>Reducer:</p> <ul> <li> <p>A reducer is a pure function that takes the current state and an action as arguments, and returns a new state based on the action. Reducers must be pure functions, meaning they should not mutate the state but instead return a new state object.</p> </li> <li> <p>Example:</p> <pre><code>function todoReducer(state = [], action) {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return [...state, { text: action.payload.text, completed: false }];\n        default:\n            return state;\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>Dispatch:</p> <ul> <li>The dispatch function is used to send actions to the store. When an action is dispatched, Redux passes the action to the reducers, which calculate the new state based on the action type.</li> <li>Example: <code>store.dispatch({ type: 'ADD_TODO', payload: { text: 'Learn Redux' } })</code></li> </ul> </li> <li> <p>Selectors:</p> <ul> <li>Selectors are functions used to access or derive specific pieces of state from the store. They help in keeping the state access logic in one place and promoting reusability.</li> </ul> </li> <li> <p>Middleware:</p> <ul> <li>Middleware functions provide a way to extend Redux with custom behavior, often for things like logging, handling asynchronous actions (e.g., redux-thunk or redux-saga), or intercepting actions before they reach the reducer.</li> </ul> </li> </ol>"},{"location":"state-management/redux/core/redux-pattern/#unidirectional-data-flow-in-redux","title":"Unidirectional Data Flow in Redux:","text":"<ul> <li>Component -&gt; Dispatch an Action -&gt; Reducer updates the Store -&gt; Component re-renders based on new state.</li> </ul>"},{"location":"state-management/redux/core/redux-pattern/#benefits-of-the-redux-pattern","title":"Benefits of the Redux Pattern:","text":"<ol> <li>Predictable State Updates: Since all state changes happen through actions and reducers, it's easy to track how and where state is updated.</li> <li>Centralized State: The entire application state is stored in a single place (the store), making it easier to debug and maintain.</li> <li>Time Travel Debugging: Since state updates are predictable and actions are serializable, you can \"time travel\" to different states in the application (with Redux DevTools).</li> <li>Separation of Concerns: The Redux pattern keeps the UI logic separate from the state management logic.</li> <li>Immutability: Redux encourages immutable updates to state, which helps prevent accidental mutations and bugs.</li> </ol>"},{"location":"state-management/redux/core/redux-pattern/#common-tools-with-redux","title":"Common Tools with Redux:","text":"<ol> <li>Redux Toolkit: A modern, opinionated approach to writing Redux logic with simplified syntax and best practices.</li> <li>Redux Thunk: Middleware for handling asynchronous actions.</li> <li>Redux Saga: A middleware for managing side effects with generator functions.</li> </ol>"},{"location":"state-management/redux/core/redux-pattern/#basic-folder-structure","title":"Basic Folder Structure:","text":"<ul> <li><code>actions/</code>: Contains the action creators and types.</li> <li><code>reducers/</code>: Contains the reducers for different parts of the state.</li> <li><code>store.js</code>: Configures the store and applies middleware.</li> <li><code>components/</code>: React components that dispatch actions and subscribe to state.</li> </ul>"},{"location":"state-management/redux/core/redux-pattern/#middleware","title":"Middleware","text":"<p>Let's dive deeper into handling asynchronous logic in Redux, especially focusing on middleware like Redux Thunk and Redux Saga.</p>"},{"location":"state-management/redux/core/redux-pattern/#1-handling-asynchronous-logic-in-redux","title":"1. Handling Asynchronous Logic in Redux:","text":"<p>By default, Redux only supports synchronous data flow\u2014state is updated immediately after an action is dispatched. However, most modern apps require dealing with asynchronous operations (like API requests). To handle this, Redux uses middleware that allows you to write logic between the action being dispatched and the reducer handling it.</p> <p>Key Middleware for Asynchronous Logic:</p> <ul> <li>Redux Thunk (Simple, widely used for small to medium apps)</li> <li>Redux Saga (More advanced, great for large, complex apps)</li> </ul>"},{"location":"state-management/redux/core/redux-pattern/#2-redux-thunk","title":"2. Redux Thunk:","text":"<p>Overview:</p> <p>Redux Thunk is the most popular middleware for handling asynchronous logic. It allows you to write action creators that return a function instead of an action object. This function can perform side effects (e.g., API calls) and dispatch actions based on the result.</p> <p>How Thunk Works:</p> <p>Without Redux Thunk, action creators return a plain JavaScript object. With Thunk, they can return a function that takes <code>dispatch</code> as an argument and allows for asynchronous calls.</p> <p>Basic Example:</p> InstallationExampleExplanation <pre><code>npm install redux-thunk\n</code></pre> <pre><code>// actionTypes.js\nexport const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n\n// actions.js\nexport const fetchData = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_DATA_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/data');\n            const data = await response.json();\n            dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n        } catch (error) {\n            dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// reducer.js\nconst initialState = {\n    loading: false,\n    data: [],\n    error: null,\n};\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return { ...state, loading: true };\n        case FETCH_DATA_SUCCESS:\n            return { ...state, loading: false, data: action.payload };\n        case FETCH_DATA_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>Dispatching Actions: The <code>fetchData</code> action first dispatches <code>FETCH_DATA_REQUEST</code>, performs the API call, and based on success or failure, dispatches either <code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>.</li> <li>Handling Asynchronous Logic: The middleware intercepts this function and ensures the async operation is executed.</li> </ul> <p>Pros of Redux Thunk:</p> <ul> <li>Simplicity: Easy to understand and use.</li> <li>Direct access to dispatch: You can control when to dispatch actions (before, during, or after async operations).</li> </ul> <p>Cons of Redux Thunk:</p> <ul> <li>Messy code: Thunks can get long and cluttered if there's too much logic in them.</li> <li>Testing challenges: Testing action creators can be more difficult as they contain both logic and side effects.</li> </ul>"},{"location":"state-management/redux/core/redux-pattern/#3-redux-saga","title":"3. Redux Saga:","text":"<p>Overview:</p> <p>Redux Saga is a middleware that handles more complex asynchronous logic using generator functions. It's great for dealing with complex async workflows (like canceling, debouncing, or retrying actions), managing multiple side effects, and handling intricate state changes.</p> <p>Redux Saga introduces a more declarative style where you \"describe\" side effects in your sagas and then \"yield\" them.</p> <p>How Redux Saga Works:</p> <ul> <li>It listens for dispatched actions and runs sagas in response.</li> <li>Sagas are generator functions that handle side effects like data fetching, background processing, or state updates.</li> </ul> InstallationExampleExplanation <pre><code>npm install redux-saga\n</code></pre> <pre><code>import { call, put, takeLatest } from 'redux-saga/effects';\nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actionTypes';\nimport { fetchDataFromApi } from './api';\n\n// Worker Saga: Will be fired on FETCH_DATA_REQUEST actions\nfunction* fetchDataSaga(action) {\n    try {\n        const data = yield call(fetchDataFromApi);\n        yield put({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        yield put({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n}\n\n// Watcher Saga: Spawn a new fetchDataSaga on each FETCH_DATA_REQUEST\nfunction* watchFetchDataSaga() {\n    yield takeLatest(FETCH_DATA_REQUEST, fetchDataSaga);\n}\n\nexport default watchFetchDataSaga;\n</code></pre> <p>Explanation:</p> <ul> <li>Saga Workflow: The <code>watchFetchDataSaga</code> listens for <code>FETCH_DATA_REQUEST</code> actions and runs the <code>fetchDataSaga</code>. The <code>fetchDataSaga</code> performs an API call using <code>call()</code> and dispatches actions using <code>put()</code>.</li> <li>Effects:<ul> <li><code>call()</code>: Calls the <code>fetchDataFromApi</code> function.</li> <li><code>put()</code>: Dispatches an action (<code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>).</li> <li><code>takeLatest()</code>: Ensures only the latest request is handled, canceling previous ones.</li> </ul> </li> </ul> <p>Pros of Redux Saga:</p> <ul> <li>Structured code: Complex async logic is easier to structure and manage.</li> <li>Powerful features: Offers fine-grained control over side effects like cancelation, debouncing, retrying, etc.</li> <li>Testable: Generator functions are easier to test in isolation.</li> </ul> <p>Cons of Redux Saga:</p> <ul> <li>Steeper learning curve: Using generators and understanding Redux Saga\u2019s API can be challenging.</li> <li>More boilerplate: Sagas can add more code overhead.</li> </ul>"},{"location":"state-management/redux/core/redux-pattern/#4-which-one-should-you-use","title":"4. Which One Should You Use?","text":"<p>Redux Thunk: -   Ideal for simple to moderately complex applications where you only need basic async functionality (like fetching data). -   It's easier to learn and can handle most common use cases.</p> <p>Redux Saga: -   Best for complex applications where you need to handle multiple side effects, complex async flows (like canceling, retrying, or parallel execution), or want more control over async logic. -   It\u2019s suited for larger projects with many async actions and requirements like debouncing or task cancelation.</p>"},{"location":"state-management/redux/core/redux-pattern/#5-combining-redux-with-other-middleware","title":"5. Combining Redux with Other Middleware:","text":"<p>You can use multiple middleware together (e.g., both Redux Thunk and logging middleware) to enhance Redux functionality.</p> <p>Example of combining middleware:</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga';\nimport logger from 'redux-logger';\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk, sagaMiddleware, logger)\n);\n\n// Run the saga middleware\nsagaMiddleware.run(rootSaga);\n</code></pre>"},{"location":"state-management/redux/core/redux-pattern/#conclusion","title":"Conclusion:","text":"<ul> <li>Redux Thunk is straightforward and good for smaller apps with simple async needs.</li> <li>Redux Saga is powerful and suited for larger, more complex applications requiring more control over side effects.</li> </ul> <p>If you're looking for simplicity, start with Thunk. If you're dealing with complex workflows and need advanced side effect management, Saga is the way to go. Would you like to explore any specific real-world scenarios using Thunk or Saga?</p>"},{"location":"state-management/redux/core/redux-pattern/#example","title":"Example","text":"<p>Let\u2019s explore some real-world scenarios where we can apply Redux Thunk and Redux Saga to manage asynchronous operations effectively.</p>"},{"location":"state-management/redux/core/redux-pattern/#scenario-1-api-fetching-with-redux-thunk","title":"Scenario 1: API Fetching with Redux Thunk","text":"<p>Scenario:</p> <p>Imagine an e-commerce app where you need to fetch a list of products from an API when a user visits the product page.</p> <p>Step-by-Step Solution Using Redux Thunk:</p> <ol> <li> <p>Set Up the Action Types: Define action types for requesting, succeeding, and failing the product fetch operation.</p> <pre><code>// actionTypes.js\nexport const FETCH_PRODUCTS_REQUEST = 'FETCH_PRODUCTS_REQUEST';\nexport const FETCH_PRODUCTS_SUCCESS = 'FETCH_PRODUCTS_SUCCESS';\nexport const FETCH_PRODUCTS_FAILURE = 'FETCH_PRODUCTS_FAILURE';\n</code></pre> </li> <li> <p>Create the Action Creator with Thunk: Use <code>redux-thunk</code> to create an action creator that fetches the products asynchronously.</p> <pre><code>// actions.js\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nexport const fetchProducts = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_PRODUCTS_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/products');\n            const products = await response.json();\n            dispatch({ type: FETCH_PRODUCTS_SUCCESS, payload: products });\n        } catch (error) {\n            dispatch({ type: FETCH_PRODUCTS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre> </li> <li> <p>Create the Reducer: The reducer will handle the state changes for product fetching. It reacts to the actions dispatched by the thunk.</p> <pre><code>// productReducer.js\nconst initialState = {\n    loading: false,\n    products: [],\n    error: null,\n};\n\nexport const productReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_PRODUCTS_REQUEST:\n            return { ...state, loading: true, error: null };\n        case FETCH_PRODUCTS_SUCCESS:\n            return { ...state, loading: false, products: action.payload };\n        case FETCH_PRODUCTS_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Dispatch the Action in a React Component: Use <code>useEffect</code> to dispatch the <code>fetchProducts</code> action when the product page component mounts.</p> <pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductPage = () =&gt; {\n    const dispatch = useDispatch();\n    const { products, loading, error } = useSelector(state =&gt; state.productReducer);\n\n    useEffect(() =&gt; {\n        dispatch(fetchProducts());\n    }, [dispatch]);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            {products.map(product =&gt; (\n                &lt;div key={product.id}&gt;\n                    &lt;h2&gt;{product.name}&lt;/h2&gt;\n                    &lt;p&gt;{product.description}&lt;/p&gt;\n                &lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\nexport default ProductPage;\n</code></pre> </li> </ol> <p>Result:</p> <p>When the <code>ProductPage</code> component is mounted, the <code>fetchProducts</code> thunk is dispatched. It sends a request to the API, and depending on the outcome, either the product list or an error message is rendered.</p>"},{"location":"state-management/redux/core/redux-pattern/#scenario-2-handling-multiple-concurrent-api-calls-with-redux-saga","title":"Scenario 2: Handling Multiple Concurrent API Calls with Redux Saga","text":"<p>Scenario:</p> <p>Let\u2019s say you\u2019re developing a social media app. When a user logs in, you need to fetch their profile, notifications, and posts concurrently. If any of these requests fail, you want to retry the failed request up to 3 times.</p> <p>Step-by-Step Solution Using Redux Saga:</p> <ol> <li> <p>Set Up Action Types: Define action types for fetching the profile, notifications, and posts.</p> <pre><code>// actionTypes.js\nexport const FETCH_PROFILE_REQUEST = 'FETCH_PROFILE_REQUEST';\nexport const FETCH_PROFILE_SUCCESS = 'FETCH_PROFILE_SUCCESS';\nexport const FETCH_PROFILE_FAILURE = 'FETCH_PROFILE_FAILURE';\nexport const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\nexport const FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';\nexport const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';\nexport const FETCH_POSTS_FAILURE = 'FETCH_POSTS_FAILURE';\n</code></pre> </li> <li> <p>Create the API Call Functions: These functions will perform the actual API calls to fetch the data.</p> <pre><code>// api.js\nexport const fetchProfileApi = () =&gt; fetch('https://api.example.com/profile').then(res =&gt; res.json());\nexport const fetchNotificationsApi = () =&gt; fetch('https://api.example.com/notifications').then(res =&gt; res.json());\nexport const fetchPostsApi = () =&gt; fetch('https://api.example.com/posts').then(res =&gt; res.json());\n</code></pre> </li> <li> <p>Create the Saga with Retry Logic: The <code>yield</code> keyword allows us to handle async actions declaratively. We can use <code>all</code> to run multiple API requests concurrently and <code>retry</code> to handle failed requests.</p> <pre><code>import { call, put, all, retry } from 'redux-saga/effects';\nimport { FETCH_PROFILE_REQUEST, FETCH_PROFILE_SUCCESS, FETCH_PROFILE_FAILURE, FETCH_NOTIFICATIONS_REQUEST, FETCH_NOTIFICATIONS_SUCCESS, FETCH_NOTIFICATIONS_FAILURE, FETCH_POSTS_REQUEST, FETCH_POSTS_SUCCESS, FETCH_POSTS_FAILURE } from './actionTypes';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\n\nfunction* fetchUserProfile() {\n    try {\n        const profile = yield retry(3, 1000, fetchProfileApi);  // Retry up to 3 times with 1-second intervals\n        yield put({ type: FETCH_PROFILE_SUCCESS, payload: profile });\n    } catch (error) {\n        yield put({ type: FETCH_PROFILE_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserNotifications() {\n    try {\n        const notifications = yield retry(3, 1000, fetchNotificationsApi);\n        yield put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: notifications });\n    } catch (error) {\n        yield put({ type: FETCH_NOTIFICATIONS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserPosts() {\n    try {\n        const posts = yield retry(3, 1000, fetchPostsApi);\n        yield put({ type: FETCH_POSTS_SUCCESS, payload: posts });\n    } catch (error) {\n        yield put({ type: FETCH_POSTS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserData() {\n    yield all([\n        call(fetchUserProfile),\n        call(fetchUserNotifications),\n        call(fetchUserPosts),\n    ]);\n}\n\nexport default function* watchFetchUserData() {\n    yield takeLatest(FETCH_PROFILE_REQUEST, fetchUserData);\n}\n</code></pre> </li> <li> <p>Dispatch the Action: When the user logs in, dispatch the action to start fetching all required data.</p> <pre><code>// In a component or action creator\ndispatch({ type: FETCH_PROFILE_REQUEST });\n</code></pre> </li> </ol> <p>Result:</p> <p>The <code>fetchUserData</code> saga runs <code>fetchUserProfile</code>, <code>fetchUserNotifications</code>, and <code>fetchUserPosts</code> concurrently using <code>all()</code>. If any of these requests fail, they will be retried up to 3 times using <code>retry()</code>. Once all the requests have succeeded or failed, the appropriate success or failure actions are dispatched.</p>"},{"location":"state-management/redux/core/redux-pattern/#conclusion_1","title":"Conclusion:","text":"<ul> <li>Thunk Example: Perfect for handling simple API requests, ideal when the logic isn't too complex.</li> <li>Saga Example: Shows the power of Redux Saga in managing multiple asynchronous operations and more advanced control like retrying failed requests or handling concurrent actions.</li> </ul>"},{"location":"state-management/redux/core/redux-testing/","title":"Redux Testing","text":"<p>Great! Let\u2019s dive deeper into testing Redux Thunk and Redux Saga to ensure that your asynchronous operations behave as expected in real-world applications.</p>"},{"location":"state-management/redux/core/redux-testing/#testing-redux-thunk","title":"Testing Redux Thunk","text":"<p>When testing actions that use Redux Thunk, we can use a mock store to dispatch actions and check that the correct actions are being dispatched based on the asynchronous logic.</p> <ol> <li> <p>Testing Redux Thunk with Jest</p> <p>Scenario: You want to test the <code>fetchProducts</code> thunk action creator, which dispatches <code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or <code>FETCH_PRODUCTS_FAILURE</code> depending on the result of an API call.</p> <p>Test Setup:</p> <ul> <li>Mocking the API: We'll mock the API call to return some fake data.</li> <li>Mock Store: Use <code>redux-mock-store</code> to simulate Redux store behavior.</li> </ul> </li> </ol> <p>Code:</p> <ol> <li> <p>Install dependencies for testing:</p> <pre><code>npm install redux-mock-store redux-thunk jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Thunk:</p> ExampleHow the Test Works <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // To mock fetch API\nimport { fetchProducts } from './actions'; // Thunk action\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts action', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks();\n    });\n\n    it('dispatches FETCH_PRODUCTS_SUCCESS after a successful API request', () =&gt; {\n        const mockProducts = [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }];\n        fetchMock.mockResponseOnce(JSON.stringify(mockProducts));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_SUCCESS, payload: mockProducts },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n\n    it('dispatches FETCH_PRODUCTS_FAILURE when the API request fails', () =&gt; {\n        const errorMessage = 'Failed to fetch';\n        fetchMock.mockRejectOnce(new Error(errorMessage));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_FAILURE, payload: errorMessage },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n});\n</code></pre> <ul> <li>Mock Store: <code>redux-mock-store</code> creates a mock version of the Redux store.</li> <li>Action Sequence: The test ensures that the correct sequence of actions (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or    <code>FETCH_PRODUCTS_FAILURE</code>) is dispatched based on the result of the API call.</li> <li>Mock API Response: We use <code>fetchMock</code> to simulate different API responses (success and failure).</li> </ul> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#testing-redux-saga","title":"Testing Redux Saga","text":"<p>Testing Redux Saga involves verifying the flow of effects (<code>call</code>, <code>put</code>, <code>take</code>, etc.). We can use a library like <code>redux-saga-test-plan</code> to test sagas in isolation.</p> <ol> <li> <p>Testing Redux Saga with Jest and redux-saga-test-plan</p> <p>Scenario: You want to test the <code>fetchUserData</code> saga, which fetches the user profile, notifications, and posts concurrently. You also want to ensure it retries the API calls up to 3 times if they fail.</p> </li> </ol> <p>Code:</p> <ol> <li> <p>Install the necessary testing libraries:</p> <pre><code>npm install redux-saga-test-plan jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Saga:</p> ExampleHow the Test Works <pre><code>import { testSaga } from 'redux-saga-test-plan';\nimport { fetchUserData } from './sagas';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\nimport { FETCH_PROFILE_SUCCESS, FETCH_NOTIFICATIONS_SUCCESS, FETCH_POSTS_SUCCESS } from './actionTypes';\n\ndescribe('fetchUserData saga', () =&gt; {\n    it('fetches profile, notifications, and posts concurrently', () =&gt; {\n        const mockProfile = { name: 'John Doe' };\n        const mockNotifications = [{ id: 1, message: 'New notification' }];\n        const mockPosts = [{ id: 1, content: 'New post' }];\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                call(fetchProfileApi),\n                call(fetchNotificationsApi),\n                call(fetchPostsApi),\n            ])\n            .next([mockProfile, mockNotifications, mockPosts])\n            .put({ type: FETCH_PROFILE_SUCCESS, payload: mockProfile })\n            .next()\n            .put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: mockNotifications })\n            .next()\n            .put({ type: FETCH_POSTS_SUCCESS, payload: mockPosts })\n            .next()\n            .isDone();\n    });\n\n    it('retries API calls up to 3 times if they fail', () =&gt; {\n        const error = new Error('API error');\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                retry(3, 1000, fetchProfileApi),\n                retry(3, 1000, fetchNotificationsApi),\n                retry(3, 1000, fetchPostsApi),\n            ])\n            .throw(error)\n            .put({ type: FETCH_PROFILE_FAILURE, payload: error.message })\n            .next()\n            .isDone();\n    });\n});\n</code></pre> <ul> <li>Test Flow: <code>redux-saga-test-plan</code> allows you to simulate the exact flow of your saga and assert each step (<code>call</code>, <code>put</code>, etc.).</li> <li>Concurrent API Calls: We use <code>all()</code> to test that profile, notifications, and posts are fetched concurrently.</li> <li>Retry Mechanism: The second test ensures that the API call retries up to 3 times using the <code>retry()</code> effect.</li> </ul> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#testing-best-practices-for-redux-thunk-and-redux-saga","title":"Testing Best Practices for Redux Thunk and Redux Saga","text":"<ol> <li> <p>Mock External Dependencies:</p> <ul> <li>For Thunk, mock API calls using <code>jest-fetch-mock</code> or similar libraries.</li> <li>For Saga, use <code>redux-saga-test-plan</code> to simulate effects and test the sequence of actions.</li> </ul> </li> <li> <p>Test Action Sequences:</p> <ul> <li>Ensure the correct actions are dispatched in the expected order.</li> <li>For complex flows, check that the appropriate success or failure actions are dispatched based on the outcome.</li> </ul> </li> <li> <p>Isolate Logic:</p> <ul> <li>Test action creators, reducers, and sagas separately to ensure that each piece of logic works independently before testing them together.</li> </ul> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#summary","title":"Summary:","text":"<ul> <li>Thunk Testing: Use <code>redux-mock-store</code> to mock the Redux store and simulate dispatching asynchronous actions.</li> <li>Saga Testing: Use <code>redux-saga-test-plan</code> to test the flow of saga effects like <code>call</code>, <code>put</code>, and <code>all()</code>, and simulate advanced logic such as retries.</li> </ul>"},{"location":"state-management/redux/core/redux-testing/#testing-reducers","title":"Testing Reducers","text":"<p>Reducers are pure functions in Redux, meaning they should always produce the same output given the same input. This makes them easy to test. The goal of testing reducers is to ensure that they correctly update the state based on the dispatched actions.</p>"},{"location":"state-management/redux/core/redux-testing/#1-basic-structure-of-a-reducer","title":"1.  Basic Structure of a Reducer","text":"<pre><code>Let\u2019s say you have a reducer that handles fetching products:\n\n```jsx\nconst initialState = {\n    products: [],\n    loading: false,\n    error: null,\n};\n\nfunction productReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'FETCH_PRODUCTS_REQUEST':\n            return { ...state, loading: true };\n        case 'FETCH_PRODUCTS_SUCCESS':\n            return { ...state, loading: false, products: action.payload };\n        case 'FETCH_PRODUCTS_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n}\n```\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#writing-unit-tests-for-reducers","title":"Writing Unit Tests for Reducers","text":"<p>Testing reducers is straightforward because they are pure functions. You only need to call the reducer with an action and an initial state, and then check if the output matches the expected state.</p>"},{"location":"state-management/redux/core/redux-testing/#2-writing-tests-for-the-product-reducer","title":"2.  Writing Tests for the Product Reducer","text":"<p>Here\u2019s an example of how you would test this reducer using Jest:</p> <pre><code>import productReducer from './productReducer';\n\ndescribe('Product Reducer', () =&gt; {\n  const initialState = {\n    products: [],\n    loading: false,\n    error: null,\n  };\n\n  it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n  });\n\n  it('should handle FETCH_PRODUCTS_REQUEST', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_REQUEST' };\n    const expectedState = { ...initialState, loading: true };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_SUCCESS', () =&gt; {\n    const action = {\n      type: 'FETCH_PRODUCTS_SUCCESS',\n      payload: [{ id: 1, name: 'Product 1' }],\n    };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      products: action.payload,\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_FAILURE', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Error' };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      error: 'Error',\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n});\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#best-practices-for-testing-reducers","title":"Best Practices for Testing Reducers","text":"<ol> <li> <p>Test for Default State:</p> <ul> <li> <p>Always test that the reducer returns the initial state when the state is <code>undefined</code> and the action is irrelevant (e.g., <code>{}</code>).</p> <pre><code>it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n});\n</code></pre> </li> </ul> </li> <li> <p>Test Each Action Type:</p> <ul> <li>Write a test case for each action type the reducer handles (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, etc.). Ensure the state is updated as expected.</li> </ul> </li> <li> <p>Use Mocks for Action Payloads:</p> <ul> <li> <p>If an action payload is complex (e.g., an array of products), use mock data to ensure the test is focused on the reducer logic.</p> <pre><code>const action = {\n    type: 'FETCH_PRODUCTS_SUCCESS',\n    payload: [{ id: 1, name: 'Mock Product' }],\n};\n</code></pre> </li> </ul> </li> <li> <p>Test Edge Cases:</p> <ul> <li>Consider testing edge cases like actions that are dispatched with unexpected payloads or malformed data.</li> </ul> </li> <li> <p>Avoid Testing Built-in Functions:</p> <ul> <li>Don\u2019t test things like <code>Object.assign</code> or spread operators (<code>...</code>), as these are built-in JavaScript features. Focus on testing that your reducer logic is correct.</li> </ul> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#testing-redux-with-thunk-saga-and-reducers-summary","title":"Testing Redux with Thunk, Saga, and Reducers: Summary","text":"<p>Now that you\u2019ve seen how to test thunks, sagas, and reducers, here\u2019s a summary of the flow:</p> <ol> <li> <p>Thunks:</p> <ul> <li>Use <code>redux-mock-store</code> to mock the Redux store.</li> <li>Mock external dependencies like APIs and verify that the correct actions are dispatched based on asynchronous logic.</li> </ul> </li> <li> <p>Sagas:</p> <ul> <li>Use <code>redux-saga-test-plan</code> to simulate effects and check the flow of your saga (e.g., concurrent API calls, retry logic).</li> <li>Focus on verifying the flow of effects (<code>call</code>, <code>put</code>, etc.).</li> </ul> </li> <li> <p>Reducers:</p> <ul> <li>Test reducers by dispatching different actions and ensuring the state is updated correctly.</li> <li>Write one test per action type, ensuring each action\u2019s impact on the state is validated.</li> </ul> </li> </ol> <p>Awesome! Let\u2019s move into testing React components that connect to Redux and handle more advanced testing scenarios, such as dealing with components that rely on Redux state and actions.</p>"},{"location":"state-management/redux/core/redux-testing/#testing-react-components-connected-to-redux","title":"Testing React Components Connected to Redux","text":"<p>When testing React components that are connected to Redux, we need to ensure:</p> <ol> <li>The component renders correctly with the expected state from Redux.</li> <li>The component dispatches the correct actions when interacting with UI elements (e.g., clicking buttons).</li> </ol> <p>We'll use <code>react-testing-library</code> (or <code>@testing-library/react</code>) and <code>redux-mock-store</code> to test connected components without relying on a real Redux store.</p>"},{"location":"state-management/redux/core/redux-testing/#1-basic-structure-of-a-connected-component","title":"1. Basic Structure of a Connected Component","text":"<p>Let\u2019s assume we have a React component, <code>ProductList</code>, which is connected to Redux. It fetches products from the store and displays them, and it also has a button to reload the products.</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts(); // Fetch products when component mounts\n  }, [fetchProducts]);\n\n  if (loading) {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#2-writing-tests-for-the-connected-component","title":"2. Writing Tests for the Connected Component","text":"<p>We\u2019ll test two scenarios:</p> <ol> <li>Rendering the component with initial state.</li> <li>Simulating a button click to dispatch the <code>fetchProducts</code> action.</li> </ol> <p>Setting Up Tests for Connected Components</p> <ol> <li> <p>Install necessary libraries:</p> <pre><code>npm install @testing-library/react redux-mock-store jest --save-dev\n</code></pre> </li> <li> <p>Writing Tests with Mock Redux Store:</p> <p>We can use a mock Redux store to simulate different states in our tests. Here\u2019s how to set it up.</p> ExampleExplanation <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport configureMockStore from 'redux-mock-store';\nimport { Provider } from 'react-redux';\nimport ProductList from './ProductList'; // The connected component\nimport thunk from 'redux-thunk';\n\n// Mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n    let store;\n\n    beforeEach(() =&gt; {\n        // Initial mock state\n        store = mockStore({\n            products: {\n                items: [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }],\n                loading: false,\n            },\n        });\n    });\n\n    it('should render product list with products from Redux state', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Product List')).toBeInTheDocument();\n        expect(screen.getByText('Product 1')).toBeInTheDocument();\n        expect(screen.getByText('Product 2')).toBeInTheDocument();\n    });\n\n    it('should dispatch fetchProducts action when \"Reload Products\" button is clicked', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        const reloadButton = screen.getByText('Reload Products');\n        fireEvent.click(reloadButton);\n\n        const actions = store.getActions();\n        expect(actions).toEqual([{ type: 'FETCH_PRODUCTS_REQUEST' }]); // Adjust depending on the action dispatched\n    });\n\n    it('should show loading message when fetching products', () =&gt; {\n        store = mockStore({\n            products: { items: [], loading: true },\n        });\n\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Loading...')).toBeInTheDocument();\n    });\n});\n</code></pre> <ol> <li>Mock Store: We create a mock Redux store with an initial state that mimics the real state in your app.</li> <li>Provider: Wrap the component in the Redux <code>Provider</code> and pass the mock store.</li> <li> <p>Assertions:</p> <ul> <li>Check if the component correctly renders data from the mock Redux state.</li> <li>Simulate a button click and verify if the correct action is dispatched.</li> </ul> </li> </ol> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#best-practices-for-testing-connected-components","title":"Best Practices for Testing Connected Components:","text":"<ul> <li>Mock the Store: Use a mock store to simulate various Redux states (loading, error, etc.) to thoroughly test how your component handles different scenarios.</li> <li>Test Action Dispatching: Simulate user interactions (like clicking a button) and verify if the correct Redux actions are dispatched.</li> <li>Isolate UI Logic: Focus on testing the UI\u2019s interaction with Redux, not the internal logic of actions or reducers. These can be tested separately.</li> </ul>"},{"location":"state-management/redux/core/redux-testing/#advanced-testing-scenarios-for-redux-connected-components","title":"Advanced Testing Scenarios for Redux-Connected Components","text":"<ol> <li> <p>Testing with Nested States:</p> <ul> <li> <p>If your Redux state has nested objects (e.g., <code>state.products.items</code>), ensure that you correctly mock and test the nested structure.</p> <pre><code>// Example for a deeply nested state:\n\nstore = mockStore({\n    products: {\n        data: {\n            items: [{ id: 1, name: 'Product 1' }],\n        },\n        loading: false,\n    },\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing with Selectors:</p> <ul> <li> <p>If you\u2019re using selectors to derive data from the Redux store, you should mock the selector\u2019s output and test how the component renders based on it.</p> <pre><code>import { getVisibleProducts } from './selectors';\njest.mock('./selectors');\n\nit('should render visible products', () =&gt; {\n    getVisibleProducts.mockReturnValue([{ id: 1, name: 'Visible Product' }]);\n\n    render(\n        &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n        &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Visible Product')).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing Middleware:</p> <ul> <li> <p>If you\u2019re using custom middleware or middleware like redux-thunk, ensure you test the interaction with middleware by checking the actions that are dispatched as a result of user interactions.</p> <pre><code>const middlewares = [thunk]; // Include middleware in mock store setup\n</code></pre> </li> </ul> </li> <li> <p>Testing Complex Interactions:</p> <ul> <li>For more complex interactions, simulate multiple steps (e.g., multiple button clicks or form submissions) and verify that the state and actions evolve correctly.</li> </ul> <p>Example: Testing a multi-step form that dispatches multiple actions:</p> <pre><code>fireEvent.click(screen.getByText('Next Step'));\nexpect(store.getActions()).toEqual([\n    { type: 'STEP_1_COMPLETE' },\n    { type: 'LOAD_NEXT_STEP' },\n]);\n</code></pre> </li> </ol> <p>Great! Let\u2019s dive into middleware testing and mocking API calls within Redux-connected components to handle asynchronous behavior.</p>"},{"location":"state-management/redux/core/redux-testing/#testing-middleware-in-redux","title":"Testing Middleware in Redux","text":"<p>Middleware in Redux is used to extend the functionality of the Redux store, allowing you to intercept actions before they reach the reducers. Common middleware like redux-thunk and redux-saga enable handling side effects such as API calls.</p>"},{"location":"state-management/redux/core/redux-testing/#1-testing-thunk-middleware","title":"1. Testing Thunk Middleware","text":"<p>If you're using redux-thunk for async operations (like API calls), you\u2019ll often want to ensure that:</p> <ul> <li>Correct actions are dispatched before and after the async logic (e.g., <code>LOADING</code>, <code>SUCCESS</code>, <code>ERROR</code>).</li> <li>The API calls (or any async logic) are correctly mocked.</li> </ul> <p>Example: Async Action with Thunk</p> <p>Let\u2019s assume you have a simple thunk that fetches products from an API:</p> <pre><code>// actions.js\nexport const fetchProducts = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_PRODUCTS_REQUEST' });\n    try {\n      const response = await fetch('/api/products');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n    }\n  };\n};\n</code></pre> <p>Writing Tests for Thunks</p> <p>To test this, we mock the API call and check that the right actions are dispatched.</p> <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // or axios-mock-adapter if you use axios\nimport { fetchProducts } from './actions';\n\n// Setup mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts thunk', () =&gt; {\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset mock fetch calls\n  });\n\n  it('should dispatch FETCH_PRODUCTS_SUCCESS after successful API call', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      {\n        type: 'FETCH_PRODUCTS_SUCCESS',\n        payload: [{ id: 1, name: 'Product 1' }],\n      },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n\n  it('should dispatch FETCH_PRODUCTS_FAILURE after a failed API call', async () =&gt; {\n    // Mock a failed API response\n    fetchMock.mockReject(new Error('Failed to fetch'));\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Failed to fetch' },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n});\n</code></pre> <p>??+ note \"Key Points\"</p> <pre><code>1.  **Mocking API calls**:\n\n    -   Use `fetch-mock` or `axios-mock-adapter` to simulate successful and failed API responses.\n\n2.  **Asserting Dispatched Actions**:\n\n    -   Verify that the correct actions (e.g., `REQUEST`, `SUCCESS`, `FAILURE`) are dispatched in the right order based on the API call.\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#2-testing-redux-saga-middleware","title":"2. Testing Redux Saga Middleware","text":"<p>If you\u2019re using redux-saga for side effects, testing involves simulating the side effects and asserting the correct sequence of events (e.g., dispatching actions, making API calls).</p> <p>Saga Example</p> <p>Let\u2019s say you have a saga that fetches products:</p> <pre><code>// sagas.js\nimport { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchProductsSaga() {\n  try {\n    yield put({ type: 'FETCH_PRODUCTS_REQUEST' });\n    const response = yield call(fetch, '/api/products');\n    const data = yield call([response, 'json']);\n    yield put({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n  }\n}\n\nexport function* watchFetchProducts() {\n  yield takeEvery('FETCH_PRODUCTS', fetchProductsSaga);\n}\n</code></pre> <p>Testing Sagas with <code>redux-saga-test-plan</code></p> <p>The <code>redux-saga-test-plan</code> library simplifies testing sagas by allowing you to simulate effects and assert their behavior.</p> <ol> <li> <p>Install the library:</p> <pre><code>npm install redux-saga-test-plan --save-dev\n</code></pre> </li> <li> <p>Writing Tests for the Saga:</p> <p>Here\u2019s how you can test the <code>fetchProductsSaga</code>:</p> ExampleKey Points for Saga Testing <pre><code>import { runSaga } from 'redux-saga';\nimport { fetchProductsSaga } from './sagas';\nimport fetchMock from 'jest-fetch-mock';\n\ndescribe('fetchProductsSaga', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks(); // Reset mock fetch calls\n    });\n\n    it('should dispatch success action after fetching products', async () =&gt; {\n        // Mock API response\n        fetchMock.mockResponseOnce(JSON.stringify([{ id: 1, name: 'Product 1' }]));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_SUCCESS',\n            payload: [{ id: 1, name: 'Product 1' }],\n        });\n    });\n\n    it('should dispatch failure action if API call fails', async () =&gt; {\n        // Mock API error\n        fetchMock.mockReject(new Error('API Error'));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_FAILURE',\n            payload: 'API Error',\n        });\n    });\n});\n</code></pre> <ol> <li> <p>Use runSaga:</p> <ul> <li>Run your saga with mocked <code>dispatch</code> and <code>state</code> functions to simulate side effects.</li> </ul> </li> <li> <p>Mock API Calls:</p> <ul> <li>Mock the API calls (or any other side effects) to ensure that your saga correctly handles both success and failure cases.</li> </ul> </li> <li> <p>Verify Dispatched Actions:</p> <ul> <li>After running the saga, check that the correct actions were dispatched (e.g., <code>SUCCESS</code>, <code>FAILURE</code>).</li> </ul> </li> </ol> </li> </ol>"},{"location":"state-management/redux/core/redux-testing/#mocking-api-calls-in-redux-connected-components","title":"Mocking API Calls in Redux-Connected Components","text":"<p>Testing components that rely on async data (like API calls) means you need to mock those API responses and ensure the component behaves correctly.</p> <p>Example: ProductList Component with Thunk</p> <p>Let\u2019s take the <code>ProductList</code> component and test it with mocked API calls:</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts();\n  }, [fetchProducts]);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#testing-the-component-with-api-calls","title":"Testing the Component with API Calls","text":"<p>We\u2019ll mock the API call and test the component rendering.</p> <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock';\nimport ProductList from './ProductList';\n\n// Mock store and thunk middleware\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n  let store;\n\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset the fetch mocks before each test\n\n    store = mockStore({\n      products: { items: [], loading: false },\n    });\n  });\n\n  it('should fetch and display products', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    // Simulate component mounting and fetching products\n    expect(fetchMock).toHaveBeenCalledTimes(1); // Ensure the API call was made\n\n    // Assert that the product is rendered\n    expect(await screen.findByText('Product 1')).toBeInTheDocument();\n  });\n\n  it('should display loading state', () =&gt; {\n    store = mockStore({\n      products: { items: [], loading: true },\n    });\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"state-management/redux/core/redux-testing/#summary_1","title":"Summary:","text":"<ul> <li>Thunk Testing: Simulate API calls and check dispatched actions using a mock store.</li> <li>Saga Testing: Use <code>runSaga</code> to execute sagas and assert the side effects.</li> <li>Component Testing: Mock API calls using fetchMock or similar tools and verify the component behavior.</li> </ul>"},{"location":"state-management/redux/core/action/intro/","title":"Intro","text":""},{"location":"state-management/redux/core/action/intro/#what-is-an-action-in-redux","title":"What is an Action in Redux?","text":"<p>In Redux, an action is a plain JavaScript object that represents an event or change that happened in the application. It is the only source of information for the store, meaning all state changes in the store are triggered by actions.</p> <p>An action has two key properties:</p> <ul> <li>type: A string that defines the type of action (e.g., 'ADD_TODO', 'FETCH_DATA_SUCCESS'). This is mandatory.</li> <li>payload (optional): An additional data object that contains the information needed to perform the action (e.g., the todo item or fetched data).</li> </ul> Basic Example of an Action <pre><code>// Simple action to add a todo\nconst addTodoAction = {\n    type: 'ADD_TODO',               // Mandatory 'type' field\n    payload: {\n        text: 'Learn Redux',        // Optional 'payload' field containing data\n        id: 1\n    }\n};\n</code></pre> <p>The type field tells the Redux store what happened, and the payload field holds the data related to the action.</p> How Actions Work in Redux <ol> <li>Dispatch: Actions are dispatched from the UI or other parts of the app.</li> <li>Reducer: The action is passed to the reducer, which determines how the state should change based on the action's type.</li> <li>State Update: The store updates the state according to the reducer's instructions.</li> </ol>"},{"location":"state-management/redux/core/action/intro/#action-creator","title":"Action Creator","text":"<p>An action creator is a function that returns an action. It simplifies creating actions and helps avoid manually creating action objects.</p> <pre><code>// Action Creator to add a todo\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo }\n});\n</code></pre> Using Action in a Component <pre><code>import React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addTodo } from './actions/todoActions';\n\nconst TodoComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddTodo = () =&gt; {\n        const newTodo = { text: 'Learn Redux Basics', id: 1 };\n        dispatch(addTodo(newTodo)); // Dispatching the action\n    };\n\n    return (\n        &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;\n    );\n};\n</code></pre> Simple Reducer Example <pre><code>const todoReducer = (state = { todos: [] }, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        default:\n            return state;\n    }\n};\n</code></pre>"},{"location":"state-management/redux/core/action/intro/#difference-between-plain-action-action-creator","title":"Difference between plain action &amp; action creator","text":"<p>In Redux, actions and action creators are related but distinct concepts:</p>"},{"location":"state-management/redux/core/action/intro/#action","title":"Action","text":"<p>An action is a plain JavaScript object that describes a change or event in your application. It has at least one required property:</p> <ul> <li>type: A string that specifies the action type (e.g., 'ADD_TODO').</li> </ul> <p>Optionally, it can also include other properties:</p> <ul> <li>payload: Additional data needed to describe the action (e.g., the new todo item).</li> </ul> Example of an Action:<pre><code>// actions/todoActions.js (if you want to keep it organized)\nexport const addTodoAction = {\n    type: 'ADD_TODO',\n    payload: {\n        text: 'Learn Redux',\n        id: 1\n    }\n}\n// Usage in component\nconst handleAddTodo = () =&gt; {\n    dispatch(addTodoAction); // Dispatch the plain action object\n};\n</code></pre>"},{"location":"state-management/redux/core/action/intro/#action-creator_1","title":"Action Creator","text":"<p>An action creator is a function that creates and returns an action. It abstracts away the action object creation process and makes it easier to generate actions with the right structure.</p> <p>Action creators simplify creating actions and are useful for:</p> <ul> <li>Consistent action creation.</li> <li>Dynamically generating actions with specific payloads.</li> <li>Avoiding typos in action types.</li> </ul> <pre><code>// actions/todoActions.js (if you want to keep it organized)\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: todo\n});\n\n// Usage\nconst handleAddTodo = () =&gt; {\n  const newTodo = { text: 'Learn Redux', id: 1 };\n  dispatch(addTodo(newTodo)); // Using action creator\n};\n</code></pre> Summary <ul> <li>Action: A plain object that represents an event or change in the application. It has a type and optionally other properties like payload.</li> <li>Action Creator: A function that returns an action object. It helps in creating actions with the right structure and potentially dynamic data.</li> </ul> <p>In practice, action creators are commonly used in Redux applications because they provide a clear and consistent way to create actions and often handle complex logic for creating action objects.</p>"},{"location":"state-management/redux/core/action/intro/#tips-and-tricks-for-redux-actions","title":"Tips and Tricks for Redux Actions","text":"<ol> <li> <p>Action Types as Constants:</p> <ul> <li> <p>Use constants for action types to prevent typos and make refactoring easier.</p> <pre><code>export const ADD_TODO = 'ADD_TODO';\n</code></pre> </li> </ul> </li> <li> <p>Batched Actions:</p> <ul> <li> <p>Instead of dispatching multiple actions in sequence, you can batch them together.</p> <pre><code>const addTodoAndLog = (todo) =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(addTodoAction(todo));\n        dispatch(logAction(todo));\n    };\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"state-management/redux/core/reducer/example/","title":"Example","text":"<p>Facebook's developers follow a modular and organized approach to manage action types in their projects. Here is a closer look at how Facebook's React and Redux codebases might handle action types, inspired by best practices from projects like React and React Native.</p>"},{"location":"state-management/redux/core/reducer/example/#directory-structure","title":"Directory Structure","text":"<p>Let's assume a structure similar to how a large project at Facebook might be organized:</p> <pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 userActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 userActionTypes.js\n\u2502   \u251c\u2500\u2500 notificationActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 userReducer.js\n\u2502   \u251c\u2500\u2500 notificationReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u2514\u2500\u2500 store.js\n</code></pre>"},{"location":"state-management/redux/core/reducer/example/#define-action-types-in-separate-files","title":"Define Action Types in Separate Files","text":"<p>Each module or domain (e.g., users, notifications) has its own action types file.</p> <p>actionTypes/userActionTypes.js</p> <pre><code>export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST';\nexport const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';\nexport const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE';\n</code></pre> <p>actionTypes/notificationActionTypes.js</p> <pre><code>export const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\n</code></pre> <p>actionTypes/index.js</p> <p>This file aggregates all the action types from different domains.</p> <pre><code>export * from './userActionTypes';\nexport * from './notificationActionTypes';\n// Export other action types as needed\n</code></pre>"},{"location":"state-management/redux/core/reducer/example/#define-actions","title":"Define Actions","text":"<p>Each module has its own action creators, which use the specific action types.</p> <p>actions/userActions.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\n// Action creator for initiating the fetch request\nexport const fetchUsersRequest = () =&gt; ({\n  type: FETCH_USERS_REQUEST\n});\n\n// Action creator for handling successful fetch\nexport const fetchUsersSuccess = (users) =&gt; ({\n  type: FETCH_USERS_SUCCESS,\n  payload: users\n});\n\n// Action creator for handling fetch failure\nexport const fetchUsersFailure = (error) =&gt; ({\n  type: FETCH_USERS_FAILURE,\n  payload: error\n});\n\n// Thunk action creator for fetching users from API\nexport const fetchUsers = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch(fetchUsersRequest());\n\n    try {\n      const response = await fetch('https://api.example.com/users');\n      const data = await response.json();\n\n      if (response.ok) {\n        dispatch(fetchUsersSuccess(data));\n      } else {\n        throw new Error(data.message || 'Failed to fetch users');\n      }\n    } catch (error) {\n      dispatch(fetchUsersFailure(error.message));\n    }\n  };\n};\n</code></pre> <p>actions/index.js</p> <p>This file aggregates all action creators from different modules.</p> <pre><code>export * from './userActions';\nexport * from './notificationActions';\n// Export other actions as needed\n</code></pre>"},{"location":"state-management/redux/core/reducer/example/#define-reducers","title":"Define Reducers","text":"<p>Each module has its own reducer, which handles the specific action types.</p> <p>reducers/userReducer.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\nconst initialState = {\n  loading: false,\n  users: [],\n  error: ''\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case FETCH_USERS_REQUEST:\n      return {\n        ...state,\n        loading: true\n      };\n    case FETCH_USERS_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: action.payload,\n        error: ''\n      };\n    case FETCH_USERS_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        users: [],\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n\nexport default userReducer;\n</code></pre> <p>reducers/index.js</p> <p>This file combines all the reducers from different modules.</p> <pre><code>import { combineReducers } from 'redux';\nimport userReducer from './userReducer';\nimport notificationReducer from './notificationReducer';\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  notification: notificationReducer,\n  // Add other reducers as needed\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"state-management/redux/core/reducer/example/#setting-up-the-redux-store","title":"Setting Up the Redux Store","text":"<p>store.js</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk)\n);\n\nexport default store;\n</code></pre>"},{"location":"state-management/redux/core/reducer/example/#using-actions-in-a-component","title":"Using Actions in a Component","text":"UserList.js<pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUsers } from './actions';\n\nconst UserList = () =&gt; {\n  const dispatch = useDispatch();\n  const { loading, users, error } = useSelector((state) =&gt; state.user);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers());\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserList;\n</code></pre> <p>By modularizing the action types, actions, and reducers, the codebase remains clean, maintainable, and scalable. This approach aligns with how large teams, like those at Facebook, manage their code.</p>"},{"location":"state-management/redux/core/reducer/intro/","title":"Intro","text":"<p>To master the Redux reducer, you should focus on understanding its core principles and progressively advancing to more complex patterns. Here\u2019s a step-by-step guide to mastering Redux reducers:</p>"},{"location":"state-management/redux/core/reducer/intro/#mastering-reducer","title":"Mastering Reducer","text":"<ol> <li> <p>Understand the Basics of a Reducer</p> <ul> <li>Pure Functions: Reducers must be pure functions. They should return a new state based on the action type without modifying the original state.</li> <li>Action Types: Actions describe what happened, and reducers define how the state changes in response to those actions.</li> <li>State Immutability: Always return a new copy of the state. Use spread syntax (<code>...state</code>) or libraries like <code>immer</code> for immutability.</li> </ul> <pre><code>const initialState = { count: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Work with Complex State</p> <p>Once comfortable with simple states, move to complex nested state management. This is common in real-world apps, where state contains objects or arrays.</p> <ul> <li>Updating nested properties: For deep nested properties, make sure you understand how to properly update them without mutating the state.</li> </ul> <pre><code>const initialState = {\n    user: { name: 'John', details: { age: 30 } }\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'UPDATE_AGE':\n            return {\n                ...state,\n                user: {\n                    ...state.user,\n                    details: {\n                        ...state.user.details,\n                        age: action.payload.age\n                    }\n                }\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Handle Arrays in Reducers</p> <p>Understanding how to add, remove, or update items in arrays is crucial for managing lists in Redux.</p> <pre><code>const initialState = { todos: [] };\n\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo]\n            };\n        case 'REMOVE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id)\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Refactor and Modularize Reducers</p> <p>For large applications, breaking your reducers into smaller, manageable pieces (reducer composition) is crucial.</p> <ul> <li>Combine Reducers: Use <code>combineReducers</code> to split large reducers into smaller ones.</li> </ul> <pre><code>import { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n    counter: counterReducer,\n    todos: todoReducer,\n});\n</code></pre> <ul> <li>Action creators: Define action creators to make your reducer more readable and maintainable.</li> </ul> <pre><code>const increment = () =&gt; ({ type: 'INCREMENT' });\nconst addTodo = (todo) =&gt; ({ type: 'ADD_TODO', payload: { todo } });\n</code></pre> </li> <li> <p>Use Middlewares (for Async Logic)</p> <p>Mastering reducers also involves handling asynchronous logic. Redux Thunk or Redux-Saga are commonly used for side effects.</p> Thunk Example: <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_DATA_START' });\n    try {\n        const data = await apiCall();\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n</code></pre> </li> <li> <p>Learn Advanced Patterns</p> <ul> <li>Normalization of State: As your state grows, it\u2019s crucial to normalize it, particularly for collections of related data like lists of users or posts.</li> <li>Reducer Factories: For repetitive tasks, such as managing similar types of state (e.g., loading/error states), use factory functions to create reusable reducer logic.</li> </ul> <pre><code>const createLoadingReducer = (actionType) =&gt; (state = false, action) =&gt; {\n    switch (action.type) {\n        case `${actionType}_REQUEST`:\n            return true;\n        case `${actionType}_SUCCESS`:\n        case `${actionType}_FAILURE`:\n            return false;\n        default:\n            return state;\n    }\n};\n\nconst loadingReducer = createLoadingReducer('FETCH_DATA');\n</code></pre> </li> <li> <p>Immer for Simplified State Management</p> <p>Immer is a popular library that allows you to write reducers as if you're mutating the state directly while keeping it immutable under the hood.</p> <pre><code>import produce from 'immer';\n\nconst todoReducer = (state = initialState, action) =&gt; \n    produce(state, draft =&gt; {\n        switch (action.type) {\n            case 'ADD_TODO':\n                draft.todos.push(action.payload.todo);\n                break;\n            case 'REMOVE_TODO':\n                const index = draft.todos.findIndex(todo =&gt; todo.id === action.payload.id);\n                if (index !== -1) draft.todos.splice(index, 1);\n                break;\n            }\n    });\n</code></pre> </li> <li> <p>Testing Reducers</p> <p>Testing is key to mastering reducers. Write unit tests for your reducers to ensure they behave as expected.</p> <pre><code>it('should increment the count', () =&gt; {\n    const action = { type: 'INCREMENT' };\n    const initialState = { count: 0 };\n    const newState = counterReducer(initialState, action);\n    expect(newState.count).toEqual(1);\n});\n</code></pre> </li> <li> <p>Master Edge Cases</p> <ul> <li>Handle default states and unknown actions.</li> <li>Ensure your reducer is optimized and scalable, particularly when dealing with large state objects.</li> </ul> </li> <li> <p>Keep Up with Best Practices</p> <ul> <li>Regularly review Redux documentation and explore Redux Toolkit, which simplifies many Redux patterns, such as creating reducers and handling immutability.</li> </ul> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst todoSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: (state, action) =&gt; {\n            state.push(action.payload.todo);\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload.id);\n        },\n    },\n});\n\nexport const { addTodo, removeTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n</code></pre> </li> </ol> <p>By mastering these steps and gradually building more complex reducers, you'll become proficient in managing state in Redux.</p>"},{"location":"state-management/redux/core/reducer/intro/#what-is-an-action-creator","title":"What is an Action Creator?","text":"<p>An action creator is simply a function that returns an action. Actions are plain JavaScript objects that describe what happened in your application. The action creator is responsible for constructing that action object.</p> <p>In Redux, actions must have a <code>type</code> property that indicates the type of action being performed. Additional data related to the action can be passed as <code>payload</code>.</p>"},{"location":"state-management/redux/core/reducer/intro/#basic-example-of-an-action-creator","title":"Basic Example of an Action Creator","text":"<p>Here's a simple action creator:</p> <pre><code>// Basic Action Creator\nconst increment = () =&gt; ({\n  type: 'INCREMENT',\n});\n</code></pre> <p>This action creator returns an object with a <code>type</code> property. When dispatched, it will tell the reducer to increment the value in the state.</p> Usage: <pre><code>// Action object returned by the action creator\n{\n    type: 'INCREMENT'\n}\n\n// Dispatch the action\nstore.dispatch(increment());\n</code></pre> With Payload (passing additional data): <pre><code>const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: {\n        todo,\n    },\n});\n\n// Example usage:\nstore.dispatch(addTodo('Learn Redux'));\n\n// This returns:\n{\n    type: 'ADD_TODO',\n    payload: { todo: 'Learn Redux' }\n}\n</code></pre> <pre><code>// todoActions.js (Action File)\n\n// Action creator for adding a todo\nexport const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo },\n});\n\n// Action creator for deleting a todo\nexport const deleteTodo = (id) =&gt; ({\n    type: 'DELETE_TODO',\n    payload: { id },\n});\n</code></pre> <pre><code>// todoReducer.js (Reducer File)\n\nconst initialState = { todos: [] };\n\n// Reducer function for handling todo actions\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        case 'DELETE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id),\n            };\n        default:\n            return state;\n  }\n};\n\nexport default todoReducer;\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/","title":"Modular Reducer","text":""},{"location":"state-management/redux/core/reducer/modular-reducer/#define-api-urls","title":"Define API URLs","text":"apiUrls.js<pre><code>export const API_URLS = {\n    FETCH_ITEMS: '/api/items',\n    CREATE_ITEM: '/api/items',\n    // Add more URLs as needed\n};\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/#define-headers","title":"Define Headers","text":"headers.js<pre><code>export const DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n    // Add more default headers if needed\n};\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/#define-api-request-functions","title":"Define API Request Functions","text":"api.js<pre><code>import { DEFAULT_HEADERS } from './headers';\n\nexport const getApi = async (url, headers = DEFAULT_HEADERS) =&gt; {\n  const response = await fetch(url, { headers });\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\nexport const postApi = async (url, body, headers = DEFAULT_HEADERS) =&gt; {\n  const options = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(url, options);\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\n// Add more methods (PUT, DELETE, etc.) as needed\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/#use-the-api-request-functions-in-action-creators","title":"Use the API Request Functions in Action Creators","text":"actions/itemActions.js<pre><code>import { getApi, postApi } from '../api';\nimport { API_URLS } from '../apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/#full-example-directory-structure","title":"Full Example Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 itemActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 itemActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 apiUrls.js\n\u2502   \u2514\u2500\u2500 headers.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 itemReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 store.js\n\u2514\u2500\u2500 components/\n    \u2514\u2500\u2500 ItemList.js\n</code></pre>"},{"location":"state-management/redux/core/reducer/modular-reducer/#putting-it-all-together","title":"Putting It All Together","text":"src/actions/itemActions.js<pre><code>import { getApi, postApi } from '../api/api';\nimport { API_URLS } from '../api/apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"state-management/redux/core/reducer/throw-new-error/","title":"Throw New Error","text":""},{"location":"state-management/redux/core/reducer/throw-new-error/#understanding-throw-new-error","title":"Understanding throw new Error","text":"<p><code>throw new Error</code> is a way to create and throw a custom error in JavaScript. When you throw an <code>Error</code> object, you stop the normal execution flow and send control to the nearest catch block or global error handler, if no catch block is found.</p> Syntax<pre><code>if (!response.ok) {\n  throw new Error(data.message || 'Something went wrong');\n}\n</code></pre>"},{"location":"state-management/redux/core/reducer/throw-new-error/#importance-in-redux","title":"Importance in Redux","text":"<p>In a Redux-based application, throwing a new <code>Error</code> object is crucial for several reasons:</p> <ol> <li> <p>Consistent Error Handling:</p> <ul> <li> <p>By throwing an <code>Error</code>, you ensure that all errors are handled in a consistent manner. This consistency is vital for debugging and maintenance.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n} catch (error) {\n    console.error(error.message);\n}\n</code></pre> </li> </ul> </li> <li> <p>Centralized Error Management:</p> <ul> <li> <p>Redux action creators often make asynchronous calls (e.g., API requests). Throwing an <code>Error</code> allows these action creators to handle errors centrally, dispatching appropriate error actions.</p> </li> <li> <p>Example:</p> <pre><code>export const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_DATA_REQUEST });\n    try {\n        const data = await apiCall(url);\n        dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n};\n</code></pre> </li> </ul> </li> <li> <p>Enhanced Debugging:</p> <ul> <li> <p>The <code>Error</code> object captures a stack trace, which provides valuable context about where the error occurred. This stack trace can be logged and used for debugging.</p> </li> <li> <p>Example:</p> <pre><code>catch (error) {\n    console.error('Error stack:', error.stack);\n}\n</code></pre> </li> </ul> </li> <li> <p>Flow Control:</p> <ul> <li> <p>Throwing an <code>Error</code> ensures that the normal flow of execution is interrupted, allowing you to handle exceptions appropriately. Without this, errors might go unnoticed, leading to unexpected behavior.</p> </li> <li> <p>Example:</p> <pre><code>const fetchData = async () =&gt; {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error('Failed to fetch data');\n    }\n    return response.json();\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"state-management/redux/core/reducer/throw-new-error/#consequences-of-not-throwing-an-error","title":"Consequences of Not Throwing an Error","text":"<p>If you don't throw an <code>Error</code>, the consequences can include:</p> <ol> <li> <p>Silent Failures:</p> <ul> <li> <p>Errors may go unnoticed, leading to silent failures where the application continues to run without handling the error.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No error thrown, so the function continues executing\n    console.error('Error fetching data');\n}\n</code></pre> </li> </ul> </li> <li> <p>Inconsistent State::</p> <ul> <li> <p>The application state might become inconsistent if errors are not properly handled, potentially causing further issues down the line.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n    // State might not update correctly if error is not handled\n} catch (error) {\n    // Handle error here\n}\n</code></pre> </li> </ul> </li> <li> <p>Difficult Debugging:</p> <ul> <li> <p>Without stack traces, debugging becomes more challenging. Developers have less context about where and why the error occurred.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No stack trace available\n    console.error('Error occurred');\n}\n</code></pre> </li> </ul> </li> </ol>"},{"location":"state-management/redux/core/reducer/throw-new-error/#example-in-redux-action-creator","title":"Example in Redux Action Creator","text":"<p>Here\u2019s a complete example demonstrating the use of throw new Error in a Redux action creator:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>By throwing an <code>Error</code>, you ensure that your Redux actions can handle errors robustly and consistently, leading to a more stable and maintainable application.</p>"},{"location":"state-management/redux/core/reducer/throw-new-error/#why-we-throw-errors","title":"Why We Throw Errors","text":"<p>The primary reason for throwing errors is to ensure that they can be caught and handled appropriately. When you throw an error using <code>throw new Error</code>, it interrupts the normal execution flow and transfers control to the nearest <code>catch</code> block or an equivalent error-handling mechanism. Without this, errors might not be caught, leading to potential issues such as silent failures or inconsistent application states.</p>"},{"location":"state-management/redux/core/reducer/throw-new-error/#what-happens-if-we-dont-throw-an-error","title":"What Happens if We Don't Throw an Error","text":"<p>If you don't throw an error, it won't be caught by the catch block, and the execution will continue as if nothing went wrong. This can lead to various issues:</p> <ol> <li> <p>Silent Failures:</p> <p>The error might go unnoticed, leading to the application behaving incorrectly without any indication of what went wrong.</p> </li> <li> <p>Inconsistent State:</p> <p>If an error occurs and is not handled, the application state might become inconsistent, causing further issues down the line.</p> </li> <li> <p>Difficulty in Debugging:</p> <p>Without throwing an error, you lose the stack trace information, making it harder to debug and trace the source of the issue.</p> </li> </ol>"},{"location":"state-management/redux/core/reducer/throw-new-error/#example-without-throwing-an-error","title":"Example Without Throwing an Error","text":"<p>Here\u2019s an example to illustrate what happens when you don't throw an error:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    // Not throwing an error\n    if (!response.ok) {\n        return data.message || 'Something went wrong';\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await apiCall('/api/items');\n    if (!data.ok) {\n      dispatch({ type: FETCH_ITEMS_FAILURE, payload: data.message });\n    } else {\n      dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    }\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        if (!data.ok) {\n            dispatch({ type: CREATE_ITEM_FAILURE, payload: data.message });\n        } else {\n            dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n        }\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>In this case, you have to handle the error within the action creator itself by checking the response. This approach is cumbersome and error-prone.</p>"},{"location":"state-management/redux/core/reducer/throw-new-error/#example-with-throwing-an-error","title":"Example With Throwing an Error","text":"<p>By throwing an error, you can simplify the error handling process:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre>"},{"location":"state-management/redux/core/reducer/throw-new-error/#advantages-of-throwing-an-error","title":"Advantages of Throwing an Error","text":"<ol> <li> <p>Centralized Error Handling:</p> <p>By throwing an error, you allow the catch block to handle it centrally, making your code cleaner and easier to maintain.</p> </li> <li> <p>Clear Flow Control:</p> <p>Throwing an error immediately stops execution of the current function and transfers control to the nearest error handler.</p> </li> <li> <p>Detailed Error Information:</p> <p>The Error object includes a message and a stack trace, which are useful for debugging.</p> </li> <li> <p>Consistency:</p> <p>Ensures that all errors are handled consistently, reducing the likelihood of uncaught errors.</p> </li> </ol> <p>By adhering to this pattern, you ensure that your application handles errors robustly, making it more reliable and easier to maintain.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/","title":"Intro","text":""},{"location":"state-management/redux/core/redux-middleware/intro/#redux-middleware-saga-and-thunk","title":"Redux middleware \u2013 Saga and Thunk","text":"<p>The basic Redux store can only perform simple synchronous state updates by dispatching an action.</p> <p>Middleware such as Redux Thunk and Redux Saga help extend the store capabilities by writing the async logic to interact with the store. These middleware are helpful to avoid directly causing side effects in our actions, action creators, or components.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#what-is-redux-middleware-how-do-you-create-middleware","title":"What is Redux middleware? How do you create middleware?","text":"<p>Redux middleware provides a third-party extension to intercept every action sent to the reducer by modifying the action or canceling the action. It is helpful for logging, error reporting, routing, and making asynchronous API calls. Although Redux middleware is like Node.js middleware (for example, Express and Koa), it solves different problems.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#how-do-you-handle-asynchronous-tasks-in-redux","title":"How do you handle asynchronous tasks in Redux?","text":"<p>Most modern web applications need to deal with asynchronous tasks. In React, there are two popular libraries available to handle them: </p> <ol> <li>Redux Thunk &amp;</li> <li>Redux Saga.</li> </ol>"},{"location":"state-management/redux/core/redux-middleware/intro/#how-do-you-choose-between-redux-saga-and-redux-thunk","title":"How do you choose between Redux Saga and Redux Thunk?","text":"<p>Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux store to interact with external API calls (or side effects) asynchronously. But the decision to choose one of them totally depends on your project requirements and personal preference. </p> <p>Redux Thunk is a good choice if you are new to the React or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires less boilerplate code and is easy to understand.</p> <p>On the other hand, Redux Saga is suitable for big projects where you need to split the logic into multiple files. However, the main advantage of Redux Saga over Redux Thunk is the ability to write clean and readable tests for asynchronous code.</p> <p>The plain Redux requires a lot of boilerplate code to fulfill the state management requirements.Developers need to implement common tasks such as store setup, writing reducers and actions, and so on. Also, you may need to import APIs from other packages based on needs. So, this entire process makes it difficult for developers to learn and implement the Redux solution. RTK is going to standardize the process and simplify it with its helpers.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#standardizing-redux-logic-using-rtk","title":"Standardizing Redux logic using RTK","text":"<p>The RTK package provides the necessary tools to ease Redux development. This package not only eases development but also prevents common mistakes, provides suggested best practices, and many more features.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#what-is-rtk","title":"What is RTK?","text":"<p>Redux Toolkit (RTK) is a set of tools that simplifies Redux development and is used as an officially recommended approach to writing Redux logic. It was previously known as Redux Smarter Kit. The node package for this toolkit is available with the name @reduxjs/toolkit, which is wrapped around the core redux package. In summary, this package provides utilities and common dependencies that are required for building a Redux application.</p> <p>This tool helps cover common use cases such as setting up the store, creating the reducers and actions, writing immutable update logic, and creating entire slices of state at once.</p> <p>By default, RTK automatically supports the following officially recommended set of tools or libraries to cover most of the common use cases:</p> <ul> <li>Redux DevTools</li> <li>Immer</li> <li>Redux Thunk</li> <li>Reselect</li> </ul> <p>RTK supports TypeScript through which APIs provide excellent type safety and reduce the number of types used in the code.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#what-are-the-problems-solved-by-rtk","title":"What are the problems solved by RTK?","text":"<p>RTK is helpful to speed up the development process and apply the recommended best practices automatically. It solves the following three major issues found in the Redux library:</p> <ul> <li>Configuring a Redux store that is too complicated</li> <li>This Redux library requires a lot of dependencies for building a large-scale application</li> <li>Redux requires too much boilerplate code, which impacts the efficiency and quality of the code</li> </ul> <p>The toolkit provides certain options to configure the global store, creating actions and reducers that make the development simpler by abstracting the Redux API.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#what-is-rtk-query-how-do-you-use-it","title":"What is RTK Query? How do you use it?","text":"<p>RTK Query is a powerful data fetching and client-side caching tool to simplify common use cases in Redux applications. For example, this tool supports use cases such as loading data in the web application, avoiding the need for hand-written data fetching and caching logic, and so on. If you are using the RTK package, this query feature is going to be available as an optional add-on. Also, this feature is built-in on top of the RTK API methods such as <code>createSlice</code> and <code>createAsyncThunk</code> for its implementation.</p>"},{"location":"state-management/redux/core/redux-middleware/intro/#reference","title":"Reference","text":"<ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"state-management/redux/core/redux-middleware/redux-saga/","title":"Redux Saga","text":""},{"location":"state-management/redux/core/redux-middleware/redux-saga/#what-is-redux-saga","title":"What is Redux Saga?","text":"<p>Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous side effects. Redux Saga uses an ES6 feature known as generators that helps in writing asynchronous code. These generators are functions that can be paused, resumed, exited in the middle of execution, and re-entered later during the operations.</p> <p>The side effects will be generated using special helper functions from the <code>redux-saga</code> package. Some of those commonly used functions are listed here:</p> <ul> <li>Call: An effect description that instructs the middleware to call other functions in Saga</li> <li>Put: Used to dispatch an action to the store</li> <li>Yield: A built-in function that allows the use of generator functions sequentially</li> <li>takeLatest: Invokes the function handler only once at a time and cancels the previous tasks by running again with the latest data</li> <li>takeEvery: Invokes the function handler every time infinitely and concurrently whenever the action fires</li> </ul> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"state-management/redux/core/redux-middleware/redux-thunk/","title":"Redux Thunk","text":"<p>Redux Thunk middleware is used to write an action creator that returns a function instead of just an action object in the Redux application. The functions returned from the action creator are called thunk functions and are used to delay the computation. These functions accept two arguments \u2013 the dispatch and getState methods:</p>"},{"location":"state-management/redux/core/redux-middleware/redux-thunk/#what-are-the-use-cases-of-redux-thunk","title":"What are the use cases of Redux Thunk?","text":"<p>Redux Thunk can have any arbitrary logic and it can be used for a variety of purposes. The most common use cases of Redux Thunk are listed as follows:</p> <ul> <li>When you\u2019re trying to move complex logic out of React components</li> <li>When you are making async requests such as Ajax calls and other async logic</li> <li>When you need to create a logic that needs to dispatch multiple distinct actions in a row</li> <li>When you are planning to write a logic that needs to access getState or other state values to make decisions</li> </ul> <p>In summary, the main use case of Redux Thunk middleware is for handling actions that are not synchronous.</p> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"state-management/redux/history/overview/","title":"Overview","text":""},{"location":"state-management/redux/history/overview/#overview","title":"Overview","text":""},{"location":"state-management/redux/history/overview/#the-three-principles","title":"The three principles","text":"<ol> <li>Single source of truth</li> <li>State is read-only</li> <li>Changes are made with pure functions</li> </ol>"},{"location":"state-management/redux/history/overview/#the-workflow","title":"The workflow","text":"<p>Modern web applications are ultimately about handling events. They could be initiated by a user, such as navigating to a new page or submitting a form. Or they could be initiated by another external source, such as a server response. Responding to events usually involves updating state and re\u00adrendering with that updated state. The more your application does, the more state you need to track and update.</p> <p>Combine this with the fact that most of these events occur asynchronously, and you suddenly have real obstacles to maintaining an application at scale.</p> <p></p> <p>You want to do two things in response to a user submitting a new post: add the post to the user\u2019s activity feed and increment their total post count. After the user submits, you\u2019ll kick off the process by dispatching an action.</p>"},{"location":"state-management/redux/history/overview/#actions","title":"Actions","text":"<p>Actions are plain old JavaScript objects that represent an event in your application, as follows:</p> <pre><code>{\n    type: 'CREATE_POST',\n    payload: {\n        body: 'All that is gold does not glitter'\n    }\n}\n</code></pre> Let\u2019s break that down. You have an object with two properties: <ul> <li> <p>type \u2014 A string that represents the category of action being performed. By convention, this property is capitalized and uses underscores as delimiters.</p> </li> <li> <p>payload \u2014 An object that provides the data necessary to perform the action. In your case, you only need one field: the contents of the message we want to post. The name \u201cpayload\u201d is only a popular convention.</p> </li> </ul> <p>Actions have the advantage of serving as audits, which keep a historical record of everything happening in your application, including any data needed to complete a transaction. It\u2019s hard to understate how valuable this is in maintaining a grasp on a complex application. Once you get used to having a highly readable stream describing the behavior of your application in real time, you\u2019ll find it hard to live without.</p> <p>Throughout the book, we\u2019ll frequently come back to this idea of what versus how. You can think of Redux as decoupling what happens in an application from how we respond to an event. Actions handle the what in this equation. They describe an event; they don\u2019t know and don\u2019t care what happens downstream. Somewhere down the road you\u2019ll eventually have to specify how to handle an action. Sounds like a job fit for a reducer!</p>"},{"location":"state-management/redux/history/overview/#reducers","title":"Reducers","text":"<p>Reducers are functions responsible for updating your state in response to actions.</p> <p>They\u2019re simple functions that take your current state and an action as arguments, and return the next state.</p> <p>Figure 1.5. An abstract representation of a reducer\u2019s function signature. If this diagram looks simple, that\u2019s because it is! Reducers are meant to be simple functions that compute a result, making them easy to work with and test.</p> <p></p> <p>Reducers are typically easy to work with. Similar to all pure functions, they produce no side effects. They don\u2019t affect the outside world in any way, and they\u2019re referentially transparent. The same inputs will always yield the same return value. This makes them particularly easy to test. Given certain inputs, you can verify that you receive the expected result.</p> <p></p> <p>You\u2019re focusing on a single event in this example, which means you need only one reducer. However, you certainly aren\u2019t limited to only one. In fact, more sizable applications frequently implement several reducer functions, each concerned with a different slice of the state tree. These reducers are combined, or composed, into a single \u201croot reducer.\u201d</p>"},{"location":"state-management/redux/history/overview/#store","title":"Store","text":"<p>Reducers describe how to update state in response to an action, but they can\u2019t modify state directly. That privilege rests solely with the store.</p> <p>In Redux, application state is stored in a single object.</p> The store has a few main roles, which follow: <ul> <li>Hold application state.</li> <li>Provide a way to access state.</li> <li>Provide a way to specify updates to state. The store requires an action be dispatched to modify state.</li> <li>Allow other entities to subscribe to updates (React components in this case). View bindings provided by react\u00adredux will allow you to receive updates from the store and respond to them in your components.</li> </ul> <p>The reducer processed the action and computed the next state. Now it\u2019s time for the store to update itself and broadcast the new state to all registered listeners (you care specifically about the components that make up your profile page).</p>"},{"location":"state-management/redux/history/overview/#reference","title":"Reference","text":"<ul> <li>Redux in Action by Marc Garreau</li> <li>Beginner\u2019s guide to react/redux \u2014painting a mental model</li> </ul>"},{"location":"state-management/redux/history/testing-redux/","title":"Testing Redux","text":""},{"location":"state-management/redux/history/testing-redux/#testing-redux-applications","title":"Testing Redux Applications","text":"<p>Choice means flexibility, but it also means mental overhead.</p>"},{"location":"state-management/redux/persist/example/","title":"Example","text":"<p>Redux Persist is a library that helps you save and rehydrate the Redux state in your application, enabling it to persist between page reloads or browser sessions. Essentially, it allows your Redux store to survive page refreshes by storing the Redux state in a storage engine like <code>localStorage</code> or <code>sessionStorage</code> in the browser (or <code>AsyncStorage</code> in React Native).</p>"},{"location":"state-management/redux/persist/example/#key-concepts-of-redux-persist","title":"Key Concepts of Redux Persist:","text":"<ul> <li>Persisted State: It saves the Redux state in a persistent storage (e.g., <code>localStorage</code>, <code>sessionStorage</code>, etc.).</li> <li>Rehydration: When the app restarts or reloads, it loads the saved state back into the Redux store.</li> </ul>"},{"location":"state-management/redux/persist/example/#common-use-cases","title":"Common Use Cases:","text":"<ul> <li>User Authentication: To persist user login status, like saving a JWT token or user information.</li> <li>App Preferences: Persisting theme settings, user preferences, etc.</li> <li>Shopping Cart: Storing cart data in eCommerce apps.</li> </ul>"},{"location":"state-management/redux/persist/example/#where-to-use-redux-persist","title":"Where to Use Redux Persist:","text":"<p>You typically integrate Redux Persist in your Redux setup at the root level, because it needs to wrap your Redux store and ensure that the persistence is set up properly for the entire store. Here's a high-level example of how you can implement Redux Persist:</p>"},{"location":"state-management/redux/persist/example/#steps-to-set-up-redux-persist","title":"Steps to Set Up Redux Persist:","text":"<ol> <li> <p>Install Redux Persist:</p> <pre><code>npm install redux-persist\n</code></pre> </li> <li> <p>Configure Redux Persist:</p> <p>You need to create a configuration that defines the persist behavior and specify which parts of the state you want to persist.</p> </li> <li> <p>Setup Redux Store with Redux Persist:</p> <p>Example of integrating Redux Persist into a Redux store:</p> <pre><code>import { createStore } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\"; // Defaults to localStorage in the browser\nimport rootReducer from \"./reducers\"; // Your root reducer\n\n// Redux Persist config\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"auth\", \"preferences\"], // Only persist auth and preferences reducers (optional)\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\n// Create the store\nconst store = createStore(persistedReducer);\n\n// Create the persistor to manage the persistence logic\nconst persistor = persistStore(store);\n\nexport { store, persistor };\n</code></pre> </li> <li> <p>Wrap Your Application with <code>PersistGate</code>:</p> <p>In your main app component (typically <code>App.js</code> or <code>index.js</code>), you'll use the PersistGate component to wrap your app to delay the rendering of the app until the Redux state has been rehydrated (i.e., restored from storage).</p> <pre><code>import React from \"react\";\nimport { PersistGate } from \"redux-persist/integration/react\";\nimport { Provider } from \"react-redux\";\nimport { store, persistor } from \"./store\"; // Import the store and persistor\n\nfunction App() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;PersistGate loading={null} persistor={persistor}&gt;\n        {/* Your app components go here */}\n      &lt;/PersistGate&gt;\n    &lt;/Provider&gt;\n  );\n}\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"state-management/redux/persist/example/#do-you-need-redux-persist-in-the-root","title":"Do You Need Redux Persist in the Root?","text":"<p>Yes, Redux Persist should be configured at the root level, because:</p> <ul> <li>It needs to wrap your Redux store to persist and rehydrate the global state of your application.</li> <li>It should be set up before the main app starts rendering so that it ensures the persisted state is restored when your application reloads.</li> </ul>"},{"location":"state-management/redux/persist/example/#in-summary","title":"In summary:","text":"<ul> <li>Root level: Set up Redux Persist in your store configuration (with <code>persistReducer</code> and <code>persistStore</code>).</li> <li>App level: Use <code>PersistGate</code> to ensure the app waits for the Redux state to be rehydrated before rendering the UI.</li> </ul> <p>This ensures that your app has access to the persisted state as soon as it starts, and users can resume their activities after a page reload without losing their data.</p>"},{"location":"state-management/redux/persist/immer-example/","title":"Immer","text":"<p>To use Immer in your Redux reducer, you can simplify the state updates by leveraging the produce function from Immer. Here's how you can refactor your reducer code using Immer:</p> <ol> <li> <p>Install Immer if you haven't already:</p> </li> <li> <p>Update your reducer to use <code>produce</code>. Here's an example based on your code:</p> ExampleExplanation <pre><code>import { produce } from 'immer';\n\nconst initialState = {\n    exportDailDiary: null,\n    exportDailDiaryLoading: false,\n};\n\nconst dailyDairyReducer = (state = initialState, action) =&gt; {\n    return produce(state, (draft) =&gt; {\n        switch (action.type) {\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_INIT:\n                draft.exportDailDiaryLoading = true;\n                break;\n\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_SUCCESS:\n                draft.exportDailDiary = action.payload;\n                draft.exportDailDiaryLoading = false;\n                break;\n\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_FINISH:\n                draft.exportDailDiaryLoading = false;\n                break;\n\n            default:\n                return state;\n        }\n    });\n};\n\nexport default dailyDairyReducer;\n</code></pre> <ul> <li><code>produce</code>: This function takes the current state and a \"draft\" function, allowing you to modify the draft directly. Immer takes care of creating a new state based on the modifications.</li> <li>Draft Mutability: Within the draft function, you can directly mutate the <code>draft</code> object without worrying about immutability.</li> </ul> </li> </ol> <p>This approach results in cleaner and more readable code while maintaining the benefits of immutability that Redux requires.</p>"},{"location":"state-management/redux/persist/immer-example/#additional","title":"Additional","text":"question <p>The difference between the two import statements lies in how the <code>produce</code> function is exported from the Immer library:</p> <ol> <li> <p><code>import produce from 'immer';</code>:</p> <ul> <li>This is a default import syntax.</li> <li>It works when a module exports a single entity as its default export.</li> <li>In the case of Immer, <code>produce</code> is not the default export.</li> </ul> </li> <li> <p><code>import { produce } from 'immer';</code>:</p> <ul> <li>This is a named import syntax.</li> <li>It is used to import specific exports from a module.</li> <li>Since <code>produce</code> is a named export in Immer, this is the correct way to import it.</li> </ul> </li> </ol> <p>Which Works in React?</p> <ul> <li>Correct Usage: You should use <code>import { produce } from 'immer';</code> because <code>produce</code> is a named export.</li> <li>Default Import Error: If you use <code>import produce from 'immer';</code>, you will encounter an error stating that Immer does not contain a default export.</li> </ul> <p>Conclusion</p> <p>For React (and any JavaScript code using Immer), always use the named import syntax:</p> <pre><code>import { produce } from \"immer\";\n</code></pre> <p>This is the proper way to import the <code>produce</code> function from Immer.</p>"},{"location":"state-management/redux/persist/question/","title":"Question","text":"<pre><code>{\n    key: \"auth\",\n    storage,\n};\n\nby default it creates root. where do i need to store it in \"root\" or i can create as many key name like \"auth\" as i like\n</code></pre> <p>Yes, you can create as many key names as you like when configuring Redux Persist. The key name you specify is used to differentiate different parts of the state that you want to persist.</p>"},{"location":"state-management/redux/persist/question/#key-points-to-understand","title":"Key Points to Understand:","text":"<ol> <li> <p>Default Key (<code>root</code>):</p> <ul> <li>When you use <code>key: 'root'</code>, you're specifying the main key under which the entire Redux state will be persisted. This is the default behavior when you don't specify a custom key.</li> </ul> <pre><code>const persistConfig = {\n  key: \"root\",\n  storage,\n};\n</code></pre> </li> <li> <p>Custom Key Names:</p> <p>You can use any name as the <code>key</code>, such as <code>auth</code>, <code>preferences</code>, or <code>cart</code>, and that key will specifically store the relevant part of the Redux state.</p> <pre><code>const persistConfig = {\n  key: \"auth\", // Store only the 'auth' part of the state\n  storage,\n};\n</code></pre> <p>In this case, only the <code>auth</code> reducer's state will be persisted in storage (e.g., <code>localStorage</code> or <code>sessionStorage</code>), not the entire Redux state.</p> </li> </ol>"},{"location":"state-management/redux/persist/question/#where-should-you-store-it-root-vs-custom-key-names","title":"Where Should You Store it: \"root\" vs. Custom Key Names","text":"<ul> <li>Root key (root): You should only use the key: 'root' when you want to persist the entire Redux store (all reducers and all state).</li> <li>Custom key names: If you want to persist specific parts of your state, you can use any custom key like 'auth', 'preferences', 'userData', etc.</li> </ul>"},{"location":"state-management/redux/persist/question/#example-with-multiple-keys","title":"Example with Multiple Keys:","text":"<p>If you want to persist multiple parts of your state (e.g., <code>auth</code> and <code>preferences</code>), you can use a combination of <code>whitelist</code> (or <code>blacklist</code>) in your configuration.</p> Example Configuration for Multiple Keys:<pre><code>import { createStore } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport rootReducer from \"./reducers\"; // Assuming you have an auth and preferences reducer\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"auth\", \"preferences\"], // Persist only the auth and preferences reducers\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nconst store = createStore(persistedReducer);\nconst persistor = persistStore(store);\n\nexport { store, persistor };\n</code></pre> <p>In this case:</p> <ul> <li><code>key: 'root'</code> persists the entire store.</li> <li><code>whitelist: ['auth', 'preferences']</code> ensures that only the <code>auth</code> and <code>preferences</code> reducers are saved in persistent storage (e.g., localStorage).</li> </ul> <p>???+ note title=\"Important Notes:\"</p> <pre><code>`whitelist` vs. `blacklist`:\n\n-   `whitelist`: Specifies which reducers (by key name) to persist.\n-   `blacklist`: Specifies which reducers (by key name) to not persist.\n\nIf you use `whitelist`, only those parts of the state will be persisted. Conversely, if you use `blacklist`, all parts of the state will be persisted except those you specify.\n</code></pre> Important Notes: <pre><code>const persistConfig = {\n    key: 'root',\n    storage,\n    blacklist: ['tempData'], // Don't persist the 'tempData' reducer\n};\n</code></pre>"},{"location":"state-management/redux/persist/question/#conclusion","title":"Conclusion:","text":"<ul> <li>Root (<code>'root'</code>): If you want to persist the entire store, use <code>key: 'root'</code>.</li> <li>Custom keys: If you want to persist specific parts of the state, use custom keys like <code>'auth'</code>, <code>'preferences'</code>, etc., and configure <code>whitelist</code> or <code>blacklist</code> accordingly.</li> </ul>"},{"location":"state-management/redux/persist/redux-persist-purge/","title":"Purge","text":""},{"location":"state-management/redux/persist/redux-persist-purge/#when-to-purge","title":"When to purge","text":"<p>Here are some key topics related to when to purge or clear Redux Persist state:</p> <ol> <li> <p>User Authentication:</p> <ul> <li>On Logout: Purge persisted state when a user logs out to remove sensitive information.</li> <li>On Session Expiry: Clear state if a session is detected to be expired.</li> </ul> <pre><code>// actions.js\nexport const logoutUser = () =&gt; {\n  return async (dispatch) =&gt; {\n    // Perform logout logic\n    dispatch({ type: \"LOGOUT\" });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>User Switching:</p> <ul> <li>On User Switch: Clear state when switching users to prevent carrying over data from one session to another.</li> </ul> <pre><code>// actions.js\nexport const switchUser = (newUser) =&gt; {\n  return async (dispatch) =&gt; {\n    // Update user state\n    dispatch({ type: \"SWITCH_USER\", payload: newUser });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Account Deletion:</p> <ul> <li>On Account Deletion: Purge data when a user deletes their account to ensure all personal information is removed.</li> </ul> <pre><code>// actions.js\nexport const deleteAccount = () =&gt; {\n  return async (dispatch) =&gt; {\n    // Perform account deletion logic\n    dispatch({ type: \"DELETE_ACCOUNT\" });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Sensitive Operations:</p> <ul> <li>After Sensitive Actions: Consider clearing state after certain actions that involve sensitive data, like changing passwords or personal details.</li> </ul> <pre><code>// actions.js\nexport const changePassword = (newPassword) =&gt; {\n  return async (dispatch) =&gt; {\n    // Change password logic\n    dispatch({ type: \"CHANGE_PASSWORD\" });\n\n    // Optionally purge state for security\n    const persistor = store.persistor;\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>On Critical Errors: Optionally, you can clear state when encountering critical errors that might compromise application integrity.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>During Tests: Clear the state to ensure tests start with a clean slate.</li> </ul> </li> <li> <p>Application Reset:</p> <ul> <li>On App Reset: If your application has a reset feature, you might want to clear persisted state at that point.</li> </ul> </li> </ol> <p>Implementing these practices ensures that your application maintains security and integrity when handling user data.</p>"},{"location":"state-management/redux/persist/redux-persist-purge/#using-middleware","title":"Using Middleware","text":"<p>You can also create middleware to listen for specific actions and purge the state accordingly:</p> <pre><code>// middleware.js\nconst purgeMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  if (action.type === \"LOGOUT\" || action.type === \"DELETE_ACCOUNT\") {\n    const persistor = store.persistor;\n    persistor.purge();\n  }\n  return next(action);\n};\n\n// Applying middleware\nconst store = createStore(reducer, applyMiddleware(purgeMiddleware));\n</code></pre> <p>Using middleware for managing Redux Persist purging can indeed be a great option for several reasons:</p> ExampleAdvantages of Using MiddlewareConclusion <pre><code>// middleware.js\nconst purgeMiddleware = (persistor) =&gt; store =&gt; next =&gt; action =&gt; {\n    if (action.type === 'LOGOUT' || action.type === 'DELETE_ACCOUNT') {\n        persistor.purge();\n    }\n    return next(action);\n};\n\n// Applying middleware in your store setup\nimport { createStore, applyMiddleware } from 'redux';\nimport { persistStore } from 'redux-persist';\nimport rootReducer from './reducers';\n\nconst store = createStore(rootReducer, applyMiddleware(purgeMiddleware(persistor)));\nconst persistor = persistStore(store);\n</code></pre> <ol> <li> <p>Separation of Concerns: Middleware helps keep your action creators clean and focused on dispatching actions rather than handling side effects. This leads to better-organized code.</p> </li> <li> <p>Centralized Logic: By placing purge logic in middleware, you can manage it in one place. This makes it easier to maintain and update the purging behavior without needing to modify multiple action creators.</p> </li> <li> <p>Reusability: If you have multiple actions that require similar purging behavior, middleware allows you to reuse that logic without duplicating code.</p> </li> <li> <p>Easier Testing: Middleware can be tested independently, making it simpler to ensure that your purging logic behaves as expected without tying it to the specifics of your actions.</p> </li> <li> <p>Conditional Purging: Middleware can handle more complex conditions for purging state, allowing you to define when state should be cleared based on various actions or application states.</p> </li> </ol> <p>Using middleware for this purpose is often a good practice, particularly in larger applications where separation of concerns and code maintainability are priorities. However, if your application is smaller and the purging logic is minimal, you might opt to keep it directly in the action creators for simplicity. Ultimately, the best approach depends on your specific application's architecture and requirements.</p>"},{"location":"state-management/redux/persist/redux-persist-purge/#creating-separate-purge-middleware","title":"Creating Separate <code>purge</code> middleware","text":""},{"location":"state-management/redux/persist/redux-persist-purge/#standard-redux","title":"Standard Redux","text":"<p>Yes, you can definitely create a separate file to handle the purging logic for Redux Persist. This can further improve the organization of your code. Here\u2019s how you can structure it:</p> 1. Create a New File for Purge Logic2. Update Your Store Configuration3. Optional: Action Types <p>You can create a file named <code>purgeMiddleware.js</code> (or a similar name) to define the middleware that handles purging the persisted state.</p> <pre><code>import { PURGE } from 'redux-persist';\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (action.type === 'LOGOUT' || action.type === 'DELETE_ACCOUNT') {\n        persistor.purge();\n    }\n    return next(action);\n};\n\nexport default purgeMiddleware;\n</code></pre> <p>Next, import this middleware into your <code>store.js</code> file and apply it.</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { persistStore } from \"redux-persist\";\nimport rootReducer from \"./rootReducer\";\nimport loggerMiddleware from \"../middleware/loggerMiddleware\";\nimport purgeMiddleware from \"../middleware/purgeMiddleware\"; // Import the purge middleware\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(loggerMiddleware, purgeMiddleware(persistor)), // Add purge middleware\n});\n\n// Create the persistor to manage state persistence\nexport const persistor = persistStore(store);\n</code></pre> <p>If you want to keep track of specific actions for purging, you could also define action types in a separate file to manage them more easily:</p> actionTypes.js<pre><code>export const LOGOUT = 'LOGOUT';\nexport const DELETE_ACCOUNT = 'DELETE_ACCOUNT';\n</code></pre> <p>Then use these action types in your <code>purgeMiddleware.js</code>:</p> <pre><code>import { LOGOUT, DELETE_ACCOUNT } from './actionTypes';\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (action.type === LOGOUT || action.type === DELETE_ACCOUNT) {\n        persistor.purge();\n    }\n    return next(action);\n};\n</code></pre> <p>Conclusion</p> <p>By creating a separate file for your purge middleware, you maintain a clean structure in your Redux setup. This makes it easier to manage and update the purging logic independently from the rest of your store configuration. This modular approach enhances readability and maintainability in larger applications.</p>"},{"location":"state-management/redux/persist/redux-persist-purge/#redux-toolkit","title":"Redux Toolkit","text":"1. Define Your Action in the Slice2. Update <code>purgeMiddleware.js</code>3. Use Middleware in the Store <p>First, ensure that your <code>logout</code> action is defined in your Redux slice:</p> <pre><code>// exampleSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst exampleSlice = createSlice({\n    name: 'example',\n    initialState: { user: null },\n    reducers: {\n        login: (state, action) =&gt; {\n        state.user = action.payload;\n        },\n        logout: (state) =&gt; {\n        state.user = null; // Clear user state\n        },\n    },\n});\n\n// Export actions\nexport const { login, logout } = exampleSlice.actions;\n\n// Export reducer\nexport default exampleSlice.reducer;\n</code></pre> <p>Now, you can use the <code>logout</code> action in your middleware. Import the <code>logout</code> action and check for it in your middleware.</p> <pre><code>import { logout } from './exampleSlice'; // Adjust the import based on your file structure\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    // Check if the action is the logout action\n    if (action.type === logout.type) {\n        persistor.purge();\n    }\n    return next(action);\n};\n\nexport default purgeMiddleware;\n</code></pre> <p>Make sure to include the <code>purgeMiddleware</code> in your store setup:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { persistStore } from \"redux-persist\";\nimport rootReducer from \"./rootReducer\";\nimport loggerMiddleware from \"../middleware/loggerMiddleware\";\nimport purgeMiddleware from \"../middleware/purgeMiddleware\"; // Import the purge middleware\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(loggerMiddleware, purgeMiddleware(persistor)), // Add purge middleware\n});\n\n// Create the persistor to manage state persistence\nexport const persistor = persistStore(store);\n</code></pre> <p>Conclusion</p> <p>With this setup, your <code>purgeMiddleware</code> will automatically call <code>persistor.purge()</code> when the <code>logout</code> action is dispatched. This effectively clears the persisted state when the user logs out, maintaining the integrity of your application\u2019s state. You can extend this logic to handle other actions as needed by simply adding more checks within the middleware.</p>"},{"location":"state-management/redux/persist/redux-persist/","title":"Intro","text":""},{"location":"state-management/redux/persist/redux-persist/#overview","title":"Overview","text":"<p>Setting up Redux with Redux Persist involves several steps, and understanding the workflow will help you see how the pieces fit together. Here\u2019s a detailed workflow, including setup and how it works.</p>"},{"location":"state-management/redux/persist/redux-persist/#workflow-overview","title":"Workflow Overview","text":"<ol> <li>Install Dependencies</li> <li>Set Up Redux Slices</li> <li>Create Persist Configuration</li> <li>Combine Reducers and Create Store</li> <li>Wrap Application with PersistGate</li> <li>Using Redux State in Components</li> </ol>"},{"location":"state-management/redux/persist/redux-persist/#additional","title":"Additional","text":"Step 1:Step 2:Step 3:Step 4:Step 5:Step 6: <p>Install Dependencies</p> <p>First, ensure you have the necessary libraries installed:</p> <pre><code>npm install @reduxjs/toolkit react-redux redux-persist\n</code></pre> <p>Set Up Redux Slices</p> <p>Create slices using Redux Toolkit for managing state. For example, here\u2019s a simple sidebar slice:</p> <pre><code>// src/redux/features/sidebar/slice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst sidebarSlice = createSlice({\n    name: 'sidebar',\n    initialState: { collapsed: false },\n    reducers: {\n        toggleSidebar: (state) =&gt; {\n            state.collapsed = !state.collapsed;\n        },\n        setSidebar: (state, action) =&gt; {\n            state.collapsed = action.payload;\n        },\n    },\n});\n\nexport const { toggleSidebar, setSidebar } = sidebarSlice.actions;\nexport default sidebarSlice.reducer;\n</code></pre> <p>Create Persist Configuration</p> <p>Create a separate file for your persist configuration:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from 'redux-persist/lib/storage'; // defaults to localStorage\nimport { persistReducer } from 'redux-persist';\n\nconst persistConfig = {\n    key: 'root',\n    storage,\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n    return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> <p>Combine Reducers and Create Store</p> <p>Combine your reducers and create the Redux store with persistence:</p> <pre><code>// src/redux/store/rootReducer.js\nimport { combineReducers } from '@reduxjs/toolkit';\nimport sidebarReducer from '../features/sidebar/slice';\nimport { createPersistedReducer } from './persistConfig'; // Import persist function\n\nconst rootReducer = combineReducers({\n    sidebar: sidebarReducer,\n    // Add other reducers here\n});\n\nconst persistedReducer = createPersistedReducer(rootReducer);\nexport default persistedReducer;\n</code></pre> <pre><code>// src/redux/store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\nimport { persistStore } from 'redux-persist';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    // Add other middleware if needed\n});\n\nexport const persistor = persistStore(store);\n</code></pre> <p>Wrap Application with PersistGate</p> <p>In your main entry file (usually <code>index.js</code>), wrap your application with <code>PersistGate</code> to delay rendering until the persisted state is retrieved.</p> <pre><code>// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { store, persistor } from './redux/store/store';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;PersistGate loading={null} persistor={persistor}&gt;\n                &lt;App /&gt;\n            &lt;/PersistGate&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>Using Redux State in Components</p> <p>Now you can use Redux state in your components. Here\u2019s an example of how to use the sidebar state:</p> <pre><code>// src/components/Sidebar.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { toggleSidebar } from '../redux/features/sidebar/slice';\n\nconst Sidebar = () =&gt; {\n    const dispatch = useDispatch();\n    const collapsed = useSelector((state) =&gt; state.sidebar.collapsed);\n\n    return (\n        &lt;div style={{ width: collapsed ? '80px' : '200px' }}&gt;\n            &lt;button onClick={() =&gt; dispatch(toggleSidebar())}&gt;\n                {collapsed ? 'Expand' : 'Collapse'}\n            &lt;/button&gt;\n\n            {/* Sidebar content */}\n        &lt;/div&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <p>How It Works</p> <ol> <li> <p>Initial State: When the app first loads, the Redux store is created with the initial state from your reducers.</p> </li> <li> <p>Persist State: Redux Persist checks local storage (or your configured storage) for any previously saved state. If it finds any, it rehydrates the store with that state.</p> </li> <li> <p>State Updates: When you dispatch actions (like toggling the sidebar), the state in the Redux store is updated.</p> </li> <li> <p>Persisting State: Redux Persist automatically saves the state to storage whenever it changes, so your application can restore that state on the next load.</p> </li> <li> <p>UI Update: The components that are connected to the Redux store will re-render based on the updated state.</p> </li> </ol> <p>Conclusion</p> <p>By following these steps, you can set up Redux with persistence in your React application using Redux Toolkit and Redux Persist. This workflow helps maintain application state across reloads, improving user experience and state management.</p>"},{"location":"state-management/redux/persist/redux-persist/#blacklist-and-whitelist","title":"BlackList and WhiteList","text":"<p>To persist only certain parts of your Redux state using Redux Persist, you can use the <code>whitelist</code> and <code>blacklist</code> options in your persist configuration. This allows you to specify which slices of the state you want to persist or exclude.</p> <p>Whitelist and Blacklist</p> <ul> <li>Whitelist: An array of reducers that you want to persist. Only these reducers will be saved to storage.</li> <li>Blacklist: An array of reducers that you want to exclude from persistence. All other reducers will be persisted.</li> </ul>"},{"location":"state-management/redux/persist/redux-persist/#example-configuring-whitelist-and-blacklist","title":"Example: Configuring Whitelist and Blacklist","text":"<p>Here\u2019s how you can modify your <code>persistConfig</code> to include only specific slices of your state.</p> <ol> <li> <p>Using Whitelist:</p> <p>If you want to persist only specific reducers, you can set up your <code>persistConfig</code> like this:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"sidebar\"], // Only persist the sidebar slice\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> </li> <li> <p>Using Blacklist:</p> <p>If you want to persist everything except certain reducers, use the blacklist:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  blacklist: [\"someNonPersistedSlice\"], // Do not persist this slice\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> </li> </ol> <p>Best Practices</p> <ol> <li> <p>Decide What to Persist: Determine which slices of state are critical to persist. This is often user preferences, authentication tokens, or UI state (like whether a sidebar is collapsed).</p> </li> <li> <p>Use Whitelist: If you have a small number of reducers you want to persist, use the <code>whitelist</code> approach. It makes it clear what is being persisted.</p> </li> <li> <p>Use Blacklist: If you have a large number of reducers and want to exclude just a few, use <code>blacklist</code>. This keeps your configuration concise.</p> </li> <li> <p>Consider Size and Performance: Persisting large amounts of state can affect performance. Keep the persisted data minimal and relevant.</p> </li> <li> <p>Clear Old Data: Occasionally clear or reset persisted state if certain conditions are met (like user logout).</p> </li> </ol> <p>Example with Whitelist</p> <p>Here\u2019s a complete example to show how you might set up your <code>persistConfig.js</code>:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"sidebar\", \"user\"], // Persist only sidebar and user slices\n  // blacklist: ['someNonPersistedSlice'], // Alternatively, you could use blacklist\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> <p>Conclusion</p> <p>Using <code>whitelist</code> and <code>blacklist</code> provides flexibility in controlling which parts of your Redux state are persisted. By following best practices, you can ensure that only relevant data is stored, improving performance and maintaining a clean state management architecture.</p>"},{"location":"state-management/redux/persist/redux-store-subscribe/","title":"Subscribe","text":""},{"location":"state-management/redux/persist/redux-store-subscribe/#overview","title":"Overview","text":"<p>In Redux, <code>store.subscribe</code> is a method that allows you to listen for changes in the Redux store. When the state in the store changes, any function you've subscribed will be called. This is a core part of how Redux works, enabling components or other parts of your application to react to state changes.</p>"},{"location":"state-management/redux/persist/redux-store-subscribe/#usage-in-standard-redux-and-redux-toolkit","title":"Usage in Standard Redux and Redux Toolkit","text":"<p>Both standard Redux and Redux Toolkit (RTK) use <code>store.subscribe</code>. However, in RTK, you often interact with the store in a more abstracted way, utilizing hooks like <code>useSelector</code> and <code>useDispatch</code> that handle subscriptions under the hood.</p>"},{"location":"state-management/redux/persist/redux-store-subscribe/#when-to-use-storesubscribe","title":"When to Use <code>store.subscribe</code>","text":"<p>You generally use <code>store.subscribe</code> in the following scenarios:</p> <ol> <li> <p>Non-React Applications: In non-React apps or plain JavaScript, you might directly use store.subscribe to listen for state changes.</p> </li> <li> <p>Advanced Cases: If you need to perform side effects when the state changes, such as logging or syncing with an external API.</p> </li> <li> <p>Custom Subscriptions: For situations where you want to trigger an update or calculation based on specific state changes that aren't easily handled through React components.</p> </li> </ol>"},{"location":"state-management/redux/persist/redux-store-subscribe/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Unsubscribe: Always return a cleanup function from your subscription to avoid memory leaks. If your subscription is tied to a component's lifecycle, use it inside <code>useEffect</code> in React.</p> </li> <li> <p>Keep It Simple: Use <code>store.subscribe</code> only when necessary. In React applications, using hooks like <code>useSelector</code> is often more straightforward and leads to better-optimized re-renders.</p> </li> <li> <p>Limit Logic in Subscribers: Keep the logic within the subscription simple to avoid performance issues.</p> </li> </ol>"},{"location":"state-management/redux/persist/redux-store-subscribe/#real-example","title":"Real Example","text":"Standard ReduxRedux Toolkit Example <pre><code>import { createStore } from 'redux';\n\n// Reducer\nconst counter = (state = { count: 0 }, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    default:\n      return state;\n  }\n};\n\n// Create store\nconst store = createStore(counter);\n\n// Subscribe to store updates\nconst unsubscribe = store.subscribe(() =&gt; {\n  console.log('State changed:', store.getState());\n});\n\n// Dispatch actions\nstore.dispatch({ type: 'INCREMENT' });\nstore.dispatch({ type: 'INCREMENT' });\n\n// Unsubscribe when no longer needed\nunsubscribe();\n</code></pre> <p>In a React component using Redux Toolkit:</p> <pre><code>import React, { useEffect } from 'react';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\n// Create a slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { count: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.count += 1;\n    },\n  },\n});\n\nconst store = configureStore({ reducer: counterSlice.reducer });\n\n// React component\nconst Counter = () =&gt; {\n  useEffect(() =&gt; {\n    const unsubscribe = store.subscribe(() =&gt; {\n      console.log('State changed:', store.getState());\n    });\n    return () =&gt; unsubscribe(); // Cleanup on unmount\n  }, []);\n\n  const increment = () =&gt; {\n    store.dispatch(counterSlice.actions.increment());\n  };\n\n  return &lt;button onClick={increment}&gt;Increment&lt;/button&gt;;\n};\n\nexport default Counter;\n</code></pre>"},{"location":"state-management/redux/persist/redux-store-subscribe/#summary","title":"Summary","text":"<ul> <li><code>store.subscribe</code> is useful for listening to state changes in both standard Redux and Redux Toolkit.</li> <li>Prefer using hooks in React for easier management.</li> <li>Always manage subscriptions properly to avoid leaks and performance issues.</li> </ul>"},{"location":"state-management/redux/persist/redux-store-subscribe/#implementation","title":"Implementation","text":"<p>You can use <code>store.subscribe</code> in both standard Redux and Redux Toolkit. However, in most cases with Redux Toolkit, you may not need to use it directly because of the built-in features and patterns that Redux Toolkit provides, such as slices and thunks.</p>"},{"location":"state-management/redux/persist/redux-store-subscribe/#when-you-might-use-storesubscribe-in-redux-toolkit","title":"When You Might Use <code>store.subscribe</code> in Redux Toolkit","text":"<ol> <li> <p>Side Effects: If you have specific side effects that need to occur in response to state changes and are not covered by the existing middleware or thunk patterns, <code>store.subscribe</code> can be useful.</p> </li> <li> <p>External Libraries: If you need to update external libraries or components that aren't directly connected to your Redux store, subscribing to state changes can help.</p> </li> <li> <p>Debugging: It can still be useful for logging state changes during development or debugging.</p> </li> </ol>"},{"location":"state-management/redux/persist/redux-store-subscribe/#example-in-redux-toolkit","title":"Example in Redux Toolkit","text":"<p>Here's a simple example of using <code>store.subscribe</code> in a Redux Toolkit setup:</p> store.js<pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport rootReducer from \"./rootReducer\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n});\n\n// Subscribe to store updates\nconst unsubscribe = store.subscribe(() =&gt; {\n  console.log(\"State updated:\", store.getState());\n});\n\n// Dispatch actions\nstore.dispatch({ type: \"SOME_ACTION\" });\n\n// Unsubscribe when needed\n// unsubscribe();\n</code></pre>"},{"location":"state-management/redux/persist/redux-store-subscribe/#conclusion","title":"Conclusion","text":"<p>While you can use <code>store.subscribe</code> with Redux Toolkit, it's often not necessary due to the framework's design that encourages using thunks and slices for handling side effects and state management. If your use case requires direct subscriptions, it's perfectly fine to use it as needed. Just remember to manage performance and memory properly.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/","title":"rtkquery","text":"<ul> <li>How to Use Redux Persist in React Applications</li> </ul>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#overview","title":"Overview","text":"<p>is the redux tookit and rtk query is different or same</p> <p>Redux Toolkit and RTK Query are related but serve different purposes within the Redux ecosystem.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"<ul> <li>Purpose: It is the official, recommended way to write Redux logic. It simplifies store setup, reduces boilerplate, and provides a set of best practices.</li> <li>Features: Includes utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and built-in support for immutability with <code>Immer</code>.</li> </ul>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#rtk-query","title":"RTK Query","text":"<ul> <li>Purpose: It is a powerful data fetching and caching library that is included with Redux Toolkit. It simplifies managing server-side data in your Redux store.</li> <li>Features: Provides tools for making API calls, caching responses, and automatically updating your store based on server responses.</li> </ul> <p>In summary, Redux Toolkit is the overall framework for Redux development, while RTK Query is a specific tool within it designed for handling asynchronous data fetching.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#using-both-together","title":"Using Both Together","text":"<p>can we mix both in same app or not</p> <p>Yes, you can definitely mix both Redux Toolkit and RTK Query in the same application! In fact, they are designed to work together seamlessly.</p> How to Use Them Together:Benefits of Mixing: <ul> <li>Set Up Redux Toolkit: Start by setting up your Redux store using Redux Toolkit, which can include slices and reducers as needed.</li> <li>Integrate RTK Query: Use RTK Query to manage API calls. You can define API slices using <code>createApi</code>, which allows you to fetch, cache, and manage server data effectively.</li> </ul> <ul> <li>Simplified State Management: Use Redux Toolkit for general state management and RTK Query for server-side data, leading to cleaner and more maintainable code.</li> <li>Optimized Performance: RTK Query handles caching and updates, reducing the need for manual state management and ensuring your UI stays in sync with your data.</li> </ul> <p>Overall, using both together can lead to a more efficient and organized application structure.</p> <p></p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#example-1-using-redux-toolkit-with-rtk-quer","title":"Example 1: Using Redux Toolkit with RTK Quer","text":"store.jsapiSlice.jsPosts.js <p>Setting Up the Redux Store</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { apiSlice } from './apiSlice'; // Import the RTK Query API slice\nimport counterReducer from './counterSlice'; // Import a regular slice\n\nconst store = configureStore({\nreducer: {\n    [apiSlice.reducerPath]: apiSlice.reducer, // Add the RTK Query reducer\n    counter: counterReducer,\n},\nmiddleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(apiSlice.middleware), // Add the RTK Query middleware\n});\n\nexport default store;\n</code></pre> <p>Creating an RTK Query API Slice</p> <pre><code>// apiSlice.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }), // Replace with your API URL\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n        query: () =&gt; 'posts', // Endpoint for fetching posts\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = apiSlice; // Export the hook for using the query\n</code></pre> <p>Using the RTK Query in a Component</p> <pre><code>// Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from './apiSlice';\n\nconst Posts = () =&gt; {\n    const { data: posts, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n            {posts.map(post =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default Posts;\n</code></pre>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#example-2-using-redux-toolkit-without-rtk-query","title":"Example 2: Using Redux Toolkit Without RTK Query","text":"store.jscounterSlice.jsCounter.js <p>Setting Up the Redux Store</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> <p>Creating a Regular Slice</p> <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: 0,\n    reducers: {\n        increment: (state) =&gt; state + 1,\n        decrement: (state) =&gt; state - 1,\n    },\n});\n\nexport const { increment, decrement } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <p>Using the Redux State in a Component</p> <pre><code>// Counter.js\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { increment, decrement } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <p>Summary</p> <ul> <li>The first example shows how to use both Redux Toolkit and RTK Query together to fetch and manage data from an API.</li> <li>The second example demonstrates how to use just Redux Toolkit for local state management without any asynchronous data fetching.</li> </ul>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#question-1","title":"Question 1:","text":"<p>Can we use RTK Query with traditional Redux (without Redux Toolkit)?</p> <p>Answer:</p> <p>No, RTK Query is specifically designed to work with Redux Toolkit and relies on its APIs and features. It cannot be directly integrated into a traditional Redux setup without the Redux Toolkit.</p> <p>Explanation:</p> <ul> <li>RTK Query is part of Redux Toolkit and uses its constructs, like <code>createSlice</code> and middleware, to manage API calls, caching, and updates to the Redux store.</li> <li>If you're using traditional Redux (without Redux Toolkit), you would need to implement your own data fetching and state management logic, typically involving more boilerplate code.</li> </ul> <p>Alternative for Traditional Redux:</p> <p>If you're using traditional Redux and want to handle API calls, you might consider using libraries like:</p> <ul> <li>redux-thunk: For handling asynchronous logic in your action creators.</li> <li>redux-saga: For more complex side effects and asynchronous workflows.</li> </ul> <p>These alternatives can help manage API interactions, but they won't offer the same level of integration and simplicity that RTK Query provides within the Redux Toolkit.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#question-2","title":"Question 2:","text":"<p>How do we persist data in Redux Toolkit and RTK Query? Is the approach the same or different?</p> <p>Answer:</p> <p>The approaches to persisting data in Redux Toolkit and RTK Query are different, primarily due to their distinct purposes and functionalities.</p> <p>Explanation:</p> Persisting Data in Redux Toolkit:Persisting Data in RTK Query: <ol> <li> <p>Manual Persistence: You can manually persist your Redux state using libraries like redux-persist. This allows you to store part of your Redux state in local storage or other storage mechanisms.</p> <ul> <li>Setup: Integrate redux-persist with your Redux store.</li> <li>Configuration: Define which slices of state you want to persist.</li> </ul> <pre><code>import { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // defaults to localStorage\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nconst persistConfig = {\n    key: 'root',\n    storage,\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nconst store = configureStore({\n    reducer: persistedReducer,\n});\n\nexport const persistor = persistStore(store);\n</code></pre> </li> <li> <p>State Management: You manage the persisted state using Redux Toolkit slices and reducers.</p> </li> </ol> <ol> <li> <p>Automatic Caching: RTK Query automatically caches API responses in the Redux store. You can configure how long data should remain in the cache.</p> <ul> <li>Configuration: You can use <code>keepUnusedDataFor</code> and other cache-related settings in your API slice.</li> </ul> <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n        query: () =&gt; 'posts',\n            keepUnusedDataFor: 60, // Cache for 60 seconds\n        }),\n    }),\n});\n</code></pre> </li> <li> <p>No Manual Persistence: Unlike Redux Toolkit, RTK Query doesn't require additional libraries for persistence, as it handles caching internally.</p> </li> </ol> <p>Summary:</p> <ul> <li>Redux Toolkit: You typically use a library like redux-persist to persist your state manually.</li> <li>RTK Query: It handles caching and persistence of API data automatically, but it doesn't persist data across sessions without additional setup.</li> </ul> <p>Thus, while both can handle data persistence, the methods and complexities involved are different.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#clear-persist","title":"Clear Persist","text":"<p>Is it standard practice to clear Redux Persist data on user logout?</p> <p>The standard practice is indeed to clear the persisted state when a user logs out. This ensures that sensitive user data is not retained and prevents unauthorized access if a different user logs in afterward.</p> <p>To do this, you can use Redux Persist's <code>purge</code> method to clear the stored state in local storage or wherever it's persisted. This can be done in your logout action or in a middleware that listens for logout events.</p> <p>Overall, clearing the persisted state on logout is a good security measure and helps maintain a clean application state.</p>"},{"location":"state-management/redux/persist/reduxtoolkit-and-rtkquery/#reference","title":"Reference","text":"<ul> <li>Persistence and Rehydration</li> <li>How to configure redux-persist with redux-toolkit?</li> <li>Setting up Redux Tool Kit (RTK), Redux and Redux-Persist for React.</li> <li>Persisting State in Your React App with Redux-Persist</li> <li>How to Use Redux Persist in React Applications</li> <li>React: API Response Validation</li> <li>The Most Powerful Tool for Redux Management \u2014 @reduxjs/toolkit!</li> </ul>"},{"location":"state-management/redux/rtk/core-vs-query/","title":"Core vs Query","text":""},{"location":"state-management/redux/rtk/core-vs-query/#overview","title":"Overview","text":"<p>RTK Core and RTK Query are related but they refer to different aspects of Redux Toolkit (RTK).</p>"},{"location":"state-management/redux/rtk/core-vs-query/#1-rtk-core","title":"1. RTK Core","text":"<p>RTK Core refers to the central part of Redux Toolkit (RTK), which is the official toolset for efficient Redux development. RTK Core includes the main utilities to work with Redux, such as:</p> <ul> <li><code>configureStore</code>: A helper function to set up a Redux store.</li> <li><code>createSlice</code>: A function to simplify the creation of Redux reducers and actions.</li> <li><code>createAsyncThunk</code>: A function for handling async logic and dispatching actions based on async outcomes.</li> <li><code>createReducer</code>: A utility for handling reducers in a more declarative way.</li> <li><code>createAction</code>: A utility to define Redux action creators.</li> </ul> <p>RTK Core provides foundational tools for managing global state in a Redux store.</p>"},{"location":"state-management/redux/rtk/core-vs-query/#2-rtk-query","title":"2. RTK Query","text":"<p>RTK Query is a set of tools and utilities built on top of Redux Toolkit to simplify data fetching and caching. It is an advanced feature of RTK that aims to reduce the need for boilerplate code when working with APIs. RTK Query provides tools for:</p> <ul> <li>Fetching data from APIs (via <code>createApi</code>).</li> <li>Caching and automatic re-fetching (with built-in cache management and re-fetching policies).</li> <li>Managing loading, success, and error states.</li> <li>Optimizing performance by avoiding unnecessary requests (through caching).</li> <li>Automatic Redux slice generation for API calls.</li> </ul> <p>RTK Query integrates deeply with Redux Toolkit, providing a more structured and efficient way to handle API interactions compared to traditional approaches in Redux.</p>"},{"location":"state-management/redux/rtk/core-vs-query/#key-differences","title":"Key Differences:","text":"<ul> <li>RTK Core is the main library for setting up and managing the Redux store, reducers, actions, and state logic.</li> <li>RTK Query is an add-on (a part of RTK) specifically for handling server-side data fetching and caching, reducing the complexity of managing API requests and responses.</li> </ul>"},{"location":"state-management/redux/rtk/core-vs-query/#in-short","title":"In short:","text":"<ul> <li>RTK Core is the foundational Redux Toolkit library.</li> <li>RTK Query is a specific extension for managing API requests, built on top of RTK Core.</li> </ul> <p>While both are part of the same Redux Toolkit ecosystem, RTK Query builds on RTK Core to handle a particular use case (data fetching and caching).</p> Tip <ul> <li>Use RTK Core if you\u2019re managing local state or custom logic that doesn\u2019t involve interacting with external APIs or server data.</li> <li>Use RTK Query if your app needs to interact with external APIs, manage complex server-side state, and benefit from features like caching, automatic refetching, and request deduplication.</li> </ul> <p>In most modern web applications that involve both local state and server-side data fetching, you'll likely end up using both RTK Core (for managing app state) and RTK Query (for handling API interactions) together.</p>"},{"location":"state-management/redux/rtk/intro/","title":"Intro","text":"<pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre>"},{"location":"state-management/redux/rtk/intro/#authorization","title":"Authorization","text":"<p>Implementing login and authorization in a React application can be achieved through various libraries and techniques. Here's a step-by-step guide using common libraries like <code>redux</code>, <code>redux-toolkit</code>, <code>react-router</code>, and <code>jwt-decode</code>.</p>"},{"location":"state-management/redux/rtk/intro/#libraries-to-use","title":"Libraries to Use","text":"<ol> <li>React Router: For handling routing.</li> <li>Redux/Redux Toolkit: For state management.</li> <li>Axios: For making API requests.</li> <li>JWT-decode: For decoding JSON Web Tokens.</li> <li>React Hook Form: For handling form state.</li> </ol>"},{"location":"state-management/redux/rtk/intro/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"InstallationStoreSliceComponentRouteRoutingSummary <ol> <li> <p>Setting Up Your Project</p> <p>Install the necessary packages:</p> <pre><code>npm install react-router-dom @reduxjs/toolkit react-redux axios jwt-decode react-hook-form\n</code></pre> </li> </ol> <ol> <li> <p>Configure Redux Store</p> <p>Set up a Redux store with slices for authentication.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport authReducer from \"./features/auth/authSlice\";\n\nexport const store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n</code></pre> </li> </ol> <ol> <li> <p>Create Authentication Slice</p> <p>Create a slice for authentication state management.</p> <pre><code>// features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport jwt_decode from \"jwt-decode\";\n\nconst initialState = {\n    token: localStorage.getItem(\"token\") || null,\n    user: localStorage.getItem(\"token\")\n        ? jwt_decode(localStorage.getItem(\"token\"))\n        : null,\n    status: \"idle\",\n    error: null,\n};\n\nexport const login = createAsyncThunk(\"auth/login\", async (credentials) =&gt; {\n    const response = await axios.post(\"/api/auth/login\", credentials);\n    return response.data.token;\n});\n\nconst authSlice = createSlice({\n    name: \"auth\",\n    initialState,\n    reducers: {\n        logout: (state) =&gt; {\n            state.token = null;\n            state.user = null;\n            localStorage.removeItem(\"token\");\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = \"loading\";\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = \"succeeded\";\n            state.token = action.payload;\n            state.user = jwt_decode(action.payload);\n            localStorage.setItem(\"token\", action.payload);\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = \"failed\";\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Create Login Component</p> <p>Create a component for the login form using react-hook-form.</p> <pre><code>// components/Login.js\nimport React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useForm } from \"react-hook-form\";\nimport { login } from \"../features/auth/authSlice\";\nimport { Redirect } from \"react-router-dom\";\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const { register, handleSubmit } = useForm();\n    const { token, error, status } = useSelector((state) =&gt; state.auth);\n\n    const onSubmit = (data) =&gt; {\n        dispatch(login(data));\n    };\n\n    if (token) {\n        return &lt;Redirect to=\"/\" /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n        &lt;h2&gt;Login&lt;/h2&gt;\n\n        &lt;form onSubmit={handleSubmit(onSubmit)}&gt;\n            &lt;div&gt;\n            &lt;label&gt;Email:&lt;/label&gt;\n            &lt;input type=\"email\" {...register(\"email\")} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n            &lt;label&gt;Password:&lt;/label&gt;\n            &lt;input type=\"password\" {...register(\"password\")} /&gt;\n            &lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n\n        {status === \"loading\" &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n        {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> </ol> <ol> <li> <p>Protect Routes</p> <p>Create a higher-order component (HOC) to protect routes.</p> <pre><code>// components/PrivateRoute.js\nimport React from \"react\";\nimport { Route, Redirect } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const token = useSelector((state) =&gt; state.auth.token);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Routing</p> <p>Configure routing in your application using React Router.</p> <pre><code>// App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./store\";\nimport Login from \"./components/Login\";\nimport PrivateRoute from \"./components/PrivateRoute\";\nimport Home from \"./components/Home\";\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n                &lt;Route path=\"/login\" component={Login} /&gt;\n                &lt;PrivateRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol> <ol> <li>Setup Redux store: Configure the store with <code>redux-toolkit</code>.</li> <li>Create auth slice: Manage authentication state with a slice.</li> <li>Login component: Use <code>react-hook-form</code>for handling the login form.</li> <li>Protect routes: Use a higher-order component to protect routes.</li> <li>Configure routing: Set up routing with React Router.</li> </ol> <p>By using these tools and techniques, you can implement robust login and authorization mechanisms in your React application.</p>"},{"location":"state-management/redux/rtk/intro/#which-one-to-choose","title":"Which one to choose?","text":"<ul> <li>Standard Redux is still usable and maintained but involves more boilerplate and manual configuration.</li> <li>Redux Toolkit (RTK) is recommended for new projects as it simplifies Redux setup, encourages best practices, and provides tools to reduce boilerplate.</li> </ul> <p>If you are starting a new project or maintaining an existing one, it is highly advisable to use Redux Toolkit for a better development experience.</p>"},{"location":"state-management/redux/rtk/intro/#predefined-functions-in-redux-toolkit","title":"Predefined Functions in Redux Toolkit","text":"<p>Yes, the items I listed are predefined functions and utilities provided by Redux Toolkit. They are not classes in the traditional object-oriented sense but rather functions that help you implement Redux logic more easily and with less boilerplate code. Here\u2019s a quick recap:</p> <ol> <li><code>configureStore</code>: A function to create a Redux store with default middleware and settings.</li> <li><code>createSlice</code>: A utility that simplifies the process of writing reducers and actions in a single declaration.</li> <li><code>createAsyncThunk</code>: A function to handle asynchronous operations and automatically manage action dispatching for the lifecycle of a promise.</li> <li><code>createEntityAdapter</code>: A utility for managing collections of entities in a normalized format, providing methods for CRUD operations.</li> <li><code>createSelector</code>: A function to create memoized selectors for efficiently deriving and accessing state.</li> <li><code>createReducer</code>: A function to create reducers with a simpler syntax, allowing for mutative state updates.</li> <li><code>createAction</code>: A function to create action creators that return action objects.</li> </ol> <p>These functions are part of the Redux Toolkit library and are designed to enhance the Redux experience by reducing boilerplate, promoting best practices, and making it easier to manage state in applications.</p>"},{"location":"state-management/redux/rtk/query/anatomy-of-rtkquery/","title":"Anatomy of rtkQuery","text":"<p>fasdfsdf</p>"},{"location":"state-management/redux/rtk/query/anatomy-of-rtkquery/#onquerystarted","title":"onQueryStarted","text":"<p><code>onQueryStarted</code> is a lifecycle hook provided by RTK Query (part of Redux Toolkit) that allows you to run custom logic before or during the execution of a query or mutation. It's an advanced feature for cases when you need to interact with the Redux state or perform additional side effects as part of the API call process.</p> Key Points about <code>onQueryStarted</code> <ul> <li> <p>Purpose: <code>onQueryStarted</code> is primarily used to trigger side effects (like optimistic updates, cache manipulation, logging, etc.) at the start of an API call before the query or mutation actually completes.</p> </li> <li> <p>Context: It's available within both queries and mutations that are defined with the <code>createApi</code> function in RTK Query.</p> </li> <li> <p>Arguments: <code>onQueryStarted</code> receives the following arguments:</p> <ul> <li><code>arg</code>: The argument passed to the query or mutation.</li> <li><code>api</code>: The API slice instance.</li> <li><code>dispatch</code>: The Redux <code>dispatch</code> function, which allows you to dispatch actions to the Redux store.</li> <li><code>queryFulfilled</code>: A promise that resolves when the query or mutation is successfully completed. You can use this to await the successful completion or failure of the operation.</li> </ul> </li> </ul> Signature<pre><code>onQueryStarted: async (arg, { dispatch, queryFulfilled }) =&gt; {\n  // Your custom logic here\n};\n</code></pre> <p>Example 1: Optimistic Updates with <code>onQueryStarted</code></p> <p>In this example, we use <code>onQueryStarted</code> to optimistically update a post's title before the server responds to the mutation:</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    fetchPosts: builder.query({\n      query: () =&gt; \"posts\",\n    }),\n    updatePost: builder.mutation({\n      query: (post) =&gt; ({\n        url: `posts/${post.id}`,\n        method: \"PUT\",\n        body: post,\n      }),\n      // Using onQueryStarted for optimistic updates\n      onQueryStarted: async (arg, { dispatch, queryFulfilled }) =&gt; {\n        // Optimistic update\n        const patchResult = dispatch(\n          api.util.updateQueryData(\"fetchPosts\", undefined, (draft) =&gt; {\n            // Find the post to update optimistically\n            const postIndex = draft.findIndex((p) =&gt; p.id === arg.id);\n            if (postIndex !== -1) {\n              draft[postIndex] = { ...draft[postIndex], ...arg };\n            }\n          })\n        );\n\n        // Wait for the mutation to complete\n        try {\n          await queryFulfilled; // Wait for success\n        } catch (error) {\n          // Rollback the optimistic update if the mutation fails\n          patchResult.undo();\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useFetchPostsQuery, useUpdatePostMutation } = api;\n</code></pre> <p>In this example:</p> <ul> <li>Optimistic update: We optimistically update the post in the local cache before the mutation is actually completed.</li> <li><code>patchResult.undo()</code>: If the mutation fails, we undo the optimistic update and revert the cache to its previous state.</li> </ul> Key Concepts: <ul> <li> <p><code>queryFulfilled</code>: This is a promise that resolves once the query or mutation completes successfully. It represents the final state of the query after it has been executed. If the query or mutation fails, it throws an error.</p> </li> <li> <p><code>dispatch</code>: You can dispatch Redux actions within <code>onQueryStarted</code>, enabling you to manipulate the state or trigger other actions (like optimistic updates or logging).</p> </li> <li> <p><code>undo()</code>: This function is used to revert any optimistic changes if the mutation fails.</p> </li> </ul>"},{"location":"state-management/redux/rtk/query/anatomy-of-rtkquery/#what-is-apiutilupdatequerydata-in-rtk-query","title":"What is <code>api.util.updateQueryData</code> in RTK Query?","text":"<p>Yes, <code>api.util.updateQueryData</code> is built-in to RTK Query. It\u2019s a utility function provided by RTK Query\u2019s api slice, and it allows you to optimistically update the cache for a specific query without having to wait for the network response.</p> Syntax of updateQueryData<pre><code>api.util.updateQueryData(queryName, arg, patch);\n</code></pre> <ul> <li><code>queryName</code>: The name of the query you're updating.</li> <li><code>arg</code>: The argument passed to the query when it was originally requested. In most cases, this will be undefined if the query doesn't take any arguments or a specific parameter to identify the cached data.</li> <li><code>patch</code>: A function that receives a draft of the cached data (via Immer). You modify this draft, and Immer takes care of applying those changes immutably.</li> </ul> When to Use undefined? <p>The second argument (<code>undefined</code> in your case) is used when the query doesn't require any parameters to fetch the data. If the query takes parameters (e.g., an ID or a search term), you would pass the argument that you used when the query was initially dispatched.</p> Without argumentsWith arguments <p>Without arguments (undefined)</p> <pre><code>api.util.updateQueryData(\"fetchPosts\", undefined, (draft) =&gt; {\n    // Modify the draft cache for fetchPosts (without arguments)\n    draft.push(newPost);\n});\n</code></pre> <p>With arguments (e.g., for updating a single post by ID):</p> <pre><code>api.util.updateQueryData(\"fetchPostById\", postId, (draft) =&gt; {\n    // Update the specific post with `postId`\n    const post = draft.find(p =&gt; p.id === postId);\n\n    if (post) {\n        post.content = updatedContent; // Modify the specific post\n    }\n});\n</code></pre>"},{"location":"state-management/redux/rtk/query/anatomy-of-rtkquery/#reference","title":"Reference","text":"<ul> <li> <p>A Beginner\u2019s Guide to Redux Toolkit Query/RTK Query</p> </li> <li> <p>optimistic-updates: official</p> </li> </ul>"},{"location":"state-management/redux/rtk/query/intro/","title":"Intro","text":""},{"location":"state-management/redux/rtk/query/intro/#query","title":"Query","text":"<p>RTK Query (Redux Toolkit Query) is a powerful data fetching and caching tool that is integrated into Redux Toolkit, simplifying the process of managing server-side data in your React applications. It's designed to eliminate the need for manually writing action creators, reducers, and thunks for common operations like fetching, caching, and synchronizing data.</p> <p>Here\u2019s a basic overview of how to use RTK Query in a React application:</p>"},{"location":"state-management/redux/rtk/query/intro/#1-install-redux-toolkit","title":"1. Install Redux Toolkit","text":"<p>If you haven't already, start by installing Redux Toolkit:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre>"},{"location":"state-management/redux/rtk/query/intro/#2-create-an-api-service","title":"2. Create an API Service","text":"<p>The first step is to define an API service using createApi from RTK Query. This service will describe how to interact with your backend.</p> ExampleExplanation <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// Define your API service\nconst api = createApi({\n    reducerPath: 'api',  // unique name for the reducer\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://api.example.com/' }),  // API base URL\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; 'posts',  // Fetches the 'posts' endpoint\n        }),\n        getPostById: builder.query({\n            query: (id) =&gt; `posts/${id}`,  // Fetches a single post by ID\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery, useGetPostByIdQuery } = api; // Export the generated hooks\nexport default api;\n</code></pre> <p>In the example above:</p> <ul> <li><code>createApi</code> creates the service.</li> <li><code>fetchBaseQuery</code> is a utility function that simplifies the base API URL setup.</li> <li><code>endpoints</code> defines different API endpoints and their corresponding queries or mutations.</li> <li><code>useGetPostsQuery</code> and <code>useGetPostByIdQuery</code> are hooks automatically generated by RTK Query for fetching data.</li> </ul>"},{"location":"state-management/redux/rtk/query/intro/#3-set-up-the-redux-store","title":"3. Set Up the Redux Store","text":"<p>Next, integrate the API service into your Redux store.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport api from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer, // Add the API reducer to the store\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Add API middleware\n});\n\nexport default store;\n</code></pre>"},{"location":"state-management/redux/rtk/query/intro/#4-provide-the-redux-store-to-your-application","title":"4. Provide the Redux Store to Your Application","text":"<p>Make sure you wrap your root component with the <code>Provider</code> from react-redux and pass it the store.</p> <pre><code>// index.js or App.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport App from \"./App\";\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre>"},{"location":"state-management/redux/rtk/query/intro/#5-use-the-generated-hooks-in-your-components","title":"5. Use the Generated Hooks in Your Components","text":"<p>Finally, use the automatically generated hooks inside your React components to fetch data.</p> ExampleExplanation <pre><code>// PostsList.js\nimport React from 'react';\nimport { useGetPostsQuery } from './services/api';\n\nconst PostsList = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error loading posts: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default PostsList;\n</code></pre> <p>In this component:</p> <ul> <li><code>useGetPostsQuery</code> is the hook generated by RTK Query.</li> <li>The hook returns an object with <code>data</code>, <code>error</code>, and <code>isLoading</code> properties that help you manage loading and error states.</li> </ul>"},{"location":"state-management/redux/rtk/query/intro/#6-running-the-app","title":"6. Running the App","text":"<p>Once everything is set up, your app should now be able to fetch data from your API and display it in your components. RTK Query will automatically cache the data, and handle re-fetching as necessary when the data changes.</p>"},{"location":"state-management/redux/rtk/query/intro/#conclusion","title":"Conclusion","text":"<p>RTK Query simplifies API data fetching by providing:</p> <ul> <li>Automatic caching and synchronization</li> <li>Reduced boilerplate code</li> <li>Built-in error and loading state management</li> </ul> <p>This is just a basic overview, but RTK Query also supports mutations (for creating/updating data), pagination, optimistic updates, and more advanced features like custom queries or caching strategies. You can refer to the official documentation for more detailed information.</p>"},{"location":"state-management/redux/rtk/query/intro/#question","title":"Question","text":"<p>Where do the names like <code>useGetPostsQuery</code> and <code>useCreatePostMutation</code> come from, and is it possible to change them?</p> <p>The names like <code>useGetPostsQuery</code> and <code>useCreatePostMutation</code> are auto-generated based on the endpoint name and the type of request (GET, POST, PUT, DELETE, etc.) that you define in your API slice with RTK Query.</p> Naming Convention Breakdown <ol> <li> <p>Base Name:</p> <ul> <li>The first part of the name (e.g., <code>useGetPosts</code> or <code>useCreatePost</code>) corresponds to the name of the endpoint you define in your <code>createApi</code> service. This is the key part that defines the operation you're performing (GET, POST, etc.) and the resource you're interacting with.</li> </ul> </li> <li> <p>Operation Type:</p> <ul> <li>If the endpoint is a GET request, the generated hook will have a suffix of <code>Query</code> (e.g., <code>useGetPostsQuery</code>).</li> <li>If the endpoint is a POST, PUT, or PATCH request (i.e., mutations), the generated hook will have a suffix of <code>Mutation</code> (e.g., <code>useCreatePostMutation</code>).</li> </ul> </li> </ol> Example Example API ServiceHow the Names are Generated <p>Let's look at an example API service to understand how these names are generated.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n    reducerPath: \"api\",\n    baseQuery: fetchBaseQuery({\n        baseUrl: \"https://jsonplaceholder.typicode.com/\",\n    }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; \"posts\", // GET request endpoint\n        }),\n        createPost: builder.mutation({\n            query: (newPost) =&gt; ({\n                url: \"posts\",\n                method: \"POST\",\n                body: newPost,\n            }), // POST request endpoint\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = api;\nexport default api;\n</code></pre> <p>In this case:</p> <ol> <li> <p><code>getPosts</code> is the endpoint name (a <code>query</code> for a GET request).</p> <ul> <li>The generated hook will be named useGetPostsQuery.</li> <li>The hook follows this pattern:     <code>use&lt;endpoint name&gt;Query</code></li> </ul> </li> <li> <p><code>createPost</code> is the endpoint name (a <code>mutation</code> for a POST request).</p> <ul> <li>The generated hook will be named useCreatePostMutation.</li> <li>The hook follows this pattern:     <code>use&lt;endpoint name&gt;Mutation</code></li> </ul> </li> </ol> <p>Can You Customize the Hook Names?</p> <p>By default, RTK Query uses this automatic naming convention, but you can customize the names if needed.</p> <ul> <li>You can change the name of the hook directly by renaming the function in the export.</li> </ul> Example ExampleExplanation <p>For example, if you want to change the names of the hooks to something more specific:</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n    reducerPath: \"api\",\n    baseQuery: fetchBaseQuery({\n        baseUrl: \"https://jsonplaceholder.typicode.com/\",\n    }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; \"posts\",\n        }),\n        createPost: builder.mutation({\n            query: (newPost) =&gt; ({\n                url: \"posts\",\n                method: \"POST\",\n                body: newPost,\n            }),\n        }),\n    }),\n});\n\nexport const {\n    useGetPostsQuery: useFetchPosts,\n    useCreatePostMutation: useSubmitPost,\n} = api;\nexport default api;\n</code></pre> <p>In this example:</p> <ul> <li><code>useGetPostsQuery</code> is renamed to <code>useFetchPosts</code>.</li> <li><code>useCreatePostMutation</code> is renamed to <code>useSubmitPost</code>.</li> </ul> <p>You can name the hooks whatever you like, but it's recommended to follow a consistent naming pattern that reflects the action and type of the request for clarity and maintainability.</p> <p>Recap of Naming Pattern</p> <ul> <li><code>use&lt;endpoint name&gt;Query</code>: For GET requests (queries).</li> <li><code>use&lt;endpoint name&gt;Mutation</code>: For POST, PUT, PATCH, or DELETE requests (mutations).</li> </ul> <p>Example:</p> <p>Given these endpoints:</p> <pre><code>endpoints: (builder) =&gt; ({\n  getPosts: builder.query({ query: () =&gt; \"posts\" }),\n  createPost: builder.mutation({\n    query: (newPost) =&gt; ({ url: \"posts\", method: \"POST\", body: newPost }),\n  }),\n});\n</code></pre> <ul> <li>The GET request hook will be <code>useGetPostsQuery</code> by default (or any name you choose).</li> <li>The POST request hook will be <code>useCreatePostMutation</code> by default (or any name you choose).</li> </ul> <p>You can customize these names, but the default pattern helps maintain consistency in your codebase</p>"},{"location":"state-management/redux/rtk/query/mnemonic/","title":"Mnemonics","text":"<p>To remember how RTK Query (Redux Toolkit Query) works, you can use a mnemonic that focuses on the key concepts:</p>"},{"location":"state-management/redux/rtk/query/mnemonic/#mnemonic-create","title":"Mnemonic: \"C.R.E.A.T.E.\"","text":"<p>Each letter represents an essential part of RTK Query's functionality:</p> <ul> <li>C \u2013 Create API Service:</li> </ul> <p>The first step is to define your API service using <code>createApi()</code>. This is where you define the base URL, endpoints, and how to fetch data.</p> <ul> <li>R \u2013 Reducers Automatically Generated:</li> </ul> <p>RTK Query automatically generates reducers for the API service, handling the state (loading, success, error) of each query or mutation.</p> <ul> <li>E \u2013 Endpoints:</li> </ul> <p>Endpoints are key actions inside the API slice. These define the different operations like <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc., that the API will perform. Each endpoint is a function, and it defines how to fetch or mutate data.</p> <ul> <li>A \u2013 Async Thunks:</li> </ul> <p>RTK Query generates async thunks for you automatically. These thunks handle dispatching actions, calling the API, and managing the loading, success, and error states.</p> <ul> <li>T \u2013 Transform Response:</li> </ul> <p>RTK Query allows you to transform the response data before it's added to the Redux store using <code>transformResponse</code>. This is useful for manipulating or formatting data as it comes from the server.</p> <ul> <li>E \u2013 ExtraReducers:</li> </ul> <p>You can add custom logic to handle API responses or integrate with other slices using <code>extraReducers</code>. This gives you flexibility beyond the auto-generated reducers.</p>"},{"location":"state-management/redux/rtk/query/mnemonic/#full-explanation","title":"Full Explanation:","text":"<ul> <li>Create an API service: Set up the API service using <code>createApi()</code>, which includes base URL and endpoints.</li> <li>Reducers for data management: Redux Toolkit will create reducers for you, managing loading, success, and error states.</li> <li>Endpoints: Define the API operations like GET, POST, etc., with specific parameters and transformations.</li> <li>Async thunks: Automatically generated thunks (async actions) that will make the API calls and update Redux state.</li> <li>Transform response: You can modify the server response before it's stored in Redux.</li> <li>Extra reducers: Add custom logic or additional handlers for specific actions beyond the defaults provided.</li> </ul> <p>By using \"C.R.E.A.T.E.\" as a mnemonic, you can easily remember the essential concepts when working with RTK Query.</p>"},{"location":"state-management/redux/rtk/query/mnemonic/#step-by-step-example-of-rtk-query","title":"Step-by-Step Example of RTK Query","text":"<p>1. Create an API Service</p> <p>First, we'll define the API service using <code>createApi</code> from Redux Toolkit.</p> <pre><code>// src/services/postsApi.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\", // Name of the slice\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }), // Base URL of the API\n  endpoints: (builder) =&gt; ({\n    // Define an endpoint for fetching posts\n    getPosts: builder.query({\n      query: () =&gt; \"posts\", // API call to fetch posts\n    }),\n    // Define an endpoint for creating a new post\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = postsApi;\n</code></pre> <p>2. Reducers Automatically Generated</p> <p>RTK Query will automatically generate the reducers for the API service defined in <code>postsApi</code>. This includes reducers for handling the loading, success, and error states.</p> <p>In your Redux store setup, you will add <code>postsApi.reducer</code> as a slice of the store:</p> <pre><code>// src/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { postsApi } from \"./services/postsApi\";\n\nexport const store = configureStore({\n  reducer: {\n    // Add the API reducer to the store\n    [postsApi.reducerPath]: postsApi.reducer,\n  },\n  // Adding the api middleware enables caching, invalidation, polling, and other features of RTK Query\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(postsApi.middleware),\n});\n</code></pre> <p>3. Endpoints</p> <p>Endpoints define how to interact with the API (such as fetching data or creating new resources). In the example above, we defined two endpoints:</p> <ul> <li><code>getPosts</code> (for fetching posts)</li> <li><code>createPost</code> (for creating a new post)</li> </ul> <p>These endpoints are used in your components using the automatically generated hooks.</p> <p>4. Async Thunks</p> <p>RTK Query automatically creates async thunks for you. When you use the <code>useGetPostsQuery</code> hook, it dispatches an action to fetch the posts, and internally manages the loading, success, and error states for you.</p> <p>Example of using the <code>useGetPostsQuery</code> hook to fetch posts in a component:</p> <pre><code>// src/components/PostList.js\nimport React from \"react\";\nimport { useGetPostsQuery } from \"../services/postsApi\";\n\nconst PostList = () =&gt; {\n  const { data, error, isLoading } = useGetPostsQuery();\n\n  if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Posts&lt;/h1&gt;\n      &lt;ul&gt;\n        {data.map((post) =&gt; (\n          &lt;li key={post.id}&gt;\n            &lt;h3&gt;{post.title}&lt;/h3&gt;\n            &lt;p&gt;{post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default PostList;\n</code></pre> <p>5. Transform Response</p> <p>You can transform the response before it's saved into the Redux store using the <code>transformResponse</code> option in the endpoint definition.</p> <p>Let's say we want to include a derived field, such as \"postLength\" (the length of the post body):</p> <pre><code>// src/services/postsApi.js\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n      transformResponse: (response) =&gt; {\n        // Add a \"postLength\" field to each post\n        return response.map((post) =&gt; ({\n          ...post,\n          postLength: post.body.length,\n        }));\n      },\n    }),\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n</code></pre> <p>Now, the <code>data</code> returned from <code>useGetPostsQuery()</code> will include the <code>postLength</code> field for each post.</p> <p>6. Extra Reducers</p> <p>You can also define custom logic using <code>extraReducers</code> to handle actions dispatched outside of the API service. For example, let's add an extra reducer that listens to changes in posts and updates the UI accordingly:</p> <pre><code>// src/services/postsApi.js\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n    }),\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n  extraReducers: (builder) =&gt; {\n    builder.addMatcher(\n      (action) =&gt; action.type.startsWith(\"postsApi/\"),\n      (state, action) =&gt; {\n        // Custom logic for handling state changes\n        console.log(\"API action was dispatched:\", action);\n      }\n    );\n  },\n});\n</code></pre> <p>This example shows how you could handle other custom actions in your app, in addition to the auto-generated ones.</p>"},{"location":"state-management/redux/rtk/query/mnemonic/#final-directory-structure","title":"Final Directory Structure","text":"<pre><code>/src\n  /services\n    postsApi.js\n  /components\n    PostList.js\n  store.js\n</code></pre>"},{"location":"state-management/redux/rtk/query/mnemonic/#summary-of-create","title":"Summary of C.R.E.A.T.E.","text":"<ul> <li>Create an API Service: Use <code>createApi</code> to define API endpoints.</li> <li>Reducers Automatically Generated: RTK Query generates reducers for managing state.</li> <li>Endpoints: Define various API operations (e.g., <code>GET</code>, <code>POST</code>).</li> <li>Async Thunks: RTK Query automatically dispatches thunks for asynchronous API calls.</li> <li>Transform Response: Optionally transform the API response before it's stored.</li> <li>Extra Reducers: Use <code>extraReducers</code> to define custom logic outside of RTK Query.</li> </ul> <p>This example should give you a good understanding of how RTK Query simplifies API interaction in a Redux app while following the C.R.E.A.T.E. mnemonic.</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/","title":"RTK Advanced","text":""},{"location":"state-management/redux/rtk/query/rtkadvanced/#basic-about-rtk","title":"Basic about RTK","text":"<p>To get started with RTK Query (Redux Toolkit Query), you only need to understand a few key concepts and features that allow you to integrate API data fetching and state management into your React app. Below are the most basic things you need to learn to use RTK Query effectively:</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#1-what-is-rtk-query","title":"1. What is RTK Query?","text":"<p>RTK Query is a data fetching and caching tool built into Redux Toolkit that provides:</p> <ul> <li>Simplified data fetching: Automatically manages HTTP requests and responses.</li> <li>Caching: Automatically caches data and synchronizes your store.</li> <li>Optimized performance: Provides built-in utilities for handling things like pagination and re-fetching.</li> <li>No need for reducers: Handles API calls without needing additional action types, reducers, or custom middleware.</li> </ul> <p>RTK Query handles <code>data fetching</code>, <code>caching</code>, <code>synchronization</code>, and <code>state management</code> with minimal boilerplate.</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#2-basic-setup","title":"2. Basic Setup","text":"<p>Before diving into how to use RTK Query, you need to set it up in your application. Here's how:</p> <ol> <li> <p>Install Redux Toolkit and React-Redux:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Create an API service: You use <code>createApi</code> from RTK Query to define API endpoints. Here's a basic example of creating a service to fetch data.</p> <pre><code>// src/services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\n// Create an API slice\nexport const api = createApi({\n  reducerPath: \"api\", // Name of the slice\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n  }), // API base URL\n  endpoints: (builder) =&gt; ({\n    // Define an endpoint to fetch posts\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\", // Endpoint path\n    }),\n  }),\n});\n\n// Export the auto-generated hook for the getPosts endpoint\nexport const { useGetPostsQuery } = api;\n</code></pre> </li> <li> <p>Add the API service to the Redux store: You need to add the API service's reducer to your Redux store and also include the middleware to support caching, polling, and other features.</p> <pre><code>// src/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { api } from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer, // Adding API slice reducer\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Adding RTK Query middleware\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Provide the Redux store to your app: Wrap your app with the <code>Provider</code> component from react-redux to make the Redux store available throughout the app.</p> <pre><code>// src/index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport App from \"./App\";\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> </li> </ol>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#3-using-rtk-query-in-components","title":"3. Using RTK Query in Components","text":"<p>Once you have set up the API service, you can use the auto-generated hooks in your components to fetch data.</p> ExampleExplanation <p>Example: Fetching posts with useGetPostsQuery</p> <pre><code>// src/components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    // Use the auto-generated hook to fetch data\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <ul> <li><code>useGetPostsQuery</code> is the hook that was auto-generated from the <code>getPosts</code> endpoint defined in the API slice.</li> <li> <p>It returns:</p> <ul> <li><code>data</code>: The fetched data (in this case, posts).</li> <li><code>error</code>: Any error that occurred during the request.</li> <li><code>isLoading</code>: Boolean flag indicating whether the data is still being fetched.</li> </ul> </li> </ul>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#4-key-concepts-you-should-know","title":"4. Key Concepts You Should Know","text":"<p>To use RTK Query effectively, you should understand the following core concepts:</p> <p><code>createApi</code>:</p> <p>This is the function that defines an API service. You use it to:</p> <ul> <li>Define endpoints (API paths like <code>/posts</code>, <code>/users</code>, etc.).</li> <li>Specify a baseQuery to handle the HTTP requests (e.g., using <code>fetchBaseQuery</code> for simple fetch requests or using Axios for more complex ones).</li> </ul> Auto-generated hooks: <p>For each endpoint defined, RTK Query automatically generates hooks such as:</p> <ul> <li><code>useGetPostsQuery</code>: Hook for fetching data (GET request).</li> <li><code>useCreatePostMutation</code>: Hook for creating or modifying data (POST, PUT, DELETE requests).</li> </ul> <p>These hooks simplify the process of interacting with APIs by automatically managing loading states, caching, and error handling.</p> <p><code>fetchBaseQuery</code>:</p> <p>This is a simple query function used to make requests. It's essentially a wrapper around fetch (or you could use Axios). It allows you to define the base URL for your API and handle the actual HTTP requests easily.</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#5-handling-loading-error-and-success-states","title":"5. Handling Loading, Error, and Success States","text":"<p>RTK Query automatically provides you with states like <code>isLoading</code>, <code>error</code>, and <code>data</code> to help you manage your component UI.</p> <p>Here\u2019s how it works in the context of the <code>useGetPostsQuery</code> hook:</p> <ul> <li><code>isLoading</code>: Indicates if the request is still in progress.</li> <li><code>data</code>: Contains the response data once the request is successful.</li> <li><code>error</code>: Contains error information if the request fails.</li> </ul> Displaying loading and error states BasicAdvanced <pre><code>const Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;; // Show loading state\n    }\n\n    if (error) {\n        return &lt;div&gt;Error: {error.message}&lt;/div&gt;; // Show error message\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#summary-of-what-you-need-to-learn-to-get-started-with-rtk-query","title":"Summary of What You Need to Learn to Get Started with RTK Query:","text":"<ul> <li>Understand <code>createApi</code>: This is where you define your endpoints and how to make HTTP requests.</li> <li>Learn to use auto-generated hooks: These hooks (like <code>useGetQuery</code>, <code>usePostMutation</code>, etc.) simplify API interaction.</li> <li>Handle loading, error, and data states: RTK Query provides automatic states (<code>isLoading</code>, <code>error</code>, <code>data</code>) to manage API requests in your components.</li> <li>Set up your Redux store correctly: Integrate the API service with your Redux store and use the <code>Provider</code> to make the store available.</li> </ul>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#example-summary","title":"Example Summary:","text":"api.jsstore.jsApp.js <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({ query: () =&gt; '/posts' }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport { api } from './services/api';\n\nconst store = configureStore({\n    reducer: {\n        [api.reducerPath]: api.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(api.middleware),\n});\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport { useGetPostsQuery } from './services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>By understanding these basic concepts and steps, you'll be well on your way to using RTK Query for data fetching in a Redux-based React application. Let me know if you have any specific questions or need further examples!</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#rtk-query-auto-generated-hooks","title":"RTK Query Auto-Generated Hooks","text":"<p>Auto-generated hooks like <code>useGetQuery</code>, <code>usePostMutation</code>, and others are typically part of libraries or frameworks that simplify the process of making API requests and managing state. One of the most common tools that provides auto-generated hooks is Redux Toolkit Query (RTK Query), which is a part of Redux Toolkit. This tool allows you to define API endpoints and automatically generate hooks to interact with those endpoints, reducing the boilerplate code required to make requests.</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#understanding-auto-generated-hooks","title":"Understanding Auto-Generated Hooks","text":"<p>When you define your API service with RTK Query, it auto-generates hooks for each operation (GET, POST, PUT, DELETE, etc.). These hooks are ready to be used inside your React components, and they encapsulate the logic for fetching data, posting data, or handling mutations.</p>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#step-by-step-example-using-rtk-query","title":"Step-by-Step Example Using RTK Query","text":"<ol> <li> <p>Install Redux Toolkit: First, if you haven't installed <code>@reduxjs/toolkit</code>, you need to add it:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Define an API Service: You use <code>createApi</code> to define endpoints for different HTTP operations. Here\u2019s how you can define GET and POST requests:</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    // GET request example\n    getPosts: builder.query({\n      query: () =&gt; \"posts\", // The relative URL for the GET request\n    }),\n    // POST request example\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = api;\nexport default api;\n</code></pre> <p>In this example, we defined:</p> <ul> <li><code>getPosts</code>: A GET endpoint to fetch posts.</li> <li><code>createPost</code>: A POST endpoint to create a new post.</li> </ul> </li> <li> <p>Add API Reducer to Your Store: Next, add this service to your Redux store so that the auto-generated hooks can access it.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { api } from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer,\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Add RTK Query middleware\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Using Auto-Generated Hooks in Components: Now, you can use the generated hooks (<code>useGetPostsQuery</code>, <code>useCreatePostMutation</code>) inside your components to interact with your API.</p> </li> </ol> Fetching Data (GET):Posting Data (POST): <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return (\n        &lt;ul&gt;\n            {data.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>In this example:</p> <ul> <li><code>useGetPostsQuery</code> is the hook auto-generated by RTK Query.</li> <li>The hook automatically handles the request, loading state, and error state.</li> </ul> <pre><code>// components/CreatePost.js\nimport React, { useState } from \"react\";\nimport { useCreatePostMutation } from \"../services/api\";\n\nconst CreatePost = () =&gt; {\n    const [title, setTitle] = useState(\"\");\n    const [body, setBody] = useState(\"\");\n    const [createPost, { isLoading, isError }] = useCreatePostMutation();\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        await createPost({ title, body });\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"text\"\n                placeholder=\"Title\"\n                value={title}\n                onChange={(e) =&gt; setTitle(e.target.value)}\n            /&gt;\n            &lt;textarea\n                placeholder=\"Body\"\n                value={body}\n                onChange={(e) =&gt; setBody(e.target.value)}\n            /&gt;\n            &lt;button type=\"submit\" disabled={isLoading}&gt;\n                {isLoading ? \"Submitting...\" : \"Submit\"}\n            &lt;/button&gt;\n\n            {isError &amp;&amp; &lt;p&gt;Error submitting the post.&lt;/p&gt;}\n        &lt;/form&gt;\n    );\n};\n\nexport default CreatePost;\n</code></pre> <p>In this example:</p> <ul> <li><code>useCreatePostMutation</code> is the hook for creating a new post.</li> <li>The hook returns a function (<code>createPost</code>) that you can call to trigger the POST request, and the hook also returns states like <code>isLoading</code> and <code>isError</code>.</li> </ul>"},{"location":"state-management/redux/rtk/query/rtkadvanced/#more-example-hooks","title":"More Example Hooks","text":"<p>RTK Query will generate a hook for each endpoint operation you define. Here are some possible auto-generated hooks and how they can be used:</p> <ol> <li> <p>GET Request (e.g., fetching users):</p> <pre><code>const { data, isLoading, error } = useGetUsersQuery();\n</code></pre> </li> <li> <p>POST Request (e.g., creating a comment):</p> <pre><code>const [createComment, { isLoading, error }] = useCreateCommentMutation();\n</code></pre> </li> <li> <p>PUT/PATCH Request (e.g., updating a post):</p> <pre><code>const [updatePost, { isLoading, error }] = useUpdatePostMutation();\n</code></pre> </li> <li> <p>DELETE Request (e.g., deleting a post):</p> <pre><code>const [deletePost, { isLoading, error }] = useDeletePostMutation();\n</code></pre> </li> </ol> Summary <ul> <li>Auto-generated hooks like <code>useGetQuery</code>, <code>usePostMutation</code>, and others simplify working with API requests by automatically managing states like loading, error, and data.</li> <li>You define API endpoints with <code>createApi</code> in Redux Toolkit Query, and the library generates hooks for each operation.</li> <li>The generated hooks provide an easy interface to interact with your API without needing to manually write logic for <code>fetch</code>, <code>loading</code>, <code>error</code>, and <code>success</code> states.</li> </ul> <p>By using these auto-generated hooks, you can focus on building your UI while letting RTK Query handle the underlying complexities of interacting with APIs.</p> <p>Advanced Tips &amp; Tricks 2</p> <p>When using RTK Query (Redux Toolkit Query), there are several advanced techniques, patterns, and best practices you can implement to make your code more efficient, maintainable, and scalable. Here are some of the advanced tips, tricks, and patterns for leveraging RTK Query:</p> <p>1. Optimistic Updates</p> <p>Optimistic updates allow you to update the UI before an API request has completed. This is particularly useful when dealing with actions that take a long time (e.g., submitting a form, deleting an item). You can \"optimistically\" assume success and update the state, then revert if the request fails.</p> <p>Example: Optimistic Update for a Like/Dislike Action</p> <pre><code>// In your API slice\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    likePost: builder.mutation({\n      query: (postId) =&gt; ({\n        url: `/posts/${postId}/like`,\n        method: \"POST\",\n      }),\n      // Optimistically update the cache\n      async onQueryStarted(postId, { dispatch, queryFulfilled }) {\n        // Optimistic update\n        dispatch(\n          postsApi.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n            const post = draft.find((p) =&gt; p.id === postId);\n            if (post) post.likes += 1;\n          })\n        );\n        // Wait for the API response\n        try {\n          await queryFulfilled;\n        } catch (err) {\n          // Revert the optimistic update if the mutation fails\n          dispatch(\n            postsApi.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n              const post = draft.find((p) =&gt; p.id === postId);\n              if (post) post.likes -= 1;\n            })\n          );\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useLikePostMutation } = postsApi;\n</code></pre> <p>In this example, when the <code>likePost</code> mutation is triggered, the state is updated optimistically by increasing the like count, and if the request fails, the change is rolled back.</p> <p>2. Cache Management and Data Normalization</p> <p>RTK Query provides powerful caching mechanisms, and caching can be further improved with data normalization (e.g., by storing entities in a normalized format).</p> <p>You can use <code>upsert</code> to add or update data in the cache.</p> <p>Example: Normalizing Data and Using <code>upsert</code></p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const usersApi = createApi({\n  reducerPath: \"usersApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getUser: builder.query({\n      query: (id) =&gt; `/users/${id}`,\n      // Normalize the data when fetching users\n      transformResponse: (response) =&gt; ({\n        ...response,\n        __typename: \"User\", // Optional: Add a type for caching\n      }),\n    }),\n    updateUser: builder.mutation({\n      query: (user) =&gt; ({\n        url: `/users/${user.id}`,\n        method: \"PUT\",\n        body: user,\n      }),\n      // Using `upsert` to update or insert in the cache\n      async onQueryStarted(user, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          usersApi.util.updateQueryData(\"getUser\", user.id, (draft) =&gt; {\n            Object.assign(draft, user);\n          })\n        );\n        try {\n          await queryFulfilled;\n        } catch (err) {\n          patchResult.undo(); // Undo the update if the query fails\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useGetUserQuery, useUpdateUserMutation } = usersApi;\n</code></pre> <p>In this example:</p> <ul> <li>We normalize the <code>user</code> data when it is fetched (<code>transformResponse</code>).</li> <li>We use <code>updateQueryData</code> to update or \"upsert\" data in the cache after a mutation.</li> </ul> <p>3. Polling for Real-time Data</p> <p>You can periodically refetch data (e.g., for real-time updates) by using polling with <code>pollingInterval</code>.</p> <p>Example: Polling for Real-time Data</p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      // Poll every 30 seconds\n      pollingInterval: 30000,\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>In this example, the <code>getPosts</code> query will automatically refetch the data every 30 seconds. This can be useful for showing real-time updates like live comments, stock prices, or chat messages.</p> <p>4. Handling Multiple Requests with <code>batch</code></p> <p>When you need to fire off multiple API requests in parallel, you can use <code>batch</code> to manage them efficiently.</p> <p>Example: Making Multiple API Requests in Parallel</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getUsers: builder.query({\n      query: () =&gt; \"/users\",\n    }),\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetUsersQuery, useGetPostsQuery } = api;\n\n// In a component:\nconst MyComponent = () =&gt; {\n  const { data: users } = useGetUsersQuery();\n  const { data: posts } = useGetPostsQuery();\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Users&lt;/h1&gt;\n      &lt;ul&gt;\n        {users?.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;h1&gt;Posts&lt;/h1&gt;\n      &lt;ul&gt;\n        {posts?.map((post) =&gt; (\n          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>In this case, both <code>getUsers</code> and <code>getPosts</code> will be fetched in parallel, making the app more efficient.</p> <p>5. Lazy Loading with <code>skip</code></p> <p>You can conditionally skip queries or mutations if you don't need to fetch data until a certain condition is met. This can be useful for reducing unnecessary API requests.</p> <p>Example: Lazy Loading Queries with <code>skip</code></p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      // Skip query if no posts are needed\n      skip: ({ isUserLoggedIn }) =&gt; !isUserLoggedIn,\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>In this example, the <code>getPosts</code> query will be skipped unless the user is logged in.</p> <p>6. Custom <code>baseQuery</code> for Complex Scenarios</p> <p>You can customize the <code>baseQuery</code> to handle more complex scenarios, such as adding authorization tokens, handling retries, or logging.</p> <p>Example: Custom <code>baseQuery</code> for Authorization and Retry Logic</p> <pre><code>const baseQueryWithAuth = async (args, api, extraOptions) =&gt; {\n  const token = localStorage.getItem(\"auth_token\");\n\n  const result = await fetchBaseQuery({\n    baseUrl: \"/api\",\n    prepareHeaders: (headers) =&gt; {\n      if (token) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n      }\n      return headers;\n    },\n  })(args, api, extraOptions);\n\n  // Retry logic (e.g., if token is expired, refresh it and retry)\n  if (result.error?.status === 401) {\n    // Handle retry logic or refresh token here\n  }\n\n  return result;\n};\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: baseQueryWithAuth,\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n</code></pre> <p>In this example, the <code>baseQueryWithAuth</code> adds an <code>Authorization</code> header for API requests if a token is present. Additionally, you can extend this to include retry logic or token refreshing if needed.</p> <p>7. Using <code>selectFromResult</code> for Optimized Data Fetching</p> <p>If you're using RTK Query to fetch a large dataset but only need part of the data, use <code>selectFromResult</code> to limit the amount of data returned to just what you need.</p> <p>Example: Using <code>selectFromResult</code></p> <pre><code>const { data } = useGetPostsQuery(undefined, {\n  selectFromResult: (result) =&gt; ({\n    posts: result.data?.filter((post) =&gt; post.isPublished),\n  }),\n});\n</code></pre> <p>In this example, we filter the posts on the fly to only return published posts, optimizing performance when you have a large dataset.</p> <p>8. Error Handling with <code>onError</code></p> <p>For complex error handling (e.g., for logging or user feedback), you can use the <code>onError</code> callback to handle errors globally or within a specific endpoint.</p> <p>Example: Using <code>onError</code> for Error Handling</p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      onError: (error) =&gt; {\n        console.error(\"Error fetching posts:\", error);\n        // Optionally send error info to a logging service\n      },\n    }),\n  }),\n});\n</code></pre> <p>In this example, if an error occurs when fetching posts, it's logged to the console, and you could extend it to handle retries, user notifications, or report the error to a monitoring service.</p> <p>Conclusion</p> <p>These advanced techniques can help you leverage the full power of RTK Query and optimize your application's data fetching, caching, and UI state management:</p> <ol> <li>Optimistic Updates: Improves UI responsiveness by assuming success before receiving the response.</li> <li>Cache Management &amp; Data Normalization: Improves performance and data consistency.</li> <li>Polling: Useful for real-time data updates (e.g., live notifications).</li> <li>Batch Requests: Efficiently handle multiple API requests in parallel.</li> <li>Lazy Loading: Conditionally skip API calls based on certain conditions.</li> <li>Custom <code>baseQuery</code>: Allows for flexible API configuration (e.g., authentication or retries).</li> <li><code>selectFromResult</code>: Limits the returned data to what's necessary.</li> <li>Error Handling with <code>onError</code>: Centralized error handling for logging or reporting.</li> </ol> <p>By implementing these patterns, you'll be able to build more scalable, efficient, and maintainable applications using RTK Query.</p>"},{"location":"state-management/redux/rtk/query/tools/","title":"Tools","text":""},{"location":"state-management/redux/rtk/query/tools/#overview","title":"Overview","text":"<p>When building a React application, choosing the right tools is crucial to ensure your app is scalable, maintainable, and performant. Here's a list of the best tools to use in a React project, categorized by different aspects of the development process:</p>"},{"location":"state-management/redux/rtk/query/tools/#1-development-tools","title":"1. Development Tools","text":"<p>Code Editors</p> <p>VSCode: The most popular code editor for React development, with features like IntelliSense, Git integration, and extensions for React.</p> <p>Recommended Extensions for React:</p> <ul> <li>ESLint: Lint your code to maintain consistent style and catch potential bugs.</li> <li>Prettier: Auto-format your code according to your preferred style.</li> <li>Bracket Pair Colorizer: Color-code matching brackets for better readability.</li> <li>Path Intellisense: Auto-completion for file paths.</li> <li>Reactjs code snippets: Get React code snippets and syntax templates.</li> </ul> <p>TypeScript</p> <p>TypeScript: Highly recommended for large React applications because it provides static typing, which helps catch errors early and enhances IDE support.</p> <ul> <li>Install: <code>npm install typescript --save-dev</code></li> <li>If starting from scratch, use a TypeScript template for React projects: <code>npx create-react-app my-app --template typescript</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#2-routing","title":"2. Routing","text":"<p>React Router</p> <p>React Router is the standard for client-side routing in React apps.</p> <ul> <li>Install: <code>npm install react-router-dom</code></li> <li>Supports features like nested routing, route protection, dynamic routing, and lazy loading of routes.</li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#3-state-management","title":"3. State Management","text":"<p>Redux Toolkit</p> <p>Redux Toolkit is the modern approach to Redux, reducing boilerplate and making Redux easier to use.</p> <ul> <li>Install: <code>npm install @reduxjs/toolkit react-redux</code></li> <li>Use Redux Thunk (or Redux Saga) for handling asynchronous actions.</li> </ul> <p>React Context API</p> <p>React Context API: A simpler state management solution for passing data through the component tree without prop drilling.</p> <ul> <li>Good for small to medium-sized applications.</li> </ul> <p>Zustand</p> <p>Zustand: A minimalistic state management tool with a simple API and no boilerplate. It's great for small to medium apps and has better performance than Redux for simple state.</p> <ul> <li>Install: <code>npm install zustand</code></li> </ul> <p>Recoil</p> <p>Recoil: A powerful state management library designed by Facebook, good for large-scale apps with complex state and dependencies.</p> <ul> <li>Install: <code>npm install recoil</code></li> </ul> <p>MobX</p> <p>MobX: An easy-to-use reactive state management library. It's less verbose than Redux and great for applications with a lot of dynamic state.</p> <ul> <li>Install: <code>npm install mobx react-mobx</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#4-api-data-fetching","title":"4. API Data Fetching","text":"<p>Axios</p> <p>Axios: A promise-based HTTP client for the browser and Node.js. It simplifies making API requests, handling errors, and adding custom configurations.</p> <ul> <li>Install: npm install axios</li> </ul> <p>React Query</p> <p>React Query: A powerful library for fetching, caching, and synchronizing server state in React applications. It helps with data fetching, caching, and background data syncing without complex state management.</p> <ul> <li>Install: npm install react-query</li> </ul> <p>SWR</p> <p>SWR: Another data-fetching library, similar to React Query. It's lighter and focuses on caching and re-fetching data with hooks.</p> <ul> <li>Install: npm install swr</li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#5-forms","title":"5. Forms","text":"<p>Formik</p> <p>Formik: One of the most popular form libraries for React. It simplifies form validation, handling submission, and managing form state.</p> <ul> <li>Install: <code>npm install formik</code></li> </ul> <p>React Hook Form</p> <p>React Hook Form: A performant, flexible form library that minimizes re-renders and is easier to integrate with the rest of your React app.</p> <ul> <li>Install: <code>npm install react-hook-form</code></li> </ul> <p>Yup</p> <p>Yup: A schema-based validation library commonly used with Formik or React Hook Form to validate form data.</p> <ul> <li>Install: <code>npm install yup</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#6-styling","title":"6. Styling","text":"<p>Styled Components</p> <p>Styled Components: A CSS-in-JS library that allows you to write traditional CSS syntax within your JavaScript components. It also supports theming, nesting, and dynamic styling.</p> <ul> <li>Install: <code>npm install styled-components</code></li> </ul> <p>Emotion</p> <p>Emotion: A performant CSS-in-JS library for styling React components. It provides both styled-components API and a faster, optimized version.</p> <ul> <li>Install: <code>npm install @emotion/react @emotion/styled</code></li> </ul> <p>Tailwind CSS</p> <p>Tailwind CSS: A utility-first CSS framework that makes it easy to design components without writing custom CSS.</p> <ul> <li>Install: <code>npm install tailwindcss</code></li> <li>Use PostCSS to configure Tailwind.</li> </ul> <p>CSS Modules</p> <p>CSS Modules: Locally scoped CSS for better modularization of styles and avoidance of global styles conflicts.</p> <ul> <li>Works with vanilla CSS, SCSS, or PostCSS.</li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#7-performance-optimization","title":"7. Performance Optimization","text":"<p>React Lazy &amp; Suspense</p> <p>React.lazy and Suspense: Built-in React features to enable <code>code splitting</code> and lazy loading of components.</p> <pre><code>const MyComponent = React.lazy(() =&gt; import('./MyComponent'));\n</code></pre> <p>React.memo</p> <p>React.memo: A higher-order component that memoizes a component, preventing unnecessary re-renders if the props don't change.</p> <p>React DevTools</p> <p>React DevTools: A browser extension for inspecting the React component tree and props/state, optimizing performance, and debugging.</p> <ul> <li>Install via Chrome/Firefox extensions.</li> </ul> <p>webpack Bundle Analyzer</p> <p>webpack Bundle Analyzer: Helps you visualize the size of webpack output files and optimize the size of your bundles.</p> <ul> <li>Install: <code>npm install --save-dev webpack-bundle-analyzer</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#8-testing","title":"8. Testing","text":"<p>Jest</p> <p>Jest: A popular testing framework for JavaScript and React. It supports unit testing, snapshots, and code coverage.</p> <ul> <li>Install: <code>npm install --save-dev jest</code></li> </ul> <p>React Testing Library</p> <p>React Testing Library: A testing utility for React components that encourages testing through user interactions and behavior rather than implementation details.</p> <ul> <li>Install: <code>npm install --save-dev @testing-library/react</code></li> </ul> <p>Cypress</p> <p>Cypress: A powerful end-to-end testing framework that allows you to test the full flow of your app in a real browser.</p> <ul> <li>Install: <code>npm install --save-dev cypress</code></li> </ul> <p>MSW (Mock Service Worker)</p> <p>MSW: For mocking API requests in unit or integration tests, useful when you don't want to hit real APIs during tests.</p> <ul> <li>Install: <code>npm install msw</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#9-code-quality-linting","title":"9. Code Quality &amp; Linting","text":"<p>ESLint</p> <p>ESLint: A tool for identifying and fixing problems in JavaScript code. It ensures consistent coding style and helps catch errors early.</p> <ul> <li>Install: <code>npm install --save-dev eslint</code></li> <li>Recommended Setup: Airbnb ESLint Config for React apps.</li> <li>Install: <code>npm install --save-dev eslint-config-airbnb eslint-plugin-react</code></li> </ul> <p>Prettier</p> <p>Prettier: An opinionated code formatter that automatically formats your code for consistent style.</p> <ul> <li>Install: <code>npm install --save-dev prettier</code></li> </ul> <p>Husky</p> <p>Husky: A tool that enables Git hooks, allowing you to run scripts before commits or pushes, like linting or testing.</p> <ul> <li>Install: <code>npm install --save-dev husky</code></li> </ul> <p>Lint-staged</p> <p>Lint-staged: A tool for running linting or formatting only on the staged files in Git.</p> <ul> <li>Install: <code>npm install --save-dev lint-staged</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#10-deployment-cicd","title":"10. Deployment &amp; CI/CD","text":"<p>Vercel / Netlify</p> <p>Vercel: A platform for deploying static sites and serverless functions, highly optimized for React applications. Set up continuous deployment directly from GitHub. Netlify: Another great platform for deploying React apps. It offers automatic builds, continuous deployment, and serverless functions.</p> <p>GitHub Actions / CircleCI / Travis CI</p> <p>Set up CI/CD pipelines to automate testing, linting, and deployment.</p>"},{"location":"state-management/redux/rtk/query/tools/#11-miscellaneous","title":"11. Miscellaneous","text":"<p>Storybook</p> <p>Storybook: An isolated environment to develop and showcase UI components, great for design systems.</p> <ul> <li>Install: <code>npm install @storybook/react</code></li> </ul> <p>React Helmet</p> <p>React Helmet: A library for managing the document head (title, meta tags, etc.), ideal for SEO and SSR (Server-Side Rendering).</p> <ul> <li>Install: <code>npm install react-helmet</code></li> </ul>"},{"location":"state-management/redux/rtk/query/tools/#conclusion","title":"Conclusion","text":"<p>The tools listed above help optimize various aspects of a React app, from development and testing to deployment and performance optimization. <code>React Router</code>, <code>Redux Toolkit</code>, <code>React Query</code>, <code>Styled Components</code>, <code>Jest</code>, <code>ESLint</code>, and <code>Prettier</code> are some of the most essential libraries and tools that most React apps should incorporate for smooth development and maintenance.</p> <p>Great! Let\u2019s dive deeper into any area that interests you. Here are some topics we can explore:</p> <pre><code>1.  State Management\n    Redux Toolkit vs. Context API vs. Zustand: How to choose the right state management approach for your app.\n\n2. Routing\n    React Router: Advanced patterns for handling nested routes, dynamic routes, and lazy loading.\n\n3. Forms Handling\n    Formik vs. React Hook Form: A deeper comparison, including performance considerations and best practices for form validation.\n\n4. Styling\n    Styled Components vs. Tailwind CSS: Which one should you use based on your app's requirements?\n\n5. API Data Fetching\n    React Query and SWR: When and why to use these libraries for caching and background syncing of data.\n\n6. Testing\n    How to effectively use React Testing Library and Jest to test your components.\n\n7. Performance Optimization\n    Advanced React optimizations (e.g., useMemo, React.memo, lazy loading, etc.).\n\n8. CI/CD\n    Setting up a CI/CD pipeline for React apps using GitHub Actions, CircleCI, or Travis CI.\n\n9. Deployment\n    Deploying to Vercel or Netlify: Best practices for serverless React apps.\n\n10. Code Quality\n    Using ESLint, Prettier, and Husky to ensure your code remains clean, consistent, and maintainable.\n```\n</code></pre>"},{"location":"state-management/redux/rtk/query/topic/","title":"Topic","text":""},{"location":"state-management/redux/rtk/query/topic/#overview","title":"Overview","text":"<p>To master RTK Query (Redux Toolkit Query), it's helpful to break it down into key concepts and topics from basic to advanced. Here's a roadmap of topics you can follow to level up your skills, starting from the fundamentals to advanced features:</p> Basic Concepts:Intermediate Concepts:Advanced Concepts:Mastering RTK Query: <ol> <li> <p>Introduction to Redux Toolkit (RTK)</p> <ul> <li>What is Redux Toolkit and how does it simplify Redux?</li> <li>Key concepts: <code>configureStore</code>, <code>createSlice</code>, <code>createAsyncThunk</code></li> </ul> </li> <li> <p>What is RTK Query?</p> <ul> <li>Introduction to RTK Query and how it integrates with Redux Toolkit.</li> <li>Benefits of using RTK Query over traditional redux-thunk or redux-saga for data fetching.</li> </ul> </li> <li> <p>Setting Up RTK Query</p> <ul> <li>Installing dependencies: @reduxjs/toolkit and react-redux</li> <li>Setting up API service using <code>createApi</code>.</li> <li>Defining API endpoints (e.g., <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>).</li> </ul> </li> <li> <p>Basic RTK Query Usage</p> <ul> <li><code>createApi</code>: Structure of the <code>baseQuery</code> and endpoints.</li> <li>Example of defining API services and fetching data with <code>useGetQuery</code>.</li> <li>Fetching data within a component using hooks (e.g., <code>useGetExampleQuery</code>).</li> </ul> </li> <li> <p>Handling API Responses &amp; Errors</p> <ul> <li>Using <code>data</code>, <code>error</code>, and <code>isLoading</code> states returned from RTK Query hooks.</li> <li>Displaying loading states, errors, and the fetched data.</li> </ul> </li> </ol> <ol> <li> <p>Caching &amp; Normalization</p> <ul> <li>How RTK Query automatically handles caching.</li> <li>Understanding cache lifetimes and cache invalidation.</li> <li>Normalization of data and how RTK Query helps manage normalized data in the Redux store.</li> </ul> </li> <li> <p>Optimistic Updates</p> <ul> <li>What are optimistic updates and why are they useful for improving UX?</li> <li>Example of implementing optimistic updates in a mutation endpoint.</li> </ul> </li> <li> <p>Polling &amp; Re-fetching</p> <ul> <li>How to set up polling using <code>pollingInterval</code>.</li> <li>Manually triggering re-fetching of data (e.g., using <code>refetch</code>).</li> </ul> </li> <li> <p>Pagination &amp; Infinite Scrolling</p> <ul> <li>Setting up endpoints for pagination.</li> <li>Using <code>useInfiniteQuery</code> for infinite scrolling and managing paginated results.</li> </ul> </li> <li> <p>Batch Requests / Parallel Queries</p> <ul> <li>Sending multiple queries or mutations in parallel and handling their results.</li> <li>Using <code>useLazyQuery</code> and <code>Promise.all</code>.</li> </ul> </li> </ol> <ol> <li> <p>Custom Base Query</p> <ul> <li>How to write a custom base query using <code>baseQuery</code>.</li> <li>Examples of custom base queries using fetch, axios, or other HTTP clients.</li> <li>Handling custom headers, authentication tokens, etc.</li> </ul> </li> <li> <p>Caching &amp; Invalidating Data</p> <ul> <li>Fine-grained control over caching and invalidation.</li> <li>Using <code>providesTags</code> and <code>invalidatesTags</code> for managing cache dependencies.</li> <li>Using <code>cacheKey</code> and <code>refetchOnMount</code> options.</li> </ul> </li> <li> <p>Optimizing RTK Query Performance</p> <ul> <li>Handling large datasets efficiently (pagination, batch requests, caching strategies).</li> <li>Debouncing API requests in cases like search.</li> <li>Using web workers or other background techniques to avoid blocking the UI.</li> </ul> </li> <li> <p>Error Handling &amp; Retries</p> <ul> <li>Implementing custom error handling and retries in RTK Query.</li> <li>Handling HTTP errors, network failures, and server-side issues gracefully.</li> <li>Automatically retrying failed requests with backoff strategies.</li> </ul> </li> <li> <p>RTK Query with WebSockets</p> <ul> <li>Setting up WebSockets or real-time API interactions with RTK Query.</li> <li>Using RTK Query for real-time data updates (e.g., subscriptions, live feeds).</li> </ul> </li> </ol> <ol> <li> <p>Advanced Use Cases</p> <ul> <li>Managing <code>file uploads</code> and <code>downloads</code> using RTK Query.</li> <li><code>Authenticated endpoints</code> and managing tokens or credentials.</li> <li><code>Pagination</code> in the context of large-scale applications (e.g., server-side pagination).</li> </ul> </li> <li> <p>Custom Hooks and Code Reusability</p> <ul> <li>How to create reusable custom hooks with RTK Query.</li> <li>Refactoring common logic into custom hooks and reusable API service logic.</li> </ul> </li> <li> <p>RTK Query with SSR (Server-side rendering)</p> <ul> <li>Using RTK Query with server-side rendering (e.g., Next.js or Gatsby).</li> <li>Hydrating the Redux store on the server and sharing the store state between client and server.</li> </ul> </li> <li> <p>Testing with RTK Query</p> <ul> <li>Unit testing and mocking RTK Query endpoints in unit tests.</li> <li>Writing integration tests that interact with real API endpoints.</li> <li>Using MSW (Mock Service Worker) to mock API responses in tests.</li> </ul> </li> <li> <p>RTK Query Internals</p> <ul> <li>Understanding how RTK Query works internally.</li> <li>How caching and automatic updates happen under the hood.</li> <li>The Redux middleware and how RTK Query interacts with it.</li> </ul> </li> </ol> <p>Additional Resources:</p> <ul> <li>Official Documentation: The RTK Query documentation is a great starting point for each of these topics.</li> <li>Video Tutorials &amp; Blog Posts: Many developers and educators provide in-depth tutorials (e.g., on YouTube or Medium) covering specific use cases and advanced techniques.</li> <li>GitHub Repositories: Look for real-world applications on GitHub that use RTK Query extensively to get hands-on examples of best practices.</li> </ul> <p>This progression from basic to advanced topics should give you a comprehensive understanding of RTK Query. Would you like to dive deeper into any specific section? I can provide examples or explanations for any of the topics above.</p>"},{"location":"state-management/redux/rtk/query/topic/#example","title":"Example","text":"<p>Below is a step-by-step guide from basic to advanced concepts of RTK Query with examples to help you understand how to use the features in practice.</p> <p>1. Introduction to RTK Query</p> <p>RTK Query is a library within Redux Toolkit that simplifies data fetching, caching, synchronization, and much more.</p> Installation: <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <p>2. Basic RTK Query Usage</p> Step 1Step 2Step 3 <p>Step 1: Setup API Service using <code>createApi</code></p> <p>Create an API service with <code>createApi</code> to define endpoints and fetch data.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// Create an API service\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        // Define a 'getPosts' endpoint to fetch posts data\n        getPosts: builder.query({\n            query: () =&gt; '/posts',\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <p>Step 2: Setup Redux Store</p> <p>Add the API slice to your store and configure the Redux Toolkit.</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { api } from './services/api';\n\nconst store = configureStore({\n    reducer: {\n        [api.reducerPath]: api.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(api.middleware), // Add RTK Query middleware\n});\n\nexport default store;\n</code></pre> <p>Step 3: Using the API in Components</p> <p>Use the generated hook useGetPostsQuery to fetch the data in your component.</p> <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>3. Handling API Responses &amp; Errors</p> <p>RTK Query provides states like <code>isLoading</code>, <code>data</code>, and <code>error</code> to manage the response and handle errors.</p> Displaying data and errors <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>4. Pagination and Infinite Scrolling</p> <p>You can implement pagination or infinite scrolling using RTK Query's hooks and endpoint parameters.</p> Fetch paginated posts services/api.jscomponents/Posts.js <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: (page = 1) =&gt; `/posts?_page=${page}&amp;_limit=5`, // Implement pagination via query params\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <pre><code>// components/Posts.js\nimport React, { useState } from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const [page, setPage] = useState(1);\n    const { data, error, isLoading } = useGetPostsQuery(page);\n\n    const loadMore = () =&gt; setPage(page + 1);\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts (Page {page})&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n            &lt;button onClick={loadMore}&gt;Load More&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <ol> <li>Mutations with RTK Query</li> </ol> <p>You can use <code>mutations</code> for creating, updating, or deleting resources. For example, creating a new post.</p> Post a new item using mutation services/api.jscomponents/CreatePost.js <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        createPost: builder.mutation({\n        query: (newPost) =&gt; ({\n            url: '/posts',\n            method: 'POST',\n            body: newPost,\n        }),\n        }),\n    }),\n});\n\nexport const { useCreatePostMutation } = api;\n</code></pre> <pre><code>// components/CreatePost.js\nimport React, { useState } from 'react';\nimport { useCreatePostMutation } from '../services/api';\n\nconst CreatePost = () =&gt; {\n    const [title, setTitle] = useState('');\n    const [body, setBody] = useState('');\n    const [createPost, { isLoading, error }] = useCreatePostMutation();\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        await createPost({ title, body });\n        setTitle('');\n        setBody('');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Create a Post&lt;/h1&gt;\n            {isLoading &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}\n            {error &amp;&amp; &lt;div&gt;Error: {error.message}&lt;/div&gt;}\n\n            &lt;form onSubmit={handleSubmit}&gt;\n                &lt;input\n                    type=\"text\"\n                    placeholder=\"Title\"\n                    value={title}\n                    onChange={(e) =&gt; setTitle(e.target.value)}\n                /&gt;\n                &lt;textarea\n                    placeholder=\"Body\"\n                    value={body}\n                    onChange={(e) =&gt; setBody(e.target.value)}\n                /&gt;\n                &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CreatePost;\n</code></pre> <p>6. Advanced Topics</p> Optimistic Updates <p>Optimistic updates allow you to immediately update the UI before the server responds. Useful for things like adding/deleting items where you want to show immediate feedback.</p> <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        deletePost: builder.mutation({\n            query: (postId) =&gt; ({\n                url: `/posts/${postId}`,\n                method: 'DELETE',\n            }),\n            // Optimistically update the cache by removing the deleted post immediately\n            async onQueryStarted(postId, { dispatch, queryFulfilled }) {\n                const patchResult = dispatch(\n                    api.util.updateQueryData('getPosts', undefined, (draft) =&gt; {\n                        return draft.filter((post) =&gt; post.id !== postId);\n                })\n                );\n                try {\n                    await queryFulfilled;\n                } catch {\n                    patchResult.undo();\n                }\n            },\n            }),\n    }),\n});\n\nexport const { useDeletePostMutation } = api;\n</code></pre> <p>7. Custom Base Query</p> <p>If you need more control over the API request (e.g., adding authentication headers), you can write a custom base query.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst customBaseQuery = async (args, api, extraOptions) =&gt; {\n  const token = localStorage.getItem(\"authToken\"); // Assume authentication token is stored\n  const headers = {\n    Authorization: `Bearer ${token}`,\n  };\n\n  const result = await fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n    headers,\n  })(args, api, extraOptions);\n\n  return result;\n};\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: customBaseQuery,\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <p>Conclusion:</p> <p>These examples cover basic to advanced usage of RTK Query to manage API interactions in a Redux-powered React application. As you get more familiar with RTK Query, you can dive deeper into concepts like custom base queries, optimistic updates, caching strategies, pagination, and error handling.</p>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/","title":"Code Modularity","text":""},{"location":"state-management/redux/rtk/toolkit/code-modularity/#overview","title":"Overview","text":"<p>In Redux Toolkit, especially when using createSlice, the actions and the reducer logic are closely related. Here's a breakdown of how they are intertwined:</p>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/#how-actions-and-reducers-are-related","title":"How Actions and Reducers Are Related","text":"<ol> <li> <p>Action Creators: When you define a reducer function within <code>createSlice</code>, Redux Toolkit automatically generates action creators for each reducer. For example, if you define a reducer named <code>increment</code>, Redux Toolkit creates an action creator with the same name.</p> </li> <li> <p>Reducer Logic: The logic inside each reducer function dictates how the state changes in response to an action. For instance, in the <code>increment</code> reducer, the state is updated by incrementing a value.</p> </li> </ol> Example Breakdown <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1; // This is the reducer logic\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1; // This is the reducer logic\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload; // This is the reducer logic using action\n        },\n    },\n});\n\n// Action creators\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/#code-modularity","title":"Code Modularity","text":"<p>When breaking the slice into multiple files, you could separate the action creators and reducer logic, but they are often used together. Here\u2019s how you might approach it:</p> <ul> <li>Reducer File: Contains the logic for updating the state.</li> <li>Action File: Defines and exports the action creators.</li> </ul> <p>If you want to separate them, it can look like this:</p> 1. Reducer File:2. Actions File: <pre><code>// counterReducer.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// counterActions.js\nimport { createAction } from '@reduxjs/toolkit';\n\nexport const increment = createAction('counter/increment');\nexport const decrement = createAction('counter/decrement');\nexport const incrementByAmount = createAction('counter/incrementByAmount');\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/#conclusion","title":"Conclusion","text":"<p>While the actions and reducers are related, they can be separated for clarity in larger applications. This modular approach helps maintain organization, but for many projects, keeping them together in a slice is often simpler and more straightforward. It depends on the complexity and scale of your application.</p>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/#additional","title":"Additional","text":"<p>Is creating a separate action file in Redux Toolkit beneficial ot unnecessary ?</p> <p>Creating a separate action file in Redux Toolkit can be both beneficial and unnecessary, depending on the scale and complexity of your application. Here are some considerations to help you decide whether it\u2019s a good practice for your project:</p> When It\u2019s a Good PracticeWhen It Might Be Unnecessary <ol> <li> <p>Complex Applications: If your application has many actions, separating them into their own file can improve readability and maintainability. It can help avoid clutter in the slice file.</p> </li> <li> <p>Reusability: If you have actions that need to be used in multiple places or modules, defining them in a separate file makes them easier to import and reuse.</p> </li> <li> <p>Clear Organization: For larger codebases, having a clear structure helps team members understand where to find specific logic, making onboarding and collaboration smoother.</p> </li> <li> <p>Testing: Isolating actions can facilitate testing. You can test action creators independently of the slice logic.</p> </li> </ol> <ol> <li> <p>Simple Applications: If your application is small and only has a few actions, keeping them within the slice can simplify the code and reduce the number of files to manage.</p> </li> <li> <p>Standard Slice Usage: Redux Toolkit is designed to work well with slices. Since createSlice generates action creators automatically, separating them might add unnecessary boilerplate.</p> </li> <li> <p>Action Overhead: For simple state changes, creating separate action files might introduce extra complexity without significant benefits.</p> </li> </ol> <p>Example Scenario</p> <ul> <li> <p>Good Practice: If you have a <code>counterSlice.js</code> with multiple actions related to different features (like adding, subtracting, resetting), creating a separate <code>counterActions.js</code> might be wise.</p> </li> <li> <p>Unnecessary: For a small application with a single slice and a couple of actions, keeping everything in one place would be more straightforward.</p> </li> </ul> <p>Conclusion</p> <p>Ultimately, whether to create separate action files in Redux Toolkit depends on your project\u2019s specific needs. If you anticipate growth or want a clean organizational structure, it can be a good practice. If you\u2019re working on a small project, it might be more efficient to keep everything together.</p> <p>Adapting to your team's preferences and the project's complexity is key. If you have any further questions or need examples, feel free to ask!</p>"},{"location":"state-management/redux/rtk/toolkit/code-modularity/#suggested-structure-for-a-slice","title":"Suggested Structure for a Slice","text":"<pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 counterActions.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 counterSelectors.js\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Breakdown of the Files</p> counterSlice.jscounterActions.jscounterSelectors.js <ol> <li> <p><code>counterSlice.js</code>: This file contains the slice definition, including the initial state and the reducers.</p> <pre><code>// src/features/counter/counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    value: 0,\n};\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState,\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p><code>counterActions.js</code>: This file can contain exported action creators, which can be useful for grouping related actions.</p> <pre><code>// src/features/counter/counterActions.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n</code></pre> </li> </ol> <ol> <li> <p><code>counterSelectors.js</code>: This file can contain selector functions that encapsulate the logic for retrieving specific parts of the state.</p> <pre><code>// src/features/counter/counterSelectors.js\nexport const selectCount = (state) =&gt; state.counter.value;\n</code></pre> </li> </ol> <p>How to Use in Your Component</p> <p>Now, in your component, you would import these parts accordingly:</p> <pre><code>// src/components/Counter.js\nimport React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport {\n  increment,\n  decrement,\n  incrementByAmount,\n} from \"../features/counter/counterActions\";\nimport { selectCount } from \"../features/counter/counterSelectors\";\n\nconst Counter = () =&gt; {\n  const count = useSelector(selectCount);\n  const dispatch = useDispatch();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\n      &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;\n        Increment by 5\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Counter;\n</code></pre> <p>Summary</p> <ul> <li>Modularization: Breaking down the slice into multiple files helps in maintaining and scaling your codebase.</li> <li>Separation of Concerns: This approach provides a clear separation of actions, selectors, and slice definitions.</li> <li>Standard Practice: While it might not be strictly necessary for smaller applications, for larger codebases, this modular approach is considered a best practice.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/folder-structure/","title":"Folder Structure","text":""},{"location":"state-management/redux/rtk/toolkit/folder-structure/#basic-redux-toolkit-rtk-folder-structure","title":"Basic Redux Toolkit (RTK) Folder Structure","text":"<p>A basic folder structure using Redux Toolkit might look something like this:</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 counter/\n\u2502       \u251c\u2500\u2500 counterSlice.js\n\u2502       \u2514\u2500\u2500 Counter.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jscounterSlice.jsCounter.jsApp.jsindex.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n</code></pre> <pre><code>// src/features/counter/counterSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: {\n        value: 0,\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;div&gt;\n                &lt;button\n                    aria-label=\"Increment value\"\n                    onClick={() =&gt; dispatch(increment())}\n                &gt;\n                +\n                &lt;/button&gt;\n\n                &lt;span&gt;{count}&lt;/span&gt;\n\n                &lt;button\n                    aria-label=\"Decrement value\"\n                    onClick={() =&gt; dispatch(decrement())}\n                &gt;\n                -\n                &lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;div&gt;\n                &lt;button\n                    onClick={() =&gt; dispatch(incrementByAmount(5))}\n                &gt;\n                    Increment by 5\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <pre><code>// src/App.js\n\nimport React from 'react';\nimport Counter from './features/counter/Counter';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;Counter App&lt;/h1&gt;\n        &lt;Counter /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/folder-structure/#advanced-redux-toolkit-rtk-folder-structure","title":"Advanced Redux Toolkit (RTK) Folder Structure","text":"<p>For a more complex application, the folder structure can be expanded to include additional features such as authentication, API calls, and more modular organization.</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 apiSlice.js\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 user/\n\u2502       \u251c\u2500\u2500 userSlice.js\n\u2502       \u2514\u2500\u2500 UserProfile.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsauthSlice.jsapiSlice.jsuserSlice.jsPrivateRoute.jsauthUtils.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport authReducer from '../features/auth/authSlice';\nimport userReducer from '../features/user/userSlice';\nimport { apiSlice } from '../features/api/apiSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n        auth: authReducer,\n        user: userReducer,\n        [apiSlice.reducerPath]: apiSlice.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(apiSlice.middleware),\n});\n</code></pre> <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n            state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/api/apiSlice.js\n\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n            getUserById: builder.query({\n            query: (id) =&gt; `user/${id}`,\n            }),\n            updateUser: builder.mutation({\n            query: (user) =&gt; ({\n                url: `user/${user.id}`,\n                method: 'PUT',\n                body: user,\n            }),\n        }),\n    }),\n});\n\nexport const { useGetUserByIdQuery, useUpdateUserMutation } = apiSlice;\n</code></pre> <pre><code>// src/features/user/userSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: {\n        profile: null,\n    },\n    reducers: {\n        setProfile: (state, action) =&gt; {\n            state.profile = action.payload;\n        },\n    },\n});\n\nexport const { setProfile } = userSlice.actions;\n\nexport default userSlice.reducer;\n</code></pre> <pre><code>// src/components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Summary</p> <ul> <li>Basic Structure: Simple setup with essential files and folders.</li> <li>Advanced Structure: More complex organization with features, components, and utility functions separated into dedicated folders.</li> </ul> <p>By organizing your project in this way, you can scale your application more effectively and maintain a clean and manageable codebase.</p>"},{"location":"state-management/redux/rtk/toolkit/folder-structure/#more-advanced","title":"More Advanced","text":"<pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 store.js\n\u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterApi.js\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 userApi.js\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js\n\u2502   \u2502   \u2514\u2500\u2500 UserList.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 auth.js\n\u2502   \u2514\u2500\u2500 user.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useAuth.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsrootReducer.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(),\n});\n</code></pre> <pre><code>// src/app/rootReducer.js\n\nimport { combineReducers } from 'redux';\nimport authReducer from '../features/auth/authSlice';\nimport counterReducer from '../features/counter/counterSlice';\nimport userReducer from '../features/user/userSlice';\nimport dashboardReducer from '../features/dashboard/dashboardSlice';\n\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    counter: counterReducer,\n    user: userReducer,\n    dashboard: dashboardReducer,\n});\n\nexport default rootReducer;\n</code></pre> <p>Feature Slices and APIs</p> Example authSlice.jsauthApi.jsDashboard.jsx <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\nimport { login } from './authApi';\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n        state.user = null;\n        state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/auth/authApi.js\n\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n</code></pre> <pre><code>// src/features/dashboard/Dashbaord.jsx\nimport { useSelector } from 'react-redux';\n\nconst Dashboard = () =&gt; {\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;div className=\"dashboard-container\"&gt;\n        &lt;h1&gt;Welcome to your Dashboard, {user?.name}!&lt;/h1&gt;\n        &lt;p&gt;This is a protected route. Only authenticated users can see this.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Dashboard;\n</code></pre> <p>Centralized API Service</p> Example api.jsauth.js <pre><code>// src/services/api.js\n\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n    baseURL: '/api',\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\nexport const setAuthToken = (token) =&gt; {\n    if (token) {\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    } else {\n        delete apiClient.defaults.headers.common['Authorization'];\n    }\n};\n\nexport default apiClient;\n</code></pre> <pre><code>// src/services/auth.js\n\nimport apiClient from './api';\n\nexport const login = (credentials) =&gt; {\n    return apiClient.post('/auth/login', credentials);\n};\n\nexport const register = (userData) =&gt; {\n    return apiClient.post('/auth/register', userData);\n};\n</code></pre> <p>Utility Functions</p> Example authUtils.js <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Custom Hooks</p> Example useAuth.js <pre><code>// src/hooks/useAuth.js\n\nimport { useSelector } from 'react-redux';\n\nconst useAuth = () =&gt; {\n    const { user, token } = useSelector((state) =&gt; state.auth);\n    return { user, token };\n};\n\nexport default useAuth;\n</code></pre> Example App.jsxmain.jsx <pre><code>// src/App.jsx\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Login from './features/auth/login.jsx';\nimport Dashboard from './features/dashboard/Dashboard.jsx';\nimport PrivateRoute from './components/PrivateRoute.jsx';\nimport Navbar from './components/Navbar.jsx';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;div&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n    &lt;/Router&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/main.jsx\n\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;Provider store={store}&gt;\n        &lt;React.StrictMode&gt;\n            &lt;App /&gt;\n        &lt;/React.StrictMode&gt;\n    &lt;/Provider&gt;\n)\n</code></pre> <p>Components</p> Navbar.jsxPrivateRoute.jsx <pre><code>// components/Navbar.jsx\nimport { Link } from 'react-router-dom';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { logout } from '../features/auth/authSlice';\n\nconst Navbar = () =&gt; {\n    const dispatch = useDispatch();\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    const handleLogout = () =&gt; {\n        dispatch(logout());\n    };\n\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            {user ? (\n                &lt;&gt;\n                    &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;\n                    &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n                &lt;/&gt;\n            ) : (\n                &lt;Link to=\"/login\"&gt;Login&lt;/Link&gt;\n            )}\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>// components/PrivateRoute.jsx\n\nimport { Route, Navigate } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\nimport PropTypes from 'prop-types';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            element={token ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n        /&gt;\n    );\n};\n\nPrivateRoute.propTypes = {\n    component: PropTypes.elementType.isRequired,\n};\n\nexport default PrivateRoute;\n</code></pre> <p>Summary</p> <ul> <li>Modular Structure: Break down features into separate folders, each containing related slices, API calls, and components.</li> <li>Centralized API Service: Use a single api.js file to configure and manage API calls.</li> <li>Custom Hooks: Create custom hooks for reusable logic.</li> <li>Utility Functions: Use utility functions to manage common operations.</li> </ul> <p>Benefits of this Approach</p> <ol> <li>Scalability: Easy to add new features without disrupting the existing codebase.</li> <li>Maintainability: Clear separation of concerns makes it easier to maintain and update the code.</li> <li>Reusability: Common logic and utilities are centralized, promoting code reuse.</li> <li>Extensibility: Easily extend the application by adding new features, APIs, and components.</li> </ol> <p>By following this modular approach, you can manage a large codebase effectively, ensuring that your application remains organized and maintainable as it grows.</p>"},{"location":"state-management/redux/rtk/toolkit/intro/","title":"Intro","text":""},{"location":"state-management/redux/rtk/toolkit/intro/#overview","title":"Overview","text":"<p>To master Redux Toolkit (RTK) and become a top developer, you should focus on the following key areas:</p>"},{"location":"state-management/redux/rtk/toolkit/intro/#1-understanding-redux-core-concepts","title":"1. Understanding Redux Core Concepts","text":"<ul> <li>Actions, Reducers, and Store: Have a solid grasp of how the Redux flow works, including the role of actions, reducers, and the store.</li> <li>Immutable State: Know how to update state immutably and how RTK simplifies this with <code>createSlice()</code>.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#2-rtk-apis-and-features","title":"2. RTK APIs and Features","text":"<ul> <li><code>createSlice</code>: Master the <code>createSlice()</code> function, which combines actions and reducers, streamlining the Redux workflow.</li> <li><code>createAsyncThunk</code>: Learn to handle asynchronous operations (like API calls) elegantly with <code>createAsyncThunk()</code>.</li> <li>RTK Query: Familiarize yourself with RTK Query to manage data fetching, caching, and synchronization in a declarative way.</li> <li><code>configureStore</code>: Understand how to configure the store with built-in middleware like <code>redux-thunk</code>, and add your own custom middleware if needed.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#3-selectors-and-memoization","title":"3. Selectors and Memoization","text":"<ul> <li>Use selectors to retrieve data from the Redux store efficiently.</li> <li>Learn how to optimize performance using memoized selectors with <code>reselect</code> to avoid unnecessary re-renders.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#4-middleware-and-side-effects","title":"4. Middleware and Side Effects","text":"<ul> <li>Learn how Redux middleware works and master custom middleware to handle complex side effects.</li> <li>Understand how tools like Redux Thunk and Redux-Saga integrate for handling side effects asynchronously.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#5-typescript-with-rtk","title":"5. TypeScript with RTK","text":"<ul> <li>Get comfortable using TypeScript with Redux Toolkit, including typing the state, actions, and thunks to reduce bugs and improve maintainability.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#6-code-structuring-and-best-practices","title":"6. Code Structuring and Best Practices","text":"<ul> <li>Organize your Redux logic (slices, actions, thunks) into well-structured, scalable modules.   Follow the Ducks pattern or other organization patterns to keep Redux code modular and maintainable.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#7-testing-redux","title":"7. Testing Redux","text":"<ul> <li>Write unit tests for reducers, selectors, and async thunks.</li> <li>Learn how to use tools like Jest and React Testing Library to test Redux logic and components integrated with Redux.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#8-performance-optimization","title":"8. Performance Optimization","text":"<ul> <li>Learn how to prevent unnecessary renders with efficient state updates and memoization.</li> <li>Understand how to use tools like Redux DevTools to monitor state changes and improve performance.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#9-debugging-and-developer-tools","title":"9. Debugging and Developer Tools","text":"<ul> <li>Master Redux DevTools for debugging your state, actions, and time travel debugging.</li> <li>Use logging middleware or <code>console.log()</code> effectively to trace issues.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/intro/#10-interoperability-with-other-libraries","title":"10. Interoperability with Other Libraries","text":"<ul> <li>Understand how Redux can integrate with React Router, Axios, or other third-party libraries.</li> <li>Ensure you can handle complex scenarios like server-side rendering (SSR) with Redux.</li> </ul> <p>By mastering these concepts and staying updated with the latest features, you'll have the skill set to leverage Redux Toolkit at an expert level.</p>"},{"location":"state-management/redux/rtk/toolkit/intro/#reference","title":"Reference","text":"<ul> <li>redux-thunk: github</li> <li>Redux docs: Writing Logic with Thunks</li> <li>Stack Overflow: Dispatching Redux Actions with a Timeout</li> <li>Stack Overflow: Why do we need middleware for async flow in Redux?</li> <li>What the heck is a \"thunk\"?</li> <li>Thunks in Redux: The Basics</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/","title":"Topic","text":"<p>To master Redux Toolkit, there are several key concepts and components you should be familiar with. Here\u2019s a breakdown of the main topics to focus on:</p>"},{"location":"state-management/redux/rtk/toolkit/topic/#1-core-concepts-of-redux","title":"1. Core Concepts of Redux","text":"<ul> <li>Store: Understand what a Redux store is and how it holds the state of your application.</li> <li>State: Learn how to structure your state and why immutability is important.</li> <li>Actions: Familiarize yourself with actions as plain objects that describe changes to the state.</li> <li>Reducers: Understand how reducers are pure functions that take the current state and an action to return a new state.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#2-redux-toolkit-basics","title":"2. Redux Toolkit Basics","text":"<ul> <li>Installation and Setup: Know how to set up a new project with Redux Toolkit and configure the store using <code>configureStore</code>.</li> <li>createSlice: Learn how to use <code>createSlice</code> to create reducers and action creators in a concise way.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#3-middleware","title":"3. Middleware","text":"<ul> <li>Built-in Middleware: Understand the default middleware included with Redux Toolkit (like Redux Thunk) and how to apply custom middleware using <code>getDefaultMiddleware</code>.</li> <li>Custom Middleware: Know how to create and integrate your own middleware for logging, error handling, etc.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#4-async-logic","title":"4. Async Logic","text":"<ul> <li>createAsyncThunk: Learn how to handle asynchronous actions with <code>createAsyncThunk</code>, which simplifies the process of making API calls or handling async logic.</li> <li>extraReducers: Understand how to manage the lifecycle of asynchronous actions using <code>extraReducers</code> in slices.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#5-selectors","title":"5. Selectors","text":"<ul> <li>Creating Selectors: Know how to create and use selectors to access specific parts of the state.</li> <li>Memoization: Familiarize yourself with using libraries like Reselect for optimizing selector performance.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#6-typescript-support","title":"6. TypeScript Support","text":"<ul> <li>If you're using TypeScript, understand how to type your state, actions, and reducers in Redux Toolkit. Redux Toolkit provides good TypeScript support out of the box.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Structuring Your Store: Learn how to organize your slices and reducers effectively, especially in larger applications.   Testing: Understand how to test your slices, reducers, and components that connect to Redux.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#8-integration-with-react","title":"8. Integration with React","text":"<ul> <li>React-Redux: Familiarize yourself with the React-Redux library for connecting your components to the Redux store.</li> <li>useSelector and useDispatch Hooks: Learn how to use these hooks to read from and dispatch actions to the Redux store.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#9-performance-optimization","title":"9. Performance Optimization","text":"<ul> <li>Batching Updates: Understand how to minimize re-renders and optimize performance in your React components connected to Redux.</li> <li>Redux DevTools: Learn how to use Redux DevTools for debugging your application state.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#10-advanced-patterns","title":"10. Advanced Patterns","text":"<ul> <li>Entity Management: Explore patterns for managing collections of entities (like normalizing state).</li> <li>Dynamic Slices: Understand how to create slices dynamically if your application requires it.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/topic/#summary","title":"Summary","text":"<p>Mastering these topics will give you a solid foundation in Redux Toolkit and help you build scalable, maintainable applications. As you dive deeper, working on real projects and experimenting with these concepts will solidify your understanding.</p>"},{"location":"state-management/redux/rtk/toolkit/topic/#reference","title":"Reference","text":"<ul> <li>Quick Start</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/ultimate/","title":"Utltimate","text":""},{"location":"state-management/redux/rtk/toolkit/ultimate/#axios-config","title":"Axios Config","text":"<p>Creating a reusable config for your Axios requests can help streamline your API interactions and maintain consistency across your application. Here\u2019s how you can do it:</p> <pre><code>// axiosConfig.js\nimport axios from \"axios\";\n\nconst defaultBaseConfig = {\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst defaultBlogConfig = {\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  timeout: 10000,\n};\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    ...defaultBaseConfig,\n  }),\n  blog: axios.create({\n    baseURL: process.env.REACT_APP_BLOG_API_URL,\n    ...defaultBlogConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre> 1. Create a Default Axios Configuration2. Centralize Configuration in a Service <p>You can create a default configuration object that includes common headers, base URL, and other settings. This can be extended or overridden on a per-request basis.</p> <pre><code>// axiosConfig.js\nimport axios from \"axios\";\n\nconst defaultConfig = {\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosInstance = axios.create(defaultConfig);\n\nexport default axiosInstance;\n</code></pre> <p>You can create a service that provides a reusable configuration function. This function can generate specific configurations based on the needs of each request.</p> <pre><code>// dataService.js\nimport axiosInstance from \"./axiosConfig\";\n\nconst createRequestConfig = (overrideConfig = {}) =&gt; {\n    return {\n        headers: {\n            ...axiosInstance.defaults.headers,\n            ...overrideConfig.headers,\n        },\n        timeout: overrideConfig.timeout || axiosInstance.defaults.timeout,\n        // Add more common settings as needed\n        ...overrideConfig,\n    };\n};\n\nexport const fetchData = (url, signal, config = {}) =&gt; {\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    const requestConfig = createRequestConfig(config);\n\n    return axiosInstance.get(url, {\n        cancelToken: signal,\n        ...requestConfig,\n    });\n};\n</code></pre> <p>how to separate axios config</p> <p>1. Create a Configuration File for Axios Instances</p> <p>You can create separate configuration files for different Axios instances. This way, each instance can have its own specific settings and configurations.</p> <p>Separating your Axios configuration can help improve the organization and maintainability of your code. Here\u2019s how you can structure your project to keep the Axios configuration modular and clean.</p> Example Structure <pre><code>src/\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 axios/\n\u2502   \u2502   \u251c\u2500\u2500 axiosBaseConfig.js\n\u2502   \u2502   \u251c\u2500\u2500 axiosBlogConfig.js\n\u2502   \u2502   \u251c\u2500\u2500 axiosInstance.js\n\u2502   \u2502   \u2514\u2500\u2500 axiosInterceptors.js\n\u2502   \u2514\u2500\u2500 dataService.js\n\u2514\u2500\u2500 ...\n</code></pre> <p>2. Create Base and Blog Configuration Files</p> <p>You can define your base and blog configurations in their respective files.</p> axiosBaseConfig.jsaxiosBlogConfig.js <pre><code>import axios from \"axios\";\n\nconst baseConfig = {\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosBase = axios.create(baseConfig);\n\nexport default axiosBase;\n</code></pre> <pre><code>import axios from \"axios\";\n\nconst blogConfig = {\n    baseURL: process.env.REACT_APP_BLOG_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosBlog = axios.create(blogConfig);\n\nexport default axiosBlog;\n</code></pre> <p>3. Create a Central Instance File</p> <p>You can then create an <code>axiosInstance.js</code> file that imports both configurations and exports them together.</p> axiosInstance.js <pre><code>import axiosBase from './axiosBaseConfig';\nimport axiosBlog from './axiosBlogConfig';\n\nconst axiosInstance = {\n    base: axiosBase,\n    blog: axiosBlog,\n};\n\nexport default axiosInstance;\n</code></pre> <p>4. Set Up Interceptors</p> <p>If you have interceptors that need to apply to both instances, you can create a separate file for them.</p> axiosInterceptors.js <pre><code>import axiosInstance from \"./axiosInstance\";\n\nconst apiKey = process.env.REACT_APP_API_KEY;\n\naxiosInstance.base.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Request made to BASE API:\", config.url);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n\naxiosInstance.blog.interceptors.request.use(\n    (config) =&gt; {\n        if (apiKey) {\n        config.headers[\"Authorization\"] = `Api-Key ${apiKey}`;\n        }\n        console.log(\"Request made to BLOG API:\", config.url);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n    );\n</code></pre> <p>5. Update Your Data Service</p> <p>Now, update your <code>dataService.js</code> to use the centralized <code>axiosInstance</code>.</p> dataService.js <pre><code>import axiosInstance from \"./axios/axiosInstance\";\n\nconst fetchData = (url, signal, instanceType = 'base', config = {}) =&gt; {\n    const instance = instanceType === 'blog' ? axiosInstance.blog : axiosInstance.base;\n\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    return instance.get(url, {\n        cancelToken: signal,\n        ...config,\n    });\n};\n\nexport { fetchData };\n</code></pre> <p>6. Using the Service</p> <p>You can now use the <code>fetchData</code> function with your specified instance type:</p> Example <pre><code>const fetchPosts = async (signal) =&gt; {\n    try {\n        const data = await fetchData(\"/posts\", signal);\n        console.log(data);\n    } catch (error) {\n        console.error(\"Error fetching posts:\", error);\n    }\n};\n\n// Call the function\nfetchPosts(axios.CancelToken.source().token);\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/ultimate/#service","title":"Service","text":"<p>To separate the HTTP methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) into different files, you can create a dedicated service for each method. This will help keep your code organized and maintainable. Here\u2019s how to structure your files:</p> <p>Step 1: Create a Services Directory</p> <p>Create a new directory in your project, e.g., <code>src/services</code>, where you will place your HTTP method files.</p> <p>Step 2: Create Service Files</p> <p>You can create separate files for each HTTP method. Here's how you can structure them:</p> 1. GET Requests2. POST Requests3. PUT Requests4. DELETE Requests <p>Create a file called <code>getService.js</code>:</p> <pre><code>// src/services/getService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const fetchData = async (endpoint) =&gt; {\n    const response = await axiosInstance.base.get(endpoint);\n    return response.data;\n};\n\nexport const fetchBlogPosts = async (endpoint) =&gt; {\n    const response = await axiosInstance.blog.get(endpoint);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>postService.js</code>:</p> <pre><code>// src/services/postService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const createData = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.base.post(endpoint, data);\n    return response.data;\n};\n\nexport const createBlogPost = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.blog.post(endpoint, data);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>putService.js</code>:</p> <pre><code>// src/services/putService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const updateData = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.base.put(endpoint, data);\n    return response.data;\n};\n\nexport const updateBlogPost = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.blog.put(endpoint, data);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>deleteService.js</code>:</p> <pre><code>// src/services/deleteService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const deleteData = async (endpoint) =&gt; {\n    const response = await axiosInstance.base.delete(endpoint);\n    return response.data;\n};\n\nexport const deleteBlogPost = async (endpoint) =&gt; {\n    const response = await axiosInstance.blog.delete(endpoint);\n    return response.data;\n};\n</code></pre> <p>Step 3: Using the Services in Your Slices</p> <p>Now you can use these services in your Redux Toolkit slices. Here\u2019s how you would update the base and blog slices to utilize these services:</p> Example for Base Slice with GETExample for Blog Slice with POST <pre><code>// features/baseSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchData } from '../services/getService';\n\nexport const fetchBaseData = createAsyncThunk(\n    'base/fetchData',\n    async () =&gt; {\n        const data = await fetchData('/data'); // Adjust the endpoint\n        return data;\n    }\n);\n\n//... rest of the slice as before\n</code></pre> <pre><code>// features/blogSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { createBlogPost } from '../services/postService';\n\nexport const addBlogPost = createAsyncThunk(\n    'blog/addPost',\n    async (newPost) =&gt; {\n        const data = await createBlogPost('/posts', newPost); // Adjust the endpoint\n        return data;\n    }\n);\n\n//... rest of the slice as before\n</code></pre> <p>Conclusion</p> <p>By separating your HTTP methods into different service files, you enhance the organization and readability of your code. Each service file handles its respective HTTP method, making it easier to maintain and test. You can follow a similar structure for other HTTP methods as needed.</p>"},{"location":"state-management/redux/rtk/toolkit/ultimate/#questions","title":"Questions","text":""},{"location":"state-management/redux/rtk/toolkit/ultimate/#question-1","title":"Question 1","text":"<pre><code>// features/baseSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchData } from '../services/getService';\n\nexport const fetchBaseData = createAsyncThunk(\n  'base/fetchData',\n  async () =&gt; {\n    const data = await fetchData('/data'); // Adjust the endpoint\n    return data;\n  }\n);\n\n\n// servces/getService.js\nimport axiosInstance from \"./axiosInstance\";\n\n// Base\nexport const createData = async (endpoint, data) =&gt; {\n  const response = await axiosInstance.base.post(endpoint, data);\n  return response.data;\n};\n\n\ndo we need to async await both in the createAsyncThunk in slice and async await in slice getService. or we don't need async await in getService because we have already use the asyc await in slice.\n</code></pre> <p>Yes, you need the <code>async/await</code> in both places for different reasons:</p> <ol> <li> <p>In the <code>createAsyncThunk</code>: This is where you're defining the asynchronous action. The <code>async</code> keyword allows you to use <code>await</code> within that function to handle the asynchronous operation (in this case, fetching data from your API).</p> </li> <li> <p>In the <code>getService</code>: The <code>createData</code> function is also an asynchronous function that performs its own asynchronous operation (making an API request). Using <code>await</code> here ensures that you wait for the API call to complete and return the response data before proceeding.</p> </li> </ol> <p>In summary, each function manages its own asynchronous operations, so you need to keep the <code>async/await</code> in both the <code>createAsyncThunk</code> and your service functions.</p>"},{"location":"state-management/redux/rtk/toolkit/ultimate/#canceltoken","title":"CancelToken","text":"<p>so how to use axios cancelToken in getService</p> <p>To use Axios' <code>CancelToken</code> for cancelling requests in your <code>getService</code> functions, you can follow these steps:</p> <ul> <li>Create a cancel token when you initiate the request.</li> <li>Pass the cancel token to the Axios request.</li> <li>Handle the cancellation as needed in your code.</li> </ul> getService.js <pre><code>import axiosInstance from \"./axiosInstance\";\nimport { CancelToken } from 'axios';\n\n// Base\nexport const createData = async (endpoint, data, cancelToken) =&gt; {\n    const response = await axiosInstance.base.post(endpoint, data, {\n        cancelToken,\n    });\n    return response.data;\n};\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/ultimate/#question-3","title":"Question 3","text":"<p>Your code for fetching data and handling API calls looks solid, but there are opportunities to enhance readability, maintainability, and functionality. Here are some suggestions:</p> <p>1. Centralize API URL Management</p> <p>Instead of hardcoding the endpoints in your <code>apiForDashboardTodo</code> and <code>apiForDashboardPicture</code> functions, consider creating a centralized configuration for your API endpoints. This will make it easier to manage and update in the future.</p> <pre><code>// apiConfig.js\nexport const API_ENDPOINTS = {\n  posts: \"/posts\",\n  albumPhotos: \"/albums/1/photos\",\n};\n\n// dashboard/api.js\nimport { postData, fetchData } from \"../../services/dataService\";\nimport { API_ENDPOINTS } from \"./apiConfig\";\n\nexport const apiForDashboardTodo = (signal) =&gt; {\n  return fetchData(API_ENDPOINTS.posts, signal);\n};\n\nexport const apiForDashboardPicture = (signal) =&gt; {\n  return fetchData(API_ENDPOINTS.albumPhotos, signal);\n};\n</code></pre> <p>2. Improve Fetch Functionality</p> <p>You might want to consider adding additional parameters to the fetchData function to allow for more flexibility, such as custom headers or query parameters.</p> <pre><code>export const fetchData = (url, signal, config = {}) =&gt; {\n  console.log(\"fetchData called with URL:\", url); // Debug log\n  return axiosInstance.base.get(url, {\n    cancelToken: signal,\n    ...config, // Allow for additional config options\n  });\n};\n</code></pre> <p>3. Handle Response Transformation and Errors</p> <p>Consider adding response interceptors in your <code>axiosInterceptors.js</code>for handling transformations and errors globally.</p> <pre><code>axiosInstance.base.interceptors.response.use(\n  (response) =&gt; {\n    // Transform or process response data if needed\n    return response.data; // Return only the data\n  },\n  (error) =&gt; {\n    console.error(\"Response error:\", error);\n    return Promise.reject(error); // Propagate error for handling in calling functions\n  }\n);\n</code></pre> <p>Use <code>Async/Await</code> for API Calls</p> <p>When you consume these API functions, consider using <code>async/await</code> for better readability, especially if you need to handle responses or errors.</p> <pre><code>const fetchDataFromAPI = async () =&gt; {\n  const signal = axios.CancelToken.source().token; // Create cancel token\n  try {\n    const todos = await apiForDashboardTodo(signal);\n    const pictures = await apiForDashboardPicture(signal);\n    // Process the data as needed\n  } catch (error) {\n    console.error(\"Error fetching data:\", error);\n  }\n};\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/example/example/","title":"Intro","text":""},{"location":"state-management/redux/rtk/toolkit/example/example/#basic-example","title":"Basic Example","text":"<p>Here's a modular setup for a simple counter application using Redux Toolkit and React-Redux. We will structure the code in separate files to keep it organized.</p> <p>Project Structure</p> <pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u2514\u2500\u2500 store.js\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u2514\u2500\u2500 counterSlice.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> store.jscounterSlice.jsCounter.jsApp.jsindex.js <ol> <li> <p>Create Redux Store (<code>store.js</code>)</p> <p>Create the file <code>src/app/store.js</code>:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> </li> </ol> <ol> <li> <p>Create Counter Slice (<code>counterSlice.js</code>)</p> <p>Create the file <code>src/features/counterSlice.js</code>:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    value: 0,\n};\n\nexport const counterSlice = createSlice({\n    name: 'counter',\n    initialState,\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Create Counter Component (<code>Counter.js</code>)</p> <p>Create the file <code>src/components/Counter.js</code>:</p> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from '../features/counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;Increment by 5&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up the Main App Component (<code>App.js</code>)</p> <p>Modify the file <code>src/App.js</code>:</p> <pre><code>import React from 'react';\nimport Counter from './components/Counter';\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Redux Toolkit Counter Example&lt;/h1&gt;\n            &lt;Counter /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> </li> </ol> <ol> <li> <p>Wrap the Application with Provider (<code>index.js</code>)</p> <p>Modify the file <code>src/index.js</code>:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport store from './app/store';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n    root.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;\n);\n</code></pre> </li> </ol> <p>Summary</p> <p>In this modular setup:</p> <ul> <li>Store: Defined in <code>store.js</code>, which configures the Redux store.</li> <li>Slice: The <code>counterSlice.js</code> file defines the state, actions, and reducer.</li> <li>Component: The <code>Counter.js</code> file uses hooks to access the Redux state and dispatch actions.</li> <li>App Component: The <code>App.js</code> file serves as the main component that includes the <code>Counter</code>.</li> </ul> <p>This organization helps keep your code clean and maintainable, especially as your application grows.</p>"},{"location":"state-management/redux/rtk/toolkit/example/example/#additional","title":"Additional","text":"<p>where is action here, and reducer?</p> <p>Let\u2019s break down your <code>counterSlice.js</code> code to clarify where the actions and the reducer are defined and how they work.</p> ActionsReducerSummary <p>In Redux, actions are payloads of information that send data from your application to the Redux store. In your <code>counterSlice.js</code>, the actions are created automatically by <code>createSlice</code>.</p> <p>Here\u2019s how it works:</p> <ol> <li> <p>Define Actions: Inside the <code>reducers</code> object of <code>createSlice</code>, you define functions for each action you want. In your code, you have:</p> <ul> <li><code>increment</code></li> <li><code>decrement</code></li> <li><code>incrementByAmount</code></li> </ul> </li> <li> <p>Export Actions: When you call <code>createSlice</code>, it generates action creators for each of these reducers. You export them like this:</p> <pre><code>export const { increment, decrement, incrementByAmount } = counterSlice.actions;\n</code></pre> </li> </ol> <p>The reducer is a function that determines how the state changes in response to actions. In your <code>counterSlice.js</code>, the reducer is also created automatically by <code>createSlice</code>.</p> <ol> <li> <p>Generated Reducer: The <code>createSlice</code> function creates a reducer based on the functions defined in the <code>reducers</code> object. This reducer handles updates to the state based on the actions dispatched.</p> </li> <li> <p>Export the Reducer: You export the reducer with this line:</p> <pre><code>export default counterSlice.reducer;\n</code></pre> </li> </ol> <ul> <li>Actions: The actions are the functions you defined in the <code>reducers</code> object. They are automatically turned into action creators by <code>createSlice</code> and can be dispatched to update the state.</li> <li>Reducer: The <code>createSlice</code> function generates a reducer that you export, which handles how the state should change based on the actions dispatched.</li> </ul> <p>Example of Using Actions and Reducer</p> <p>Here\u2019s how you would use them in a React component:</p> 1. Dispatching Actions2. Using the Reducer in the Store <pre><code>import { useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './features/counterSlice';\n\nconst MyComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    return (\n        &lt;&gt;\n        &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;Increment by 5&lt;/button&gt;\n        &lt;/&gt;\n    );\n};\n</code></pre> <p>When you set up your Redux store, you include this reducer:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer, // This is where the reducer is used\n    },\n});\n\nexport default store;\n</code></pre> <p>This structure allows your application to respond to user actions by updating the state in a predictable way.</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/intro/","title":"Intro","text":"<p>RTK (Redux Toolkit) middleware is a powerful feature that allows you to extend Redux's capabilities by adding custom behavior to the dispatch process. Middleware can intercept actions before they reach the reducer, enabling you to handle side effects, logging, error reporting, and more.</p> explain to 5 years old <p>Imagine you have a toy box, and every time you want to play, you ask your helper to get a toy for you.</p> <p>Middleware is like that helper. When you ask for a toy (like getting some information), the helper makes sure everything goes smoothly. It can even do some extra things, like making sure the toy is clean before giving it to you or telling you if the toy is broken.</p> <p>In Redux Toolkit, middleware helps handle special tasks (like fetching data) when your app needs to change things. It makes sure everything is done right before you see the results!</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/","title":"Setup","text":"<p>Redux Thunk is a middleware for async actions</p> <p>You can log the result of <code>configureStore</code> to see its properties, including the middleware and any other configurations. However, since <code>configureStore</code> returns a store object, you won't see the middleware directly. Instead, you can inspect the store object for its properties.</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#example-of-logging-configurestore","title":"Example of Logging configureStore","text":"<p>Here\u2019s how you can log the configured store:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport userReducer from \"./userSlice\"; // Adjust the path accordingly\n\nconst store = configureStore({\n  reducer: {\n    users: userReducer, // Your slice reducer\n  },\n  // You can also add middleware here if needed\n});\n\n// Log the store\nconsole.log(store);\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#what-you-can-see","title":"What You Can See","text":"<p>When you log the store, you\u2019ll see various properties, such as:</p> <ul> <li><code>dispatch</code>: The dispatch function to send actions to the store.</li> <li><code>getState</code>: A function to access the current state.</li> <li><code>subscribe</code>: A function to listen for changes to the store.</li> <li><code>replaceReducer</code>: A method to replace the current reducer.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#checking-middleware","title":"Checking Middleware","text":"<p>To see the middleware specifically, you can inspect the store using the Redux DevTools extension in your browser. This tool will show you dispatched actions and the state changes, giving you insight into how the middleware is working.</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#redux-toolkit-consolelog","title":"Redux Toolkit <code>console.log</code>","text":"<p>To find out how many utility functions are available in a library like Redux Toolkit, you typically look at the library\u2019s documentation or its source code. However, you can also explore the library's exports using JavaScript. Here\u2019s how you can do that:</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#1-check-the-documentation","title":"1. Check the Documentation","text":"<p>The first and best way to find available utility functions is to check the Redux Toolkit documentation. It provides detailed information about the various functions, hooks, and utilities you can use.</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#2-log-all-exports","title":"2. Log All Exports","text":"<p>If you want to explore the available functions programmatically, you can log the exports from the Redux Toolkit module. Here\u2019s how to do it:</p> <p>Example: Logging Available Functions</p> <ol> <li>Import the Module: First, import the entire module.</li> <li>Log the Exports: Use <code>console.log</code> to inspect them.</li> </ol> <pre><code>import * as reduxToolkit from \"@reduxjs/toolkit\";\n\n// Log all available exports\nconsole.log(\"Redux Toolkit Exports:\", reduxToolkit);\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#3-explore-the-logged-object","title":"3. Explore the Logged Object","text":"<p>In the console, you can expand the reduxToolkit object to see all available functions.</p>"},{"location":"state-management/redux/rtk/toolkit/middleware/setup/#4-using-objectkeys","title":"4. Using <code>Object.keys</code>","text":"<p>If you just want to see the names of the available functions, you can use <code>Object.keys</code>:</p> <pre><code>import * as reduxToolkit from \"@reduxjs/toolkit\";\n\nconst toolkitFunctions = Object.keys(reduxToolkit);\nconsole.log(\"Available Redux Toolkit Functions:\", toolkitFunctions);\n</code></pre> <p>This will give you an array of strings, where each string is the name of an exportable function.</p> Summary <ol> <li>Check Documentation: Always start with the official documentation for the most reliable information.</li> <li>Log Exports: Use <code>console.log</code> to log the entire Redux Toolkit module.</li> <li>Explore: Expand the logged object in the console to see available functions.</li> <li>List Function Names: Use <code>Object.keys</code> to get a simple list of function names.</li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/a.how-to-right-question/","title":"Intro","text":"<p>.....correct me with right question and right answer</p> <p></p> <p></p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/","title":"How action types are managed","text":""},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#overview","title":"Overview","text":"<p>In Redux Toolkit, you generally don't need to define action types as separate constants like you do in standard Redux. When you use <code>createSlice</code>, it automatically generates action types based on the names of the reducers you define. Here\u2019s how it works:</p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#how-action-types-are-managed-in-redux-toolkit","title":"How Action Types Are Managed in Redux Toolkit","text":"<ol> <li> <p>Automatic Generation: When you create a slice using <code>createSlice</code>, the action types are automatically created using the format <code>sliceName/actionName</code>. For example, if your slice is named \"<code>counter</code>\" and you have an action called \"<code>increment</code>\", the action type will be \"<code>counter/increment</code>\".</p> </li> <li> <p>No Need for Constants: Because the action types are generated automatically, you don't have to define them as constants manually. This reduces boilerplate code.</p> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#example","title":"Example","text":"<p>Here\u2019s a simple example to illustrate:</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1; // No need to define the action type as a constant\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// Action creators are automatically generated\nexport const { increment, decrement } = counterSlice.actions;\n\n// The action types are automatically created:\n// increment -&gt; \"counter/increment\"\n// decrement -&gt; \"counter/decrement\"\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>No Manual Action Types: You don\u2019t need to define action types manually in Redux Toolkit, which simplifies your code.</li> <li>Automatic Action Type Generation: Action types are generated based on the slice name and reducer names, making it clear and easy to understand.</li> </ul> <p>This design choice in Redux Toolkit aims to reduce boilerplate and make it easier to manage state in applications.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#additional","title":"Additional","text":"<p>so this name: 'counter' is important and should be unique, am i correct</p> <p>Yes, you are correct! The <code>name</code> property in <code>createSlice</code> is important and should be unique within your application. Here\u2019s why:</p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#importance-of-the-name-property","title":"Importance of the <code>name</code> Property","text":"<ol> <li> <p>Action Type Prefix: The <code>name</code> you provide becomes the prefix for the automatically generated action types. For example, if you name your slice \"<code>counter</code>\", the actions generated will be \"<code>counter/increment</code>\" and \"<code>counter/decrement</code>\". If you have another slice named \"<code>todos</code>\", its actions will be \"<code>todos/add</code>\" and \"<code>todos/remove</code>\". This helps avoid action name collisions.</p> </li> <li> <p>Clarity and Organization: A unique name helps clarify what the slice represents. It makes it easier to understand the purpose of the slice just by looking at the action types and helps in organizing your code, especially in larger applications.</p> </li> <li> <p>Avoiding Conflicts: If two slices have the same name, it can lead to confusion and unintended behavior, as their action types would clash. Keeping names unique helps prevent such conflicts.</p> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#example_1","title":"Example","text":"<p>Here\u2019s an example demonstrating the importance of unique names:</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\", // Unique name for the counter slice\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1;\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// todosSlice.js\nconst todosSlice = createSlice({\n  name: \"todos\", // Unique name for the todos slice\n  initialState: { items: [] },\n  reducers: {\n    addTodo: (state, action) =&gt; {\n      state.items.push(action.payload);\n    },\n    removeTodo: (state, action) =&gt; {\n      state.items = state.items.filter((todo) =&gt; todo.id !== action.payload.id);\n    },\n  },\n});\n\n// Action types will be:\n// \"counter/increment\"\n// \"counter/decrement\"\n// \"todos/addTodo\"\n// \"todos/removeTodo\"\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#summary_1","title":"Summary","text":"<ul> <li>Unique and Descriptive: Make sure the name is unique and descriptive of the slice's purpose.</li> <li>Prevents Clashes: Helps prevent naming conflicts in your action types.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/","title":"How does Redux Toolkit use default thunk middleware","text":"<p>How does Redux Toolkit use default thunk middleware, and can you provide an example?</p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#overview","title":"Overview","text":"<p>Redux Toolkit automatically applies thunk middleware when you create a store using <code>configureStore</code>. This allows you to write action creators that return functions (thunks) to handle asynchronous logic, like API calls.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#example","title":"Example","text":"<p>Here's how you can use Redux Toolkit with default thunk middleware to manage an asynchronous API call:</p> <ol> <li> <p>Set Up Your Slice with Thunks: Create a slice that includes an asynchronous action creator using <code>createAsyncThunk</code> (which is built on top of thunk).</p> </li> <li> <p>Configure the Store: Use <code>configureStore</code> to create your Redux store.</p> </li> <li> <p>Dispatch the Thunk from a Component: Use the <code>useDispatch</code> hook in your React component to trigger the asynchronous action.</p> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#step-by-step-example","title":"Step-by-Step Example","text":"<ol> <li> <p>Create a Slice with Thunks</p> <pre><code>// usersSlice.js\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\n\n// Async thunk for fetching users\nexport const fetchUsers = createAsyncThunk(\"users/fetchUsers\", async () =&gt; {\n  const response = await axios.get(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n  return response.data; // This will be the payload in the fulfilled action\n});\n\n// Create the users slice\nconst usersSlice = createSlice({\n  name: \"users\",\n  initialState: {\n    users: [],\n    loading: false,\n    error: null,\n  },\n  reducers: {},\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchUsers.pending, (state) =&gt; {\n        state.loading = true; // Set loading to true\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) =&gt; {\n        state.loading = false; // Set loading to false\n        state.users = action.payload; // Store fetched users\n      })\n      .addCase(fetchUsers.rejected, (state, action) =&gt; {\n        state.loading = false; // Set loading to false\n        state.error = action.error.message; // Store error message\n      });\n  },\n});\n\n// Export the reducer\nexport default usersSlice.reducer;\n</code></pre> </li> <li> <p>Configure the Store</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport usersReducer from \"./usersSlice\";\n\nconst store = configureStore({\n  reducer: {\n    users: usersReducer, // Add users slice reducer\n  },\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Use the Thunk in a Component</p> <pre><code>// UsersList.js\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { fetchUsers } from \"./usersSlice\";\n\nconst UsersList = () =&gt; {\n  const dispatch = useDispatch();\n  const { users, loading, error } = useSelector((state) =&gt; state.users);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers()); // Dispatch the thunk to fetch users\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;/h1&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UsersList;\n</code></pre> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#summary","title":"Summary","text":"<ul> <li>Default Thunk Middleware: Redux Toolkit automatically includes thunk middleware when using <code>configureStore</code>.</li> <li>Using Thunks: You create async action creators with <code>createAsyncThunk</code>, which can be dispatched like regular actions in your components.</li> </ul> <p>This example illustrates how Redux Toolkit leverages the default thunk middleware to handle asynchronous API calls seamlessly, providing a clean and organized way to manage state.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/","title":"Is it mandatory to use createAsyncThunk for API calls","text":"<p>Is it mandatory to use createAsyncThunk for API calls in Redux Toolkit?</p>"},{"location":"state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/#overview","title":"Overview","text":"<p>No, it is not mandatory to use <code>createAsyncThunk</code> for API calls in Redux Toolkit. However, it is recommended for several reasons:</p> <ol> <li> <p>Simplifies Code: <code>createAsyncThunk</code> helps reduce boilerplate by automatically handling the pending, fulfilled, and rejected action states, making your code cleaner and more manageable.</p> </li> <li> <p>Consistent Error Handling: It provides a structured way to handle errors, which can improve the robustness of your application.</p> </li> <li> <p>Easier Integration: It seamlessly integrates with Redux Toolkit\u2019s slice structure, allowing for a more streamlined approach to state management.</p> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/#alternatives-to-createasyncthunk","title":"Alternatives to createAsyncThunk:","text":"<p>While <code>createAsyncThunk</code> is highly beneficial, you can manage API calls using:</p> <ol> <li> <p>Custom Thunks: You can create your own thunk action creators using the <code>thunk</code> middleware without <code>createAsyncThunk</code>, though this requires more manual setup.</p> <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: \"data/fetchStart\" });\n  try {\n    const response = await axios.get(\"/api/data\");\n    dispatch({ type: \"data/fetchSuccess\", payload: response.data });\n  } catch (error) {\n    dispatch({ type: \"data/fetchError\", payload: error.message });\n  }\n};\n</code></pre> </li> <li> <p>Direct API Calls in Components: You could also handle API calls directly within your React components using hooks like <code>useEffect</code>, but this approach can lead to tightly coupled components and less reusable code.</p> </li> </ol> <p>Conclusion</p> <p>While <code>createAsyncThunk</code> is not mandatory for API calls in Redux Toolkit, using it is a best practice that can simplify your code and improve the overall structure of your application.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/","title":"Should API calls be in the same file","text":"<p>Should API calls be in the same file as the Redux slice, or is it better to separate them into different files? What is the standard practice?</p>"},{"location":"state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/#overview","title":"Overview","text":"<p>The standard practice is to separate API calls from the Redux slice. Here\u2019s why:</p> <ol> <li> <p>Separation of Concerns: Keeping API logic separate from state management logic promotes better organization and makes the code easier to maintain. It allows each part to evolve independently.</p> </li> <li> <p>Reusability: If API calls are separated, they can be reused across different slices or components without duplicating code.</p> </li> <li> <p>Testing: It\u2019s easier to test API functions independently from the slice, allowing for unit testing of each part.</p> </li> <li> <p>Readability: Separating concerns makes the code more readable. Developers can quickly understand where API calls are made and how they interact with the Redux state.</p> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/#example","title":"Example","text":"StructurepostsApi.jspostsSlice.jsComponent <p>Here\u2019s how you might organize the files:</p> <pre><code>/src\n    /api\n        postsApi.js        // Contains API call functions\n    /features\n        postsSlice.js      // Contains the slice and thunks\n</code></pre> <pre><code>import axios from 'axios';\n\nexport const fetchPostsApi = () =&gt; {\n    return axios.get('https://jsonplaceholder.typicode.com/posts');\n};\n\nexport const addPostApi = (newPost) =&gt; {\n    return axios.post('https://jsonplaceholder.typicode.com/posts', newPost);\n};\n\nexport const deletePostApi = (postId) =&gt; {\n    return axios.delete(`https://jsonplaceholder.typicode.com/posts/${postId}`);\n};\n</code></pre> <pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchPostsApi, addPostApi, deletePostApi } from \"../api/postsApi\";\n\n// Async thunk for fetching posts\nexport const fetchPosts = createAsyncThunk(\"posts/fetchPosts\", async () =&gt; {\n    const response = await fetchPostsApi();\n    return response.data;\n});\n\n// Async thunk for adding a post\nexport const addPost = createAsyncThunk(\"posts/addPost\", async (newPost) =&gt; {\n    const response = await addPostApi(newPost);\n    return response.data;\n});\n\n// Async thunk for deleting a post\nexport const deletePost = createAsyncThunk(\n    \"posts/deletePost\",\n    async (postId) =&gt; {\n        await deletePostApi(postId);\n        return postId;\n    }\n);\n\n// Create the posts slice (similar to previous example)\nconst postsSlice = createSlice({\n    name: \"posts\",\n    initialState: {\n        posts: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        // other reducers...\n    },\n    extraReducers: (builder) =&gt; {\n        // handle extra reducers...\n    },\n});\n\n// Export actions and reducer\nexport const { updatePost } = postsSlice.actions;\nexport default postsSlice.reducer;\n</code></pre> <pre><code>// Blog.js\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchPosts, addPost, deletePost, updatePost } from './features/postsSlice';\n\nconst Blog = () =&gt; {\n    const dispatch = useDispatch();\n    const { posts, loading, error } = useSelector((state) =&gt; state.posts);\n    const [newPost, setNewPost] = useState({ title: '', body: '' });\n    const [editingPost, setEditingPost] = useState(null);\n\n    // Fetch posts when the component mounts\n    useEffect(() =&gt; {\n        dispatch(fetchPosts());\n    }, [dispatch]);\n\n    const handleAddPost = () =&gt; {\n        if (newPost.title &amp;&amp; newPost.body) {\n            dispatch(addPost(newPost));\n            setNewPost({ title: '', body: '' });\n        }\n    };\n\n    const handleUpdatePost = () =&gt; {\n        if (editingPost) {\n            dispatch(updatePost(editingPost));\n            setEditingPost(null);\n            setNewPost({ title: '', body: '' }); // Reset input fields\n        }\n    };\n\n    const handleEditClick = (post) =&gt; {\n        setEditingPost(post);\n        setNewPost({ title: post.title, body: post.body });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Blog Posts&lt;/h1&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;div&gt;\n                &lt;input\n                    value={newPost.title}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, title: e.target.value })}\n                    placeholder=\"Title\"\n                /&gt;\n                &lt;textarea\n                    value={newPost.body}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, body: e.target.value })}\n                    placeholder=\"Body\"\n                /&gt;\n                &lt;button onClick={editingPost ? handleUpdatePost : handleAddPost}&gt;\n                    {editingPost ? 'Update Post' : 'Add Post'}\n                &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;ul&gt;\n                {posts.map(post =&gt; (\n                    &lt;li key={post.id}&gt;\n                        &lt;h2&gt;{post.title}&lt;/h2&gt;\n                        &lt;p&gt;{post.body}&lt;/p&gt;\n                        &lt;button onClick={() =&gt; handleEditClick(post)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch(deletePost(post.id))}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Blog;\n</code></pre> <p>Conclusion</p> <p>Separating API calls into their own module is the standard practice. It enhances code maintainability, readability, and reusability, aligning with best practices in software development.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/","title":"What are thunk action creators","text":"<p>What are thunk action creators, and does Redux Toolkit use thunk or saga by default?</p>"},{"location":"state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#1-what-are-thunk-action-creators","title":"1. What are Thunk Action Creators?","text":"<ul> <li> <p>Thunk Action Creators are functions that return another function (the thunk) instead of a plain action object. This thunk can perform asynchronous operations, such as API calls, and then dispatch actions based on the results.</p> </li> <li> <p>In Redux, this allows for side effects like fetching data, waiting for promises to resolve, and conditionally dispatching actions based on the state.</p> </li> </ul> Example<pre><code>const fetchUser = (userId) =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: \"USER_FETCH_REQUEST\" });\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      dispatch({ type: \"USER_FETCH_SUCCESS\", payload: data });\n    } catch (error) {\n      dispatch({ type: \"USER_FETCH_FAILURE\", error: error.message });\n    }\n  };\n};\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#2-does-redux-toolkit-use-thunk-or-saga-by-default","title":"2. Does Redux Toolkit Use Thunk or Saga by Default?","text":"<ul> <li>Redux Toolkit uses thunk middleware by default. This means when you create a store using <code>configureStore</code>, it automatically applies the thunk middleware, allowing you to use thunk action creators directly.</li> <li>Redux Saga is not included by default in Redux Toolkit, but it can be added as middleware if needed for handling more complex side effects or managing asynchronous flows.</li> </ul>"},{"location":"state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#summary","title":"Summary","text":"<ul> <li>Thunk Action Creators: Functions that return another function to handle asynchronous logic and side effects in Redux.</li> <li>Default Middleware: Redux Toolkit uses thunk middleware by default, while Redux Saga can be added as needed for more complex scenarios.</li> </ul> <p>This structure makes Redux Toolkit simpler and more accessible for most applications while still allowing for advanced patterns if required.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/where-do-we-define-action/","title":"Where do we define action","text":"<p>where do we defined the action in the standa redux vs redux toolk</p> <p>In both standard Redux and Redux Toolkit, actions are a crucial part of managing state, but they are defined and organized differently. Here\u2019s a breakdown of where and how actions are defined in each approach:</p>"},{"location":"state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#standard-redux","title":"Standard Redux","text":"<p>In standard Redux, actions are typically defined as follows:</p> <ol> <li> <p>Action Types: You define constant action types, usually in a separate file.</p> <pre><code>// actionTypes.js\nexport const INCREMENT = \"INCREMENT\";\nexport const DECREMENT = \"DECREMENT\";\n</code></pre> </li> <li> <p>Action Creators: You create action creators that return action objects. This is usually done in a separate file as well.</p> <pre><code>// actions.js\nimport { INCREMENT, DECREMENT } from \"./actionTypes\";\n\nexport const increment = () =&gt; ({\n  type: INCREMENT,\n});\n\nexport const decrement = () =&gt; ({\n  type: DECREMENT,\n});\n</code></pre> </li> <li> <p>Reducers: In the reducer, you handle the actions based on their type.</p> <pre><code>// reducer.js\nimport { INCREMENT, DECREMENT } from \"./actionTypes\";\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, value: state.value + 1 };\n    case DECREMENT:\n      return { ...state, value: state.value - 1 };\n    default:\n      return state;\n  }\n};\n\nexport default counterReducer;\n</code></pre> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#redux-toolkit","title":"Redux Toolkit","text":"<p>In Redux Toolkit, actions are defined differently using <code>createSlice</code>, which combines the action creator and reducer definitions into one:</p> <ol> <li> <p>Using <code>createSlice</code>: You define actions along with the reducer in a single slice file.</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1; // Directly mutating the state, thanks to Immer\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// Export actions\nexport const { increment, decrement } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#summary-of-differences","title":"Summary of Differences","text":"<ol> <li> <p>Organization:</p> <ul> <li>Standard Redux: Actions are usually defined separately from reducers, leading to more boilerplate code.</li> <li>Redux Toolkit: Actions and reducers are combined in a slice, making it more concise and easier to manage.</li> </ul> </li> <li> <p>Action Creation:</p> <ul> <li>Standard Redux: You manually create action objects and define action types.</li> <li>Redux Toolkit: You use <code>createSlice</code>, which automatically generates action creators based on the defined reducers.</li> </ul> </li> </ol>"},{"location":"state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#conclusion","title":"Conclusion","text":"<p>Redux Toolkit streamlines the process of defining actions and reducers, making it easier to work with Redux and reducing the amount of boilerplate code required. If you have any further questions or need more examples, feel free to ask!</p>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/","title":"Why does redux toolkit combine","text":"<p>Why does Redux Toolkit combine action creators and reducers in the same function?</p>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#overview","title":"Overview","text":"<p>Redux Toolkit uses a function called <code>createSlice</code> to combine action creators and reducers for several reasons:</p> <ol> <li> <p>Simplicity: By defining actions and reducers together, it reduces boilerplate code and makes the codebase easier to read and maintain.</p> </li> <li> <p>Co-location: Having related logic in one place helps with understanding the flow of data and makes it easier to see how actions affect state.</p> </li> <li> <p>Automatic Action Creation: When you define reducers in <code>createSlice</code>, Redux Toolkit automatically generates corresponding action creators, so you don\u2019t have to define them separately.</p> </li> <li> <p>Type Safety: It enhances type safety in TypeScript projects by linking action types directly with their reducers, minimizing the chance of errors.</p> </li> <li> <p>Improved Maintainability: When the logic for state updates is closely associated with the actions that trigger them, it helps future developers (or yourself) quickly grasp how to modify the state effectively.</p> </li> </ol> <p>By integrating these concepts, Redux Toolkit streamlines state management, making it more efficient and developer-friendly.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#example","title":"Example","text":"<p>Here\u2019s a simple example followed by a more advanced example of using Redux Toolkit with <code>createSlice</code>.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#simple-example","title":"Simple Example","text":"<p>Goal: A counter application that increments and decrements a counter value.</p> ExampleUsage in a Component <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        reset: (state) =&gt; {\n            state.value = 0;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, reset } = counterSlice.actions;\n\n// Export reducer\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { increment, decrement, reset } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const dispatch = useDispatch();\n    const count = useSelector((state) =&gt; state.counter.value);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(reset())}&gt;Reset&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#advanced-example","title":"Advanced Example","text":"<p>Goal: A todo application that adds, removes, and toggles the completion status of todos.</p> ExampleComponent <pre><code>// todosSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst todosSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: {\n            reducer: (state, action) =&gt; {\n                state.push(action.payload);\n            },\n            prepare: (text) =&gt; {\n                return { payload: { id: Date.now(), text, completed: false } };\n            },\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload);\n        },\n        toggleTodo: (state, action) =&gt; {\n            const todo = state.find(todo =&gt; todo.id === action.payload);\n            if (todo) {\n                todo.completed = !todo.completed;\n            }\n        },\n    },\n});\n\n// Export actions\nexport const { addTodo, removeTodo, toggleTodo } = todosSlice.actions;\n\n// Export reducer\nexport default todosSlice.reducer;\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { addTodo, removeTodo, toggleTodo } from \"./todosSlice\";\n\nconst Todos = () =&gt; {\n    const [text, setText] = useState(\"\");\n    const dispatch = useDispatch();\n    const todos = useSelector((state) =&gt; state.todos);\n\n    const handleAdd = () =&gt; {\n        if (text) {\n            dispatch(addTodo(text));\n            setText(\"\");\n        }\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                value={text}\n                onChange={(e) =&gt; setText(e.target.value)}\n                placeholder=\"Add a todo\"\n            /&gt;\n            &lt;button onClick={handleAdd}&gt;Add Todo&lt;/button&gt;\n            &lt;ul&gt;\n                {todos.map((todo) =&gt; (\n                    &lt;li key={todo.id}&gt;\n                        &lt;span\n                            onClick={() =&gt; dispatch(toggleTodo(todo.id))}\n                            style={{\n                                textDecoration: todo.completed ? \"line-through\" : \"none\",\n                            }}\n                        &gt;\n                            {todo.text}\n                        &lt;/span&gt;\n                        &lt;button onClick={() =&gt; dispatch(removeTodo(todo.id))}&gt;\n                        Remove\n                        &lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Todos;\n</code></pre> <p>Summary</p> <ul> <li>Simple Example: A basic counter with increment, decrement, and reset actions.</li> <li>Advanced Example: A todo app that allows adding, removing, and toggling todos with unique IDs and completion status.</li> </ul> <p>These examples show how Redux Toolkit simplifies the process of defining state management logic by combining actions and reducers, making it more intuitive and easier to manage.</p>"},{"location":"state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#complex-example","title":"Complex Example","text":"<p>Complex Example: Blog Application</p> <p>Goal: A blog application that allows users to create, update, delete, and fetch posts.</p> SetupComponentExplanation <p>Setup: Slice with Async Thunks</p> <p>We'll use <code>createSlice</code> and <code>createAsyncThunk</code> to handle asynchronous actions for fetching posts.</p> <pre><code>// postsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Async thunk for fetching posts\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () =&gt; {\n    const response = await axios.get('https://jsonplaceholder.typicode.com/posts');\n    return response.data;\n});\n\n// Async thunk for adding a post\nexport const addPost = createAsyncThunk('posts/addPost', async (newPost) =&gt; {\n    const response = await axios.post('https://jsonplaceholder.typicode.com/posts', newPost);\n    return response.data;\n});\n\n// Async thunk for deleting a post\nexport const deletePost = createAsyncThunk('posts/deletePost', async (postId) =&gt; {\n    await axios.delete(`https://jsonplaceholder.typicode.com/posts/${postId}`);\n    return postId; // Return the post ID to remove it from the state\n});\n\n// Create the posts slice\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState: {\n        posts: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        updatePost: (state, action) =&gt; {\n            const index = state.posts.findIndex(post =&gt; post.id === action.payload.id);\n            if (index !== -1) {\n                state.posts[index] = action.payload; // Update the post\n            }\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchPosts.pending, (state) =&gt; {\n                state.loading = true;\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) =&gt; {\n                state.loading = false;\n                state.posts = action.payload;\n            })\n            .addCase(fetchPosts.rejected, (state, action) =&gt; {\n                state.loading = false;\n                state.error = action.error.message;\n            })\n            .addCase(addPost.fulfilled, (state, action) =&gt; {\n                state.posts.push(action.payload);\n            })\n            .addCase(deletePost.fulfilled, (state, action) =&gt; {\n                state.posts = state.posts.filter(post =&gt; post.id !== action.payload);\n            });\n    },\n});\n\n// Export actions\nexport const { updatePost } = postsSlice.actions;\n\n// Export reducer\nexport default postsSlice.reducer;\n</code></pre> <p>Component: Blog Post Management</p> <p>This component will allow you to fetch, add, update, and delete posts.</p> <pre><code>// Blog.js\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchPosts, addPost, deletePost, updatePost } from './postsSlice';\n\nconst Blog = () =&gt; {\n    const dispatch = useDispatch();\n    const { posts, loading, error } = useSelector((state) =&gt; state.posts);\n    const [newPost, setNewPost] = useState({ title: '', body: '' });\n    const [editingPost, setEditingPost] = useState(null);\n\n    useEffect(() =&gt; {\n        dispatch(fetchPosts());\n    }, [dispatch]);\n\n    const handleAddPost = () =&gt; {\n        if (newPost.title &amp;&amp; newPost.body) {\n            dispatch(addPost(newPost));\n            setNewPost({ title: '', body: '' });\n        }\n    };\n\n    const handleUpdatePost = () =&gt; {\n        if (editingPost) {\n            dispatch(updatePost(editingPost));\n            setEditingPost(null);\n        }\n    };\n\n    const handleEditClick = (post) =&gt; {\n        setEditingPost(post);\n        setNewPost({ title: post.title, body: post.body });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Blog Posts&lt;/h1&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;div&gt;\n                &lt;input\n                    value={newPost.title}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, title: e.target.value })}\n                    placeholder=\"Title\"\n                /&gt;\n                &lt;textarea\n                    value={newPost.body}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, body: e.target.value })}\n                    placeholder=\"Body\"\n                /&gt;\n                &lt;button onClick={editingPost ? handleUpdatePost : handleAddPost}&gt;\n                    {editingPost ? 'Update Post' : 'Add Post'}\n                &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;ul&gt;\n                {posts.map(post =&gt; (\n                    &lt;li key={post.id}&gt;\n                        &lt;h2&gt;{post.title}&lt;/h2&gt;\n                        &lt;p&gt;{post.body}&lt;/p&gt;\n                        &lt;button onClick={() =&gt; handleEditClick(post)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch(deletePost(post.id))}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Blog;\n</code></pre> <ol> <li> <p>Asynchronous Actions: The example uses <code>createAsyncThunk</code> to handle API requests for fetching, adding, and deleting posts. This separates the side effects (like API calls) from the reducers.</p> </li> <li> <p>Loading and Error Handling: The slice keeps track of loading states and errors, which are displayed in the component.</p> </li> <li> <p>Edit Functionality: Users can edit posts by filling in the input fields, which updates the corresponding post in the state.</p> </li> <li> <p>Combined Actions: The slice uses both synchronous reducers (like <code>updatePost</code>) and asynchronous thunks, allowing for complex interactions.</p> </li> </ol> <p>Conclusion</p> <p>This example illustrates a more complex use case for Redux Toolkit, demonstrating how to manage a list of items with asynchronous operations while handling loading and error states effectively. It provides a good foundation for building out a more complete application.</p>"},{"location":"state-management/redux/standard-redux/intro/","title":"Intro","text":""},{"location":"state-management/redux/standard-redux/intro/#redux-toolkit-a-modern-approach-to-redux","title":"Redux Toolkit: a modern approach to Redux","text":"<p>Redux Toolkit is the official, opinionated, and batteries-included toolset for efficient Redux development. It was created to help developers write better and more efficient Redux code with less boilerplate.</p> <p>Intallation</p>"},{"location":"state-management/redux/standard-redux/intro/#install-redux-toolkit-and-react-redux","title":"Install Redux Toolkit and React-Redux","text":"<p>Add the Redux Toolkit and React-Redux packages to your project:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <ul> <li>ofiical redux tookit</li> </ul>"},{"location":"state-management/redux/standard-redux/intro/#key-features","title":"Key features","text":"<p>Redux Toolkit comes with several key features that simplify the Redux development process:</p> <ul> <li>configureStore: A function that sets up a Redux store with sensible defaults.</li> <li>createSlice: A function that automatically generates action creators and reducers based on a provided configuration.</li> <li>createAction: A utility function to create action creators with a specific type and payload.</li> <li>createReducer: A utility function that simplifies reducer creation using Immer, enabling direct state manipulation.</li> </ul> <p>Redux Middleware is code that lets us intercept redux actions before they reach the reducer. <code>redux-thunk</code> is an example of Redux Middleware, along with other popular <code>redux</code> libraries like <code>redux-logger</code> , <code>redux-promise-middleware</code> , and <code>redux-saga</code> (an alternative to <code>redux-thunk</code> ).</p> <p></p>"},{"location":"state-management/redux/standard-redux/intro/#redux-thunk-gives-redux-side-effects","title":"Redux Thunk Gives Redux Side-Effects","text":"<p>In <code>redux</code>, actions creators are functions that return an action, which is a plain javascript objects with a <code>type</code> property.</p> <ul> <li><code>redux-thunk</code> is a Redux Middleware that lets your action creators return a function called a thunk, instead of an action. </li> <li>This thunk can return an action when invoked but it also has access to the Redux store's <code>dispatch</code> function, meaning it can also dispatch other actions. </li> <li>Typically, API calls are invoked inside these thunks and different actions are dispatched depending on these API responses.</li> </ul> <p>For example, below are two action creators, the first returns a plain redux action. The second returns a <code>thunk</code>, thanks to <code>redux-thunk</code>.</p> <pre><code>// action creators\n\n// Action Creator returns action\nloadUser = (userData) =&gt; ({\n  type: \"LOAD_USER_DATA\", userData\n})\n\n/* \n  Action Creator which returns function which dispatches other actions\n*/\nfetchUser = (usersUrl) =&gt; (dispatch) =&gt; {\n  dispatch({ type: \"DISPLAY_LOADING_SCREEN\" })\n\n  return fetch(usersUrl)\n    .then(response =&gt; response.json())\n    .then((json) =&gt; {\n      if (json.success) {\n        dispatch({ type: \"LOAD_USER_DATA\", json.userData })\n      } else {\n        dispatch({ type: \"LOAD_USER_FAILED\" })\n      }\n    })\n}\n</code></pre>"},{"location":"state-management/redux/standard-redux/intro/#summary","title":"Summary","text":"<ul> <li><code>redux-thunk</code> lets us create actions which are functions that can dispatch other functions instead of just objects.</li> <li><code>redux-thunk</code> is an example of Redux Middleware and as such, needs to adhere to the Redux Middleware signature of <code>validMiddleware =&gt; (store) =&gt; (next) =&gt; (action)</code></li> <li>The core logic of <code>redux-thunk</code> is essentially a simple if statement that checks if the action is a thunk (ie. a function) and invokes it if it is. By default, it exports the Middleware with no <code>extraArgument</code> but it then attaches the <code>createThunkMiddleware</code> function onto the exported Middleware to be used if needed.</li> </ul>"},{"location":"state-management/redux/standard-redux/intro/#differences-between-standard-redux-and-redux-toolkit-rtk","title":"Differences between <code>standard Redux</code> and <code>Redux Toolkit</code> (RTK)","text":"<p>The key differences between standard Redux and Redux Toolkit (RTK) revolve around simplification, boilerplate reduction, and built-in best practices. RTK is a set of tools and recommendations to help write Redux logic more efficiently and with fewer bugs.</p>"},{"location":"state-management/redux/standard-redux/intro/#standard-redux","title":"Standard Redux","text":"Characteristics: <ol> <li> <p>Boilerplate Code:</p> <p>Writing actions, action creators, and reducers involves a lot of repetitive boilerplate code.</p> </li> <li> <p>Manual Immutable Updates:</p> <p>You must ensure immutability by manually copying and updating state slices, which can be error-prone.</p> </li> <li> <p>Middleware Setup:</p> <p>Middleware like <code>redux-thunk</code> or <code>redux-saga</code> must be manually added and configured.</p> </li> <li> <p>Configure Store:</p> <p>Creating and configuring the store involves several steps and manual setup for middleware, devtools, etc.</p> </li> <li> <p>Async Logic:</p> <p>Handling asynchronous logic typically requires custom middleware and manually structured action types and creators.</p> </li> <li> <p>Code Organization:</p> <p>Developers need to decide how to organize actions, reducers, and constants, leading to varied and inconsistent project structures.</p> </li> </ol>"},{"location":"state-management/redux/standard-redux/intro/#standard-redux-example","title":"Standard Redux Example","text":"Example ActionsReducerStore Configuration <pre><code>// actions.js\nexport const INCREMENT = 'INCREMENT';\n\nexport const increment = () =&gt; ({\n    type: INCREMENT,\n});\n</code></pre> <pre><code>// reducer.js\nimport { INCREMENT } from './actions';\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case INCREMENT:\n            return { ...state, value: state.value + 1 };\n        default:\n            return state;\n    }\n};\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport counterReducer from './reducer';\n\nconst store = createStore(counterReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre>"},{"location":"state-management/redux/standard-redux/intro/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"Characteristics: <ol> <li> <p>Reduced Boilerplate:</p> <p>Provides utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and <code>createAction</code> that automate and reduce boilerplate.</p> </li> <li> <p>Automatic Immutable Updates:</p> <p>Uses Immer under the hood to handle immutable state updates automatically.</p> </li> <li> <p>Integrated Middleware:</p> <p>Pre-configures the store with useful middleware like <code>redux-thunk</code>, and you can easily add more.</p> </li> <li> <p>Simplified Store Configuration:</p> <p>The <code>configureStore</code> function simplifies the store creation process, integrating devtools, middleware, and enhancers by default.</p> </li> <li> <p>Built-in Async Logic:</p> <p>The <code>createAsyncThunk</code> utility standardizes and simplifies handling asynchronous actions.</p> </li> <li> <p>Standardized Code Organization:</p> <p>Encourages a standardized way to organize slices, reducers, and actions, leading to more consistent codebases.</p> </li> </ol>"},{"location":"state-management/redux/standard-redux/intro/#redux-toolkit-example","title":"Redux Toolkit Example","text":"Example SliceStore Configuration <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n    },\n});\n\nexport const { increment } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre>"},{"location":"state-management/redux/standard-redux/intro/#key-benefits-of-rtk","title":"Key Benefits of RTK","text":"<ol> <li>Boilerplate Reduction: By automating repetitive tasks, RTK reduces boilerplate, making the codebase cleaner and easier to maintain.</li> <li>Immutability Handling: Automatic handling of immutable updates using Immer simplifies state updates and reduces bugs.</li> <li>Pre-configured Store: configureStore streamlines the store setup process, providing good defaults and simplifying middleware addition.</li> <li>Async Thunks: createAsyncThunk offers a standardized way to handle async logic, reducing the need for custom middleware.</li> <li>Code Structure: Encourages a modular and consistent way to structure code using slices, leading to more maintainable projects.</li> </ol> <p>Overall, RTK provides a more modern and efficient way to write Redux logic, addressing many of the pain points associated with standard Redux.</p>"},{"location":"state-management/redux/standard-redux/intro/#reference","title":"Reference","text":"<ul> <li> <p>React 18 Design Patterns - 2023</p> </li> <li> <p>RTK</p> </li> <li>official redux rtk</li> <li>Understanding Redux Toolkit</li> <li> <p>reduxt toolkit</p> </li> <li> <p>Middleware</p> </li> <li>Understanding redux thunk</li> <li>What is the use of middleware Redux thunk ?</li> </ul>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/","title":"5 Ways to Call API","text":""},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#5-ways-to-call-an-rtk-query-api-onclick","title":"\ud83d\udd25 5 Ways to Call an RTK Query API onClick","text":"<p>In React + RTK Query, you have several flexible ways to dispatch an API call on a button click (or any event). Each has different use cases depending on your control needs, UI structure, and preference between declarative or imperative patterns.</p>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#1-using-a-mutation-hook-usemutation-unwrap","title":"\u2705 1. Using a Mutation Hook (<code>useMutation</code>) + <code>.unwrap()</code>","text":"<p>Best for creating, updating, or deleting something.</p> <pre><code>const [createUser] = useCreateUserMutation();\n\nconst handleClick = async () =&gt; {\n  try {\n    const result = await createUser({ name: \"John\" }).unwrap();\n    console.log(\"Success:\", result);\n  } catch (err) {\n    console.error(\"Error:\", err);\n  }\n};\n\n&lt;button onClick={handleClick}&gt;Create User&lt;/button&gt;;\n</code></pre>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#2-using-a-query-hook-uselazyquery","title":"\u2705 2. Using a Query Hook (<code>useLazyQuery</code>)","text":"<p>Great for fetching on-demand (e.g., when user clicks \u201cLoad Data\u201d).</p> <pre><code>const [trigger, { data, isFetching }] = useLazyGetUserQuery();\n\nconst handleClick = () =&gt; {\n  trigger({ id: 1 });\n};\n\n&lt;button onClick={handleClick}&gt;Load User&lt;/button&gt;;\n</code></pre>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#3-manual-dispatch-from-apiendpointsnameinitiate","title":"\u2705 3. Manual Dispatch from <code>api.endpoints.[name].initiate()</code>","text":"<p>For advanced control or when you're outside a component (like in Redux thunks or listeners).</p> <pre><code>import { useDispatch } from \"react-redux\";\nimport { myApi } from \"../services/myApi\";\n\nconst dispatch = useDispatch();\n\nconst handleClick = async () =&gt; {\n  const resultAction = await dispatch(\n    myApi.endpoints.getUser.initiate({ id: 1 })\n  );\n\n  if (myApi.endpoints.getUser.matchFulfilled(resultAction)) {\n    console.log(\"Success:\", resultAction.payload);\n  } else {\n    console.error(\"Failed:\", resultAction.error);\n  }\n};\n\n&lt;button onClick={handleClick}&gt;Fetch User&lt;/button&gt;;\n</code></pre>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#4-using-query-with-skip-refetch","title":"\u2705 4. Using Query with <code>skip</code> + <code>refetch</code>","text":"<p>For delayed queries, and when you want to control when the query runs.</p> <pre><code>const { data, refetch } = useGetUserQuery({ id: 1 }, { skip: true });\n\nconst handleClick = () =&gt; {\n  refetch();\n};\n\n&lt;button onClick={handleClick}&gt;Fetch User&lt;/button&gt;;\n</code></pre>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#5-via-a-redux-thunk-that-dispatches-api-internally","title":"\u2705 5. Via a Redux Thunk that Dispatches API Internally","text":"<p>Encapsulates logic in one place \u2014 great for post-login flows or reusable logic.</p> <pre><code>// thunk\nexport const loadUserAndPermissions = (userId) =&gt; async (dispatch) =&gt; {\n  await dispatch(myApi.endpoints.getUser.initiate({ id: userId }));\n  await dispatch(myApi.endpoints.getPermissions.initiate({ id: userId }));\n};\n\n// component\nconst dispatch = useDispatch();\n\nconst handleClick = () =&gt; {\n  dispatch(loadUserAndPermissions(123));\n};\n\n&lt;button onClick={handleClick}&gt;Load Everything&lt;/button&gt;;\n</code></pre>"},{"location":"state-management/rtkquery/5-ways-to-call-rtkquery-api/#which-one-should-you-use","title":"\u2696\ufe0f Which One Should You Use?","text":"Approach Best For Pros When to Avoid <code>useMutation + unwrap</code> Create/update/delete operations Clean error/success handling Avoid for GET requests <code>useLazyQuery</code> On-demand fetches Simple and declarative If you need prefetching <code>dispatch(api.endpoints...)</code> Manual calls, thunks, outside React Full control, works in Redux thunks/listeners More verbose <code>useQuery + skip + refetch</code> Delayed fetching, toggle-based UI Keeps data cached, declarative fetch control Slightly more boilerplate Thunk with dispatch inside Complex flows (e.g. login + permissions) Encapsulation, logic reuse, better separation Overkill for simple fetches"},{"location":"state-management/rtkquery/best-approach-rtk/","title":"Best Approach RTK","text":""},{"location":"state-management/rtkquery/best-approach-rtk/#revolt-1","title":"Revolt 1","text":"<pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 store/\n    \u2502   \u2514\u2500\u2500 index.js        // Configure and export the Redux store\n    \u251c\u2500\u2500 middleware/\n    \u2502   \u2514\u2500\u2500 customMiddleware.js // Your custom middleware (if any)\n    \u251c\u2500\u2500 blog/\n    \u2502   \u251c\u2500\u2500 api.js          // API calls using Axios\n    \u2502   \u251c\u2500\u2500 slice.js        // Redux slice for blog state\n    \u2502   \u2514\u2500\u2500 services.js     // Business logic and service functions\n    \u2514\u2500\u2500 index.js            // Optional: combine all slices if needed\n</code></pre> <p>Breakdown of Each File</p> 1. <code>api.js</code>:2. <code>slice.js</code>:3. <code>services.js</code>:Using <ul> <li>Use this file to define your Axios instance and API calls.</li> <li> <p>Example:</p> <pre><code>import axios from 'axios';\n\nconst api = axios.create({\n    baseURL: 'https://your-api-url.com',\n});\n\nexport const fetchBlogs = () =&gt; api.get('/blogs');\nexport const createBlog = (blogData) =&gt; api.post('/blogs', blogData);\n</code></pre> </li> </ul> <ul> <li>This file contains the Redux slice for managing the blog state.</li> <li> <p>Example:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst blogSlice = createSlice({\n    name: 'blog',\n    initialState: {\n        blogs: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        setBlogs: (state, action) =&gt; {\n            state.blogs = action.payload;\n        },\n        setLoading: (state, action) =&gt; {\n            state.loading = action.payload;\n        },\n        setError: (state, action) =&gt; {\n            state.error = action.payload;\n        },\n    },\n});\n\nexport const { setBlogs, setLoading, setError } = blogSlice.actions;\nexport default blogSlice.reducer;\n</code></pre> </li> </ul> <ul> <li>Handle the business logic and asynchronous operations here, like dispatching actions.</li> <li> <p>Example:</p> <pre><code>import { fetchBlogs } from './api';\nimport { setBlogs, setLoading, setError } from './slice';\n\nexport const loadBlogs = () =&gt; async (dispatch) =&gt; {\n    dispatch(setLoading(true));\n    try {\n        const response = await fetchBlogs();\n        dispatch(setBlogs(response.data));\n    } catch (error) {\n        dispatch(setError(error.message));\n    } finally {\n        dispatch(setLoading(false));\n    }\n};\n</code></pre> </li> </ul> <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { loadBlogs } from \"../redux/blog/services\";\n\nconst BlogList = () =&gt; {\n    const dispatch = useDispatch();\n    const blogs = useSelector((state) =&gt; state.blog.blogs);\n    const loading = useSelector((state) =&gt; state.blog.loading);\n    const error = useSelector((state) =&gt; state.blog.error);\n\n    useEffect(() =&gt; {\n        dispatch(loadBlogs());\n    }, [dispatch]);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n            {blogs.map((blog) =&gt; (\n                &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre>"},{"location":"state-management/rtkquery/best-approach-rtk/#revolt-2","title":"Revolt 2","text":"StructureExplanationBenefits of This Structure <pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 store/\n    \u2502   \u2514\u2500\u2500 index.js             // Configure and export the Redux store\n    \u251c\u2500\u2500 middleware/\n    \u2502   \u2514\u2500\u2500 customMiddleware.js   // Your custom middleware (if any)\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 blogs/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for blogs\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for blogs\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for blogs\n    \u2502   \u251c\u2500\u2500 users/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for users\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for users\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for users\n    \u2502   \u251c\u2500\u2500 comments/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for comments\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for comments\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for comments\n    \u2502   \u2514\u2500\u2500 ...                   // Other feature folders\n    \u2514\u2500\u2500 index.js                  // Optional: combine all slices if needed\n</code></pre> <ol> <li> <p><code>features/ Folder</code>:</p> <ul> <li>This is a dedicated folder for all your feature slices. Each feature (like blogs, users, comments, etc.) gets its own subfolder.</li> </ul> </li> <li> <p>Feature Structure:</p> <p>Inside each feature folder, you maintain the same structure:</p> <ul> <li><code>api.js</code>: Contains API calls relevant to that feature.</li> <li><code>slice.js</code>: Contains the Redux slice for managing that feature's state.</li> <li><code>services.js</code>: Contains the business logic and any async actions for that feature.</li> </ul> </li> </ol> <ul> <li>Scalability: You can easily add new features without cluttering the Redux folder. Each feature is self-contained.</li> <li>Maintainability: It's easier to find related files for a specific feature. Developers can navigate directly to the feature they are working on.</li> <li>Consistency: Following a consistent structure across all feature folders simplifies understanding the codebase.</li> </ul> <p>Updated <code>api</code> for crud</p> api.jsservices.jsBenefits of This Structure <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal) =&gt; apiClient.get(\"/posts\", { cancelToken: signal }),\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport blogsApi from \"./api\"; // Import the API functions\n\nexport const fetchBlogs = createAsyncThunk(\n    \"blog/fetchBlogs\",\n    async (signal, { rejectWithValue }) =&gt; {\n        try {\n            const response = await blogsApi.fetchBlogs(signal);\n            return response.data;\n        } catch (err) {\n            if (axios.isCancel(err)) {\n                console.log(\"Request canceled:\", err.message);\n                return rejectWithValue(\"Request was canceled\");\n            }\n            return rejectWithValue(err.message);\n        }\n    }\n);\n\n// Additional service functions for other CRUD operations\nexport const createBlog = createAsyncThunk(\n    \"blog/createBlog\",\n    async (blogData, { rejectWithValue }) =&gt; {\n        try {\n            const response = await blogsApi.createBlog(blogData);\n            return response.data;\n        } catch (err) {\n            return rejectWithValue(err.message);\n        }\n    }\n);\n\n// Add similar functions for updateBlog and deleteBlog\n</code></pre> <ul> <li>Modularity: Each function in <code>api.js</code> handles a specific API call, making it clear and easy to manage.</li> <li>Reusability: The <code>blogsApi</code> object can be reused across different service functions or even in different components if necessary.</li> <li>Clarity: It's clear which API calls are available for the <code>blog</code> feature, making it easier for other developers (or future you) to understand the code.</li> </ul>"},{"location":"state-management/rtkquery/best-approach-rtk/#decomposition","title":"Decomposition","text":"<pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\n\nexport const fetchBlogs = createAsyncThunk(\n  \"blog/fetchBlogs\",\n  async (signal, { rejectWithValue }) =&gt; {\n    try {\n      const response = await axios.get(\n        \"https://jsonplaceholder.typicode.com/posts\",\n        {\n          cancelToken: signal,\n        }\n      );\n      return response.data;\n    } catch (err) {\n      if (axios.isCancel(err)) {\n        console.log(\"Request canceled:\", err.message);\n        return rejectWithValue(\"Request was canceled\");\n      }\n      return rejectWithValue(err.message);\n    }\n  }\n);\n\nconst blogSlice = createSlice({\n  name: \"blog\",\n  initialState: {\n    blogs: [],\n    status: \"idle\",\n    error: null,\n  },\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchBlogs.pending, (state) =&gt; {\n        state.status = \"loading\";\n      })\n      .addCase(fetchBlogs.fulfilled, (state, action) =&gt; {\n        state.status = \"succeeded\";\n        state.blogs = action.payload;\n        state.error = null;\n      })\n      .addCase(fetchBlogs.rejected, (state, action) =&gt; {\n        state.status = \"failed\";\n        state.error = action.payload;\n      });\n  },\n});\n\nexport default blogSlice.reducer;\n</code></pre> <p>To decompose your Redux slice code into multiple files while keeping your project organized, you'll want to separate your concerns into three distinct files: <code>api.js</code>, <code>slice.js</code>, and <code>services.js</code>. Here\u2019s how you can structure each of them:</p> api.jsslice.jsservices.jsFinal Folder StructureSummary <p>This file is responsible for making API requests. It contains functions that handle communication with your backend or external API. You\u2019ll define your Axios calls here.</p> <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nexport const fetchBlogsApi = (signal) =&gt; {\n    return apiClient.get(\"/posts\", {\n        cancelToken: signal,\n    });\n};\n</code></pre> <p>This file contains your Redux slice. It defines the state structure, reducers, and actions related to the <code>blog</code> feature.</p> <pre><code>import { createSlice } from \"@reduxjs/toolkit\";\nimport { fetchBlogs } from \"./services\"; // Import the async thunk from services\n\nconst blogSlice = createSlice({\n    name: \"blog\",\n    initialState: {\n        blogs: [],\n        status: \"idle\",\n        error: null,\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchBlogs.pending, (state) =&gt; {\n                state.status = \"loading\";\n            })\n            .addCase(fetchBlogs.fulfilled, (state, action) =&gt; {\n                state.status = \"succeeded\";\n                state.blogs = action.payload;\n                state.error = null;\n            })\n            .addCase(fetchBlogs.rejected, (state, action) =&gt; {\n                state.status = \"failed\";\n                state.error = action.payload;\n            });\n    },\n});\n\nexport const { actions, reducer } = blogSlice;\nexport default reducer;\n</code></pre> <p>This file contains your asynchronous logic, such as <code>createAsyncThunk</code> functions. It uses the API functions defined in <code>api.js</code> to make requests.</p> <pre><code>import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchBlogsApi } from \"./api\"; // Import the API function\nimport axios from \"axios\";\n\nexport const fetchBlogs = createAsyncThunk(\n    \"blog/fetchBlogs\",\n    async (signal, { rejectWithValue }) =&gt; {\n        try {\n            const response = await fetchBlogsApi(signal);\n            return response.data;\n        } catch (err) {\n            if (axios.isCancel(err)) {\n                console.log(\"Request canceled:\", err.message);\n                return rejectWithValue(\"Request was canceled\");\n            }\n            return rejectWithValue(err.message);\n        }\n    }\n);\n</code></pre> <p>After splitting the functionality, your blogs folder structure will look like this:</p> <pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 blogs/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js         // API requests\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js       // Redux slice\n    \u2502   \u2502   \u2514\u2500\u2500 services.js     // Async thunks\n    \u2514\u2500\u2500 store/\n        \u2514\u2500\u2500 index.js           // Store configuration\n</code></pre> <ul> <li><code>api.js</code>: Contains API call functions (using Axios).</li> <li><code>slice.js</code>: Contains the Redux slice definition, including initial state and reducers.</li> <li><code>services.js</code>: Contains asynchronous logic, such as thunks that use the API functions to fetch data.</li> </ul>"},{"location":"state-management/rtkquery/best-approach-rtk/#advanced","title":"Advanced","text":"Approach 1Approach 2 <p>Approach 1: Multiple Axios Instances</p> <pre><code>import axios from \"axios\";\n\nconst blogApiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst userApiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com/users\", // Example for user-related API\n});\n\n// Blog API functions\nconst blogsApi = {\n    fetchBlogs: (signal) =&gt; blogApiClient.get(\"/posts\", { cancelToken: signal }),\n    fetchBlogById: (id, signal) =&gt;\n        blogApiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; blogApiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; blogApiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; blogApiClient.delete(`/posts/${id}`),\n};\n\n// User API functions\nconst usersApi = {\n    fetchUsers: () =&gt; userApiClient.get(\"/\"),\n    fetchUserById: (id) =&gt; userApiClient.get(`/${id}`),\n    createUser: (userData) =&gt; userApiClient.post(\"/\", userData),\n    updateUser: (id, userData) =&gt; userApiClient.put(`/${id}`, userData),\n    deleteUser: (id) =&gt; userApiClient.delete(`/${id}`),\n};\n\nexport { blogsApi, usersApi };\n</code></pre> <p>Approach 2: Single API Service with Dynamic Base URL</p> <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create();\n\nconst setBaseURL = (type) =&gt; {\n    switch (type) {\n        case \"blog\":\n            apiClient.defaults.baseURL = \"https://jsonplaceholder.typicode.com\";\n            break;\n        case \"user\":\n            apiClient.defaults.baseURL = \"https://jsonplaceholder.typicode.com/users\";\n            break;\n        default:\n            throw new Error(\"Unknown API type\");\n    }\n};\n\nconst api = {\n    fetchBlogs: (signal) =&gt; {\n        setBaseURL(\"blog\");\n        return apiClient.get(\"/posts\", { cancelToken: signal });\n    },\n    fetchUsers: () =&gt; {\n        setBaseURL(\"user\");\n        return apiClient.get(\"/\");\n    },\n    // Add other CRUD operations as needed\n};\n\nexport default api;\n</code></pre>"},{"location":"state-management/rtkquery/best-approach-rtk/#params","title":"Params","text":"api.jscomponent <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt;\n        apiClient.get(\"/posts\", { cancelToken: signal, params }), // Include params here\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import React, { useEffect, useState } from \"react\";\nimport blogsApi from \"./api\"; // Adjust the import path as needed\n\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const fetchBlogs = async () =&gt; {\n        const abortController = new AbortController(); // For cancellation\n        const signal = abortController.signal;\n\n        try {\n            const params = { userId: 1 }; // Example query parameter\n            const response = await blogsApi.fetchBlogs(signal, params);\n            setBlogs(response.data);\n        } catch (err) {\n            if (axios.isCancel(err)) {\n            console.log(\"Request canceled:\", err.message);\n            } else {\n            setError(err.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n\n        // Cleanup function to abort the request on unmount\n        return () =&gt; abortController.abort();\n        };\n\n        fetchBlogs();\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n        {blogs.map((blog) =&gt; (\n            &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n        ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre> <p>Example: Filtering Query Parameters in <code>api.js</code></p> api.jsservice.js <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\n// Helper function to filter and validate query parameters\nconst filterParams = (params) =&gt; {\n    const filtered = {};\n    if (params) {\n        if (params.userId) {\n            filtered.userId = params.userId; // Example filter\n        }\n        // Add more filtering logic as needed\n    }\n    return filtered;\n};\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt; {\n        const filteredParams = filterParams(params); // Filter params before sending\n        return apiClient.get(\"/posts\", {\n            cancelToken: signal,\n            params: filteredParams,\n        });\n    },\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import React, { useEffect, useState } from \"react\";\nimport blogsApi from \"./api\"; // Adjust the import path as needed\n\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const fetchBlogs = async () =&gt; {\n        const abortController = new AbortController(); // For cancellation\n        const signal = abortController.signal;\n\n        try {\n            const params = { userId: 1 }; // Example query parameter\n            const response = await blogsApi.fetchBlogs(signal, params);\n            setBlogs(response.data);\n        } catch (err) {\n            if (axios.isCancel(err)) {\n            console.log(\"Request canceled:\", err.message);\n            } else {\n            setError(err.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n\n        // Cleanup function to abort the request on unmount\n        return () =&gt; abortController.abort();\n        };\n\n        fetchBlogs();\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n        {blogs.map((blog) =&gt; (\n            &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n        ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre>"},{"location":"state-management/rtkquery/best-approach-rtk/#query-string","title":"query-string","text":"<p>The query-string package can be very useful when dealing with query parameters in URLs, especially if you need to handle complex scenarios like:</p> <ol> <li>Nested Objects: When you want to serialize nested objects as query parameters.</li> <li>Array Parameters: When you need to handle arrays and want them to be formatted in a specific way in the query string.</li> <li>URL Encoding: Automatically encoding and decoding query parameters can help avoid issues with special characters.</li> </ol> When to Use query-string <p>You might consider using the <code>query-string</code> package in the following scenarios:</p> <ol> <li> <p>Complex Query Parameters: If you need to construct complex query strings, such as nested objects or arrays.</p> <pre><code>import queryString from \"query-string\";\n\nconst params = {\n    userId: 1,\n    tags: [\"react\", \"javascript\"],\n    filters: {\n        sortBy: \"date\",\n        order: \"desc\",\n    },\n};\n\nconst query = queryString.stringify(params);\n// Result: \"userId=1&amp;tags[]=react&amp;tags[]=javascript&amp;filters[sortBy]=date&amp;filters[order]=desc\"\n</code></pre> </li> <li> <p>Parsing Query Strings: If you need to parse incoming query strings from URLs into a usable object format.</p> <pre><code>const parsed = queryString.parse(location.search);\n// Example: location.search is \"?userId=1&amp;tags[]=react\"\n// Result: { userId: '1', tags: ['react'] }\n</code></pre> </li> <li> <p>Avoiding Manual Serialization: If you find yourself frequently needing to manually construct query strings, using <code>query-string</code> can simplify your code.</p> </li> </ol> Example Usage with AxiosSummary <p>Here\u2019s how you might incorporate <code>query-string</code> into your existing <code>blogsApi</code>:</p> <ol> <li> <p>Install the Package</p> <pre><code>npm install query-string\n</code></pre> </li> <li> <p>Update Your API Calls</p> <p>Update the <code>fetchBlogs</code> method to use <code>query-string</code> for parameter serialization:</p> <pre><code>import axios from \"axios\";\nimport queryString from \"query-string\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt; {\n        const filteredParams = filterParams(params); // Assume you still filter params here\n        const query = queryString.stringify(filteredParams); // Serialize query params\n        return apiClient.get(`/posts?${query}`, { cancelToken: signal });\n    },\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> </li> </ol> <ul> <li>Use <code>query-string</code> when dealing with complex query parameters, such as nested objects or arrays.</li> <li>It simplifies the process of constructing and parsing query strings, especially in more advanced scenarios.</li> <li>If your API calls are simple (e.g., just basic key-value pairs), you might not need it, but it can still be a good addition for clarity and maintainability.</li> </ul>"},{"location":"state-management/rtkquery/best-approach-rtk/#packages","title":"Packages","text":"<p>In a large React codebase using RTK and Axios, consider incorporating the following packages:</p> <ol> <li>React Query: For data fetching and caching.</li> <li>Yup and Formik: For form handling and validation.</li> <li>Lodash: For utility functions.</li> <li>Immer: For immutable state updates.</li> <li>date-fns or moment: For date handling.</li> <li>React Router: For routing.</li> <li>react-toastify: For notifications.</li> <li>redux-logger: For Redux action logging.</li> <li>dotenv: For managing environment variables.</li> <li>classnames: For managing CSS class names.</li> <li>styled-components or emotion: For styling components.</li> </ol>"},{"location":"state-management/rtkquery/cheatsheet/","title":"CheatSheet","text":""},{"location":"state-management/rtkquery/cheatsheet/#cheatsheet","title":"CheatSheet","text":""},{"location":"state-management/rtkquery/cheatsheet/#usage","title":"\u26a1\ufe0f Usage","text":""},{"location":"state-management/rtkquery/cheatsheet/#queries-get","title":"\ud83d\udfe2 Queries (GET)","text":"jsx<pre><code>const { data, error, isLoading } = useGetPostsQuery();\n</code></pre>"},{"location":"state-management/rtkquery/cheatsheet/#mutations-post-put-delete","title":"\ud83d\udd34 Mutations (POST, PUT, DELETE)","text":"<pre><code>const [addPost, { data, isLoading }] = useAddPostMutation();\n\naddPost({ title: \"New Post\", content: \"Hello\" });\n</code></pre>"},{"location":"state-management/rtkquery/cheatsheet/#refetching","title":"\ud83d\udd01 Refetching","text":"<ul> <li>Automatically on mount: default</li> <li>Manually:</li> </ul> <pre><code>const { refetch } = useGetPostsQuery();\nrefetch();\n</code></pre>"},{"location":"state-management/rtkquery/cheatsheet/#advanced","title":"\ud83d\ude80 Advanced","text":""},{"location":"state-management/rtkquery/cheatsheet/#optimistic-updates","title":"\u2705 Optimistic Updates","text":"js<pre><code>updatePost: builder.mutation({\n  query: (post) =&gt; ({\n    url: `/posts/${post.id}`,\n    method: \"PUT\",\n    body: post,\n  }),\n  async onQueryStarted(post, { dispatch, queryFulfilled }) {\n    const patchResult = dispatch(\n      api.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n        const index = draft.findIndex((p) =&gt; p.id === post.id);\n        if (index !== -1) draft[index] = post;\n      })\n    );\n    try {\n      await queryFulfilled;\n    } catch {\n      patchResult.undo();\n    }\n  },\n});\n</code></pre>"},{"location":"state-management/rtkquery/cheatsheet/#cache-invalidation","title":"\ud83e\uddf9 Cache Invalidation","text":"js<pre><code>tagTypes: ['Post'],\n\nendpoints: (builder) =&gt; ({\n  getPosts: builder.query({\n    query: () =&gt; '/posts',\n    providesTags: ['Post'],\n  }),\n  addPost: builder.mutation({\n    query: (newPost) =&gt; ({\n      url: '/posts',\n      method: 'POST',\n      body: newPost,\n    }),\n    invalidatesTags: ['Post'],\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/cheatsheet/#helper-methods","title":"\ud83d\udee0\ufe0f Helper Methods","text":"<ul> <li><code>api.util.invalidateTags([...])</code></li> <li><code>api.util.updateQueryData(...)</code></li> <li><code>api.util.prefetch(...)</code></li> </ul>"},{"location":"state-management/rtkquery/intro/","title":"Intro","text":""},{"location":"state-management/rtkquery/intro/#overview","title":"Overview","text":""},{"location":"state-management/rtkquery/intro/#rtk-query-two-main-ways-to-call-apis","title":"\ud83d\udd39 RTK Query - Two Main Ways to Call APIs","text":""},{"location":"state-management/rtkquery/intro/#1-hook-based-approach-for-components","title":"1. Hook-based approach (for components)","text":"js<pre><code>const { data, error, isLoading } = useFetchUserDetailsQuery(userId);\n</code></pre> <ul> <li>\u2705 Great for React components.</li> <li>\u274c Can't use it outside of components (e.g., in <code>handleLogin</code>).</li> <li>Auto-executes based on arguments.</li> </ul>"},{"location":"state-management/rtkquery/intro/#2-initiate-based-approach-for-actions-functions","title":"2. Initiate-based approach (for actions, functions)","text":"js<pre><code>const userDetails = await dispatch(fetchUserDetails(userId)).unwrap();\n</code></pre> <ul> <li>\u2705 Works inside async functions, like your <code>handleLogin</code>.</li> <li>\u2705 Allows you to handle success/failure with try/catch.</li> <li>\u2705 <code>unwrap()</code> turns the result into a normal Promise, so errors throw and are catchable.</li> <li>\u2705 Fully supports chaining multiple API calls.</li> <li>\u2705 Useful for side-effects, workflows, etc.</li> </ul>"},{"location":"state-management/rtkquery/intro/#whats-unwrap-doing","title":"\ud83d\udd0d What's <code>unwrap()</code> doing?","text":"<p>RTK Query returns a Redux action result by default \u2014 not a Promise. That object has <code>meta</code>, <code>payload</code>, etc., not ideal for logic in functions.</p> js<pre><code>const result = await dispatch(fetchUserDetails(userId));\n// result.payload (on success), result.error (on failure)\n</code></pre> <p>But if you want to use <code>try/catch</code> easily, you use:</p> js<pre><code>const userDetails = await dispatch(fetchUserDetails(userId)).unwrap();\n</code></pre> <ul> <li>\u2705 On success: <code>unwrap()</code> resolves the payload directly.</li> <li>\u274c On error: it throws, and you catch it like a normal error.</li> </ul>"},{"location":"state-management/rtkquery/intro/#when-to-use-dispatchunwrap","title":"\u2705 When to use <code>dispatch(...).unwrap()</code>?","text":"<p>Perfect for your use case in <code>handleLogin</code>:</p> <ul> <li>You\u2019ve just logged in.</li> <li>You want to fetch more info based on the user (e.g. roles, preferences, etc.).</li> <li>You want to handle all logic and errors together.</li> </ul>"},{"location":"state-management/rtkquery/intro/#example-comparison","title":"\ud83d\udd01 Example comparison","text":"<p>Using <code>unwrap()</code>:</p> js<pre><code>try {\n  const userDetails = await dispatch(fetchUserDetails(userId)).unwrap();\n  console.log(\"Fetched user details:\", userDetails);\n} catch (error) {\n  console.error(\"Failed to fetch user details\", error);\n}\n</code></pre> <p>Without <code>unwrap()</code>:</p> js<pre><code>const result = await dispatch(fetchUserDetails(userId));\nif (fetchUserDetails.fulfilled.match(result)) {\n  console.log(\"Data:\", result.payload);\n} else {\n  console.error(\"Error:\", result.error);\n}\n</code></pre> <ul> <li>Second version is more verbose, but works without throwing.</li> <li><code>unwrap()</code> is just cleaner for Promises.</li> </ul>"},{"location":"state-management/rtkquery/intro/#tldr-summary","title":"TL;DR Summary","text":"Feature <code>dispatch(fetchUserDetails(...)).unwrap()</code> Works in async functions \u2705 Yes Error handling via try/catch \u2705 Yes Returns actual data or throws \u2705 Yes Cleaner syntax \u2705 Yes Use in components (hooks) \u274c No (use the auto-hooks instead) <p>Let me know if you want to convert any of your existing RTK endpoints to support this pattern or chain multiple APIs together smoothly!</p>"},{"location":"state-management/rtkquery/intro/#common-scenario-call-after-login-success","title":"Common Scenario: Call after login success","text":"<p>Assume you're logging in via a mutation like <code>useLoginMutation</code>. After a successful login (user authenticated and token received), you can then call your <code>useGetPollingPermissionsQuery</code>.</p>"},{"location":"state-management/rtkquery/intro/#option-1-conditionally-call-query-after-login","title":"Option 1: Conditionally call query after login","text":"<p>You can use the <code>skip</code> option in RTK Query to wait until the user is logged in:</p>"},{"location":"state-management/rtkquery/intro/#option-2-imperative-refetch-after-login-success","title":"Option 2: Imperative refetch after login success","text":"<p>If you're triggering login via a mutation and want to fetch manually after success:</p>"},{"location":"state-management/rtkquery/query-lifecycle/","title":"Query Lifecycle","text":""},{"location":"state-management/rtkquery/query-lifecycle/#query-lifecycle","title":"Query Lifecycle","text":""},{"location":"state-management/rtkquery/query-lifecycle/#what-are-subscribe-forcerefetch-etc-in-rtk-query","title":"\ud83d\udd0d What are <code>subscribe</code>, <code>forceRefetch</code>, etc. in RTK Query?","text":"<p>These options are part of the \"query lifecycle options\" or <code>initiate</code> options, and they are available when you manually dispatch a query or mutation using <code>.initiate()</code>.</p> <p>\u2705 They are not part of the query definition, but of the query execution via <code>dispatch(api.endpoints.someQuery.initiate(...))</code></p>"},{"location":"state-management/rtkquery/query-lifecycle/#category-initiate-options","title":"\ud83e\uddf1 Category: <code>initiate()</code> Options","text":"<p>When you do something like this:</p> js<pre><code>dispatch(api.endpoints.getSomething.initiate(arg, options));\n</code></pre> <p>The second argument \u2014 options \u2014 is where <code>subscribe</code>, <code>forceRefetch</code>, and others live.</p>"},{"location":"state-management/rtkquery/query-lifecycle/#common-initiate-options-manual-dispatch","title":"\u2699\ufe0f Common <code>initiate</code> Options (Manual Dispatch)","text":"Option Available in Description <code>subscribe</code> \u2705 Queries only Whether to keep the query result in the cache (like a hook would). Defaults to <code>true</code>. <code>forceRefetch</code> \u2705 Queries only Forces the API call even if the cache has valid data. <code>track</code> \u2705 Queries only Used internally by RTK Query; rarely needed in most use cases. <code>preferCacheValue</code> \u2705 Queries only Tries to resolve using the cache first, skips network if data is present. <code>fixedCacheKey</code> \u2705 Queries &amp; Mutations Makes the result reusable and persistent using a custom cache key. <code>dispatchConditionRejection</code> \u2705 Queries &amp; Mutations If <code>true</code>, <code>.unwrap()</code> will reject if the dispatch was skipped (e.g., due to deduping). <code>onCacheEntryAdded</code> \u2705 Queries only Lifecycle method for side effects like WebSocket connections."},{"location":"state-management/rtkquery/query-lifecycle/#queries-vs-mutations","title":"\ud83d\udccc Queries vs. Mutations","text":"Feature Queries (e.g. <code>getUser</code>) Mutations (e.g. <code>updateUser</code>) <code>subscribe</code> \u2705 Yes \u274c No (not applicable) <code>forceRefetch</code> \u2705 Yes \u274c No (mutations always call the API) <code>fixedCacheKey</code> \u2705 Yes \u2705 Yes <code>refetch</code> capability \u2705 Yes (via hooks or manual) \u274c No Caching behavior \u2705 Cached automatically \u274c No automatic caching Used for Reading / fetching data Writing / modifying data"},{"location":"state-management/rtkquery/query-lifecycle/#summary","title":"\ud83e\udde0 Summary","text":"<ul> <li>These are called manual dispatch options (or \"query initiation options\").</li> <li>Available when you use <code>.initiate(arg, options)</code>.</li> <li><code>subscribe</code>, <code>forceRefetch</code>, etc. = only for queries.</li> <li><code>mutations</code> don\u2019t cache or subscribe, so they don\u2019t need those.</li> </ul> <p>Hightlight</p> <p>To filter out <code>null</code> and <code>undefined</code> values from the result, you can simply use <code>.filter(Boolean)</code> after <code>.flat()</code> \u2014 this is a clean and effective way to remove all falsy values (like <code>null</code>, <code>undefined</code>, <code>false</code>, <code>0</code>, <code>\"\"</code>, etc.). If you want to only remove <code>null</code> and <code>undefined</code> (not other <code>falsy</code> values like <code>0</code> or <code>\"\"</code>), you can use a stricter filter.</p> <p>Here are both versions for you:</p> <p>\u2705 Clean version (filters all falsy values including <code>null</code> and <code>undefined</code>)</p> <pre><code>transformResponse: (response) =&gt; {\n  const transformed = response\n    .map((group) =&gt;\n      group.permissions.map((permission) =&gt; {\n        if (permission?.selected) {\n          return permission.value;\n        }\n      })\n    )\n    .flat()\n    .filter(Boolean); // filters out null, undefined, false, 0, \"\", NaN\n\n  return transformed;\n};\n</code></pre> <p>\ud83d\udd0d Stricter version (filters only <code>null</code> and <code>undefined</code>)</p> <pre><code>transformResponse: (response) =&gt; {\n  const transformed = response\n    .map((group) =&gt;\n      group.permissions.map((permission) =&gt; {\n        if (permission?.selected) {\n          return permission.value;\n        }\n        return null;\n      })\n    )\n    .flat()\n    .filter((value) =&gt; value !== null &amp;&amp; value !== undefined);\n\n  return transformed;\n};\n</code></pre>"},{"location":"state-management/rtkquery/rtk-lazy-query/","title":"RTK LazyQuery","text":""},{"location":"state-management/rtkquery/rtk-lazy-query/#lazy-query","title":"Lazy Query","text":"useDebounce Hook<pre><code>import { useState, useEffect } from \"react\";\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() =&gt; {\n    const handler = setTimeout(() =&gt; {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () =&gt; {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nexport default useDebounce;\n</code></pre>"},{"location":"state-management/rtkquery/rtk-lazy-query/#using-80-20-principle-to-learning-rtk-hooks","title":"Using 80 20 principle to learning RTK Hooks","text":"<p>To apply the 80/20 principle (also known as the Pareto Principle) to RTK Query hooks in Redux, you should focus on the 20% of actions, queries, or optimizations that yield 80% of the benefits. Here\u2019s how to do that effectively:</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#1-optimize-caching-refetching-behavior","title":"1. Optimize Caching &amp; Refetching Behavior","text":"<ul> <li> <p>Leverage <code>skip</code> &amp; <code>refetch</code> hooks: Instead of constantly refetching data, make use of <code>skip</code> to prevent unnecessary requests and control when data should be fetched. Additionally, use <code>refetch</code> sparingly to avoid excessive calls.</p> </li> <li> <p>Cache Time &amp; Stale Time: Set appropriate values for <code>keepUnusedDataFor</code> and <code>refetchOnMountOrArgChange</code>. This prevents redundant network requests and allows you to manage the state efficiently.</p> </li> </ul> js<pre><code>const { data, error, isLoading } = useGetUserQuery(userId, {\n  skip: !userId,\n  pollingInterval: 60000, // if needed to poll\n  refetchOnMountOrArgChange: false,\n});\n</code></pre> <p>By properly configuring <code>skip</code>, <code>refetchOnMountOrArgChange</code>, and other caching options, you save on unnecessary requests and reduce network load.</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#2-focus-on-creating-reusable-api-slices","title":"2. Focus on Creating Reusable API Slices","text":"<ul> <li> <p>Instead of defining many redundant API slices, create reusable hooks and API services that can be generalized and reused across components.</p> </li> <li> <p>Structure your RTK Query API service in a modular way to maximize reusa</p> </li> </ul> <pre><code>const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    getUser: builder.query({\n      query: (id) =&gt; `users/${id}`,\n    }),\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n    }),\n  }),\n});\n\nexport const { useGetUserQuery, useGetPostsQuery } = api;\n</code></pre> <p>By consolidating endpoints and focusing on reusability, you avoid code duplication and make maintenance easier.</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#3-leverage-selectfromresult-for-optimized-rendering","title":"3. Leverage <code>selectFromResult</code> for Optimized Rendering","text":"<ul> <li>Optimize component rendering by using the <code>selectFromResult</code> option to select only the specific slice of state you need. This minimizes unnecessary re-renders and improves performance.</li> </ul> <pre><code>const { data } = useGetUserQuery(userId, {\n  selectFromResult: (result) =&gt; ({\n    data: result.data?.name,\n  }),\n});\n</code></pre> <p>This ensures your component only re-renders when the part of the state it depends on changes, improving performance.</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#4-batch-queries-for-efficiency","title":"4. Batch Queries for Efficiency","text":"<ul> <li> <p>Instead of firing multiple queries individually, use <code>endpoints</code> that can batch requests together where possible, especially if the data is related. RTK Query allows you to run multiple queries in parallel in an optimized manner.</p> </li> <li> <p>If certain data is frequently needed together, consider using a combined endpoint to reduce the number of network requests.</p> </li> </ul> <pre><code>const { data: userData } = useGetUserQuery(userId);\nconst { data: postsData } = useGetPostsQuery();\n</code></pre> <p>If you're calling multiple queries in a component, consider combining them in a way that reduces redundant calls.</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#5-error-handling-optimistic-updates","title":"5. Error Handling &amp; Optimistic Updates","text":"<ul> <li>Focus on handling common errors gracefully and implementing optimistic updates for smooth user experiences. If your app frequently deals with certain types of errors (e.g., network errors), invest time in setting up retries or fallback mechanisms.</li> </ul> <pre><code>const { data, error, isLoading } = useGetUserQuery(userId, {\n  onError: (err) =&gt; {\n    console.log(\"Error loading user data\", err);\n  },\n  onSuccess: (data) =&gt; {\n    console.log(\"Data fetched successfully\", data);\n  },\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-lazy-query/#6-use-pagination-lazy-loading-for-large-data-sets","title":"6. Use Pagination &amp; Lazy Loading for Large Data Sets","text":"<ul> <li>If you're dealing with large datasets, make sure to leverage pagination or lazy loading strategies. RTK Query allows you to fetch data page by page, reducing the initial load time.</li> </ul> <pre><code>const { data, isLoading } = useGetPostsQuery({\n  page: 1,\n  limit: 10,\n});\n</code></pre> <p>This ensures you\u2019re not overloading your application with too much data at once, making the app faster and more efficient.</p>"},{"location":"state-management/rtkquery/rtk-lazy-query/#7-normalize-state-with-entityadapter","title":"7. Normalize State with <code>entityAdapter</code>","text":"<ul> <li>RTK Query integrates well with Redux's <code>entityAdapter</code>. For large lists of data (e.g., lists of users, posts), use this to normalize the state. Normalizing your state can dramatically improve performance when interacting with large datasets.</li> </ul> <pre><code>const usersAdapter = createEntityAdapter();\nconst initialState = usersAdapter.getInitialState();\n\nconst usersSlice = createSlice({\n  name: \"users\",\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =&gt; {\n    builder.addCase(api.endpoints.getUsers.fulfilled, (state, action) =&gt; {\n      usersAdapter.setAll(state, action.payload);\n    });\n  },\n});\n</code></pre> <p>This reduces complexity and makes data access and updates more efficient.</p> Summary <p>By focusing on the following areas:</p> <ul> <li>Optimizing caching and refetching behavior</li> <li>Creating reusable API slices</li> <li>Using <code>selectFromResult</code> to minimize unnecessary renders</li> <li>Batching queries where possible</li> <li>Handling errors and using optimistic updates</li> <li>Lazy loading and pagination for large datasets</li> <li>Normalizing state with <code>entityAdapter</code></li> </ul> <p>You\u2019ll be able to get 80% of the benefits with just 20% of the effort, making your use of RTK Query both efficient and scalable.</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/","title":"RTK Optimistic","text":"Shallow Copy vs. Deep Copy: <ul> <li>Both <code>Object.assign()</code> and the spread operator only perform shallow copies, meaning if your object contains nested objects, the references to those nested objects are copied, not the actual values.</li> <li>If you need a deep copy of an object, neither <code>Object.assign()</code> nor the spread operator will suffice, and you would need a custom solution or use libraries like <code>lodash</code>'s <code>cloneDeep()</code>.</li> </ul>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#optimistic-post-and-put","title":"Optimistic Post and Put","text":"<p>To perform an optimistic update with <code>POST</code> requests (like you are doing with <code>PUT</code>), you can follow a similar approach. Optimistic updates involve temporarily updating the state (optimistically assuming that the request will succeed) and rolling back if the request fails.</p> <p>Here's how you can modify the <code>postRoles</code> mutation to include an optimistic update:</p> <ol> <li>Optimistic Update: Update the state right after dispatching the mutation, before the server responds.</li> <li>Rollback: Undo the optimistic update in case of an error.</li> </ol> <p>You can achieve this by utilizing the same <code>onQueryStarted</code> lifecycle method as you have in <code>putRoles</code>.</p> <p>Here\u2019s how you could implement it:</p> <pre><code>export const rolesApi = createApi({\n  reducerPath: \"rolesApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Roles\"],\n  endpoints: (builder) =&gt; ({\n    getRoles: builder.query({\n      query: () =&gt; ({\n        url: \"Roles/list\",\n        method: HTTP_METHODS.GET,\n      }),\n    }),\n\n    postRoles: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Roles/create\",\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n\n      async onQueryStarted(data, { dispatch, queryFulfilled }) {\n        // Optimistic Update\n        const patchResult = dispatch(\n          rolesApi.util.updateQueryData(\"getRoles\", undefined, (draft) =&gt; {\n            draft.push(data); // Optimistically add the new role\n          })\n        );\n\n        try {\n          // Wait for the request to be fulfilled\n          await queryFulfilled;\n        } catch (error) {\n          // If the request fails, undo the optimistic update\n          patchResult.undo();\n        }\n      },\n    }),\n\n    putRoles: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Roles/edit/${id}`,\n        method: HTTP_METHODS.PUT,\n        data,\n      }),\n\n      async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          rolesApi.util.updateQueryData(\"getRoles\", undefined, (draft) =&gt; {\n            const user = draft.find((user) =&gt; user.id === id);\n            if (user) {\n              Object.assign(user, data); // Optimistically update the role\n            }\n          })\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo(); // Rollback if the update fails\n        }\n      },\n    }),\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#key-changes","title":"Key Changes:","text":"<ol> <li> <p><code>postRoles</code> Mutation:</p> <ul> <li>In the <code>onQueryStarted</code> lifecycle, we perform an optimistic update by dispatching the <code>updateQueryData</code> for the <code>getRoles</code> query.</li> <li>We optimistically add the new role (<code>data</code>) to the <code>draft</code> array (which holds the cached roles).</li> <li>If the <code>POST</code> request fails, we call <code>patchResult.undo()</code> to roll back the optimistic update.</li> </ul> </li> </ol>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#considerations","title":"Considerations:","text":"<ul> <li>Ensure that the optimistic data added or updated is aligned with the final server response (e.g., if there are any server-side modifications to the role data upon creation).</li> <li>The <code>queryFulfilled</code> is awaited to ensure that the optimistic update is not persisted unless the request succeeds.</li> </ul> <p>This approach will give you the same kind of optimistic update behavior as you have with the <code>PUT</code> mutation but for creating new roles.</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#put-post","title":"Put &amp; Post","text":"<p>The difference between using <code>draft.push(data)</code> for the POST mutation and <code>Object.assign(user, data)</code> for the PUT mutation comes down to the nature of the operations they represent:</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#1-post-creating-a-new-resource","title":"1. POST (Creating a New Resource):","text":"<ul> <li>When you send a <code>POST</code> request, you're creating a new resource.</li> <li>In this case, you are adding a new item (a new role, for example) to the existing list of items (e.g., <code>draft</code>).</li> <li><code>draft.push(data)</code> adds the newly created role (<code>data</code>) to the cached list of roles (<code>draft</code>).</li> <li>The idea is that you're appending the new item to the list because it didn't exist previously, and you don't have to worry about modifying an existing item in the list.</li> </ul> Example <ul> <li>Before the <code>POST</code> request: <code>draft = [{ id: 1, name: \"Admin\" }]</code></li> <li>After the optimistic update with <code>draft.push(data)</code>: <code>draft = [{ id: 1, name: \"Admin\" }, { id: 2, name: \"Manager\" }]</code></li> </ul>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#2-put-updating-an-existing-resource","title":"2. PUT (Updating an Existing Resource):","text":"<ul> <li>When you send a <code>PUT</code> request, you're updating an existing resource.</li> <li>You are modifying an existing item in the list, not adding a new one.</li> <li><code>Object.assign(user, data)</code> merges the updated properties (<code>data</code>) into the existing <code>user</code> object, which represents the role you are updating.</li> <li>This is important because you're modifying an existing item (the role), not creating a new one. The goal here is to mutate the current object with the new data.</li> </ul> Example <ul> <li>Before the <code>PUT</code> request: <code>draft = [{ id: 1, name: \"Admin\" }]</code></li> <li>After the optimistic update with <code>Object.assign(user, data)</code>: <code>draft = [{ id: 1, name: \"Manager\" }]</code> (assuming <code>data = { name: \"Manager\" })</code></li> </ul>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#summary-of-differences","title":"Summary of Differences:","text":"<ul> <li>POST: You are adding a new resource to the list, so you use <code>push()</code> to add the new item (data).</li> <li>PUT: You are modifying an existing resource, so you use <code>Object.assign()</code> (or other mutation techniques) to update the properties of an existing item (<code>user</code>) with the new data (<code>data</code>).</li> </ul>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#in-essence","title":"In essence:","text":"<ul> <li><code>push()</code> is used for appending new items (because you're adding something that didn't exist).</li> <li><code>Object.assign()</code> is used for updating properties of an existing object (because you're modifying something that already exists).</li> </ul> Here are some of the common mutation techniques, in addition to <code>Object.assign()</code> <p>Summary of Mutation Techniques:</p> <ul> <li>Direct Assignment (<code>=</code>): Simple and direct property changes.</li> <li><code>Object.assign()</code>: Merges properties from one object to another.</li> <li>Spread Operator (...): Creates shallow copies and allows modifying objects or arrays immutably.</li> <li><code>map()</code>: Used for updating specific elements in arrays, creating a new array with the modified items.</li> <li><code>find()</code>: Locates a specific item in an array and directly modifies it (not recommended for immutability).</li> <li><code>Object.defineProperty()</code>: Provides detailed control over object properties.</li> <li><code>Set</code> and <code>Map</code> methods: Useful for collections like <code>Set</code> and <code>Map</code>.</li> </ul> <p>When to Use Which Technique:</p> <ul> <li>For shallow updates: <code>Object.assign()</code> and spread (<code>...</code>) are often the best choices.</li> <li>For deeply nested updates: You'll need to handle deeply nested structures by either using libraries like <code>immer</code> (which allows for immutable updates with a \"draft\" concept) or applying nested spread operators for deep cloning.</li> <li>For arrays: <code>map()</code> is great for creating a new modified array, while <code>push()</code> or <code>splice()</code> are useful if you want to mutate the array directly.</li> </ul> <p>Example of Immutable Update Using <code>map()</code>:</p> <p>For array mutations (like updating an item in a list), you can use <code>map()</code> combined with the spread operator to maintain immutability:</p> <pre><code>const updatedRoles = roles.map(role =&gt;\n    role.id === updatedRole.id ? { ...role, ...updatedRole } : role\n);\n</code></pre> <p>This creates a new array, ensuring immutability while updating the <code>role</code> with the new data.</p> <p>In your case, using <code>Object.assign()</code> for the <code>PUT</code> request makes sense because you're updating an existing resource. But if you wanted to use a different technique, you could use direct assignment (<code>user.name = 'Manager'</code>) or the spread operator. The <code>map()</code> technique works well for arrays, especially when updating individual items in a list.</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#improved-code-optimisticupdateutils","title":"Improved code <code>optimisticUpdateUtils</code>","text":""},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#level-1-optimize","title":"Level 1: <code>Optimize</code>","text":"optimisticUpdateUtils.js<pre><code>import { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"./axiosBaseQuery\"; // Assuming this is defined elsewhere\n\n// Utility function for optimistic updates\nconst optimisticUpdate = (dispatch, queryName, data, modifyDraft) =&gt; {\n  return dispatch(\n    rolesApi.util.updateQueryData(queryName, undefined, (draft) =&gt; {\n      modifyDraft(draft, data);\n    })\n  );\n};\n\nexport const rolesApi = createApi({\n  reducerPath: \"rolesApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Roles\"],\n  endpoints: (builder) =&gt; ({\n    getRoles: builder.query({\n      query: () =&gt; ({\n        url: \"Roles/list\",\n        method: HTTP_METHODS.GET,\n      }),\n    }),\n\n    postRoles: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Roles/create\",\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n\n      async onQueryStarted(data, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Add a new role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          data,\n          (draft, newData) =&gt; {\n            draft.push(newData);\n          }\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          // Rollback if the request fails\n          patchResult.undo();\n          console.error(\"Failed to create role:\", error); // More informative error logging\n        }\n      },\n    }),\n\n    putRoles: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Roles/edit/${id}`,\n        method: HTTP_METHODS.PUT,\n        data,\n      }),\n\n      async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Update an existing role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          { id, data },\n          (draft, { id, data }) =&gt; {\n            const role = draft.find((role) =&gt; role.id === id);\n            if (role) {\n              Object.assign(role, data);\n            }\n          }\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          // Rollback if the request fails\n          patchResult.undo();\n          console.error(`Failed to update role with ID ${id}:`, error); // More informative error logging\n        }\n      },\n    }),\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#level-2-optimize","title":"Level 2: <code>Optimize</code>","text":"rolesApi.js<pre><code>// optimisticUpdateUtils.js\n\n/**\n * A helper function to perform optimistic updates for a given query.\n *\n * @param {Function} dispatch - The Redux dispatch function.\n * @param {string} queryName - The name of the query to update.\n * @param {any} data - The data to be optimistically updated.\n * @param {Function} modifyDraft - A function that modifies the draft state.\n * @returns {Object} The patch result, which can be used to undo the optimistic update if needed.\n */\nexport const optimisticUpdate = (dispatch, queryName, data, modifyDraft) =&gt; {\n  return dispatch(\n    rolesApi.util.updateQueryData(queryName, undefined, (draft) =&gt; {\n      modifyDraft(draft, data);\n    })\n  );\n};\n</code></pre> <pre><code>import { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"./axiosBaseQuery\"; // Assuming this is defined elsewhere\nimport { optimisticUpdate } from \"./optimisticUpdateUtils\"; // Import the function\n\nexport const rolesApi = createApi({\n  reducerPath: \"rolesApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Roles\"],\n  endpoints: (builder) =&gt; ({\n    getRoles: builder.query({\n      query: () =&gt; ({\n        url: \"Roles/list\",\n        method: HTTP_METHODS.GET,\n      }),\n    }),\n\n    postRoles: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Roles/create\",\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n\n      async onQueryStarted(data, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Add a new role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          data,\n          (draft, newData) =&gt; {\n            draft.push(newData);\n          }\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(\"Failed to create role:\", error); // More informative error logging\n        }\n      },\n    }),\n\n    putRoles: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Roles/edit/${id}`,\n        method: HTTP_METHODS.PUT,\n        data,\n      }),\n\n      async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Update an existing role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          { id, data },\n          (draft, { id, data }) =&gt; {\n            const role = draft.find((role) =&gt; role.id === id);\n            if (role) {\n              Object.assign(role, data);\n            }\n          }\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(`Failed to update role with ID ${id}:`, error); // More informative error logging\n        }\n      },\n    }),\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#level-3-optimize","title":"Level 3: <code>Optimize</code>","text":"<p>If you want to reuse the <code>optimisticUpdateUtils.js</code> for other APIs, you can make a few changes to make it more general and flexible. Essentially, you'll modify it so that it can be used with any API endpoint and is not tightly coupled with the <code>rolesApi</code> specifically.</p> <p>Step 1: Update <code>optimisticUpdateUtils.js</code> to be more generic</p> <p>The main change is to pass the <code>updateQueryData</code> function dynamically, as well as the query name and the data manipulation logic.</p> <pre><code>// optimisticUpdateUtils.js\n\n/**\n * A helper function to perform optimistic updates for a given query.\n *\n * @param {Function} dispatch - The Redux dispatch function.\n * @param {string} queryName - The name of the query to update.\n * @param {any} data - The data to be optimistically updated.\n * @param {Function} modifyDraft - A function that modifies the draft state for specific data manipulation.\n * @param {Function} updateQueryDataFn - The updateQueryData function specific to the API (passed dynamically).\n * @returns {Object} The patch result, which can be used to undo the optimistic update if needed.\n */\nexport const optimisticUpdate = (\n  dispatch,\n  queryName,\n  data,\n  modifyDraft,\n  updateQueryDataFn\n) =&gt; {\n  return dispatch(\n    updateQueryDataFn(queryName, undefined, (draft) =&gt; {\n      modifyDraft(draft, data);\n    })\n  );\n};\n</code></pre> <p>Step 2: Update Your <code>rolesApi.js</code> to Use the Generic <code>optimisticUpdate</code></p> <p>Now you can pass the <code>updateQueryData</code> function dynamically from your <code>rolesApi</code> and use the generic <code>optimisticUpdate</code> in the same way.</p> <pre><code>import { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"./axiosBaseQuery\"; // Assuming this is defined elsewhere\nimport { optimisticUpdate } from \"./optimisticUpdateUtils\"; // Import the function\n\nexport const rolesApi = createApi({\n  reducerPath: \"rolesApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Roles\"],\n  endpoints: (builder) =&gt; ({\n    getRoles: builder.query({\n      query: () =&gt; ({\n        url: \"Roles/list\",\n        method: HTTP_METHODS.GET,\n      }),\n    }),\n\n    postRoles: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Roles/create\",\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n\n      async onQueryStarted(data, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Add a new role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          data,\n          (draft, newData) =&gt; {\n            draft.push(newData);\n          },\n          rolesApi.util.updateQueryData // Pass the updateQueryData specific to rolesApi\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(\"Failed to create role:\", error); // More informative error logging\n        }\n      },\n    }),\n\n    putRoles: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Roles/edit/${id}`,\n        method: HTTP_METHODS.PUT,\n        data,\n      }),\n\n      async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Update an existing role optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getRoles\",\n          { id, data },\n          (draft, { id, data }) =&gt; {\n            const role = draft.find((role) =&gt; role.id === id);\n            if (role) {\n              Object.assign(role, data);\n            }\n          },\n          rolesApi.util.updateQueryData // Pass the updateQueryData specific to rolesApi\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(`Failed to update role with ID ${id}:`, error); // More informative error logging\n        }\n      },\n    }),\n  }),\n});\n</code></pre> <p>Step 3: Use <code>optimisticUpdate</code> in Another API</p> <p>Now that the <code>optimisticUpdate</code> function is general, you can reuse it with other APIs, passing the appropriate <code>updateQueryData</code> method and logic for that API.</p> <p>For example, if you have a <code>usersApi</code>, you can reuse the same <code>optimisticUpdate</code> function with a different set of operations:</p> <pre><code>import { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"./axiosBaseQuery\"; // Assuming this is defined elsewhere\nimport { optimisticUpdate } from \"./optimisticUpdateUtils\"; // Import the function\n\nexport const usersApi = createApi({\n  reducerPath: \"usersApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Users\"],\n  endpoints: (builder) =&gt; ({\n    getUsers: builder.query({\n      query: () =&gt; ({\n        url: \"Users/list\",\n        method: HTTP_METHODS.GET,\n      }),\n    }),\n\n    postUser: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Users/create\",\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n\n      async onQueryStarted(data, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Add a new user optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getUsers\",\n          data,\n          (draft, newData) =&gt; {\n            draft.push(newData); // Logic to optimistically add the new user\n          },\n          usersApi.util.updateQueryData // Pass the updateQueryData specific to usersApi\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(\"Failed to create user:\", error); // More informative error logging\n        }\n      },\n    }),\n\n    putUser: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Users/edit/${id}`,\n        method: HTTP_METHODS.PUT,\n        data,\n      }),\n\n      async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n        // Optimistic Update: Update an existing user optimistically\n        const patchResult = optimisticUpdate(\n          dispatch,\n          \"getUsers\",\n          { id, data },\n          (draft, { id, data }) =&gt; {\n            const user = draft.find((user) =&gt; user.id === id);\n            if (user) {\n              Object.assign(user, data); // Logic to optimistically update the user\n            }\n          },\n          usersApi.util.updateQueryData // Pass the updateQueryData specific to usersApi\n        );\n\n        try {\n          await queryFulfilled;\n        } catch (error) {\n          patchResult.undo();\n          console.error(`Failed to update user with ID ${id}:`, error); // More informative error logging\n        }\n      },\n    }),\n  }),\n});\n</code></pre> <p>Step 4: Benefits of This Approach</p> <ul> <li>Reusability: The <code>optimisticUpdate</code> function is now completely decoupled from any specific API and can be used across multiple API slices (e.g., <code>rolesApi</code>, <code>usersApi</code>, etc.).</li> <li>Flexibility: You can use any query name and modify the data as required. You just need to pass the appropriate <code>updateQueryData</code> function and the data modification logic.</li> <li>Maintainability: Centralizing the optimistic update logic makes your code easier to maintain and update. If you need to change how optimistic updates work, you only need to change one function, and the changes will apply to all API slices that use it.</li> <li>Cleaner Code: Your API slices (<code>rolesApi</code>, <code>usersApi</code>, etc.) remain focused on their specific business logic, without having to repeat the optimistic update logic.</li> </ul> <p>Summary</p> <p>By making <code>optimisticUpdate</code> more general, you can reuse it across different API slices with minimal effort. All you need to do is pass the appropriate <code>updateQueryData</code> function for each API and define the specific data manipulation logic (e.g., <code>push</code>, <code>assign</code>, etc.) for each case. This results in cleaner, more maintainable, and reusable code.</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#file-strcuture-for-optimistic-update","title":"File Strcuture for <code>Optimistic update</code>","text":"<p>If you've implemented a feature-based folder structure in your project, the <code>optimisticUpdate</code> utility file should be placed in a location that aligns with the principles of modularity and reuse. The goal is to store the optimisticUpdate file in a way that makes it accessible across different features or API slices, without unnecessarily coupling it to any one feature.</p> <p>Here are a few possible locations based on common feature-based folder structures:</p>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#1-srcutils-or-srchelpers-folder","title":"1. <code>src/utils</code> or <code>src/helpers</code> Folder","text":"<p>If your project structure includes a <code>utils</code> or <code>helpers</code> folder for shared, reusable code (which is common for utility functions), this is an ideal place for the <code>optimisticUpdate</code> utility file. This allows the function to be easily imported wherever needed.</p> <pre><code>src/\n  \u251c\u2500\u2500 api/           # API-related slices (rolesApi, usersApi, etc.)\n  \u251c\u2500\u2500 components/    # UI components\n  \u251c\u2500\u2500 features/      # Feature-specific folders\n  \u251c\u2500\u2500 utils/         # Shared utility functions (for common logic)\n  \u2502   \u2514\u2500\u2500 optimisticUpdateUtils.js\n  \u2514\u2500\u2500 App.js\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#2-srcfeaturescommon-folder","title":"2. <code>src/features/common/</code> Folder","text":"<p>If you want to keep the feature-based structure and avoid a global <code>utils</code> folder, you can place the <code>optimisticUpdateUtils.js</code> file in a <code>common</code> folder within your <code>features</code> directory. The <code>common</code> folder can store reusable logic that doesn't belong to any specific feature but can be shared across multiple features.</p> <pre><code>src/\n  \u251c\u2500\u2500 api/            # API slices for different features\n  \u251c\u2500\u2500 components/     # UI components\n  \u251c\u2500\u2500 features/\n  \u2502   \u251c\u2500\u2500 roles/      # Roles feature folder\n  \u2502   \u251c\u2500\u2500 users/      # Users feature folder\n  \u2502   \u2514\u2500\u2500 common/     # Shared, reusable code\n  \u2502       \u2514\u2500\u2500 optimisticUpdateUtils.js\n  \u2514\u2500\u2500 App.js\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#3-srcshared-folder","title":"3. <code>src/shared/</code> Folder","text":"<p>Another good option for <code>shared</code> logic is a shared folder, which is a common naming convention used to house logic that is not specific to any one feature. This approach keeps everything related to shared functionality in one place.</p> <pre><code>src/\n  \u251c\u2500\u2500 api/            # API slices\n  \u251c\u2500\u2500 components/     # UI components\n  \u251c\u2500\u2500 features/       # Feature-specific logic\n  \u251c\u2500\u2500 shared/         # Shared code (for reusable logic)\n  \u2502   \u2514\u2500\u2500 optimisticUpdateUtils.js\n  \u2514\u2500\u2500 App.js\n</code></pre>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#hocs-hooks","title":"HOCS &amp; Hooks","text":"<ul> <li><code>useDrawerReducer.js</code> should be placed in the <code>hooks/</code> folder since it is a custom hook responsible for state management.</li> <li><code>withDrawer.js</code> should be placed in the <code>components/</code> folder because it is a higher-order component that enhances UI components with additional functionality (like managing the drawer state and rendering the drawer).</li> </ul>"},{"location":"state-management/rtkquery/rtk-optimistic-mutation/#submodule-error-fix","title":"Submodule Error Fix","text":"<p>fatal: 'Bishow-Thapa.github.io' already exists in the index why git submodule</p> <p>The error message fatal: 'Bishow-Thapa.github.io' already exists in the index typically occurs when you're trying to add a submodule to a Git repository, but a path in your index (staging area) already exists as a regular file or folder. This can happen for a few reasons:</p> Common Causes: <ol> <li> <p>Directory Already Exists: If the directory <code>Bishow-Thapa.github.io</code> already exists in your repository and contains files, Git might throw this error when you're trying to add it as a submodule.</p> </li> <li> <p>Index Conflict: The path in the Git index (staging area) might already contain references to files or folders. When trying to add the submodule, it conflicts with this existing index.</p> </li> <li> <p>Previously Attempted Submodule Addition: You may have tried to add the submodule earlier, but the process didn't complete successfully, leaving files or references in the Git index.</p> </li> </ol> How to Fix It: <ol> <li> <p>Check If the Directory Exists:</p> <p>Before adding the submodule, ensure that the directory is empty or doesn't already exist in the working directory. If it's already a folder with files or a previous submodule, you may need to clean it up.</p> <p>You can check the contents of the directory with:</p> <pre><code>ls Bishow-Thapa.github.io\n</code></pre> <p>If it has files, you can either delete them or move them elsewhere. If it's a submodule from a previous attempt, you may need to remove it.</p> </li> <li> <p>Remove the Existing Directory (if applicable):</p> <p>If the directory already exists in your repository but is not a submodule, you can remove it (and its content, if needed):</p> <pre><code>rm -rf Bishow-Thapa.github.io\n</code></pre> <p>This will remove the directory and its contents. Then you can proceed with adding the submodule.</p> </li> <li> <p>Remove from the Git Index (if applicable):</p> <p>If the path exists in your Git index, but you don't want to keep it, you can remove it from the index. This will not delete the directory from the working directory but will stop Git from tracking it:</p> <pre><code>git rm --cached Bishow-Thapa.github.io\n</code></pre> <p>Then commit this change:</p> <pre><code>git rm --cached Bishow-Thapa.github.io\n</code></pre> <p>git commit -m \"Removed Bishow-Thapa.github.io from the index\"</p> <p>After this, try adding the submodule again.</p> </li> <li> <p>Add the Submodule:</p> <p>Once you've ensured the directory is either empty or cleaned up, you can try adding the submodule again using:</p> <pre><code>git submodule add &lt;repository-url&gt; Bishow-Thapa.github.io\n</code></pre> <p>Replace <code>&lt;repository-url&gt;</code> with the actual URL of the submodule repository.</p> </li> <li> <p>Check Submodule Status:</p> <p>After adding the submodule, you can check its status:</p> <pre><code>git submodule status\n</code></pre> <p>This should resolve the conflict, allowing you to successfully add the submodule. Let me know if you run into further issues!</p> </li> </ol>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/","title":"RTK Mutation","text":""},{"location":"state-management/rtkquery/rtk-post-put-mutation/#header","title":"HEADER","text":"<p>To resolve this, you should rename the states for each mutation so they don't conflict with each other. Here's a revised version:</p> <pre><code>// For the postCountry mutation\nconst [\n  postCountry,\n  { isLoading: isLoadingPost, isError: isErrorPost, error: postError },\n] = usePostCountryMutation();\n\n// For the putCountry mutation\nconst [\n  putCountry,\n  { isLoading: isLoadingPut, isError: isErrorPut, error: putError },\n] = usePutCountryMutation();\n</code></pre>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#question","title":"Question","text":"Question <pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n        }),\n\n        putCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"put\",\n                data,\n            }),\n        }),\n    }),\n});\n</code></pre> <p>how to update database when put and post</p> <p>To update the database when performing a <code>POST</code> (create) or <code>PUT</code> (update) request, you would typically follow these steps:</p>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#1-sending-the-request-to-the-server-post-or-put","title":"1. Sending the Request to the Server (POST or PUT):","text":"<ul> <li>POST is used to create a new record (in this case, a new country).</li> <li>PUT is used to update an existing record.</li> </ul> <p>In your <code>countryApi</code> definition, the <code>postCountry</code> and <code>putCountry</code> mutations are already set up to send the <code>POST</code> and <code>PUT</code> requests to the server. The <code>query</code> field inside the <code>mutation</code> will handle sending the request when it is called.</p>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#2-optimistically-updating-the-state-optional-but-recommended","title":"2. Optimistically Updating the State (Optional but Recommended):","text":"<p>After sending a <code>POST</code> or <code>PUT</code> request, you can update the Redux state (or cache) to reflect the new or modified data without waiting for the server's response. This can help with a more responsive UI.</p> <p>For this, RTK Query provides optimistic updates. In the case of <code>POST</code> and <code>PUT</code>, you can use <code>onQueryStarted</code> to update the cache optimistically. You can also update the state using <code>updateQueryData</code> and trigger a refetch if needed.</p> <p>Here is how to optimistically update the database on successful <code>POST</code> or <code>PUT</code>:</p> CodeExplanation Example Code for Optimistic Updates<pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        // Query to fetch country data (GET request)\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        // POST to add a new country\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n\n            // onSuccess or onQueryStarted for optimistic updates\n            async onQueryStarted(data, { dispatch, queryFulfilled }) {\n                // Optimistically update the cache\n                try {\n                    // Optimistically update cache for the added country\n                    const patchResult = dispatch(\n                        countryApi.util.updateQueryData(\n                        \"getCountry\",\n                        undefined,\n                        (draft) =&gt; {\n                            // Add the new country to the existing list of countries\n                            draft.push(data);\n                        }\n                        )\n                    );\n\n                    // Wait for the mutation to succeed\n                    await queryFulfilled;\n                } catch (error) {\n                    // Rollback if the request fails\n                    console.error(\"Error posting country:\", error);\n                }\n            },\n            }),\n\n            // PUT to update an existing country\n            putCountry: builder.mutation({\n                query: (data) =&gt; ({\n                    url: `Country/${data.id}`, // Assuming the country has an `id` field for identifying it\n                    method: \"put\",\n                    data,\n                }),\n\n                // onSuccess or onQueryStarted for optimistic updates\n                async onQueryStarted(data, { dispatch, queryFulfilled }) {\n                    // Optimistically update the cache\n                    try {\n                        // Optimistically update cache for the updated country\n                        const patchResult = dispatch(\n                            countryApi.util.updateQueryData(\n                            \"getCountry\",\n                            undefined,\n                                (draft) =&gt; {\n                                    const index = draft.findIndex(\n                                    (country) =&gt; country.id === data.id\n                                    );\n                                    if (index !== -1) {\n                                    draft[index] = data; // Update the country in the list\n                                    }\n                                }\n                            )\n                        );\n\n                        // Wait for the mutation to succeed\n                        await queryFulfilled;\n                    } catch (error) {\n                        // Rollback if the request fails\n                        console.error(\"Error updating country:\", error);\n                    }\n                },\n        }),\n    }),\n});\n\nexport const {\n    useGetCountryQuery,\n    usePostCountryMutation,\n    usePutCountryMutation,\n} = countryApi;\n</code></pre> <p>Explanation of the Optimistic Update Process:</p> <ol> <li> <p>Optimistic Update for POST (Adding a Country):</p> <ul> <li>After sending a <code>POST</code> request to add a new country, we optimistically update the <code>getCountry</code> query data by adding the new country to the existing list (i.e., the <code>draft.push(data)</code> step).</li> <li>If the mutation fails, no changes are made to the cache.</li> </ul> </li> <li> <p>Optimistic Update for <code>PUT</code> (Updating a Country):</p> <ul> <li>After sending a <code>PUT</code> request to update an existing country, we optimistically update the <code>getCountry</code> query data by replacing the old country data with the updated one (<code>draft[index] = data</code>).</li> <li>If the mutation fails, no changes are made to the cache.</li> </ul> </li> <li> <p><code>queryFulfilled</code>:</p> <ul> <li><code>queryFulfilled</code> is a promise that resolves when the mutation request successfully completes. If it succeeds, the cache update remains; if it fails, any optimistically applied changes are rolled back.</li> </ul> </li> </ol>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#3-handling-errors","title":"3. Handling Errors:","text":"<ul> <li>Error Handling: The <code>onQueryStarted</code> function includes error handling with a <code>try/catch</code> block. If there is any issue during the mutation (e.g., the network request fails), the changes are reverted.</li> <li>Rollback: The cache update happens optimistically, so if the request fails, we simply don't persist those changes.</li> </ul>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#4-refetching-data-after-mutation-optional","title":"4. Refetching Data After Mutation (Optional):","text":"<ul> <li>You can also configure a refetch of the data after the mutation to ensure the cache stays in sync with the server data. For example, you can dispatch a refetch query like this:</li> </ul> <pre><code>dispatch(countryApi.util.invalidateTags([{ type: \"Country\", id: \"LIST\" }]));\n</code></pre> <p>This would trigger a refetch of the <code>getCountry</code> query after a successful mutation.</p>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#conclusion","title":"Conclusion:","text":"<p>By using optimistic updates with <code>onQueryStarted</code>, your app can provide a seamless experience to the user, showing immediate updates without waiting for the server response. This pattern is particularly useful for create (POST) and update (PUT) actions, ensuring that the UI stays responsive even in cases of network latency or failure.</p>"},{"location":"state-management/rtkquery/rtk-post-put-mutation/#rollback-functionality","title":"Rollback Functionality","text":"<p>To implement rollback functionality in case of a failed request and show an error message to the user, you can follow this approach in RTK Query:</p> <ul> <li> <p>Optimistic Updates with Rollback: If an optimistic update (like adding or modifying data in the cache) is performed, you can roll back the changes if the request fails. This rollback is accomplished using <code>onQueryStarted</code> and handling the error in the <code>catch</code> block.</p> </li> <li> <p>Error Handling: You can show the error message to the user by catching the error and using it in your UI to display a relevant message.</p> </li> </ul> <p>Updated Example with Rollback and Error Display:</p> <p>Below is an updated example of your <code>countryApi</code> with proper error handling and rollback when a request fails:</p> CodeExplanation <pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        // GET query for fetching country data\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        // POST to add a new country\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n        async onQueryStarted(data, { dispatch, queryFulfilled }) {\n            const patchResult = dispatch(\n                countryApi.util.updateQueryData(\"getCountry\", undefined, (draft) =&gt; {\n                    draft.push(data); // Optimistically add the new country to the list\n                })\n            );\n\n            try {\n                // Wait for the POST request to finish\n                await queryFulfilled;\n            } catch (error) {\n                // If the request fails, rollback the optimistic update\n                dispatch(\n                    countryApi.util.updateQueryData(\n                    \"getCountry\",\n                    undefined,\n                    (draft) =&gt; {\n                        const index = draft.findIndex(\n                        (country) =&gt; country.id === data.id\n                        );\n                        if (index !== -1) draft.splice(index, 1); // Remove the country if POST fails\n                    }\n                    )\n                );\n\n                // Handle and display the error\n                console.error(\"Error posting country:\", error);\n                alert(`Failed to add country: ${error.message || \"Unknown error\"}`);\n            }\n        },\n    }),\n\n    // PUT to update an existing country\n    putCountry: builder.mutation({\n        query: (data) =&gt; ({\n            url: `Country/${data.id}`, // Assuming data has an `id` field for identification\n            method: \"put\",\n            data,\n        }),\n        async onQueryStarted(data, { dispatch, queryFulfilled }) {\n            const patchResult = dispatch(\n                countryApi.util.updateQueryData(\"getCountry\", undefined, (draft) =&gt; {\n                    const index = draft.findIndex((country) =&gt; country.id === data.id);\n                    if (index !== -1) {\n                    draft[index] = data; // Optimistically update the country data\n                    }\n                })\n            );\n\n            try {\n                // Wait for the PUT request to complete\n                await queryFulfilled;\n            } catch (error) {\n                // If the request fails, rollback the optimistic update\n                dispatch(\n                    countryApi.util.updateQueryData(\n                    \"getCountry\",\n                    undefined,\n                    (draft) =&gt; {\n                        const index = draft.findIndex(\n                        (country) =&gt; country.id === data.id\n                        );\n                        if (index !== -1) draft[index] = data; // Keep the previous data if PUT fails\n                    }\n                    )\n                );\n\n                // Handle and display the error\n                console.error(\"Error updating country:\", error);\n                alert(\n                    `Failed to update country: ${error.message || \"Unknown error\"}`\n                );\n            }\n        },\n        }),\n    }),\n});\n\nexport const {\n    useGetCountryQuery,\n    usePostCountryMutation,\n    usePutCountryMutation,\n} = countryApi;\n</code></pre> <p>Key Points in This Approach:</p> <ol> <li> <p>Optimistic Update:</p> <ul> <li>You optimistically update the local cache using <code>dispatch(countryApi.util.updateQueryData())</code> when the mutation is triggered. For example, when adding a new country via <code>POST</code>, we immediately add it to the list of countries in the cache.</li> </ul> </li> <li> <p>Rollback on Failure:</p> <ul> <li>In the <code>catch</code> block, if the request fails (e.g., network error, server error), we rollback the optimistic update by removing the added country (for <code>POST</code>) or reverting the updated country (for <code>PUT</code>).</li> <li>This is done by updating the cache again but removing or restoring the old data.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>When the request fails, the error is logged using <code>console.error()</code>. Additionally, you can show an error message to the user using <code>alert()</code> or any other UI-based method. In the example, I used an <code>alert</code> with the error message from the <code>error.message</code> object.</li> </ul> </li> <li> <p>Displaying Errors:</p> <ul> <li>In production code, you might want to use a more user-friendly way of displaying errors, such as showing the message in a UI component (e.g., a modal or a toast notification), rather than using <code>alert()</code>.</li> </ul> </li> </ol> Example <p>Example of How You Might Handle the Error in the UI (Optional):</p> <p>If you want to display the error message in a UI component (like a modal or toast), you could use a state in your component to track and display the error.</p> <pre><code>const [postCountry, { isLoading, isError, error }] = usePostCountryMutation();\nconst [errorMessage, setErrorMessage] = useState(\"\");\n\nconst handlePostCountry = async (data) =&gt; {\n    try {\n        await postCountry(data);\n    } catch (err) {\n        setErrorMessage(`Failed to add country: ${err.message || 'Unknown error'}`);\n    }\n};\n\nreturn (\n    &lt;div&gt;\n        {errorMessage &amp;&amp; &lt;div className=\"error-message\"&gt;{errorMessage}&lt;/div&gt;}\n        {/* Your form or other components */}\n    &lt;/div&gt;\n);\n</code></pre> <p>This will allow you to display the error message in a dedicated error section in your UI.</p> Conclusion <ul> <li>Optimistic Updates allow you to update the UI quickly.</li> <li>Rollback ensures that if something goes wrong, the UI reverts to its previous state.</li> <li>Error Handling ensures that users are notified when something fails, and you can show the error in a user-friendly way.</li> </ul> <p>This pattern keeps your application responsive and robust even when network or server errors occur.</p>"},{"location":"state-management/rtkquery/rtk-query-header/","title":"RTK Query","text":"api/postsApi.js<pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { store } from \"./store\"; // Import the Redux store to access state\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n    // You can add headers here, or use `prepareHeaders` for dynamic headers\n    prepareHeaders: (headers, { getState }) =&gt; {\n      // Get the token from the Redux store (assuming it's stored in auth.token)\n      const token = getState().auth.token;\n      if (token) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n      }\n      return headers;\n    },\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>Solution: Global Token Management for Multiple <code>createApi</code> Slices</p> <p>Option 1: Shared <code>baseQuery</code> with Token Injection</p> <pre><code>// api/baseQuery.js\nimport { fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { store } from \"../store\"; // Import the Redux store to access state\n\n// Custom baseQuery that includes token injection logic\nexport const baseQueryWithAuth = fetchBaseQuery({\n  baseUrl: \"https://jsonplaceholder.typicode.com\", // Default base URL (can be overridden in each createApi)\n  prepareHeaders: (headers, { getState }) =&gt; {\n    const token = getState().auth.token; // Retrieve the token from Redux state\n    if (token) {\n      headers.set(\"Authorization\", `Bearer ${token}`); // Set Authorization header with token\n    }\n    return headers; // Return the modified headers\n  },\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-query-header/#which-to-choose","title":"Which to Choose?","text":"<ul> <li> <p>If you have only one API slice or want to ensure the token is only added for requests related to <code>postsApi</code>, then you should keep the filter: <code>action.type.startsWith('postsApi/')</code>.</p> </li> <li> <p>If you have multiple API slices and want to add the token to all outgoing API requests, then removing the check is a cleaner approach. It lets you reuse the middleware across multiple createApi slices without having to duplicate the logic.</p> </li> </ul> <p></p>"},{"location":"state-management/rtkquery/rtk-query-header/#reference","title":"Reference","text":"<ul> <li>How to Use Redux Middleware to Better Control Your Data and Write Cleaner Code</li> </ul>"},{"location":"state-management/rtkquery/rtk-query-header/#examples-basequery","title":"Examples - baseQuery","text":""},{"location":"state-management/rtkquery/rtk-query-header/#axios-basequery","title":"Axios baseQuery","text":"<pre><code>import { createApi } from \"@reduxjs/toolkit/query\";\nimport axios from \"axios\";\n\nconst axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, data, params, headers }) =&gt; {\n    try {\n      const result = await axios({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n        headers,\n      });\n      return { data: result.data };\n    } catch (axiosError) {\n      const err = axiosError;\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      };\n    }\n  };\n\nconst api = createApi({\n  baseQuery: axiosBaseQuery({\n    baseUrl: \"https://example.com\",\n  }),\n  endpoints(build) {\n    return {\n      query: build.query({ query: () =&gt; ({ url: \"/query\", method: \"get\" }) }),\n      mutation: build.mutation({\n        query: () =&gt; ({ url: \"/mutation\", method: \"post\" }),\n      }),\n    };\n  },\n});\n</code></pre> <p>Impletementation in code</p> axios axios/axiosInstance.jsx<pre><code>import axios from \"axios\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  login: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n    ...axiosConfig,\n  }),\n  test: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_TEST_API_URL,\n    ...axiosConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre>"},{"location":"state-management/rtkquery/rtk-query-header/#automatic-re-authorization-by-extending-fetchbasequery","title":"Automatic re-authorization by extending fetchBaseQuery","text":"Simulating axios-like interceptors with a custom base query<pre><code>import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport { tokenReceived, loggedOut } from \"./authSlice\";\n\nconst baseQuery = fetchBaseQuery({ baseUrl: \"/\" });\nconst baseQueryWithReauth = async (args, api, extraOptions) =&gt; {\n  let result = await baseQuery(args, api, extraOptions);\n  if (result.error &amp;&amp; result.error.status === 401) {\n    // try to get a new token\n    const refreshResult = await baseQuery(\"/refreshToken\", api, extraOptions);\n    if (refreshResult.data) {\n      // store the new token\n      api.dispatch(tokenReceived(refreshResult.data));\n      // retry the initial query\n      result = await baseQuery(args, api, extraOptions);\n    } else {\n      api.dispatch(loggedOut());\n    }\n  }\n  return result;\n};\n</code></pre> <p>Preventing multiple unauthorized errors</p> <p>Using async-mutex to prevent multiple calls to '/refreshToken' when multiple calls fail with 401 Unauthorized errors.</p> Preventing multiple unauthorized errors<pre><code>import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport { tokenReceived, loggedOut } from \"./authSlice\";\nimport { Mutex } from \"async-mutex\";\n\n// create a new mutex\nconst mutex = new Mutex();\nconst baseQuery = fetchBaseQuery({ baseUrl: \"/\" });\nconst baseQueryWithReauth = async (args, api, extraOptions) =&gt; {\n  // wait until the mutex is available without locking it\n  await mutex.waitForUnlock();\n  let result = await baseQuery(args, api, extraOptions);\n  if (result.error &amp;&amp; result.error.status === 401) {\n    // checking whether the mutex is locked\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire();\n      try {\n        const refreshResult = await baseQuery(\n          \"/refreshToken\",\n          api,\n          extraOptions\n        );\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data));\n          // retry the initial query\n          result = await baseQuery(args, api, extraOptions);\n        } else {\n          api.dispatch(loggedOut());\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        release();\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      await mutex.waitForUnlock();\n      result = await baseQuery(args, api, extraOptions);\n    }\n  }\n  return result;\n};\n</code></pre>"},{"location":"state-management/rtkquery/rtk-query-header/#topic","title":"Topic","text":"<p>1. Accessing Data from Redux Persist in a React Component</p> <p>If you are using Redux Persist, you can simply use <code>useSelector</code> (a React-Redux hook) to access the persisted data from your Redux store. Redux Persist will automatically rehydrate the store when the page reloads.</p> <pre><code>import React from \"react\";\nimport { useSelector } from \"react-redux\";\n\nconst MyComponent = () =&gt; {\n  // Accessing persisted data from Redux store\n  const token = useSelector((state) =&gt; state.auth.token);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Token from Redux Persist: {token}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>In the above example, <code>token</code> is stored in your Redux store (perhaps in the <code>auth</code> slice of your state), and since you're using Redux Persist, it will persist the token in the browser's localStorage or sessionStorage. When the page reloads, the token will be automatically rehydrated and made available through the Redux state.</p> <p>2. Accessing Data from Redux Persist in Non-Component Files (Outside React)</p> <p>If you need to access the persisted data outside of React components, such as in a regular JavaScript file or a middleware, you can use Redux directly, but keep in mind that Redux Persist is just a middleware that rehydrates your store when the app loads.</p> <p>You can access persisted data like this:</p> <pre><code>import { store } from \"./store\"; // Assuming you have exported your store\n\n// Accessing persisted data from Redux state\nconst token = store.getState().auth.token;\n\nconsole.log(token);\n</code></pre>"},{"location":"state-management/rtkquery/rtk-query-header/#reference_1","title":"Reference","text":"<ul> <li>Migrating to Modern Redux</li> <li>How to add an Authorization header through middleware in an RTK query? : reddit</li> <li>Setting default headers on requests: rtk query</li> </ul>"},{"location":"state-management/rtkquery/rtk-query-header/#need-to-read","title":"Need to Read","text":"<ul> <li>The Ultimate Guide to Implementing Secure Redux Authentication</li> <li>prepare headers getState token for server side request   #2165</li> <li>refresh-token-redux-toolkit: github</li> </ul>"},{"location":"state-management/rtkquery/rtk-query-hooks/","title":"RTK Query Hooks","text":""},{"location":"state-management/rtkquery/rtk-query-hooks/#rtk-query-hook","title":"RTK Query Hook","text":""},{"location":"state-management/rtkquery/rtk-query-hooks/#reference","title":"Reference","text":"<ul> <li>\ud83d\udcda RTK Query: Understanding useQuery Hook </li> <li>Official Mutations</li> <li>API Slices: React Hooks</li> </ul>"},{"location":"state-management/rtkquery/rtk-transform/","title":"RTK Transform","text":"<p>rtk transform</p> <pre><code>export const countryApi = createApi({\n  reducerPath: \"countryApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Country\"],\n  endpoints: (builder) =&gt; ({\n    getCountry: builder.query({\n      query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n      // transformResponse: (response) =&gt;\n      //   response.filter((country) =&gt; country.isActive !== false),\n      transformResponse: (response) =&gt; {\n        logger.info({ msg: \"RESPONSE: \", response });\n        return response.filter((country) =&gt; country.isActive !== false);\n      },\n      providesTags: [\"Country\"],\n    }),\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/rtk-transform/#rtk-query-sorting","title":"RTK Query <code>Sorting</code>","text":"<p>To sort the data in the response from an RTK Query API call, you can leverage the <code>transformResponse</code> function to sort the data before it's passed to your component or store. This function allows you to manipulate the API response, including sorting the data, before it is stored in your Redux store or used in your component.</p> <p>Example: Sorting Response Data in RTK Query</p> <ol> <li>Define the API slice using <code>createApi</code>.</li> <li>Use the <code>transformResponse</code> option to sort the data.</li> </ol> Example CodeExplanation <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const myApi = createApi({\n    reducerPath: 'myApi',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/api/' }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n        query: () =&gt; 'data',  // Replace with your actual endpoint\n        transformResponse: (response) =&gt; {\n            // Sorting the response data (example: sorting by 'name' property)\n            return response.sort((a, b) =&gt; a.name.localeCompare(b.name));\n        },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <ol> <li><code>transformResponse</code>: This function is executed after the API call and before the data is stored in the Redux state. In this example, we are sorting the response array based on the <code>name</code> property (you can adjust it based on your data structure).</li> <li><code>localeCompare</code>: This method is used for string comparison to sort by the <code>name</code> field. If you're sorting by numbers or other types of data, you can adjust the sorting logic accordingly.</li> </ol> <p>Sorting by Other Criteria</p> <p>If you want to sort by a numeric value or another property, simply adjust the sorting logic within <code>transformResponse</code>. For example, if you are sorting by <code>date</code> or a numeric field, you can modify it like so:</p> <pre><code>transformResponse: (response) =&gt; {\n  return response.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)); // Sorting by date field\n};\n</code></pre> Key Takeaways <ol> <li>Use <code>transformResponse</code> in RTK Query to modify the response data before it's passed to your components.</li> <li>You can sort the data by any criteria (strings, numbers, dates, etc.) within the <code>transformResponse</code> function.</li> <li>The sorted data will automatically be available in the component when the query data is fetched.</li> </ol> <p>This approach ensures that the data is always sorted before it's available for rendering or further processing in your application</p>"},{"location":"state-management/rtkquery/rtk-transform/#example","title":"Example","text":"BasicWith SafetyKey Improvements Explained <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const myApi = createApi({\n    reducerPath: \"myApi\",\n    baseQuery: fetchBaseQuery({ baseUrl: \"https://example.com/api/\" }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n            query: () =&gt; \"data\", // Replace with your actual endpoint\n            transformResponse: (response) =&gt; {\n                // Filter the response to only include items where isActive is true\n                const activeItems = response.filter((item) =&gt; item.isActive);\n\n                // Sort the filtered active items by 'name'\n                return activeItems.sort((a, b) =&gt; a.name.localeCompare(b.name));\n            },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// API slice definition\nexport const myApi = createApi({\n    reducerPath: 'myApi',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/api/' }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n            query: () =&gt; 'data',  // Replace with your actual endpoint\n            transformResponse: (response) =&gt; {\n                try {\n                    // Filter: Only keep active items\n                    const activeItems = response.filter(item =&gt; item.isActive);\n\n                    // Sort: Safely sort by 'name', ensuring both a and b are strings\n                    const sortedItems = activeItems.sort((a, b) =&gt; {\n                        if (!a.name || !b.name) return 0; // Handle edge cases where name might be missing\n                        return a.name.localeCompare(b.name);\n                    });\n\n                    return sortedItems;\n                } catch (error) {\n                    console.error('Error while transforming response:', error);\n                    return [];  // Fallback to an empty array in case of errors\n                }\n            },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <ul> <li> <p>Error Handling with <code>try-catch</code>: Wrapping the transformation logic in a <code>try-catch</code> block helps handle any unexpected errors that might occur during filtering or sorting (e.g., if the data structure is not as expected). In case of an error, we return an empty array (<code>[]</code>) as a fallback, but you could also return <code>null</code> or handle it differently depending on the requirements.</p> </li> <li> <p>Null Safety in Sorting: While sorting, we check if both <code>a.name</code> and <code>b.name</code> exist. If either <code>name</code> field is missing (<code>null</code> or <code>undefined</code>), we return <code>0</code> to avoid errors. This ensures that items without a <code>name</code> are not causing issues during the sorting operation.</p> </li> <li> <p>Code Comments: Adding comments to each section helps explain what's happening, making the code more maintainable for future developers (or yourself).</p> </li> <li> <p>Optional: TypeScript Enhancements: If you're using TypeScript, consider adding types to the API response, the <code>item</code> object, and the <code>transformResponse</code> function to improve type safety.</p> </li> </ul> Best Practice <p>If you're unsure whether <code>response</code> or <code>item</code> can be null or undefined, it's safer to use the optional chaining version:</p> <pre><code>const activeItems = response?.filter(item =&gt; item?.isActive);\n</code></pre>"},{"location":"state-management/rtkquery/rtk-vs-tanstack/","title":"RTK vs TanStack","text":""},{"location":"state-management/rtkquery/rtk-vs-tanstack/#does-tanstack-query-replace-redux-mobx-or-other-global-state-managers","title":"Does TanStack Query replace Redux, MobX or other global state managers?","text":"<ul> <li>TanStack Query is a server-state library, responsible for managing asynchronous operations between your server and client</li> <li>Redux, MobX, Zustand, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query</li> </ul>"},{"location":"state-management/rtkquery/rtk-vs-tanstack/#client-state-vs-server-state","title":"Client State vs. Server State","text":"<p>What Apollo gives you is not just the ability to describe which data you want and to fetch that data, it also comes with a cache for that server data. This means that you can just use the same <code>useQuery</code> hook in multiple components, and it will only fetch data once and then subsequently return it from the cache.</p> <p>This sounds very familiar with what we, and probably many other teams as well, have mainly been using <code>redux</code> for: Fetch data from the server and make it available everywhere.</p> <p>So it seems that we have always been treating this server state like any other client state. Except that when it comes to server state (think: A list of articles that you fetch, the details of a User you want to display, ...), your app does not own it. We have only borrowed it to display the most recent version of it on the screen for the user. It is the server who owns the data.</p> <p>To me, that introduced a paradigm shift in how to think about data. If we can leverage the cache to display data that we do not own, there isn't really much left that is real client state that also needs to be made available to the whole app. That made me understand why many think that Apollo can replace redux in lots of instances.</p>"},{"location":"state-management/rtkquery/rtk-vs-tanstack/#reference","title":"Reference","text":"<ul> <li>RTK Query vs React/TanStack Query: A Comprehensive Comparison for Frontend Developers.</li> <li>Rtk query or tanstack</li> <li>TanStack Query (FKA React Query): official</li> <li>Rendering paginated data in React with useInfiniteQuery: tanstack</li> <li>Zustand vs. RTK Query vs. TanStack Query: Unpacking the React State Management Toolbox</li> <li>TanStack Query vs. Redux: The Ultimate Guide to API Data Handling in React Native</li> <li>Tanstack react query or rtk query</li> <li>RTK Query vs. TanStack Query \u2013 A Developer's Perspective</li> <li>React Query vs RTK Query: A Comprehensive Comparison</li> <li>What is the main difference between React Query and Redux? : stackoverflow</li> <li>Like react-query and redux? You'll love RTK Query </li> <li>RTK Query Vs. React Query: Breaking Down the Technicalities</li> <li>How we migrated from Redux to TanStack Query and Redux Toolkit</li> </ul> <p>Comparision</p> <ul> <li>Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router</li> <li>Tanstack Query vs RTK Query: gist</li> </ul>"},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/","title":"Notification Approach","text":""},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/#approach-for-notification-middleware-in-rtk-query","title":"Approach for Notification Middleware in RTK Query","text":"<p>Both approaches\u2014using a <code>notification</code> middleware or using <code>onQueryStarted</code> \u2014 are valid, but the choice depends on your requirements, how granular you want the notifications to be, and how much control you need over when and where notifications are triggered.</p>"},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/#1-using-notification-middleware-global-approach","title":"1. Using Notification Middleware (Global Approach)","text":"Pros <ul> <li>Centralized logic: You can handle notifications globally for all API calls, without having to add custom logic to each individual endpoint.</li> <li>Separation of concerns: Keeping the notification logic separate from the API logic can help maintain a cleaner separation between concerns, making the code more modular and easier to maintain.</li> <li>Consistency: You can easily ensure that notifications for errors and successes are consistent across the app.</li> </ul> Cons <ul> <li>Less control over individual requests: You have less fine-grained control over which specific requests trigger notifications. For example, if you only want notifications for certain requests (e.g., CRUD operations), you may have to introduce extra logic or markers to distinguish between different types of requests.</li> <li>Can be less flexible for complex workflows: For certain cases, like when you need to trigger different notifications based on the response, you might find the middleware approach too generic.</li> </ul> <p>If you want a global solution where all API responses (<code>success</code> or <code>failure</code>) trigger notifications, the middleware approach works well:</p> Example<pre><code>export const notificationMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  const { type, payload } = action;\n  const apiMeta = payload?.meta || {};\n  const method = apiMeta.method || \"\";\n  const actionType = apiMeta.type || \"\";\n\n  // Handle notifications for success (fulfilled)\n  if (type.endsWith(\"/fulfilled\")) {\n    if (actionType === \"create\") notifySuccess(\"Created successfully!\");\n    if (actionType === \"update\") notifySuccess(\"Updated successfully!\");\n    if (actionType === \"delete\") notifySuccess(\"Deleted successfully!\");\n  }\n\n  // Handle notifications for errors (rejected)\n  if (type.endsWith(\"/rejected\")) {\n    if (method === \"GET\") notifyError(\"Failed to fetch data.\");\n    if (actionType === \"create\") notifyError(\"Failed to create.\");\n    if (actionType === \"update\") notifyError(\"Failed to update.\");\n    if (actionType === \"delete\") notifyError(\"Failed to delete.\");\n  }\n\n  return next(action);\n};\n</code></pre>"},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/#2-using-onquerystarted-in-rtk-query-specific-to-endpoints","title":"2. Using onQueryStarted in RTK Query (Specific to Endpoints)","text":"Pros <ul> <li>Fine-grained control: You can target notifications specifically to individual endpoints, which gives you full control over when and where to show notifications (e.g., only show success notifications for <code>POST</code> or <code>PUT</code>, not for <code>GET</code>).</li> <li>Flexible: It allows you to add additional logic specific to certain API requests, such as manipulating the payload before updating the store or triggering more complex workflows.</li> <li>Works well with optimistic updates: If you're implementing optimistic updates (like immediate UI changes before the API call resolves), <code>onQueryStarted</code> gives you a way to manage both the optimistic UI and notification state.</li> </ul> Cons <ul> <li>More boilerplate: You need to define <code>onQueryStarted</code> logic for each endpoint, which can lead to some repetitive code if you're adding similar logic for multiple endpoints.</li> <li>More granular logic: It could be harder to maintain if you have many API calls across your application.</li> </ul> <p>For more specific notification control, use <code>onQueryStarted</code> inside your API slice:</p> Example<pre><code>export const currencyApi = createApi({\n  reducerPath: \"currencyApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Currency\"],\n  endpoints: (builder) =&gt; ({\n    getCurrency: builder.query({\n      query: () =&gt; ({\n        url: \"Currency\",\n        method: \"GET\",\n      }),\n      onQueryStarted: async (args, { dispatch, queryFulfilled }) =&gt; {\n        try {\n          await queryFulfilled;\n          notifySuccess(\"Data fetched successfully!\");\n        } catch (err) {\n          notifyError(\"Failed to fetch data.\");\n        }\n      },\n      providesTags: [\"Currency\"],\n    }),\n\n    postCurrency: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"Currency\",\n        method: \"POST\",\n        data,\n      }),\n      onQueryStarted: async (args, { dispatch, queryFulfilled }) =&gt; {\n        try {\n          await queryFulfilled;\n          notifySuccess(\"Currency created successfully!\");\n        } catch (err) {\n          notifyError(\"Failed to create currency.\");\n        }\n      },\n      invalidatesTags: [\"Currency\"],\n    }),\n\n    // Add similar `onQueryStarted` for other CRUD operations...\n  }),\n});\n</code></pre>"},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/#which-approach-is-best","title":"Which Approach is Best?","text":"<p>Use <code>notificationMiddleware</code> if:</p> <ul> <li>You want a global, centralized approach for handling notifications for all API calls.</li> <li>The same behavior (e.g., success and error notifications) is acceptable across many API calls.</li> <li>You don\u2019t need to customize notifications for individual requests but just want consistency.</li> </ul> <p>Use <code>onQueryStarted</code> if:</p> <ul> <li>You need fine-grained control over when and how notifications are triggered, especially for specific endpoints.</li> <li>You have complex logic or conditions around when notifications should appear.</li> <li>You want to trigger optimistic updates or other side effects directly when the query starts or completes.</li> <li>You want to show specific notifications based on the type of request (e.g., only notify success for <code>POST</code> or <code>PUT</code> requests).</li> </ul>"},{"location":"state-management/rtkquery/hooks/notification-approach-rtk/#recommendation","title":"Recommendation:","text":"<p>If your goal is simply to show <code>success/error</code> notifications for CRUD operations and you don't need to differentiate between different kinds of requests globally, the <code>onQueryStarted</code> approach is often a cleaner, more flexible choice because it ties the logic directly to the API endpoint and allows for more granular control. However, if you need a global notification system that is consistent across all API calls, notification middleware is more appropriate.</p>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/","title":"Lifecycle","text":"<p>In RTK Query (part of Redux Toolkit), lifecycle hooks are functions that you can use to handle different stages of an API request (like fetching data, handling success, failure, etc.). These hooks are available through the <code>createApi</code> service, which is used to define API endpoints and the logic around them. RTK Query provides several hooks to deal with the various stages of a request:</p>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#summary-of-lifecycle-hooks","title":"Summary of Lifecycle Hooks:","text":"<ul> <li><code>onQueryStarted</code>: Triggered when a query starts, useful for optimistic updates.</li> <li><code>onQuerySuccess</code>: Triggered when a query succeeds, useful for post-fetch actions.</li> <li><code>onQueryError</code>: Triggered when a query fails, useful for error handling.</li> <li><code>onMutationStarted</code>: Triggered when a mutation starts, useful for side effects before mutation.</li> <li><code>onMutationSuccess</code>: Triggered when a mutation succeeds, useful for post-mutation actions.</li> <li><code>onMutationError</code>: Triggered when a mutation fails, useful for error handling.</li> </ul>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#official","title":"Official","text":"<ul> <li>Optimistic Updates</li> <li>Pessimistic Updates</li> <li>General Updates</li> </ul>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#optimistic-updates-working","title":"Optimistic Updates Working","text":"Bug <pre><code>export const usersApi = createApi({\n    reducerPath: \"usersApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    tagTypes: [\"Users\"],\n    endpoints: (builder) =&gt; ({\n        getUsers: builder.query({\n            query: () =&gt; ({\n                url: \"Users\",\n                method: \"get\",\n            }),\n        }),\n\n        postUsers: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Users/create\",\n                method: \"post\",\n                data,\n            }),\n        }),\n\n        putUsers: builder.mutation({\n            query: ({ id, data }) =&gt; ({\n                url: `Users/edit/${id}`,\n                method: \"put\",\n                data,\n            }),\n\n            // BUG\n            async onQueryStarted(data, { dispatch, queryFulfilled }) {\n                const patchResult = dispatch(\n                    usersApi.util.updateQueryData(\"getUsers\", undefined, (draft) =&gt; {\n                        const item = draft.find((i) =&gt; i.id === data.id);\n\n                        console.log(\"Found item:\", item);\n                        console.log(\"Draft state:\", draft);\n\n                        if (item) {\n                            Object.assign(item, data);\n                        }\n                    })\n                );\n\n                try {\n                    await queryFulfilled;\n                    // dispatch(usersApi.endpoints.getUsers.initiate());\n                } catch {\n                    patchResult.undo();\n                }\n            },\n\n        }),\n    }),\n});\n</code></pre> <p>The code you've provided defines an API slice using Redux Toolkit's createApi, and it aims to implement optimistic updates when updating a user's data with the putUsers mutation. However, it might not work as expected for a few potential reasons. Let's break down the issues and how to fix them:</p>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#1-optimistic-update-logic","title":"1. Optimistic Update Logic","text":"<p>In an optimistic update, you're essentially making an assumption that the mutation will succeed, and you update the local cache (UI) right away. The part where you try to optimistically update the local cache by dispatching <code>updateQueryData</code> seems mostly correct, but there are a couple of things to consider:</p> <ul> <li>Using the correct state slice: The optimistic update relies on updating the data in the correct slice of the store, and it needs to match the state shape of the <code>getUsers</code> query.</li> <li>The state update is in the <code>onQueryStarted</code>: The optimistic update should ideally happen right after the mutation is initiated, before waiting for the mutation's actual response. The state change should be done in the optimistic update block.</li> </ul> <p>Let's improve it:</p>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#2-state-update-in-onquerystarted","title":"2. State Update in <code>onQueryStarted</code>","text":"<p>The issue is likely because the <code>getUsers</code> query expects the entire list of users, and you're trying to update the list based on the assumption that the <code>id</code> will exist in the state. If the data isn't structured correctly or is deeply nested, the optimistic update might not reflect the expected changes.</p> <p>Possible Fix:</p> <ul> <li>Use <code>onQueryStarted</code> to optimistically update the data.</li> <li>Ensure you're directly modifying the data to avoid race conditions.</li> </ul>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#3-correct-approach","title":"3. Correct Approach:","text":"Example CodeKey changes and explanations: <pre><code>export const usersApi = createApi({\n    reducerPath: \"usersApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    tagTypes: [\"Users\"],\n    endpoints: (builder) =&gt; ({\n        getUsers: builder.query({\n            query: () =&gt; ({\n                url: \"Users\",\n                method: \"get\",\n            }),\n        }),\n\n        postUsers: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Users/create\",\n                method: \"post\",\n                data,\n            }),\n        }),\n\n        putUsers: builder.mutation({\n            query: ({ id, data }) =&gt; ({\n                url: `Users/edit/${id}`,\n                method: \"put\",\n                data,\n            }),\n\n            // Optimistic update handling\n            async onQueryStarted({ id, data }, { dispatch, queryFulfilled }) {\n                const patchResult = dispatch(\n                    usersApi.util.updateQueryData(\"getUsers\", undefined, (draft) =&gt; {\n                        // Look for the user with the specified ID\n                        const user = draft.find((user) =&gt; user.id === id);\n\n                        if (user) {\n                            // Optimistically update the user data\n                            Object.assign(user, data);\n                        }\n                    })\n                );\n\n                try {\n                    // Wait for the mutation to finish successfully\n                    await queryFulfilled;\n                } catch (error) {\n                    // If the mutation fails, undo the optimistic update\n                    patchResult.undo();\n                }\n            },\n            // uptohere onQueryStarted\n        }),\n    }),\n});\n</code></pre> <ol> <li> <p>Use the <code>id</code> to identify the correct user: The state update looks for the <code>user</code> with the matching <code>id</code> and applies the <code>data</code> changes. This assumes that <code>draft</code> is an array of users.</p> </li> <li> <p>**Error handling: The <code>patchResult.undo()</code> ensures that if the mutation fails, the optimistic state changes will be reverted, restoring the UI to its previous state.</p> </li> <li> <p>Correct query used in <code>updateQueryData</code>: The query name <code>getUsers</code> is correctly used, and you don't need to specify the parameter <code>undefined</code> unless it's necessary (this depends on your state structure).</p> </li> <li> <p>Avoid waiting for the response before updating the UI: By applying the changes optimistically in <code>onQueryStarted</code>, we can immediately update the UI before the server responds.</p> </li> </ol>"},{"location":"state-management/rtkquery/hooks/rtk-lifecycle-hooks/#additional-considerations","title":"Additional Considerations:","text":"<ul> <li>Network issues: If the mutation fails after the optimistic update, the UI will revert to its original state thanks to <code>patchResult.undo()</code>.</li> <li>Data consistency: Make sure that the data format you expect from the API matches the structure you're working with in the <code>updateQueryData</code> function.</li> </ul> <p>With these changes, your optimistic update should work as expected, improving the user experience with immediate UI updates, and rolling back on failure.</p>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/","title":"Query","text":""},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#rtk-query-overview","title":"RTK Query Overview","text":"<p>RTK Query is a powerful data fetching and caching tool. It is designed to simplify common cases for loading data in a web application, eliminating the need to hand-write data fetching &amp; caching logic yourself.</p> <p>RTK Query is an optional addon included in the Redux Toolkit package, and its functionality is built on top of the other APIs in Redux Toolkit.</p>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#using-rtk-query","title":"Using RTK Query","text":""},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#queries","title":"Queries","text":"<p>This is the most common use case for RTK Query. A query operation can be performed with any data fetching library of your choice, but the general recommendation is that you only use queries for requests that retrieve data. For anything that alters data on the server or will possibly invalidate the cache, you should use a Mutation.</p> <p>Defining Query Endpoints</p> <p>Query endpoints are defined by returning an object inside the endpoints section of createApi, and defining the fields using the <code>builder.query()</code> method.</p> <p>Query endpoints should define either a <code>query</code> callback that constructs the URL (including any URL query params), or a queryFn callback that may do arbitrary async logic and return a result.</p> Hook types <p>There are 5 query-related hooks:</p> <ol> <li>useQuery</li> <li>useQuerySubscription</li> <li>useQueryState</li> <li>useLazyQuery</li> <li>useLazyQuerySubscription</li> </ol> <p>In practice, the standard <code>useQuery</code>-based hooks such as <code>useGetPostQuery</code> will be the primary hooks used in your application, but the other hooks are available for specific use cases.</p> Query Hook Options <p>The query hooks expect two parameters: (<code>queryArg?</code>, <code>queryOptions?</code>).</p> <p>The <code>queryArg</code> param will be passed through to the underlying <code>query</code> callback to generate the URL. The <code>queryOptions</code> object accepts several additional parameters that can be used to control the behavior of the data fetching:</p> <ul> <li>skip - Allows a query to 'skip' running for that render. Defaults to <code>false</code></li> <li>pollingInterval - Allows a query to automatically refetch on a provided interval, specified in milliseconds. Defaults to <code>0</code> (off)</li> <li>selectFromResult - Allows altering the returned value of the hook to obtain a subset of the result, render-optimized for the returned subset.</li> <li>refetchOnMountOrArgChange - Allows forcing the query to always refetch on mount (when <code>true</code> is provided). Allows forcing the query to refetch if enough time (in seconds) has passed since the last query for the same cache (when a <code>number</code> is provided). Defaults to <code>false</code></li> <li>refetchOnFocus - Allows forcing the query to refetch when the browser window regains focus. Defaults to <code>false</code></li> <li>refetchOnReconnect - Allows forcing the query to refetch when regaining a network connection. Defaults to <code>false</code></li> </ul> Info <p>All <code>refetch</code>-related options will override the defaults you may have set in createApi</p> <p>Frequently Used Query Hook Return Values</p> <p>The query hook returns an object containing properties such as the latest <code>data</code> for the query request, as well as status booleans for the current request lifecycle state. Below are some of the most frequently used properties. Refer to useQuery for an extensive list of all returned properties.</p> <ul> <li><code>data</code> - The latest returned result regardless of hook arg, if present.</li> <li><code>currentData</code> - The latest returned result for the current hook arg, if present.</li> <li><code>error</code> - The error result if present.</li> <li><code>isUninitialized</code> - When true, indicates that the query has not started yet.</li> <li><code>isLoading</code> - When true, indicates that the query is currently loading for the first time, and has no data yet. This will be true for the first request fired off, but not for subsequent requests.</li> <li><code>isFetching</code> - When true, indicates that the query is currently fetching, but might have data from an earlier request. This will be true for both the first request fired off, as well as subsequent requests.</li> <li><code>isSuccess</code> - When true, indicates that the query has data from a successful request.</li> <li><code>isError</code> - When true, indicates that the query is in an error state.</li> <li><code>refetch</code> - A function to force refetch the query</li> </ul> <p>In most cases, you will probably read data and either isLoading or isFetching in order to render your UI.</p>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#mutation","title":"Mutation","text":"<p>Mutations are used to send data updates to the server and apply the changes to the local cache. Mutations can also invalidate cached data and force re-fetches.</p>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#conditional-fetching","title":"Conditional Fetching","text":"<p>Query hooks automatically begin fetching data as soon as the component is mounted. But, there are use cases where you may want to delay fetching data until some condition becomes true. RTK Query supports conditional fetching to enable that behavior.</p> <p>If you want to prevent a query from automatically running, you can use the <code>skip</code> parameter in a hook.</p> Tip <p>Typescript users may wish to use <code>skipToken</code> as an alternative to the <code>skip</code> option in order to skip running a query, while still keeping types for the endpoint accurate.</p>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#example","title":"Example","text":""},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#queries_1","title":"Queries","text":"ComponentAPI <pre><code>const {\n    data: bank,\n    loading: bankLoading,\n    error: bankError,\n} = useGetCounterPartyQuery(formValues?.buyingCurrency, {\n    skip: !formValues?.buyingCurrency,\n});\n</code></pre> <pre><code>export const counterPartyApi = createApi({\n    reducerPath: \"counterPartyApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    tagTypes: [\"CounterParty\"],\n    endpoints: (builder) =&gt; ({\n        getCounterParty: builder.query({\n        query: (id) =&gt; ({ url: `CounterParty/${id}`, method: \"get\" }),\n        transformResponse: (response) =&gt;\n            response.filter((counterParty) =&gt; counterParty.isActive !== false),\n        providesTags: [\"CounterParty\"],\n        }),\n\n        postCounterParty: builder.mutation({\n            query: (data) =&gt; ({ url: \"CounterParty\", method: \"post\", data }),\n            invalidatesTags: [\"CounterParty\"],\n        }),\n\n        putCounterParty: builder.mutation({\n            query: ({ id, data }) =&gt; ({\n                url: `CounterParty/${id}`,\n                method: \"put\",\n                data,\n            }),\n            invalidatesTags: [\"CounterParty\"],\n        }),\n    }),\n});\n</code></pre> <pre><code>const handleSelect = (value) =&gt; {\n  logger.info({ msg: \"INFO: \", value, selectedIds });\n  setSelectedIds((prevState) =&gt; ({\n    ...prevState, // Spread the previous state\n    counterPartyId: value, // Update the counterPartyId with the new value\n  }));\n};\n\n// or\n\nconst handleSelect = (value) =&gt; {\n  setSelectedIds((prevState) =&gt; {\n    const updatedState = {\n      ...prevState,\n      counterPartyId: value,\n    };\n\n    // Log inside the state update\n    logger.info({ msg: \"INFO: State update\", updatedState });\n\n    return updatedState;\n  });\n};\n</code></pre>"},{"location":"state-management/rtkquery/hooks/rtk-query-hooks/#query-string-in-rtk-query","title":"Query String in RTK QUery","text":"CODEComponentServicesExplanation <pre><code>npm install query-string\n</code></pre> <pre><code>import { useGetDealCounterPartyAccByCurrencyQuery } from \"./apiSlice\";\n\nconst MyComponent = () =&gt; {\n    const { data, error, isLoading } = useGetDealCounterPartyAccByCurrencyQuery({\n        code: \"USD\",\n        isOwned: true, // Pass the `isOwned` parameter dynamically\n    });\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h3&gt;Data:&lt;/h3&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <pre><code>import queryString from 'query-string';\n\ngetDealCounterPartyAccByCurrency: builder.query({\n    query: ({ code, isOwned }) =&gt; {\n            // Construct the query parameters using query-string\n            const queryParams = queryString.stringify({\n            isOwned, // Add the isOwned parameter\n        });\n\n        // Return the query with the URL and method\n        return {\n            url: `DealCounterpartyAccount/GetByCurrency/${code}?${queryParams}`, // Append the query string\n            method: 'get',\n        };\n    },\n}),\n</code></pre> <ol> <li> <p><code>queryString.stringify</code>:</p> <ul> <li>This function from <code>query-string</code> takes an object and converts it into a query string. For example, if <code>isOwned = true</code>, it will generate <code>isOwned=true</code>.</li> <li>It automatically handles encoding and serializing the parameters, ensuring the query string is properly formatted (e.g., <code>key=value</code> pairs, handling <code>null</code>, <code>undefined</code>, and empty values).</li> </ul> </li> <li> <p>URL Construction:</p> <ul> <li>The <code>url</code> in the returned object is dynamically created by combining the code (as part of the path) and the query parameters (as part of the query string).</li> <li>If <code>isOwned</code> is <code>true</code>, the final URL will be something like <code>DealCounterpartyAccount/GetByCurrency/USD?isOwned=true</code>.</li> </ul> </li> </ol> Date Utils <pre><code>import React, { useEffect, useState } from \"react\";\nimport { Form, InputNumber, Button } from \"antd\";\nimport { isEmpty } from \"lodash\"; // Assuming lodash is imported\nimport logger from \"your-logger\"; // Replace with your logger\n\nconst MyComponent = ({ exchangeRateData, getLatestObjectForToday }) =&gt; {\n    const [form] = Form.useForm();\n    const [isDisabled, setIsDisabled] = useState(false);\n\n    useEffect(() =&gt; {\n        if (!isEmpty(exchangeRateData)) {\n            // Get the latest object based on today's date\n            let todayRate = getLatestObjectForToday(exchangeRateData);\n\n            // Set the form field for rate\n            form.setFieldsValue({\n                rate: todayRate?.rate || null, // Set rate or null if not available\n            });\n\n            // Disable the input number if rate is successfully set\n            if (todayRate?.rate) {\n                setIsDisabled(true); // Disable if todayRate is available\n            }\n\n            // Log the todayRate\n            logger.info({ msg: \"Today: \", todayRate });\n        } else {\n            form.setFieldsValue({\n                rate: null, // Reset rate to null if exchangeRateData is empty\n            });\n\n            setIsDisabled(false); // Re-enable if no rate data\n        }\n    }, [exchangeRateData, form, getLatestObjectForToday]);\n\nreturn (\n    &lt;Form form={form} layout=\"vertical\"&gt;\n        &lt;Form.Item\n            name=\"rate\"\n            label=\"Rate\"\n            rules={[{ required: false, message: \"Please input Rate\" }]}\n        &gt;\n            &lt;InputNumber\n            style={{ width: \"100%\" }}\n            disabled={isDisabled} // Disable based on isDisabled state\n            /&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Button onClick={() =&gt; console.log(form.getFieldsValue())}&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n);\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"state-management/rtkquery/hooks/rtk-skip-option/","title":"Skip Option","text":"<p>In RTK Query, the <code>skip</code> option is typically used to conditionally prevent the execution of a query based on certain criteria. However, RTK Query allows only a single <code>skip</code> condition per query. If you want to use multiple conditions for skipping the query, you will need to combine the conditions in a logical way.</p> <p>For example, you can combine two conditions using logical operators (<code>&amp;&amp;</code> or <code>||</code>) inside the <code>skip</code> field.</p> <p>Here\u2019s how you can add two skip values to your query:</p> <pre><code>const {\n  data: approvalPersonData,\n  isLoading: approvalPersonLoading,\n  error: approvalPersonError,\n} = useGetForexApprovalPersonQuery(\n  {\n    sellingAmount: formValues?.sellingAmount,\n    sellingCurrencyId: formValues?.sellingCurrency,\n  },\n  {\n    skip: !formValues?.sellingAmount || !formValues?.sellingCurrency, // Skip if either condition is not met\n  }\n);\n</code></pre> <p>In the example above:</p> <ul> <li>The query will be skipped if either <code>formValues?.sellingAmount</code> or <code>formValues?.sellingCurrency</code> is falsy.</li> <li> <p>You can adjust the logical condition (<code>&amp;&amp;</code>, <code>||</code>) depending on your use case:</p> <ul> <li><code>&amp;&amp;</code>: Skip only if both conditions are falsy.</li> <li><code>||</code>: Skip if either of the conditions is falsy.</li> </ul> </li> </ul> <p>This allows you to apply multiple skip conditions in a single place, making your query conditional based on multiple factors.</p>"},{"location":"state-management/rtkquery/hooks/tanStack-query/","title":"TanStack","text":"<p>TanStack</p> InstallationSetup <pre><code>npm install @tanstack/react-query\n\nnpm install @tanstack/react-query-devtools\n</code></pre> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport App from \"./App\";\n\n// Create a new Query Client instance\nconst queryClient = new QueryClient();\n\nReactDOM.render(\n    &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;App /&gt;\n    &lt;/QueryClientProvider&gt;,\ndocument.getElementById(\"root\")\n);\n</code></pre>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#flat-folder-structure-example","title":"Flat Folder Structure Example","text":"ExampleBreakdown of the Structure <pre><code>/src\n    /api\n        /queries\n            getUser.js\n            getPosts.js\n            createPost.js\n        /mutations\n            createUser.js\n            updatePost.js\n\n    /components\n        UserCard.js\n        PostList.js\n        CreatePostForm.js\n\n    /hooks\n        useGetUser.js\n        useGetPosts.js\n        useCreatePost.js\n        useCreateUser.js\n\n    /pages\n        HomePage.js\n        UserPage.js\n\n    /services\n        apiClient.js\n\n    /utils\n        queryClient.js\n\n    App.js\n</code></pre> <ul> <li> <p><code>/api</code>: Contains the logic for making API requests. This is where you would define the queries and mutations using Axios.</p> <ul> <li><code>queries/</code>: Functions to fetch data from the server.</li> <li><code>mutations/</code>: Functions to send data (e.g., creating or updating resources).</li> </ul> </li> <li> <p><code>/components</code>: Contains React components that will display data or forms.</p> <ul> <li>Components here can use hooks defined in <code>/hooks</code>.</li> </ul> </li> <li> <p><code>/hooks</code>: Custom hooks that use TanStack Query to manage the fetching and mutation logic.</p> <ul> <li><code>useQuery</code> and <code>useMutation</code> hooks are used here to interact with the data.</li> </ul> </li> <li> <p><code>/pages</code>: Page components that utilize hooks and render the appropriate UI.</p> </li> <li> <p><code>/services</code>: Contains a utility file for setting up Axios with base configurations, like API base URL, headers, etc.</p> </li> <li> <p><code>/utils</code>: Utility files for configuration or shared functionality (e.g., setting up <code>queryClient</code>).</p> </li> </ul>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#example","title":"Example","text":"apiClient.jsgetPosts.jsuseGetPosts.jscreatePost.jsuseCreatePost.jsHomePage.jsPostList.jsApp.js <p>1. <code>apiClient.js</code> (in <code>/services</code>)</p> <p>This file configures Axios to centralize HTTP requests across the app.</p> <pre><code>// /services/apiClient.js\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n    baseURL: 'https://jsonplaceholder.typicode.com',  // Example API base URL\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\nexport default apiClient;\n</code></pre> <p>2. <code>getPosts.js</code> (in <code>/api/queries</code>)</p> <p>This is the function that fetches data from the API</p> <pre><code>// /api/queries/getPosts.js\nimport apiClient from '../services/apiClient';\n\nconst getPosts = async () =&gt; {\n    const response = await apiClient.get('/posts');\n    return response.data;\n};\n\nexport default getPosts;\n</code></pre> <p>3. <code>useGetPosts.js</code> (in <code>/hooks</code>)</p> <p>This custom hook uses TanStack Query's <code>useQuery</code> hook to fetch and manage the state of posts.</p> <pre><code>// /hooks/useGetPosts.js\nimport { useQuery } from '@tanstack/react-query';\nimport getPosts from '../api/queries/getPosts';\n\nconst useGetPosts = () =&gt; {\n    return useQuery(['posts'], getPosts);\n};\n\nexport default useGetPosts;\n</code></pre> <p>4. <code>createPost.js</code> (in <code>/api/mutations</code>)</p> <p>This function sends a POST request to create a new post.</p> <pre><code>// /api/mutations/createPost.js\nimport apiClient from '../services/apiClient';\n\nconst createPost = async (newPost) =&gt; {\n    const response = await apiClient.post('/posts', newPost);\n    return response.data;\n};\n\nexport default createPost;\n</code></pre> <p>5. <code>useCreatePost.js</code> (in <code>/hooks</code>)</p> <p>This custom hook is used for creating a new post.</p> <pre><code>// /hooks/useCreatePost.js\nimport { useMutation } from '@tanstack/react-query';\nimport createPost from '../api/mutations/createPost';\n\nconst useCreatePost = () =&gt; {\n    return useMutation(createPost);\n};\n\nexport default useCreatePost;\n</code></pre> <p>6. <code>HomePage.js</code> (in <code>/pages</code>)</p> <p>A page component that fetches and displays the list of posts.</p> <pre><code>// /pages/HomePage.js\nimport React from 'react';\nimport useGetPosts from '../hooks/useGetPosts';\nimport PostList from '../components/PostList';\n\nconst HomePage = () =&gt; {\n    const { data, isLoading, error } = useGetPosts();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error fetching posts&lt;/div&gt;;\n\n    return &lt;PostList posts={data} /&gt;;\n};\n\nexport default HomePage;\n</code></pre> <p>7. <code>PostList.js</code> (in <code>/components</code>)</p> <p>A component that displays the list of posts.</p> <pre><code>// /components/PostList.js\nimport React from 'react';\n\nconst PostList = ({ posts }) =&gt; {\n    return (\n        &lt;ul&gt;\n            {posts.map(post =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default PostList;\n</code></pre> <p>8. <code>App.js</code></p> <p>The main entry point for the app, which provides the <code>queryClient</code> to the app using <code>QueryClientProvider</code>.</p> <pre><code>// /App.js\nimport React from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport HomePage from './pages/HomePage';\n\nconst queryClient = new QueryClient();\n\nconst App = () =&gt; {\n    return (\n        &lt;QueryClientProvider client={queryClient}&gt;\n            &lt;HomePage /&gt;\n        &lt;/QueryClientProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> Summary of Key Concepts <ul> <li>Axios is used to handle the actual HTTP requests (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</li> <li>TanStack Query manages the state of the data, caching, and refetching automatically.</li> <li>Custom hooks (e.g., <code>useGetPosts</code>, <code>useCreatePost</code>) encapsulate the logic for interacting with TanStack Query, making it reusable and easy to integrate across the app.</li> <li>The app structure is organized to keep API logic, components, and hooks separate for better maintainability.</li> </ul> <p>This flat folder structure makes it easy to scale the app while keeping things organized and simple.</p> Example CodeExplanation <pre><code>import React from \"react\";\nimport axios from \"axios\";\nimport { useQuery } from \"@tanstack/react-query\";\n\n// Define a function to fetch posts using Axios\nconst fetchPosts = async () =&gt; {\n    const response = await axios.get(\n        \"https://jsonplaceholder.typicode.com/posts\"\n    );\n    return response.data; // return the data from the response\n};\n\nconst Posts = () =&gt; {\n    // Use useQuery hook to fetch posts\n    const { data, error, isLoading } = useQuery({\n        queryKey: [\"posts\"], // key to cache the query results\n        queryFn: fetchPosts, // function to fetch the data\n    });\n\n    // Show loading state\n    if (isLoading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n\n    // Show error state if there is any\n    if (error) {\n        return &lt;div&gt;An error occurred: {error.message}&lt;/div&gt;;\n    }\n\n    // Render the posts\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data.map((post) =&gt; (\n                &lt;li key={post.id}&gt;\n                    &lt;h3&gt;{post.title}&lt;/h3&gt;\n                    &lt;p&gt;{post.body}&lt;/p&gt;\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;TanStack Query with Axios Example&lt;/h1&gt;\n            &lt;Posts /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ul> <li> <p><code>fetchPosts</code> function: This function uses Axios to make a GET request to the JSONPlaceholder API (<code>https://jsonplaceholder.typicode.com/posts</code>) and returns the <code>data</code> part of the response.</p> </li> <li> <p><code>useQuery</code> hook: The hook is used to fetch data. It takes an object with:</p> <ul> <li><code>queryKey</code>: An array that uniquely identifies this query. This is used for caching and invalidating the query.</li> <li><code>queryFn</code>: The function that performs the data fetching (<code>fetchPosts</code> in this case).</li> </ul> </li> <li> <p>Loading, Error, and Success Handling:</p> <ul> <li><code>isLoading</code>: If true, displays a loading state.</li> <li><code>error</code>: If there's an error, it displays the error message.</li> <li><code>data</code>: The fetched data is displayed as a list of posts.</li> </ul> </li> </ul>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#understanding-querykey-and-queryfn-in-tanstack-query-react-query","title":"Understanding <code>queryKey</code> and <code>queryFn</code> in TanStack Query (React Query)","text":"<pre><code>const { data, error, isLoading } = useQuery({\n  queryKey: [\"posts\"], // Identifies the query for caching and invalidation\n  queryFn: fetchPosts, // Function that fetches the data\n});\n</code></pre> <p>queryKey:</p> <ul> <li>The <code>queryKey</code> is a unique key used to identify and cache a query. It is passed as the first argument to the <code>useQuery</code> hook. This key helps React Query manage the data fetched for that query efficiently, by caching and refetching as necessary.</li> <li>It's commonly an array (or string) that can include multiple parameters or identifiers, which is useful for more complex queries.</li> <li>Example: <code>[\"posts\"]</code> or <code>[\"posts\", userId]</code>.</li> </ul> <p>queryFn:</p> <ul> <li>The <code>queryFn</code> is the function that is responsible for fetching data. It is the second argument to the <code>useQuery</code> hook.</li> <li>This function should return a <code>Promise</code> with the data you want to fetch.</li> <li>Example: If you are fetching posts, the <code>queryFn</code> would be a function that makes an HTTP request to get those posts.</li> </ul> Summary <ul> <li><code>queryKey</code>: A unique key used to identify and cache the query.</li> <li><code>queryFn</code>: A function that fetches the data for the query.</li> </ul> <p>Best Practice for <code>queryKey</code></p> <ul> <li>Array format is typically the best practice because it provides a consistent and easily differentiable structure for caching and query invalidation.</li> <li>String format is fine for simple queries, especially if there are no dynamic parameters.</li> <li>Object format should generally be avoided as it can cause issues with caching and invalidation, unless you explicitly need to pass an object for some reason and are confident that caching won't be an issue.</li> </ul>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#for-beginners-the-most-important-hooks-to-focus-on-are","title":"For beginners, the most important hooks to focus on are:","text":"<ul> <li><code>useState</code> \u2013 for managing local state.</li> <li><code>useEffect</code> \u2013 for side effects (data fetching, DOM updates, etc.).</li> <li><code>useContext</code> \u2013 for accessing global state/context.</li> <li><code>useRef</code> \u2013 for referencing DOM elements and persisting values across renders.</li> </ul> <p>Once you're comfortable with these, you can move on to more advanced hooks like <code>useReducer</code>, <code>useMemo</code>, and <code>useCallback</code> for more complex scenarios and performance optimizations.</p> <p>Let me know if you need any further clarifications!</p>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#as-a-beginner-with-experience-in-redux-toolkit-and-rtk-query-you-should-focus-on-mastering-these-core-tanstack-query-hooks","title":"As a beginner with experience in Redux Toolkit and RTK Query, you should focus on mastering these core <code>TanStack Query hooks</code>:","text":"<ul> <li><code>useQuery</code> for fetching data (similar to RTK Query's <code>useQuery</code>).</li> <li><code>useMutation</code> for creating, updating, or deleting data.</li> <li><code>useQueryClient</code> for managing cache and triggering invalidations or refetches.</li> <li><code>useInfiniteQuery</code> for handling paginated data.</li> <li><code>useIsFetching</code> to manage global loading states.</li> </ul> <p>These hooks will allow you to manage data fetching, mutations, and caching in your app, much like RTK Query, but with a more declarative approach to managing data fetching and caching.</p>"},{"location":"state-management/rtkquery/hooks/tanStack-query/#reference","title":"Reference","text":"<ul> <li>tanstack.com</li> <li>Query Keys</li> </ul>"},{"location":"state-management/rtkquery/official-docs/advanced/","title":"Advanced","text":""},{"location":"state-management/rtkquery/official-docs/advanced/#redux-essentials","title":"Redux Essentials","text":""},{"location":"state-management/rtkquery/official-docs/advanced/#advanced-cache-updates","title":"Advanced Cache Updates","text":""},{"location":"state-management/rtkquery/official-docs/advanced/#persisting-reactions","title":"Persisting Reactions","text":"features/api/apiSlice.ts<pre><code>export const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  tagTypes: ['Post'],\n  endpoints: builder =&gt; ({\n    // omit other endpoints\n    addReaction: builder.mutation&lt;\n      Post,\n      { postId: string; reaction: ReactionName }\n    &gt;({\n      query: ({ postId, reaction }) =&gt; ({\n        url: `posts/${postId}/reactions`,\n        method: 'POST',\n        // In a real app, we'd probably need to base this on user ID somehow\n        // so that a user can't do the same reaction more than once\n        body: { reaction }\n      }),\n      invalidatesTags: (result, error, arg) =&gt; [\n        { type: 'Post', id: arg.postId }\n      ]\n    })\n  })\n})\n\nexport const {\n  useGetPostsQuery,\n  useGetPostQuery,\n  useAddNewPostMutation,\n  useEditPostMutation,\n  useAddReactionMutation\n} = apiSlice\n</code></pre>"},{"location":"state-management/rtkquery/official-docs/advanced/#optimistic-updates-for-reactions","title":"Optimistic Updates for Reactions","text":"<p>For a small update like adding a reaction, we probably don't need to re-fetch the entire list of posts. Instead, we could try just updating the already-cached data on the client to match what we expect to have happen on the server. Also, if we update the cache immediately, the user gets instant feedback when they click the button instead of having to wait for the response to come back. This approach of updating client state right away is called an \"optimistic update\", and it's a common pattern in web apps.</p> <p>RTK Query includes utilities to update the client-side cache directly. This can be combined with RTK Query's \"request lifecycle\" methods to implement optimistic updates.</p>"},{"location":"state-management/rtkquery/official-docs/advanced/#cache-update-utilities","title":"Cache Update Utilities","text":"<p>API slices have some additional methods attached, under api.util. This includes thunks for modifying the cache: <code>upsertQueryData</code> to add or replace a cache entry, and <code>updateQueryData</code> to modify a cache entry. Since these are thunks, they can be used anywhere you have access to dispatch.</p>"},{"location":"state-management/rtkquery/official-docs/advanced/#the-onquerystarted-lifecycle","title":"The onQueryStarted Lifecycle","text":"<p>The first lifecycle method we'll look at is onQueryStarted. This option is available for both queries and mutations.</p> <p>If provided, <code>onQueryStarted</code> will be called every time a new request goes out. This gives us a place to run additional logic in response to the request.</p> <p>Similar to async thunks and listener effects, the <code>onQueryStarted</code> callback receives the query <code>arg</code> value from the request as its first argument, and a <code>lifecycleApi</code> object as the second argument. <code>lifecycleApi</code> includes the same <code>{dispatch, getState, extra, requestId}</code> values as <code>createAsyncThunk</code>. It also has a couple additional fields that are unique to this lifecycle. The most important one is <code>lifecycleApi.queryFulfilled</code>, a Promise that will resolve when the request returns, and either fulfill or reject based on the request.</p>"},{"location":"state-management/rtkquery/official-docs/advanced/#implementing-optimistic-updates","title":"Implementing Optimistic Updates","text":"<p>We can use the update utilities inside of the <code>onQueryStarted</code> lifecycle to implement either \"optimistic\" updates (updating the cache before the request is finished), or \"pessimistic\" updates (updating the cache after the request is finished).</p> <p>We can implement the optimistic update by finding the specific <code>Post</code> entry in the <code>getPosts</code> cache, and \"mutating\" it to increment the reaction counter. We also may have a second copy of the same conceptual individual <code>Post</code> object in the <code>getPost</code> cache for that post ID also, so we need to update that cache entry if it exists as well.</p> <p>By default, we expect that the request will succeed. In case the request fails, we can await <code>lifecycleApi.queryFulfilled</code>, catch a failure, and undo the patch changes to revert the optimistic update.</p> <pre><code>export const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  tagTypes: ['Post'],\n  endpoints: builder =&gt; ({\n    // omit other endpoints\n\n    addReaction: builder.mutation&lt;\n      Post,\n      { postId: string; reaction: ReactionName }\n    &gt;({\n      query: ({ postId, reaction }) =&gt; ({\n        url: `posts/${postId}/reactions`,\n        method: 'POST',\n        // In a real app, we'd probably need to base this on user ID somehow\n        // so that a user can't do the same reaction more than once\n        body: { reaction }\n      }),\n      // The `invalidatesTags` line has been removed,\n      // since we're now doing optimistic updates\n      async onQueryStarted({ postId, reaction }, lifecycleApi) {\n        // `updateQueryData` requires the endpoint name and cache key arguments,\n        // so it knows which piece of cache state to update\n        const getPostsPatchResult = lifecycleApi.dispatch(\n          apiSlice.util.updateQueryData('getPosts', undefined, draft =&gt; {\n            // The `draft` is Immer-wrapped and can be \"mutated\" like in createSlice\n            const post = draft.find(post =&gt; post.id === postId)\n            if (post) {\n              post.reactions[reaction]++\n            }\n          })\n        )\n\n        // We also have another copy of the same data in the `getPost` cache\n        // entry for this post ID, so we need to update that as well\n        const getPostPatchResult = lifecycleApi.dispatch(\n          apiSlice.util.updateQueryData('getPost', postId, draft =&gt; {\n            draft.reactions[reaction]++\n          })\n        )\n\n        try {\n          await lifecycleApi.queryFulfilled\n        } catch {\n          getPostsPatchResult.undo()\n          getPostPatchResult.undo()\n        }\n      }\n    })\n  })\n})\n</code></pre> <p>For this case, we've also removed the <code>invalidatesTags</code> line we'd just added, since we don't want to refetch the posts when we click a reaction button.</p> <p>Now, if we click several times on a reaction button quickly, we should see the number increment in the UI each time. If we look at the Network tab, we'll also see each individual request go out to the server as well.</p> <p>Sometimes mutation requests come back with meaningful data in the server response, such as a final item ID that should replace a temporary client-side ID, or other related data. If we did the <code>const res = await lifecycleApi.queryFulfilled</code> first, we could then use the data from the response after that to apply cache updates as a \"pessimistic\" update.</p>"},{"location":"state-management/rtkquery/official-docs/advanced/#streaming-updates-for-notifications","title":"Streaming Updates for Notifications","text":"<p>We've already seen the <code>onQueryStarted</code> lifecycle that let us implement optimistic (or pessimistic) updates. Additionally, RTK Query provides an onCacheEntryAdded endpoint lifecycle handler, which is a good place to implement streaming updates.</p>"},{"location":"state-management/rtkquery/official-docs/advanced/#the-oncacheentryadded-lifecycle","title":"The onCacheEntryAdded Lifecycle","text":"<p>Like <code>onQueryStarted</code>, the onCacheEntryAdded lifecycle method is available for both <code>queries</code> and <code>mutations</code>.</p> <p><code>onCacheEntryAdded</code> will be called any time a new cache entry (endpoint + serialized query arg) is added to the cache. This means it will run less often than <code>onQueryStarted</code>, which runs whenever a request happens.</p> <p>Similar to <code>onQueryStarted</code>, <code>onCacheEntryAdded</code> receives two parameters. The first is the usual query args value. The second is a slightly different <code>lifecycleApi</code> that has <code>{dispatch, getState, extra, requestId}</code>, as well as an <code>updateCachedData</code> util, an alternate form of <code>api.util.updateCachedData</code> that already knows the right endpoint name and query args to use and does the dispatching for you.</p> There's also two additional Promises that can be waited on: <ul> <li>cacheDataLoaded: resolves with the first cached value received, and is typically used to wait for an actual value to be in the cache before doing more logic</li> <li>cacheEntryRemoved: resolves when this cache entry is removed (ie, there are no more subscribers and the cache entry has been garbage-collected)</li> </ul> <p>As long as 1+ subscribers for the data are still active, the cache entry is kept alive. When the number of subscribers goes to 0 and the cache lifetime timer expires, the cache entry will be removed, and <code>cacheEntryRemoved</code> will resolve.</p> <p></p>"},{"location":"state-management/rtkquery/official-docs/advanced/#alternative-selector-libraries","title":"Alternative Selector Libraries","text":""},{"location":"state-management/rtkquery/official-docs/basic/","title":"Basic","text":""},{"location":"state-management/rtkquery/official-docs/basic/#rtk-query-overview-reduxjs","title":"RTK Query Overview: redux.js","text":"<p>Over time, the React community has come to realize that \"data fetching and caching\" is really a different set of concerns than \"state management\".</p>"},{"location":"state-management/rtkquery/official-docs/basic/#rtk-query-differences","title":"RTK Query Differences","text":"<p>RTK Query takes inspiration from other tools that have pioneered solutions for data fetching, like Apollo Client, React Query, Urql, and SWR, but adds a unique approach to its API design:</p> <ul> <li>The data fetching and caching logic is built on top of Redux Toolkit's <code>createSlice</code> and <code>createAsyncThunk</code> APIs</li> <li>Because Redux Toolkit is UI-agnostic, RTK Query's functionality can be used with any UI layer like Angular, Vue, or vanilla JS, not just with React</li> <li>Finally, RTK Query is completely written in TypeScript, and is designed to provide an excellent TS usage experience</li> </ul>"},{"location":"state-management/rtkquery/official-docs/basic/#whats-included","title":"What's included","text":""},{"location":"state-management/rtkquery/official-docs/basic/#apis","title":"APIs","text":"<p>RTK Query is included within the installation of the core Redux Toolkit package. It is available via either of the two entry points below:</p> <pre><code>// UI-agnostic entry point with the core logic\nimport { createApi } from \"@reduxjs/toolkit/query\";\n\n// React-specific entry point that automatically generates\n// hooks corresponding to the defined endpoints\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\n</code></pre> <p>RTK Query primarily consists of two APIs:</p> <ul> <li><code>createApi()</code>: The core of RTK Query's functionality. It allows you to define a set of endpoints describe how to retrieve data from a series of endpoints, including configuration of how to fetch and transform that data. In most cases, you should use this once per app, with \"one API slice per base URL\" as a rule of thumb.</li> <li><code>fetchBaseQuery()</code>: A small wrapper around <code>fetch</code> that aims to simplify HTTP requests. RTK Query can be used to cache the result of any async request, but since HTTP requests are the most common use case, <code>fetchBaseQuery</code> provides HTTP support out of the box.</li> </ul>"},{"location":"state-management/rtkquery/official-docs/basic/#thinking-in-rtk-query-caching","title":"Thinking in RTK Query Caching","text":"<p>However, when you use RTK Query, there is a mindset shift that happens. We're no longer thinking about \"managing state\" per se. Instead, we now think about \"managing cached data\". Rather than trying to write reducers ourselves, we're now going to focus on defining \"where is this data coming from?\", \"how should this update be sent?\", \"when should this cached data be re-fetched?\", and \"how should the cached data be updated?\". How that data gets fetched, stored, and retrieved becomes implementation details we no longer have to worry about.</p>"},{"location":"state-management/rtkquery/official-docs/basic/#setting-up-rtk-query","title":"Setting Up RTK Query","text":""},{"location":"state-management/rtkquery/official-docs/basic/#defining-an-api-slice","title":"Defining an API Slice","text":"<p>With RTK Query, the logic for managing cached data is centralized into a single \"API slice\" per application. In much the same way that you have a single Redux store per app, we now have a single slice for all our cached data.</p> features/api/apiSlice.ts<pre><code>// Import the RTK Query methods from the React-specific entry point\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// Use the `Post` type we've already defined in `postsSlice`,\n// and then re-export it for ease of use\nimport type { Post } from '@/features/posts/postsSlice'\nexport type { Post }\n\n// Define our single API slice object\nexport const apiSlice = createApi({\n  // The cache reducer expects to be added at `state.api` (already default - this is optional)\n  reducerPath: 'api',\n  // All of our requests will have URLs starting with '/fakeApi'\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  // The \"endpoints\" represent operations and requests for this server\n  endpoints: builder =&gt; ({\n    // The `getPosts` endpoint is a \"query\" operation that returns data.\n    // The return value is a `Post[]` array, and it takes no arguments.\n    getPosts: builder.query&lt;Post[], void&gt;({\n      // The URL for the request is '/fakeApi/posts'\n      query: () =&gt; '/posts'\n    })\n  })\n})\n\n// Export the auto-generated hook for the `getPosts` query endpoint\nexport const { useGetPostsQuery } = apiSlice\n</code></pre> <p>RTK Query's functionality is based on a single method, called <code>createApi</code>. All of the Redux Toolkit APIs we've seen so far are UI-agnostic, and could be used with any UI layer. The RTK Query core logic is the same way. However, RTK Query also includes a React-specific version of <code>createApi</code>, and since we're using RTK and React together, we need to use that to take advantage of RTK's React integration. So, we import from <code>'@reduxjs/toolkit/query/react'</code> specifically.</p>"},{"location":"state-management/rtkquery/official-docs/basic/#api-slice-parameters","title":"API Slice Parameters","text":"<p>When we call <code>createApi</code>, there are two fields that are required:</p> <ul> <li>baseQuery: a function that knows how to fetch data from the server. RTK Query includes <code>fetchBaseQuery</code>, a small wrapper around the standard <code>fetch()</code> function that handles typical processing of HTTP requests and responses. When we create a <code>fetchBaseQuery</code> instance, we can pass in the base URL of all future requests, as well as override behavior such as modifying request headers. You can create custom base queries to customize behavior like error handling and auth.</li> <li>endpoints: a set of operations that we've defined for interacting with this server. Endpoints can be queries, which return data for caching, or mutations, which send an update to the server. The endpoints are defined using a callback function that accepts a <code>builder</code> parameter and returns an object containing endpoint definitions created with <code>builder.query()</code> and <code>builder.mutation()</code>.</li> </ul> <p><code>createApi</code> also accepts a reducerPath field, which defines the expected top-level state slice field for the generated reducer.</p> Note <p>If you forget to add the reducer to the store, or attach it at a different key than what is specified in <code>reducerPath</code>, RTKQ will log an error to let you know this needs to be fixed.</p>"},{"location":"state-management/rtkquery/official-docs/basic/#exporting-api-slices-and-hooks","title":"Exporting API Slices and Hooks","text":"<p>Finally, look carefully at the last line of this file. Where's this useGetPostsQuery value coming from?</p> <p>RTK Query's React integration will automatically generate React hooks for every endpoint we define! T</p> <p>The hooks are automatically named based on a standard convention:</p> <ul> <li><code>use</code>, the normal prefix for any React hook</li> <li>The name of the endpoint, capitalized</li> <li>The type of the endpoint, Query or Mutation</li> </ul> <p>In this case, our endpoint is <code>getPosts</code> and it's a query endpoint, so the generated hook is useGetPostsQuery.</p>"},{"location":"state-management/rtkquery/official-docs/basic/#configuring-the-store","title":"Configuring the Store","text":"<pre><code>import { configureStore } from \"@reduxjs/toolkit\";\n\nimport { apiSlice } from \"@/features/api/apiSlice\";\nimport authReducer from \"@/features/auth/authSlice\";\nimport postsReducer from \"@/features/posts/postsSlice\";\nimport usersReducer from \"@/features/users/usersSlice\";\nimport notificationsReducer from \"@/features/notifications/notificationsSlice\";\n\nimport { listenerMiddleware } from \"./listenerMiddleware\";\n\nexport const store = configureStore({\n  // Pass in the root reducer setup as the `reducer` argument\n  reducer: {\n    auth: authReducer,\n    posts: postsReducer,\n    users: usersReducer,\n    notifications: notificationsReducer,\n    [apiSlice.reducerPath]: apiSlice.reducer,\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware()\n      .prepend(listenerMiddleware.middleware)\n      .concat(apiSlice.middleware),\n});\n</code></pre> <p>We can reuse the <code>apiSlice.reducerPath</code> field as a computed key in the <code>reducer</code> parameter, to ensure that the caching reducer is added in the right place.</p>"},{"location":"state-management/rtkquery/official-docs/basic/#query-hook-result-objects","title":"Query Hook Result Objects","text":"<p>Each generated query hook returns a \"result\" object containing several fields, including:</p> <ul> <li><code>data</code>: the actual response contents from the server for the most recent successful cache entry data. This field will be <code>undefined</code> until the response is received.</li> <li><code>currentData</code>: response contents</li> <li><code>isLoading</code>: boolean</li> <li><code>isFetching</code>: boolean</li> <li><code>isSuccess</code>: boolean</li> <li><code>isError</code>: boolean</li> <li><code>error</code>: a serialized error object</li> </ul>"},{"location":"state-management/rtkquery/official-docs/basic/#refreshing-cached-data","title":"Refreshing Cached Data","text":""},{"location":"state-management/rtkquery/official-docs/basic/#refetching-posts-manually","title":"Refetching Posts Manually","text":"<p>The first option is to manually force RTK Query to refetch data for a given endpoint. This isn't the approach you'd use in a real app, but we'll try it now as an intermediate step.</p> <p>Query hook result objects include a <code>refetch</code> function that we can call to force a refetch. We can temporarily add a \"Refetch Posts\" button to <code>&lt;PostsList&gt;</code> and click that after adding a new post:</p> <pre><code>export const PostsList = () =&gt; {\n  const {\n    data: posts = [],\n    isLoading,\n    isSuccess,\n    isError,\n    error,\n    refetch, //\n  } = useGetPostsQuery();\n\n  // omit content\n\n  return (\n    &lt;section className=\"posts-list\"&gt;\n      &lt;h2&gt;Posts&lt;/h2&gt;\n      &lt;button onClick={refetch}&gt;Refetch Posts&lt;/button&gt;\n      {content}\n    &lt;/section&gt;\n  );\n};\n</code></pre>"},{"location":"state-management/rtkquery/official-docs/basic/#automatic-refreshing-with-cache-invalidation","title":"Automatic Refreshing with Cache Invalidation","text":"<p>Manually forcing a refetch of data is occasionally necessary depending on user behavior, but definitely not a good solution for normal usage.</p> <p>We know that our \"server\" has a complete list of all posts, including the one we just added. Ideally, we want to have our app automatically refetch the updated list of posts as soon as the mutation request has completed. That way we know our client-side cached data is in sync with what the server has.</p> <p>RTK Query lets us define relationships between queries and mutations to enable automatic data refetching, using \"tags\". A \"tag\" is a string or small object that lets you give identifiers to certain types of data, and \"invalidate\" portions of the cache. When a cache tag is invalidated, RTK Query will automatically refetch the endpoints that were marked with that tag.</p> <p>Basic tag usage requires adding three pieces of information to our API slice:</p> <ul> <li>A root <code>tagTypes</code> field in the API slice object, declaring an array of string tag names for data types such as <code>'Post'</code></li> <li>A <code>providesTags</code> array in query endpoints, listing a set of tags describing the data in that query</li> <li>An <code>invalidatesTags</code> array in mutation endpoints, listing a set of tags that are invalidated every time that mutation runs</li> </ul> <p>We can add a single tag called <code>'Post'</code> to our API slice that will let us automatically refetch our <code>getPosts</code> endpoint any time we add a new post:</p> features/api/apiSlice.ts<pre><code>export const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  tagTypes: ['Post'],\n  endpoints: builder =&gt; ({\n    getPosts: builder.query&lt;Post[], void&gt;({\n      query: () =&gt; '/posts',\n      providesTags: ['Post']\n    }),\n    getPost: builder.query&lt;Post, string&gt;({\n      query: postId =&gt; `/posts/${postId}`\n    }),\n    addNewPost: builder.mutation&lt;Post, NewPost&gt;({\n      query: initialPost =&gt; ({\n        url: '/posts',\n        method: 'POST',\n        body: initialPost\n      }),\n      invalidatesTags: ['Post']\n    })\n  })\n})\n</code></pre> <p>That's all we need! Now, if we click \"Save Post\", you should see the <code>&lt;PostsList&gt;</code> component automatically gray out after a couple seconds, and then rerender with the newly added post at the top.</p> <p>Note that there's nothing special about the literal string <code>'Post'</code> here. We could have called it <code>'Fred'</code>, <code>'qwerty'</code>, or anything else. It just needs to be the same string in each field, so that RTK Query knows \"when this mutation happens, invalidate all endpoints that have that same tag string listed\".</p>"},{"location":"state-management/rtkquery/official-docs/basic/#reference","title":"Reference","text":"<ul> <li>RTK Query, redux.js.org</li> <li>RTK Query, redux-toolkit.js.org</li> </ul>"},{"location":"state-management/webstorage/intro/","title":"Intro","text":""},{"location":"state-management/webstorage/intro/#overview","title":"Overview","text":"<p>In web development, there are primarily two types of web storage: LocalStorage and SessionStorage. Both are part of the Web Storage API and provide a way to store data in a user's browser, but they serve different purposes and have different characteristics.</p>"},{"location":"state-management/webstorage/intro/#1-localstorage","title":"1. LocalStorage","text":"<ul> <li>Persistence: Data stored in LocalStorage remains until explicitly deleted by the user or the application. It does not expire.</li> <li>Scope: Data is accessible across multiple tabs and windows within the same origin (protocol, domain, port).</li> <li>Capacity: Typically allows for around 5 to 10 MB of storage.</li> <li>Use Cases: Suitable for storing user preferences, themes, or any data that should persist beyond a single session.</li> </ul> ExampleReact BasicReact Advanced <pre><code>// Set an item\nlocalStorage.setItem('username', 'JohnDoe');\n\n// Get an item\nconst username = localStorage.getItem('username');\n\n// Remove an item\nlocalStorage.removeItem('username');\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [username, setUsername] = useState('');\n\n    // Load username from LocalStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedUsername = localStorage.getItem('username');\n        if (savedUsername) {\n            setUsername(savedUsername);\n        }\n    }, []);\n\n    // Update LocalStorage whenever the username changes\n    const handleUsernameChange = (event) =&gt; {\n        const newUsername = event.target.value;\n        setUsername(newUsername);\n        localStorage.setItem('username', newUsername); // Save to LocalStorage\n    };\n\n    // Clear the username from LocalStorage\n    const clearUsername = () =&gt; {\n        setUsername('');\n        localStorage.removeItem('username'); // Remove from LocalStorage\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;LocalStorage Example&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={handleUsernameChange}\n                placeholder=\"Enter your username\"\n            /&gt;\n            &lt;button onClick={clearUsername}&gt;Clear Username&lt;/button&gt;\n            &lt;p&gt;Current Username: {username || 'No username set'}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [tasks, setTasks] = useState([]);\n    const [taskInput, setTaskInput] = useState('');\n\n    // Load tasks from LocalStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedTasks = JSON.parse(localStorage.getItem('tasks'));\n        if (savedTasks) {\n            setTasks(savedTasks);\n        }\n    }, []);\n\n    // Update LocalStorage whenever tasks change\n    useEffect(() =&gt; {\n        localStorage.setItem('tasks', JSON.stringify(tasks));\n    }, [tasks]);\n\n    const handleInputChange = (event) =&gt; {\n        setTaskInput(event.target.value);\n    };\n\n    const addTask = () =&gt; {\n        if (taskInput.trim() !== '') {\n            const newTask = {\n                id: Date.now(),\n                text: taskInput,\n                completed: false,\n            };\n            setTasks([...tasks, newTask]);\n            setTaskInput('');\n        }\n    };\n\n    const toggleTaskCompletion = (taskId) =&gt; {\n        const updatedTasks = tasks.map((task) =&gt;\n            task.id === taskId ? { ...task, completed: !task.completed } : task\n        );\n        setTasks(updatedTasks);\n    };\n\n    const removeTask = (taskId) =&gt; {\n        const updatedTasks = tasks.filter((task) =&gt; task.id !== taskId);\n        setTasks(updatedTasks);\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;To-Do List&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={taskInput}\n                onChange={handleInputChange}\n                placeholder=\"Add a new task\"\n            /&gt;\n            &lt;button onClick={addTask}&gt;Add Task&lt;/button&gt;\n\n            &lt;ul&gt;\n                {tasks.map((task) =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        &lt;input\n                            type=\"checkbox\"\n                            checked={task.completed}\n                            onChange={() =&gt; toggleTaskCompletion(task.id)}\n                        /&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; removeTask(task.id)}&gt;Remove&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"state-management/webstorage/intro/#2-sessionstorage","title":"2. SessionStorage","text":"<ul> <li>Persistence: Data stored in SessionStorage is only available for the duration of the page session. It is cleared when the page session ends, which occurs when the tab or window is closed.</li> <li>Scope: Data is limited to a single tab or window. If you open the same page in another tab or window, a new SessionStorage is created.</li> <li>Capacity: Similar storage limits to LocalStorage (around 5 to 10 MB).</li> <li>Use Cases: Ideal for temporary data that should only last as long as the user is on the page, such as form data or session-specific information.</li> </ul> ExampleReact BasicReact Advanced <pre><code>// Set an item\nsessionStorage.setItem('sessionId', 'abc123');\n\n// Get an item\nconst sessionId = sessionStorage.getItem('sessionId');\n\n// Remove an item\nsessionStorage.removeItem('sessionId');\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [username, setUsername] = useState('');\n\n    // Load username from SessionStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedUsername = sessionStorage.getItem('username');\n        if (savedUsername) {\n            setUsername(savedUsername);\n        }\n    }, []);\n\n    // Update SessionStorage whenever the username changes\n    const handleInputChange = (event) =&gt; {\n        const newUsername = event.target.value;\n        setUsername(newUsername);\n        sessionStorage.setItem('username', newUsername); // Save to SessionStorage\n    };\n\n    const clearUsername = () =&gt; {\n        setUsername('');\n        sessionStorage.removeItem('username'); // Remove from SessionStorage\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;SessionStorage Example&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={handleInputChange}\n                placeholder=\"Enter your username\"\n            /&gt;\n            &lt;button onClick={clearUsername}&gt;Clear Username&lt;/button&gt;\n            &lt;p&gt;Current Username: {username || 'No username set'}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [tasks, setTasks] = useState([]);\n    const [taskInput, setTaskInput] = useState('');\n\n    // Load tasks from SessionStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedTasks = JSON.parse(sessionStorage.getItem('tasks'));\n        if (savedTasks) {\n            setTasks(savedTasks);\n        }\n    }, []);\n\n    // Update SessionStorage whenever tasks change\n    useEffect(() =&gt; {\n        sessionStorage.setItem('tasks', JSON.stringify(tasks));\n    }, [tasks]);\n\n    const handleInputChange = (event) =&gt; {\n        setTaskInput(event.target.value);\n    };\n\n    const addTask = () =&gt; {\n        if (taskInput.trim() !== '') {\n            const newTask = {\n                id: Date.now(),\n                text: taskInput,\n                completed: false,\n            };\n            setTasks([...tasks, newTask]);\n            setTaskInput('');\n        }\n    };\n\n    const toggleTaskCompletion = (taskId) =&gt; {\n        const updatedTasks = tasks.map((task) =&gt;\n            task.id === taskId ? { ...task, completed: !task.completed } : task\n        );\n        setTasks(updatedTasks);\n    };\n\n    const removeTask = (taskId) =&gt; {\n        const updatedTasks = tasks.filter((task) =&gt; task.id !== taskId);\n        setTasks(updatedTasks);\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;To-Do List with SessionStorage&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={taskInput}\n                onChange={handleInputChange}\n                placeholder=\"Add a new task\"\n            /&gt;\n            &lt;button onClick={addTask}&gt;Add Task&lt;/button&gt;\n\n            &lt;ul&gt;\n                {tasks.map((task) =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        &lt;input\n                            type=\"checkbox\"\n                            checked={task.completed}\n                            onChange={() =&gt; toggleTaskCompletion(task.id)}\n                        /&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; removeTask(task.id)}&gt;Remove&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"state-management/webstorage/intro/#key-differences","title":"Key Differences","text":"Feature LocalStorage SessionStorage <code>Persistence</code> Data persists indefinitely Data persists for the session <code>Scope</code> Accessible across tabs/windows Limited to the specific tab/window <code>Use Cases</code> Delete resource Temporary data, form state"},{"location":"state-management/webstorage/intro/#conclusion","title":"Conclusion","text":"<p>Both LocalStorage and SessionStorage are useful for client-side data storage, but they cater to different needs. Choose LocalStorage for long-term data retention and SessionStorage for temporary, session-specific data.</p>"},{"location":"state-management/webstorage/token/","title":"Token","text":""},{"location":"state-management/webstorage/token/#overview","title":"Overview","text":"<p>how to save the token from the api response. and where to save in localstorage or in seession storage.</p> Storing Tokens: LocalStorage vs. SessionStorage <ol> <li> <p>LocalStorage:</p> <ul> <li><code>Persistence</code>: Data persists even after the browser is closed.</li> <li><code>Use Case</code>: Suitable for long-lived tokens (e.g., refresh tokens) or when the user is expected to remain logged in across sessions.</li> <li><code>Security Concern</code>: Vulnerable to XSS attacks, so ensure you validate and sanitize inputs.</li> </ul> </li> <li> <p>SessionStorage:</p> <ul> <li><code>Persistence</code>: Data is cleared when the tab or browser window is closed.</li> <li><code>Use Case</code>: Suitable for short-lived tokens (e.g., access tokens) when you don't want the user to remain logged in after closing the tab.</li> <li><code>Security Concern</code>: Also vulnerable to XSS attacks.</li> </ul> </li> </ol>"},{"location":"state-management/webstorage/token/#storing-a-token-example","title":"Storing a Token Example","text":"<pre><code>// src/App.js\nimport React, { useState } from 'react';\n\nconst App = () =&gt; {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n\n  const handleLogin = async (event) =&gt; {\n    event.preventDefault();\n    setError('');\n\n    try {\n      const response = await fetch('https://api.example.com/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ username, password }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Login failed');\n      }\n\n      const data = await response.json();\n      const token = data.token; // Assuming the token is in the response body\n\n      // Choose one based on your use case:\n      // LocalStorage for long-lived tokens\n      localStorage.setItem('authToken', token);\n\n      // Or SessionStorage for short-lived tokens\n      // sessionStorage.setItem('authToken', token);\n\n      alert('Login successful!');\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Login&lt;/h1&gt;\n      &lt;form onSubmit={handleLogin}&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Username\"\n          value={username}\n          onChange={(e) =&gt; setUsername(e.target.value)}\n          required\n        /&gt;\n        &lt;input\n          type=\"password\"\n          placeholder=\"Password\"\n          value={password}\n          onChange={(e) =&gt; setPassword(e.target.value)}\n          required\n        /&gt;\n        &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n      &lt;/form&gt;\n      {error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> Security Considerations <ul> <li>XSS Attacks: Be cautious about storing sensitive information in LocalStorage or SessionStorage, as both are accessible through JavaScript and vulnerable to XSS attacks.</li> <li>Token Expiration: Consider implementing token expiration and refreshing mechanisms to enhance security.</li> <li>HTTPS: Always use HTTPS to protect data in transit.</li> </ul>"},{"location":"tools/animations/","title":"Animations","text":""},{"location":"tools/animations/#animations","title":"Animations","text":"<p>Animation and effects \u2014 React Spring, Framer Motion, Remotion, React Move, GreenSock Animation Platform, Popmotion, React AOS, react-tsparticles, Lottie, and React AnimaKit</p> Tip <ul> <li>Framer Motion: Ideal for simple, declarative animations. It\u2019s fast and easy to use with AntD, especially for UI transitions.</li> <li>React Spring: Provides more flexibility and control, useful if you need advanced or physics-based animations.</li> <li>GSAP: Best for complex, high-performance animations. It is perfect when you need precise control over every detail of your animations.</li> </ul> <p>You can use each of these libraries with AntD depending on the level of complexity and control you need. For most UI transitions, Framer Motion is a great starting point. If you need more advanced control, React Spring is a powerful choice. GSAP should be used when working with intricate animations and ensuring the best performance, especially for large-scale applications.</p> Installation<pre><code>npm install framer-motion antd\n</code></pre> Framer Motion + AntD<pre><code>import React from \"react\";\nimport { Button } from \"antd\";\nimport { motion } from \"framer-motion\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;motion.div\n        initial={{ opacity: 0 }} // Initial state\n        animate={{ opacity: 1 }} // End state (fade in)\n        transition={{ duration: 1 }} // Duration of animation\n      &gt;\n        &lt;Button type=\"primary\"&gt;Click Me&lt;/Button&gt;\n      &lt;/motion.div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> Installation<pre><code>npm install @react-spring/web antd\n</code></pre> React Spring + AntD<pre><code>import React from \"react\";\nimport { Button } from \"antd\";\nimport { useSpring, animated } from \"@react-spring/web\";\n\nconst App = () =&gt; {\n  const props = useSpring({\n    opacity: 1,\n    from: { opacity: 0 }, // Start with opacity 0\n    config: { duration: 1000 }, // Duration of the fade-in\n  });\n\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;animated.div style={props}&gt;\n        &lt;Button type=\"primary\"&gt;Click Me&lt;/Button&gt;\n      &lt;/animated.div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> Installation<pre><code>npm install gsap antd\n</code></pre> GSAP + AntD<pre><code>import React, { useEffect } from \"react\";\nimport { Button } from \"antd\";\nimport { gsap } from \"gsap\";\n\nconst App = () =&gt; {\n  useEffect(() =&gt; {\n    gsap.fromTo(\n      \".animate-btn\",\n      { opacity: 0 }, // Start state\n      { opacity: 1, duration: 1 } // End state (fade-in with duration)\n    );\n  }, []);\n\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;Button className=\"animate-btn\" type=\"primary\"&gt;\n        Click Me\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"tools/barrel/","title":"Barrel","text":""},{"location":"tools/barrel/#what-is-a-barrel","title":"What is a Barrel?","text":"<p>A barrel in programming is a file (usually named <code>index.js</code> or <code>index.ts</code>) that re-exports all exports from multiple files in the same directory. It acts as a single entry point for importing from that directory.</p>"},{"location":"tools/barrel/#where-does-the-term-come-from","title":"Where Does the Term Come From?","text":"<p>The term \"barrel\" originates from the idea that it contains and organizes multiple exports like a container. The concept is not tied to any specific language or framework\u2014it is a general software development practice. However, it is especially useful in modular systems like JavaScript or TypeScript, where files and modules can proliferate quickly.</p>"},{"location":"tools/barrel/#why-use-barrels","title":"Why Use Barrels?","text":"<ol> <li> <p>Simplifies Import Paths: Without a barrel:</p> <pre><code>import Header from \"./components/Header/Header\";\nimport Footer from \"./components/Footer/Footer\";\n</code></pre> <p>With a barrel:</p> <pre><code>import { Header, Footer } from \"./components\";\n</code></pre> </li> <li> <p>Improves Maintainability:</p> <ul> <li>Changes within the directory (e.g., renaming files) don\u2019t impact import paths elsewhere.</li> <li>Centralizes export management.</li> </ul> </li> <li> <p>Enhances Readability:</p> <ul> <li>Makes the codebase easier to navigate by reducing long or nested import paths.</li> </ul> </li> </ol>"},{"location":"tools/barrel/#can-we-do-it-in-react-without-typescript","title":"Can We Do It in React Without TypeScript?","text":"<p>Yes, barrels work perfectly in plain React with JavaScript. You don\u2019t need TypeScript to use barrels.</p> Here\u2019s how you can set it up: 1. Folder Structure:2. Create a Barrel (index.js):3. Import from the Barrel: Instead of this: <pre><code>src/\n    components/\n        Header.js\n        Footer.js\n        index.js\n</code></pre> <pre><code>export { default as Header } from './Header';\nexport { default as Footer } from './Footer';\n</code></pre> <pre><code>import Header from './components/Header';\nimport Footer from './components/Footer';\n</code></pre> <p>Do this:</p> <pre><code>import { Header, Footer } from './components';\n</code></pre>"},{"location":"tools/barrel/#notes","title":"Notes","text":"<ol> <li> <p>Barrels are Framework-Agnostic:</p> <ul> <li>They are not tied to React or TypeScript. You can use them in any JavaScript or TypeScript project.</li> </ul> </li> <li> <p>Potential Downsides:</p> <ul> <li><code>Circular Dependencies</code>: If two files in a barrel depend on each other, it can cause issues.</li> <li><code>Tree Shaking</code>: If the build tool isn't configured properly, unused exports in a barrel may end up in the final bundle. However, modern tools like Webpack, Rollup, and Vite handle this well.</li> </ul> </li> </ol> <p>Barrels are a great organizational tool and can be used in any React project, whether it's written in TypeScript or plain JavaScript!</p>"},{"location":"tools/barrel/#quesition","title":"Quesition","text":"<p>In a large React TypeScript application, the best way to import a file depends on the context and the purpose of the file (e.g., component, utility, asset). However, the following practices ensure clean, efficient, and maintainable imports:</p> <ol> <li> <p>Organize Files with Barrel Exports</p> <ul> <li> <p>What: Create <code>index.ts</code> files in folders to re-export items.</p> </li> <li> <p>Why: Simplifies import paths and reduces clutter.</p> </li> </ul> <p>Example: Folder structure:</p> <pre><code>components/\n    Header/\n        Header.tsx\n        index.ts\n    Footer/\n        Footer.tsx\n        index.ts\n</code></pre> <p><code>index.ts</code> inside each folder:</p> <pre><code>export { default as Header } from \"./Header\";\nexport { default as Footer } from \"./Footer\";\n</code></pre> <p>Import in a parent file:</p> <pre><code>import { Header, Footer } from \"./components\";\n</code></pre> </li> <li> <p>Use Absolute Imports</p> <ul> <li>What: Avoid long relative paths (<code>../../../</code>) by configuring absolute paths in your project.</li> <li>Why: Makes imports cleaner and reduces errors during refactoring.</li> </ul> <p>Setup: In <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"],\n      \"@utils/*\": [\"src/utils/*\"]\n    }\n  }\n}\n</code></pre> <p>Example Import:</p> <pre><code>import { Header } from \"@components/Header\";\n</code></pre> </li> <li> <p>Dynamic Imports for Code Splitting</p> <ul> <li>What: Dynamically load components or files to optimize performance by splitting the bundle.</li> <li>Why: Reduces initial load time by lazy-loading components only when needed.</li> </ul> <p>Example:</p> <pre><code>const LazyComponent = React.lazy(\n  () =&gt; import(\"./components/LazyComponent\")\n);\n\nfunction App() {\n  return (\n    &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/React.Suspense&gt;\n  );\n}\n</code></pre> </li> <li> <p>Centralized Typings</p> <ul> <li>What: Group reusable types/interfaces in a <code>types/</code> folder.</li> <li>Why: Prevents redundancy and keeps types manageable.</li> </ul> <p>Example:</p> <ul> <li><code>src/types/index.ts</code>:</li> </ul> <pre><code>export interface User {\n  id: number;\n  name: string;\n}\n</code></pre> <ul> <li>Import:</li> </ul> <pre><code>import { User } from \"@types\";\n</code></pre> </li> <li> <p>Asset Imports with Modules</p> <ul> <li>For styles (CSS/SCSS modules):</li> </ul> <pre><code>import styles from \"./Header.module.css\";\n</code></pre> <ul> <li>For media assets (images, videos):</li> </ul> <pre><code>import Logo from \"./assets/logo.svg\";\n</code></pre> </li> <li> <p>Consider Utility Libraries</p> <ul> <li>Use libraries like [vite-tsconfig-paths] or [module-alias] to manage imports effectively if you're not using Webpack or CRA.</li> </ul> </li> </ol> <p>By following these strategies, you'll ensure your imports remain organized, scalable, and optimized for performance in a large application.</p>"},{"location":"tools/code-maintenance/","title":"Code Maintenace","text":""},{"location":"tools/code-maintenance/#code-maintenance","title":"Code Maintenance","text":"<p>Better code maintenance with developer tooling</p> <p>In other words, use Prettier for formatting and linters for catching bugs!</p> This chapter covers <ul> <li>Writing error-free code with linting</li> <li>Increasing productivity with formatting</li> <li>Making components more robust with property constraints</li> <li>Debugging React applications using developer tools</li> </ul> <p>Code quality degrades over time \u2014 unfortunately, a hard fact of our chosen profession. As our web applications grow more complicated, maintaining code quality becomes harder and harder.(1)</p> <ol> <li> <p>This is especially the case for multideveloper projects, in which different people invariably do things in different ways, but it is also a problem for single-person projects. If you are working on the same codebase over time, you will pick up new ways of doing things, and these ways will most likely differ from the ones you followed earlier. You might open a file you haven\u2019t touched in months and suddenly wonder, \u201cWhat\u2019s going on here?\u201d</p> <p>Although good comments, documentation, and code structure are all relevant solutions to the above problems, several external tools at your disposal will improve your code quality immensely without requiring you to change your ways or even do more work.</p> <ul> <li>React in Depth, pg-86</li> </ul> </li> </ol>"},{"location":"tools/code-maintenance/#code-quality","title":"Code Quality","text":"<p>If you\u2019re joining a small development team, you will need most of this material, so you might as well get ahead of the curve by learning it now. If you\u2019re looking to become a professional React developer, this content is practically mandatory.</p> <p>I will introduce four concepts for better code maintenance and the tools that can help you obtain these new improvements:</p> <ol> <li> <p>Linting</p> <p>Linting is the process of automatically checking your source code for minor programmatic and stylistic errors. We will carry out this task with the <code>eslint</code> tool.</p> </li> <li> <p>Formatting</p> <p>Formatting is the process of automatically adhering to predefined stylistic coding standards. We will carry out this task with the <code>prettier</code> tool.</p> </li> <li> <p>Property constraints</p> <p>Property constraints are ways of making components more robust and easier to use by specifying types and ranges for valid properties. We will perform this task by using the built-in feature <code>.propTypes</code> combined with the external package <code>prop-types</code>.</p> </li> <li> <p>Debugging</p> <p>Debugging with React Developer Tools (an external browser plugin) allows you to inspect and debug your React components more effectively, helping you identify and fix problems in your application\u2019s UI and state.</p> <p>We will explore the powerful features of React Developer Tools to streamline your debugging process.</p> </li> </ol> <p></p> <p>A lot of teams are using at least one of these tools, if not all four, and these tools are often configured by default in many setups in common web development frameworks.</p> <p>In fact, some of these tools are so standard that most editors have built-in support for them and almost expect them to be used because their use has become so omnipresent in modern web development.</p> Success <p>One thing I can promise you: After you\u2019ve been using any (or all) of these tools in a React project, you may not want to go back. Things tend to get a whole lot easier with tooling</p>"},{"location":"tools/code-maintenance/#reducing-errors-with-linting","title":"Reducing errors with linting","text":"<p>Here\u2019s an inexhaustive list of the types of problems that linting can help you solve automatically:</p> <ul> <li>Potential coding errors due to disambiguation (language weirdness), such as disallowing duplicate keys in an object literal (which doesn\u2019t work as expected anyway)</li> <li>Best practices such as requiring multiple returns in the same function to return the same type of variable (which makes the result consistent)</li> <li>Stylistic rules, such as requiring newlines at the end of a file</li> </ul> <p>Code linting is becoming more and more popular, to the point where it\u2019s almost standard in most projects these days. The primary linter tool used today is ESLint.</p>"},{"location":"tools/code-maintenance/#problems-solved-by-eslint","title":"Problems solved by ESLint","text":"<p>Suppose that you work on a large team, and to make things smoother, you create a coding style guideline that you want all your developers to follow. ESLint is one of the first tools for JavaScript that allows you to codify such a style in enforceable rules, which will be applied automatically to all the code for every developer, regardless of their setup.</p>"},{"location":"tools/code-maintenance/#eslint-configurations","title":"ESLint configurations","text":"<p>ESLint consists of more than 300 rules, and you can specify how you want each rule to be enforced in your project. You can also specify the severity of violating a rule.</p> <ul> <li>ESLint rules (https://eslint.org/docs/latest/rules)\u2014Includes a list of configura-   tions included in the ESLint recommended ruleset</li> <li>Airbnb style guide (https://github.com/airbnb/javascript)\u2014Contains informa-   tion about how to use it in ESLint as well</li> </ul> How to get started using ESLint <p>To get started using ESLint, follow these three steps:</p> <ol> <li>Initialize ESLint in your project.</li> <li>Modify the default configuration file, potentially extending a predefined rule-set and/or custom rule configurations.</li> <li>Enforce the rules in your editor and your build.</li> </ol>"},{"location":"tools/code-maintenance/#configuration-file-precedence","title":"Configuration File Precedence","text":"<p>If you have multiple ESLint configuration files, ESLint prioritizes JavaScript files over TypeScript files. The order of precedence is as follows:</p> <ol> <li><code>eslint.config.js</code></li> <li><code>eslint.config.mjs</code></li> <li><code>eslint.config.cjs</code></li> <li><code>eslint.config.ts</code></li> <li><code>eslint.config.mts</code></li> <li><code>eslint.config.cts</code></li> </ol> <p>Step 1: Initialize eslint configuration</p> <pre><code>npm init @eslint/config\n</code></pre> <p>Step 2: Modify the Configuration file</p> <p>As you run the initializer in step 1, a configuration file is added to the root of your project in your desired format. This file is named <code>&lt;root&gt;/.eslintrc.{js,yml,json}</code> (with the extension following your choice of format). Note the initial dot in the filename. In this file, you can extend an existing ruleset by adding an extends property (shown here in JSON):</p> <pre><code>{\n  \"extends\": \"eslint:recommended\"\n}\n</code></pre> <p>Also, you can include rules by listing them in a rules block:</p> <pre><code>{\n  \"rules\": {\n    \"semi\": [\"error\", \"always\"],\n    \"quotes\": [\"error\", \"double\"]\n  }\n}\n</code></pre> <p>The configuration doesn\u2019t take any more work, and you don\u2019t even need to do the second part if you\u2019re happy with a predefined ruleset.</p> <p>Step 3: Enforce rules in your editor and build</p> <p>All the popular editors have a package for ESLint to enforce automatically as you write your code. If your code editor has some form of package manager for extensions, it most likely has an ESLint package.</p> <p>You can see all the integrations for both your editor and your build setup at Integrations</p>"},{"location":"tools/code-maintenance/#increasing-productivity-with-formatters","title":"Increasing productivity with formatters","text":"<p>Tabs or spaces? Come on \u2014 I know you have an opinion, so out with it! But do you wanna know a secret? I don\u2019t\u2014not anymore. Since the introduction of Prettier, a commonly used code <code>autoformatter</code>, I don\u2019t care one bit.</p> <p></p> Quote <p>Single or double quotes</p> <ul> <li>Either <code>var welcome = \"Hello\";</code></li> <li>Or <code>var welcome = 'Hello';</code></li> </ul> <p>Newline or space after function definition</p> <ul> <li>Either <code>function Component() {</code></li> <li> <p>Or</p> <pre><code>function Component()\n{\n</code></pre> </li> </ul> <p>Space inside brackets in object literals</p> <ul> <li>Either <code>{property: 1}</code></li> <li>Or <code>{ property: 1 }</code></li> </ul> <p>Space inside parentheses around function arguments</p> <ul> <li>Either <code>useState(0)</code></li> <li>Or <code>useState( 0 )</code></li> </ul> <p>Sure, none of these matters are relevant to the performance of the code \u2014 only to DX.</p> <p>As I\u2019ve stated again and again, however, DX matters \u2014 a lot. It is the difference between joining a project and being productive on day one versus spending days or even weeks getting up to speed and learning the customs of a new project (not that formatting alone takes weeks to master, of course).</p> <p><code>Figure 4.4</code> shows how Prettier can format a messy piece of code into something much more consistent.</p> <p>More important, formatting choices need to be uniform within a project. Everything else leads to pure anarchy. If one file uses tabs and another uses spaces, you\u2019re in for a long day at work!</p> <p></p>"},{"location":"tools/code-maintenance/#problems-solved-by-prettier","title":"Problems solved by Prettier","text":"<p>First, know that Prettier is an opinionated ruleset. The makers of Prettier have an opin- ion about how code should be formatted, and they aren\u2019t shy about it. How code should be formatted is constantly up for discussion, of course, but at its base, Prettier is an opinion, so your team doesn\u2019t need to have one.</p> <p>The number of problems that Prettier solves is impossible to list, but one of its best features is that you never have to worry about formatting your files again. Often, you have stylistic design choices to make as a developer.</p>"},{"location":"tools/code-maintenance/#nonstandard-rules-with-prettier-configuration","title":"Nonstandard rules with Prettier configuration","text":"<p>One of the most common ways is to format the object as JSON and store it in a file named <code>.prettierrc</code> or <code>.prettierrc.json</code> located at the root of your project.</p> <p>(Note the leading \"<code>.</code>\" in the filename, which is common for configuration files like this one.)</p> <p>Alternatively, you can create a file located at <code>&lt;root&gt;/.prettierrc.json</code> with the following contents:</p> .prettierrc.json<pre><code>{\n  \"useTabs\": true,\n  \"semicolon\": false\n}\n</code></pre> How to start using Prettier <ul> <li> <p>Step1: Add Prettier as a package</p> <pre><code>npm install --save-dev prettier\n</code></pre> </li> <li> <p>STEP 2: Optionally Add a Configuration File</p> <p>By convention, this file is saved to <code>&lt;root&gt;/.prettierrc</code> in the root of your project.</p> </li> <li> <p>STEP 3: Enforce Formatting in your Editor</p> <p>Prettier works in most text editors that allow you to install custom packages. packages</p> </li> <li> <p>Step 4: Optionally enforce formatting on code commits</p> <p>Sometimes, files are changed outside your editor, or a code merge results in files being combined in a way that violates your formatting ruleset. To make sure that you never, ever commit any code that violates your formatting ruleset, a common approach is to make sure to run your formatter on any changed files before a commit is approved.</p> <p>To do this, you use what is known as a precommit hook (which is a version control hook and not at all related to React hooks), which runs a bit of code before any commit is affected.</p> <pre><code>npm install --save-dev lint-staged\n</code></pre> <ul> <li>Precommit, Preetier Official</li> </ul> </li> </ul> <p>Getting started with Prettier normally requires up to four steps, the second and fourth of which are optional but often used:</p> <ol> <li>Add Prettier to your project as a package.</li> <li>Add a configuration file if you want to deviate from the standard configuration.</li> <li>Enforce formatting in your editor.</li> <li>Enforce formatting on code commits.</li> </ol>"},{"location":"tools/code-maintenance/#configuration-file","title":"Configuration File","text":"JSON<pre><code>{\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 4,\n  \"semi\": false,\n  \"singleQuote\": true\n}\n</code></pre> JS (ES Modules)<pre><code>// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs\n\n/**\n * @see https://prettier.io/docs/en/configuration.html\n * @type {import(\"prettier\").Config}\n */\nconst config = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n\nexport default config;\n</code></pre> Summary of the Options <ul> <li>JSON-based: <code>.prettierrc</code>, <code>.prettierrc.json</code>, <code>.prettierrc.json5</code></li> <li>YAML-based: <code>.prettierrc.yml</code>, <code>.prettierrc.yaml</code></li> <li>JavaScript-based: <code>.prettierrc.js</code>, <code>prettier.config.js</code></li> <li>TypeScript-based: <code>.prettierrc.ts</code>, <code>prettier.config.ts</code></li> <li>ES Module: <code>.prettierrc.mjs</code>, <code>prettier.config.mjs</code></li> <li>CommonJS: <code>.prettierrc.cjs</code>, <code>prettier.config.cjs</code></li> <li>TOML-based: <code>.prettierrc.toml</code></li> </ul> Which Should You Choose? <ul> <li>For most projects: <code>.prettierrc</code> (JSON or YAML) is often the best choice. It\u2019s simple, widely adopted, and doesn't require extra logic.</li> <li>For JavaScript-heavy projects: If you need flexibility and more complex configuration, go with <code>.prettierrc.js</code> or <code>prettier.config.js</code>.</li> <li>For TypeScript projects: Choose <code>.prettierrc.ts</code> if you want type safety and TypeScript integration.</li> <li>For ES Module-based projects: Use <code>.prettierrc.mjs</code> if you're using ES Modules and want to use export default.</li> <li>For Node.js CommonJS projects: Use <code>.prettierrc.cjs</code>.</li> </ul> <p>In general, unless you have specific reasons to use JavaScript, TypeScript, or ES Modules in your configuration, sticking with the .prettierrc file (either JSON or YAML) is a safe and widely accepted choice.</p>"},{"location":"tools/code-maintenance/#reference","title":"Reference","text":"<ul> <li>React in Depth, pg-85</li> <li>Prettier Configuration File</li> <li>Prettier Options</li> <li>Eslint</li> </ul>"},{"location":"tools/fsm/","title":"FSM","text":""},{"location":"tools/fsm/#finite-state-machine","title":"Finite State Machine","text":"<p>In React, FSM stands for Finite State Machine. It\u2019s a design pattern that is often used to manage state transitions in applications, and can be particularly useful when you need to manage complex state logic.</p>"},{"location":"tools/fsm/#overview","title":"Overview","text":"<p>Here\u2019s what FSM is in a nutshell:</p> <ul> <li>Finite: The number of states is limited.</li> <li>State: A condition or situation of an entity at a particular time.</li> <li>Machine: A system that moves from one state to another based on inputs, events, or triggers.</li> </ul> <p>In React, this approach can be helpful to model and control how a component behaves as it transitions between different states based on user interactions, events, or API calls.</p>"},{"location":"tools/fsm/#example-of-fsm-in-react","title":"Example of FSM in React:","text":"<p>Imagine a button that changes its state based on user interactions (like clicking to toggle between \"loading\", \"idle\", and \"success\").</p> <p>Without FSM, this might be managed with boolean flags or many <code>if/else</code> statements, but with FSM, you create a predictable system where:</p> <ol> <li>States: Define the states like <code>idle</code>, <code>loading</code>, <code>success</code>.</li> <li>Transitions: Define how you can transition from one state to another, like from <code>idle</code> to <code>loading</code> when a button is clicked.</li> <li>Events: These are the actions that trigger state changes (e.g., button click).</li> </ol>"},{"location":"tools/fsm/#example-of-fsm-implementation","title":"Example of FSM Implementation:","text":"<pre><code>import React, { useState } from \"react\";\n\nconst ButtonWithStateMachine = () =&gt; {\n  const [state, setState] = useState(\"idle\"); // Initial state is 'idle'\n\n  const handleClick = () =&gt; {\n    if (state === \"idle\") {\n      setState(\"loading\");\n      setTimeout(() =&gt; {\n        setState(\"success\"); // After some time, transition to 'success'\n      }, 2000);\n    }\n  };\n\n  return (\n    &lt;button onClick={handleClick}&gt;\n      {state === \"idle\" &amp;&amp; \"Start\"}\n      {state === \"loading\" &amp;&amp; \"Loading...\"}\n      {state === \"success\" &amp;&amp; \"Done!\"}\n    &lt;/button&gt;\n  );\n};\n</code></pre>"},{"location":"tools/fsm/#why-use-fsm-in-react","title":"Why use FSM in React?","text":"<ul> <li>Predictability: The transitions between states are controlled and easier to reason about.</li> <li>Clarity: It\u2019s clear what states the component can be in, and how to get from one to another.</li> <li>Scalability: FSM can be especially helpful as your application\u2019s state logic becomes more complex.</li> <li>Separation of Concerns: State management is cleaner, and can be encapsulated in FSM transitions rather than mixed with UI logic.</li> </ul>"},{"location":"tools/fsm/#libraries","title":"Libraries:","text":"<p>There are also libraries, such as XState, that can help you manage FSMs more formally in React apps. These libraries provide utilities to define finite state machines and make your state transitions even more powerful and maintainable.</p>"},{"location":"tools/import-structure/","title":"Import Structure","text":""},{"location":"tools/import-structure/#best-practices-for-organizing-and-sequencing-hooks-in-react-components","title":"Best Practices for Organizing and Sequencing Hooks in React Components","text":"<p><code>Mastering Hook Ordering: A React Developer's Guide</code></p> <pre><code>import { useState } from \"react\";\nimport useDrawerReducer from \"@shared/hooks/useDrawerReducer\"; // Step 1: State Management\nimport usePermissionReducer from \"@features/settings/hooks/usePermissionReducer\"; // Step 1: State Management\nimport {\n  useGetRolesQuery,\n  useGetPermissionsQuery,\n} from \"@features/settings/services/settingApi\"; // Step 2: Query Hooks\nimport {\n  usePutRolesMutation,\n  usePostRolesMutation,\n} from \"@features/settings/services/settingApi\"; // Step 3: Mutation Hooks\n\nconst RolePermissions = () =&gt; {\n  // Step 1: State management hooks\n  const {\n    drawerVisible,\n    drawerMode,\n    selectedRecord,\n    onAdd,\n    onUpdate,\n    onClose,\n  } = useDrawerReducer();\n  const { permissionValues, editPermission } = usePermissionReducer();\n\n  // Step 2: Query hooks for fetching data\n  const { data: rolesData, isLoading: isLoadingRoles } = useGetRolesQuery();\n  const { data: permissionsData, isLoading: isLoadingPermissions } =\n    useGetPermissionsQuery(\n      { id: permissionValues?.id },\n      { skip: !permissionValues?.id }\n    );\n\n  // Step 3: Mutation hooks for posting or updating data\n  const [putRoles] = usePutRolesMutation();\n  const [postRoles] = usePostRolesMutation();\n\n  // Component logic...\n\n  return &lt;div&gt;{/* Your JSX content here */}&lt;/div&gt;;\n};\n</code></pre> Summary of Steps <ul> <li>Declare <code>useReducer</code> or <code>useState</code> hooks for state management.</li> <li>Declare <code>useQuery</code> hooks to fetch data, utilizing the state as needed.</li> <li>Declare <code>useMutation</code> hooks for actions like creating, updating, or deleting data.</li> </ul> <p>This approach ensures a clear flow of data and state management, and also makes sure that all components have the necessary information before initiating further logic (such as data fetching or mutations).</p>"},{"location":"tools/import-structure/#react-import-structure","title":"React Import structure","text":"<ul> <li>React Best Practices in 2023 Series' Articles</li> <li>Part 2: Folder Structure - Building a Solid Foundation </li> <li>Part 3: Component Structure - Building Reusable and Maintainable Components in React! </li> <li>Part 4: Writing Clean and Efficient React Code- Best Practices and Optimization Techniques </li> </ul> <ul> <li>Using useReducer and Redux Toolkit Together</li> <li>Folder structure - group by feature vs group by file purpose/type </li> </ul>"},{"location":"tools/import-structure/#bonus-component-hierarchy","title":"Bonus - Component Hierarchy","text":"<p>It is generally recommended to follow a specific component hierarchy to maintain consistency and readability in your codebase.</p> Example Component HierarchyTips <pre><code>// \u2705 Component Hierarchy\n\n// External dependencies\nimport React, { useState, useRef, useEffect } from \"react\";\nimport PropTypes from \"prop-types\";\nimport _ from \"lodash\";\n\n// Internal dependencies\nimport { TodoItem } from \"./TodoItem\";\nimport { TodoUtils } from \"../utils\";\nimport { useTodo } from \"../hooks\";\nimport { withTimer } from \"../hoc\";\nimport { TodoType } from \"../enums\";\n\n// Stylesheets\nimport \"./Component.css\";\nimport \"../styles/common.css\";\n\n// Assets\nimport todoImage from \"../assets/todoImage.png\";\n\nconst Todo = () =&gt; {\n    // State logic\n    const [todos, setTodos] = useState([]);\n\n    // Ref\n    const inputRef = useRef(null);\n\n    // Variable\n    const title = \"Todo List\";\n\n    // Custom hook\n    const { addTodo } = useTodo();\n\n    // Higher-order component\n    const timer = withTimer(TodoItem);\n\n    // Component lifecycle methods (useEffect)\n    useEffect(() =&gt; {\n        //...\n    }, []);\n\n    // Component render\n    return &lt;div&gt;{/* Component JSX */}&lt;/div&gt;;\n    };\n\n    Todo.propTypes = {\n        // Prop types declaration\n    };\n\nexport { Todo };\n</code></pre> <p>Aditional</p> <ul> <li>Part 3: Component Structure - Building Reusable and Maintainable Components in React! </li> </ul>"},{"location":"tools/import-structure/#atomic-design-principles","title":"Atomic Design Principles","text":"<p>Atomic Design is a methodology for designing and organizing components in a hierarchical manner based on their level of abstraction and complexity.</p> <p>It classifies components into five levels: Atoms, Molecules, Organisms, Templates, and Pages, with each level having a specific responsibility.</p> <ol> <li> <p>Atoms: At the lowest level, atoms represent the smallest and most basic UI elements, such as buttons, inputs, or icons.</p> <p>They have a single responsibility, focusing on their visual appearance and basic functionality.</p> </li> <li> <p>Molecules: Molecules are combinations of atoms that work together to create more complex UI elements.</p> <p>They have a slightly higher level of responsibility, representing a group of related atoms.</p> </li> <li> <p>Organisms: Organisms are composed of molecules and atoms, representing larger and more self-contained sections of a user interface.</p> <p>They have more complex behavior and may include state management and interaction logic.</p> </li> <li> <p>Templates: Templates are specific arrangements of organisms that provide a basic structure for a page or section.</p> <p>They define the overall layout and composition of the UI.</p> </li> <li> <p>Pages: Pages are instances where templates are populated with real data, creating actual content for the user to interact with.</p> </li> </ol>"},{"location":"tools/import-structure/#reference","title":"Reference","text":"<ul> <li>Sorting imports on save in React projects with ESLint.</li> <li> <p>Sorting your imports correctly in React </p> </li> <li> <p>Rules of Hooks: official</p> </li> </ul>"},{"location":"tools/overview/","title":"Overview","text":"<ul> <li>React Developer Tools \ud83d\udee0\ufe0f</li> <li>Create React App \ud83d\ude80</li> <li>React Router \ud83d\udee3\ufe0f</li> <li>Redux \ud83d\udd04</li> <li>React Query \ud83d\udce1</li> <li>Styled Components \ud83c\udfa8</li> <li>ESLint \ud83d\udccb</li> <li>Prettier \ud83e\uddd1\u200d\ud83c\udfa8</li> <li>Jest \ud83e\uddea</li> <li>React Testing Library \ud83e\uddf0</li> <li>Webpack \u2699\ufe0f</li> <li>Babel \ud83d\udd04</li> <li>Next.js \ud83c\udf0d</li> <li>Vite \u26a1</li> <li>React Native \ud83d\udcf1</li> <li>Tailwind CSS \ud83c\udf2c\ufe0f</li> <li>Storybook \ud83d\udcda</li> <li>React Hook Form \ud83e\ude9d</li> <li>Formik \ud83d\udcdd</li> <li>Axios \ud83c\udf10</li> </ul> <p>In React development, there are a variety of tools and libraries that help streamline the process of building, testing, and managing your app. Here are some of the most commonly used tools in the React ecosystem:</p> <ol> <li> <p>React Developer Tools</p> <ul> <li>Description: A browser extension for Chrome and Firefox that allows you to inspect and debug React applications. It gives you access to the component tree, props, state, and allows you to modify the app\u2019s state during runtime.</li> <li>Usage: Helps in debugging and inspecting your React components.</li> </ul> </li> <li> <p>Create React App (CRA)</p> <ul> <li>Description: A tool that helps you set up a new React project with a single command. It configures Webpack, Babel, ESLint, and other tools for you, so you can start developing your app right away without much configuration.</li> <li>Usage: Quickly bootstrap new React projects with sensible defaults.</li> </ul> </li> <li> <p>React Router</p> <p>Description: A routing library that allows you to handle navigation in your React application. It enables you to manage routes and render different components based on the URL. Usage: For building single-page applications (SPAs) with multiple views or pages.</p> </li> <li> <p>Redux</p> <ul> <li>Description: A state management library that helps you manage the state of your React app in a predictable way. It works well with large applications where you need to manage global state.</li> <li>Usage: Centralized state management, usually in larger apps that need to pass data around multiple components.</li> </ul> </li> <li> <p>React Query</p> <ul> <li>Description: A data-fetching library that provides hooks for managing server-state (data fetched from APIs) and caching. It automates background fetching, pagination, and refetching of data.</li> <li>Usage: Simplifies API data fetching, caching, and synchronization in React apps.</li> </ul> </li> <li> <p>Styled Components</p> <ul> <li>Description: A library for writing CSS in JavaScript. It allows you to style React components with tagged template literals, which are scoped to the component.</li> <li>Usage: For styling React components using a CSS-in-JS approach.</li> </ul> </li> <li> <p>ESLint</p> <ul> <li>Description: A linting tool that helps enforce code quality and consistency by catching syntax errors and potential bugs.</li> <li>Usage: Ensures your code follows best practices, catches errors early, and maintains consistent styling.</li> </ul> </li> <li> <p>Prettier</p> <ul> <li>Description: An opinionated code formatter that helps maintain consistent code style across your project by auto-formatting your code.</li> <li>Usage: To auto-format code and make it consistent across the entire codebase.</li> </ul> </li> <li> <p>Jest</p> <ul> <li>Description: A testing framework for JavaScript, commonly used with React to test components, functions, and other parts of the application.</li> <li>Usage: For unit tests, snapshot tests, and other forms of testing your React code.</li> </ul> </li> <li> <p>React Testing Library</p> <ul> <li>Description: A library for testing React components in a way that mimics how they are used in the real world (e.g., focusing on the output, rather than implementation details).</li> <li>Usage: Helps test components more effectively by rendering them in a virtual DOM and interacting with them as a user would.</li> </ul> </li> <li> <p>Webpack</p> <ul> <li>Description: A module bundler that compiles your JavaScript, CSS, images, etc., and bundles them into optimized assets for your app. It is often used alongside React for bundling the app.</li> <li>Usage: Bundling and optimizing assets for production in a React app.</li> </ul> </li> <li> <p>Babel</p> <ul> <li>Description: A JavaScript compiler that allows you to use the latest JavaScript features (like JSX) while ensuring compatibility with older browsers.</li> <li>Usage: Transpiles modern JavaScript code (ES6 and beyond) and JSX into code that browsers can execute.</li> </ul> </li> <li> <p>Next.js</p> <ul> <li>Description: A React framework for building server-rendered and static websites. It supports features like SSR (Server-Side Rendering), static generation, and routing.</li> <li>Usage: For building full-stack applications with React that require server-side rendering or static generation.</li> </ul> </li> <li> <p>Vite</p> <ul> <li>Description: A modern build tool that focuses on speed. It provides faster builds and hot module replacement (HMR) during development.</li> <li>Usage: A fast alternative to Webpack for building React applications.</li> </ul> </li> <li> <p>React Native</p> <ul> <li>Description: A framework for building native mobile applications using React. It allows you to write mobile apps for iOS and Android with JavaScript and React.</li> <li>Usage: To build mobile apps with React.</li> </ul> </li> <li> <p>Tailwind CSS</p> <ul> <li>Description: A utility-first CSS framework that lets you compose custom designs using low-level utility classes.</li> <li>Usage: For styling React components with utility classes instead of writing custom CSS.</li> </ul> </li> <li> <p>Storybook</p> <ul> <li>Description: A tool for developing and testing UI components in isolation. It allows you to showcase and interact with your components outside of the main application.</li> <li>Usage: Used for building and testing individual UI components in isolation, improving component reusability.</li> </ul> </li> <li> <p>React Hook Form</p> <ul> <li>Description: A library for managing forms in React applications, making it easier to handle form validation and submission.</li> <li>Usage: For simplifying form management in React apps.</li> </ul> </li> <li> <p>Formik</p> <ul> <li>Description: Another popular form management library for React that handles form state, validation, and submission.</li> <li>Usage: For managing forms in React apps with a more structured approach to validation and submission.</li> </ul> </li> <li> <p>Axios</p> <ul> <li>Description: A promise-based HTTP client for making requests to external APIs. It\u2019s commonly used for data fetching in React.</li> <li>Usage: Making HTTP requests to external APIs or backends in a React application.</li> </ul> </li> </ol> <p>These tools are just the tip of the iceberg, and the choice of tools often depends on the type of project you're building. Each tool has its purpose, and many React projects integrate several of them to optimize development, testing, and performance.</p>"},{"location":"tools/prettier/","title":"Prettier","text":""},{"location":"tools/prettier/#prettier","title":"Prettier","text":"<ol> <li> <p>Install Prettier</p> <pre><code>npm install --save-dev prettier\n</code></pre> </li> <li> <p>Run Prettier on All Files</p> CodeExplanation <pre><code>npx prettier --write .\n</code></pre> <ul> <li><code>npx</code>: This runs the Prettier command without needing to install it globally.</li> <li><code>prettier</code>: The Prettier CLI tool.</li> <li><code>--write</code>: This flag tells Prettier to format the files and write the changes to the files.</li> <li><code>.</code>: The period represents the current directory. Prettier will format all files in the directory and subdirectories.</li> </ul> </li> <li> <p>Check Specific File Types</p> <pre><code>npx prettier --write \"**/*.js\"\n</code></pre> <p>Or for all <code>.js</code>, <code>.ts</code>, <code>.jsx</code>, <code>.tsx</code> files:</p> <pre><code>npx prettier --write \"**/*.{js,ts,jsx,tsx}\"\n</code></pre> </li> <li> <p>Prettier Configuration File (optional):</p> <p>Prettier will automatically pick up any configuration in the <code>.prettierrc</code> file or <code>package.json</code> file if present. If you haven't created one yet, Prettier will apply its default formatting rules.</p> </li> </ol>"},{"location":"tools/prettier/#additional-prettier-cli-options","title":"Additional Prettier CLI Options","text":"<ul> <li> <p>Check if files are formatted correctly (without changing them):</p> <p>If you want to check if the files are formatted according to Prettier without actually formatting them, you can run:</p> <pre><code>npx prettier --check .\n</code></pre> <p>This will output a list of files that need formatting without modifying them.</p> </li> <li> <p>Ignore specific files or directories:</p> <p>You can create a <code>.prettierignore</code> file to tell Prettier which files or directories to ignore, similar to <code>.gitignore</code>.</p> .prettierignore<pre><code>node_modules/\ndist/\nbuild/\n</code></pre> <p>Files or directories listed in <code>.prettierignore</code> won\u2019t be formatted.</p> </li> </ul> bash<pre><code>npx prettier --write .\n</code></pre> <p>if i miss a semicolon. does pretieer adds semicolonor not</p> <p>Yes, Prettier will add the semicolon if you miss it and you have Prettier configured to use semicolons.</p> <p>By default, Prettier adds semicolons at the end of statements, so if you omit a semicolon, Prettier will automatically insert one when it formats the code.</p> <p>In summary: Prettier will add semicolons by default, but you can configure it to avoid them if you prefer.</p>"},{"location":"tools/react-dev-tools/","title":"React Dev Tools","text":""},{"location":"tools/react-dev-tools/#react-developer-tools","title":"React Developer Tools","text":"<p>React Developer Tools is a tool that allows you to inspect a React tree, including the component hierarchy, props, state, and more. To get started, just open the Firefox devtools and switch to the \"\u269b\ufe0f Components\" or \"\u269b\ufe0f Profiler\" tab.</p> <p></p>"},{"location":"tools/react-dev-tools/#components","title":"\u269b\ufe0f Components","text":""},{"location":"tools/react-dev-tools/#profiler","title":"\u269b\ufe0f Profiler","text":""},{"location":"tools/react-ecosystem/","title":"React Ecosystem","text":""},{"location":"tools/react-ecosystem/#react-ecosystem","title":"React Ecosystem","text":""},{"location":"tools/eslint/intro/","title":"ESLint","text":""},{"location":"tools/eslint/intro/#theory","title":"Theory","text":""},{"location":"tools/eslint/intro/#what-is-eslint","title":"What is ESLint?","text":"<p>ESLint is an open-source JavaScript linting tool that helps developers find and fix problems in their JavaScript code. Linting is the process of analyzing code for potential errors, bugs, stylistic errors, and suspicious constructs.</p>"},{"location":"tools/eslint/intro/#where-does-eslint-come-from","title":"Where Does ESLint Come From?","text":"<p>ESLint was created by Nicholas C. Zakas in June 2013. It was developed to address some of the limitations of other JavaScript linting tools like <code>JSLint</code> and <code>JSHint</code>. ESLint is highly configurable and extensible, which has made it the preferred choice for many developers.</p>"},{"location":"tools/eslint/intro/#how-to-use-eslint","title":"How to Use ESLint","text":"Installation: <ol> <li> <p>Install ESLint:     Use npm (Node Package Manager) or yarn to install ESLint in your project.</p> <pre><code>npm install eslint --save-dev\n# or\nyarn add eslint --dev\n</code></pre> </li> <li> <p>Initialize ESLint:</p> <p>Run the ESLint initialization command to create a configuration file (<code>.eslintrc.json</code>).</p> <pre><code>npx eslint --init\n</code></pre> </li> </ol>"},{"location":"tools/eslint/intro/#configuration","title":"Configuration:","text":"<ol> <li> <p>Config File:</p> <p>The initialization command will prompt you to answer a series of questions to set up your configuration file. Here is an example <code>.eslintrc.json</code>:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true\n  },\n  \"extends\": \"eslint:recommended\",\n  \"parserOptions\": {\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"rules\": {\n    \"indent\": [\"error\", 2],\n    \"linebreak-style\": [\"error\", \"unix\"],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <ol> <li>Custom Rules:</li> </ol> <p>You can customize ESLint rules according to your project's needs by modifying the <code>rules</code> section in the configuration file.</p> </li> </ol>"},{"location":"tools/eslint/intro/#running-eslint","title":"Running ESLint:","text":"<ol> <li> <p>Command Line:</p> <p>You can run ESLint from the command line to lint your code:</p> <pre><code>npx eslint yourfile.js\n</code></pre> </li> <li> <p>Automatic Fixes:</p> <p>ESLint can automatically fix certain issues:</p> <pre><code>npx eslint yourfile.js --fix\n</code></pre> </li> </ol>"},{"location":"tools/eslint/intro/#integration-with-code-editors","title":"Integration with Code Editors:","text":"<ol> <li> <p>VSCode:</p> <p>Install the ESLint extension from the Visual Studio Code Marketplace to get real-time linting feedback.</p> </li> <li> <p>Other Editors:</p> <p>Most popular editors like Atom, Sublime Text, and WebStorm have plugins or built-in support for ESLint.</p> </li> </ol>"},{"location":"tools/eslint/intro/#do-we-need-to-use-eslint-in-react","title":"Do We Need to Use ESLint in React?","text":"<p>Using ESLint in React projects is highly recommended for several reasons:</p> <ol> <li> <p>Code Quality: ESLint helps ensure that your React code follows best practices and avoids common pitfalls.</p> </li> <li> <p>Consistency: Enforces a consistent coding style across your React codebase, making it easier to read and maintain.</p> </li> <li> <p>Error Prevention: Helps catch potential errors early in the development process, reducing the likelihood of bugs in production.</p> </li> <li> <p>Integration: ESLint can be easily integrated with React projects, especially with popular configurations like Airbnb's style guide, which includes rules for React and JSX.</p> </li> </ol>"},{"location":"tools/eslint/intro/#example-configuration-for-react","title":"Example Configuration for React:","text":"<p>To use ESLint with React, you can extend a popular style guide like Airbnb\u2019s that includes React-specific linting rules. Here is an example <code>.eslintrc.json</code> for a React project:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"node\": true\n  },\n  \"extends\": [\"eslint:recommended\", \"plugin:react/recommended\", \"airbnb\"],\n  \"parserOptions\": {\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\"react\"],\n  \"rules\": {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"indent\": [\"error\", 2],\n    \"linebreak-style\": [\"error\", \"unix\"],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <p>Using ESLint in your React projects will help you maintain high code quality, consistent style, and catch errors early, ultimately leading to more robust and maintainable code.</p>"},{"location":"tools/eslint/intro/#add-eslint-scripts-to-packagejson","title":"Add ESLint Scripts to <code>package.json</code>","text":"<pre><code>{\n  \"scripts\": {\n    \"lint\": \"eslint 'src/**/*.{js,jsx}'\",\n    \"lint:fix\": \"eslint 'src/**/*.{js,jsx}' --fix\"\n  }\n}\n</code></pre>"},{"location":"tools/eslint/intro/#reference","title":"Reference","text":"<ul> <li>How to set up ESLint in VS Code for React Native applications that use TypeScript</li> </ul>"},{"location":"tools/husky/intro/","title":"Husky","text":""},{"location":"tools/husky/intro/#intro","title":"Intro","text":""},{"location":"tools/husky/intro/#precommit-and-husky","title":"Precommit and Husky","text":"<ul> <li>Precommit: Cross-platform, broader tool for git hooks, not limited to JS.</li> <li>Husky: Node-specific, great for JS/TypeScript projects with built-in integration for JS tools.</li> </ul> <pre><code>npm install --save-dev lint-staged\n# or\npnpm add lint-staged --save-dev\n</code></pre>"},{"location":"tools/husky/intro/#reference","title":"Reference","text":"<ul> <li>freecodecamp: How to Add Commit Hooks to Git with Husky to Automate Code Tasks</li> <li>Husky \u201cpre-commit\u201d hooks</li> <li>official docs</li> </ul>"},{"location":"tools/husky/lint-staged/","title":"Lint Staged","text":""},{"location":"tools/husky/lint-staged/#lint-staged","title":"Lint Staged","text":""},{"location":"tools/husky/lint-staged/#overview","title":"Overview","text":"<p><code>lint-staged</code> is often used in combination with Husky to ensure that only the files you\u2019ve changed are linted and formatted before committing them to a Git repository. It helps enforce code quality standards, even when multiple developers are working on the same codebase.</p>"},{"location":"tools/husky/lint-staged/#what-does-lint-staged-do","title":"What does <code>lint-staged</code> do?","text":"<p><code>lint-staged</code> runs linters or formatters (like ESLint, Prettier, or stylelint) only on the files that are staged (those added to the commit) rather than the entire project. This makes it more efficient because you're not running linters on files that aren't part of the current commit.</p> <ul> <li>If you have 10 files, but only 3 of them are staged for commit, <code>lint-staged</code> will run the linter only on those 3 files instead of the entire 10. This reduces the time spent on linting.</li> <li>It can also automatically fix certain issues (e.g., formatting) before the commit is made, preventing poorly formatted code from getting into the codebase.</li> </ul>"},{"location":"tools/husky/lint-staged/#how-does-it-work-with-husky","title":"How does it work with Husky?","text":"<p>Husky is used to create Git hooks that run scripts during various Git lifecycle events like <code>pre-commit</code>, <code>pre-push</code>, etc.</p> <ul> <li> <p>Pre-commit hook: <code>lint-staged</code> can be set up to run on a <code>pre-commit</code> hook, so before you actually commit your changes, <code>lint-staged</code> will run and automatically lint/format your staged files.</p> </li> <li> <p>Pre-push hook: Similarly, you could configure <code>lint-staged</code> to run before a <code>git push</code> to make sure that no broken code is pushed to a remote repository.</p> </li> </ul> <p>In summary, <code>lint-staged</code> helps enforce code quality standards efficiently by running checks only on the files you're about to commit. Without it, you'd likely have slower checks, potential errors getting into the codebase, and inconsistent code quality across different developers' commits.</p>"},{"location":"tools/husky/lint-staged/#enforcing-coding-style","title":"Enforcing Coding Style","text":""},{"location":"tools/husky/lint-staged/#choose-your-linting-and-formatting-tools","title":"Choose Your Linting and Formatting Tools","text":"<p>Typically, developers use the following tools:</p> <ul> <li>ESLint for JavaScript/TypeScript linting.</li> <li>Prettier for automatic code formatting (you can use it alongside ESLint).</li> <li>Stylelint for CSS/SASS/SCSS linting.</li> </ul> <p>You can pick the ones that suit your project's needs.</p>"},{"location":"tools/husky/lint-staged/#install-the-tools","title":"Install the Tools","text":"<p>To install ESLint and Prettier, for example:</p> <pre><code># Install ESLint and Prettier\nnpm install eslint prettier --save-dev\n</code></pre> <p>If you're using other tools, like Stylelint, install them in a similar way:</p> <pre><code>npm install stylelint --save-dev\n</code></pre>"},{"location":"tools/husky/lint-staged/#configure-eslint-and-prettier","title":"Configure ESLint and Prettier","text":"<p>Create or Update <code>.eslintrc</code> (for ESLint)</p> <pre><code>npx eslint --init\n</code></pre> <p>This will guide you through creating an ESLint configuration file (usually <code>.eslintrc</code> or <code>.eslintrc.json</code>). You can manually edit it to specify the coding rules (e.g., indent size, quotes, semicolons, etc.).</p> .eslintrc.json<pre><code>{\n  \"extends\": [\"eslint:recommended\", \"plugin:prettier/recommended\"],\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n  \"rules\": {\n    \"quotes\": [\"error\", \"double\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <p>Create or Update <code>.prettierrc</code> (for Prettier)</p> <p>Prettier can automatically format your code according to certain rules.</p> .prettierrc<pre><code>{\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 2,\n  \"semi\": true\n}\n</code></pre> <pre><code>npx eslint . --fix\nnpx prettier --write .\n</code></pre>"},{"location":"tools/husky/lint-staged/#working-in-production","title":"Working in Production","text":"<p><code>pre-commit</code></p> <pre><code>#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\n# npm test\npnpm lint-staged\n</code></pre> package.json<pre><code>  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"lint\": \"eslint . --fix\",\n    \"format\": \"prettier --write .\",\n    \"preview\": \"vite preview\",\n    \"prepare\": \"husky &amp;&amp; husky install\"\n  },\n  \"lint-staged\": {\n    \"**/*.{js,jsx,ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --fix\"\n    ],\n    \"**/*.{json,md,css,scss}\": [\n      \"prettier --write\"\n    ]\n  },\n</code></pre>"},{"location":"tools/husky/lint-staged/#reference","title":"Reference","text":"<ul> <li>lint-staged</li> <li>Pre-commit with husky &amp; lint-staged </li> <li>Importance of using Husky Pre-Commit Hooks</li> </ul>"},{"location":"tools/storybook/intro/","title":"Storybook","text":""},{"location":"tools/storybook/intro/#overview","title":"Overview","text":"<p>Astro is a modern static site generator designed for building fast, optimized websites. It allows developers to create websites using their favorite frameworks, like React, Vue, or Svelte, while focusing on performance and reducing client-side JavaScript.</p> Key features include: <ol> <li>Partial Hydration: Astro only sends JavaScript to the client when necessary, improving loading times.</li> <li>Component-based: You can use various UI frameworks alongside each other in a single project.</li> <li>Static Site Generation: It generates static HTML at build time, which can be served quickly.</li> <li>Markdown and MDX Support: Easily write content using Markdown, with the ability to include interactive components via MDX.</li> </ol> <p>Astro is ideal for content-heavy sites, blogs, and portfolios, emphasizing speed and simplicity.</p>"},{"location":"tools/storybook/intro/#what-is-createslice","title":"what is createSlice","text":"<p><code>createSlice</code> is a function provided by Redux Toolkit that simplifies the process of creating Redux slices. A slice is a portion of the Redux state and includes both the reducer logic and the actions that can modify that state. Here's a detailed breakdown of what <code>createSlice</code> does:</p>"},{"location":"tools/storybook/intro/#key-features-of-createslice","title":"Key Features of <code>createSlice</code>","text":"<ol> <li> <p>Combines Reducers and Actions:</p> <ul> <li>With <code>createSlice</code>, you can define the initial state, the reducers, and the actions all in one place, which reduces boilerplate code.</li> </ul> </li> <li> <p>Automatically Generates Action Creators:</p> <ul> <li>For each reducer you define, <code>createSlice</code> automatically generates corresponding action creators. This means you don\u2019t need to create them manually.</li> </ul> </li> <li> <p>Immer Library:</p> <ul> <li><code>createSlice</code> uses the Immer library under the hood, which allows you to write \"mutating\" logic in your reducers. This means you can directly mutate the state, and Immer will take care of producing an immutable state.</li> </ul> </li> <li> <p>Easier to Understand:</p> <ul> <li>The API is designed to be intuitive and easier to work with compared to traditional Redux patterns.</li> </ul> </li> </ol> Basic StructureComponents of <code>createSlice</code> <p>Here\u2019s a basic example of how to use createSlice:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n    name: 'counter', // Name of the slice\n    initialState: {\n        value: 0, // Initial state\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1; // Mutate state directly\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1; // Mutate state directly\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload; // Mutate state directly with payload\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export reducer\nexport default counterSlice.reducer;\n</code></pre> <ol> <li> <p>name: A string that defines the slice's name. This is used as a prefix for generated action types (e.g., <code>counter/increment</code>).</p> </li> <li> <p>initialState: The initial state of the slice.</p> </li> <li> <p>reducers: An object where each key is a reducer function. The function can directly mutate the state because of Immer's usage.</p> </li> </ol> <p>How to Use</p> <p>You would typically combine the slice's reducer with others in your Redux store setup:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"./counterSlice\";\n\nconst store = configureStore({\n  reducer: {\n    counter: counterReducer, // Adding the counter slice reducer to the store\n  },\n});\n</code></pre> <p>Conclusion</p> <p>In summary, <code>createSlice</code> is a powerful tool in Redux Toolkit that streamlines state management by allowing you to define a slice of state, its actions, and its reducers all in one concise structure. It promotes best practices while reducing boilerplate, making it easier to work with Redux in modern applications.</p>"},{"location":"tools/storybook/intro/#reference","title":"Reference","text":"<ul> <li>Is spending time learning storybook worth it? </li> <li>is it worth maintaining a storybook</li> <li>What is Storybook and Why Developers Should Use It</li> <li>The Benefits and Frustrations of Using Storybook</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Index","text":""},{"location":"blog/page/3/","title":"Index","text":""},{"location":"blog/page/4/","title":"Index","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"blog/archive/2024/page/3/","title":"2024","text":""}]}